                         ISO/IEC JTC 1/SC 22/WG 5/N2146
       DRAFT           INTERNATIONAL               ISO/IEC
       (for ballot)    STANDARD                         DIS
       28th December 2017                             1539-1
       11:02
                                                   Fourth edition
                                                      2017-12-28
                      Information technology — Programming
                      languages — Fortran —
                      Part 1:
                      Base language
                      Technologies de l’information — Langages de programmation —
                      Fortran —
                      Partie 1: Langage de base
                           PDFdisclaimer
       This PDF ﬁle may contain embedded typefaces. In accordance with Adobe’s licensing policy, this ﬁle may be
       printed or viewed but shall not be edited unless the typefaces which are embedded are licensed to and installed
       on the computer performing the editing. In downloading this ﬁle, parties accept therein the responsibility of not
       infringing Adobe’s licensing policy. The ISO Central Secretariat accepts no liability in this area.
       Adobe is a trademark of Adobe Systems Incorporated.
       Details of the software products used to create this PDF ﬁle can be found in the General Info relative to the ﬁle;
       the PDF-creation parameters were optimized for printing. Every care has been taken to ensure that the ﬁle is
       suitable for use by ISO member bodies. In the unlikely event that a problem relating to it is found, please inform
       the Central Secretariat at the address given below.
       This ISO document is a Draft International Standard and is copyright-protected by ISO. Except as permitted
       under the applicable laws of the user’s country, neither this ISO draft nor any extract from it may be reproduced,
       stored in a retrieval system or transmitted in any form or by any means, electronic, photocopying, recording or
       otherwise, without prior written permission being secured.
       Requests for permission to reproduce should be addressed to either ISO at the address below or ISO’s member
       body in the country of the requester.
         ISO copyright oﬃce
         Case postale 56 • CH-1211 Geneva 20
         Tel. + 41 22 749 01 11
         Fax + 41 22 734 10 79
         E-mail copyright@iso.ch
         Web www.iso.ch
       Reproduction may be subject to royalty payments or a licensing agreement.
       Violators may be prosecuted.
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                Contents
                Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
                Introduction    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xviii
                1   Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       1
                2   Normative references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          3
                3   Terms and deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          5
                4   Notation, conformance, and compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          27
                   4.1     Notation, symbols and abbreviated terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          27
                           4.1.1     Syntax rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     27
                           4.1.2     Constraints     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  28
                           4.1.3     Assumed syntax rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       28
                           4.1.4     Syntax conventions and characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . .         28
                           4.1.5     Text conventions      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  29
                   4.2     Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      29
                   4.3     Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      30
                           4.3.1     Previous Fortran standards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       30
                           4.3.2     New intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       30
                           4.3.3     Fortran 2008 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       30
                           4.3.4     Fortran 2003 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       31
                           4.3.5     Fortran 95 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       31
                           4.3.6     Fortran 90 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       32
                           4.3.7     FORTRAN77compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .             32
                   4.4     Deleted and obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       33
                           4.4.1     General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    33
                           4.4.2     Nature of deleted features      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
                           4.4.3     Nature of obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       33
                5   Fortran concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      35
                   5.1     High level syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      35
                   5.2     Program unit concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        38
                           5.2.1     Program units and scoping units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        38
                           5.2.2     Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      38
                           5.2.3     Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      38
                           5.2.4     Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     39
                           5.2.5     Submodule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      39
                   5.3     Execution concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       39
                           5.3.1     Statement classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      39
                           5.3.2     Statement order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      39
                           5.3.3     The END statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        40
                           5.3.4     Program execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        40
                           5.3.5     Execution sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41
                           5.3.6     Image execution states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       41
                c
                ISO/IEC 2017 – All rights reserved                                                                                          iii
                ISO/IEC DIS 1539-1:2017 (E)
                           5.3.7     Termination of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       42
                   5.4     Data concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      42
                           5.4.1     Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     42
                           5.4.2     Data value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     43
                           5.4.3     Data entity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    43
                           5.4.4     Deﬁnition of objects and pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        44
                           5.4.5     Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    44
                           5.4.6     Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    45
                           5.4.7     Coarray . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      45
                           5.4.8     Established coarrays      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  46
                           5.4.9     Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    46
                           5.4.10    Allocatable variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      46
                           5.4.11    Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    46
                   5.5     Fundamental concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         46
                           5.5.1     Names and designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        46
                           5.5.2     Statement keyword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        47
                           5.5.3     Other keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       47
                           5.5.4     Association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    47
                           5.5.5     Intrinsic   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  47
                           5.5.6     Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     47
                           5.5.7     Companion processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         47
                6   Lexical tokens and source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        49
                   6.1     Processor character set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      49
                           6.1.1     Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     49
                           6.1.2     Letters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    49
                           6.1.3     Digits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   49
                           6.1.4     Underscore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     49
                           6.1.5     Special characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     49
                           6.1.6     Other characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     50
                   6.2     Low-level syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     50
                           6.2.1     Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     50
                           6.2.2     Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      50
                           6.2.3     Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      51
                           6.2.4     Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      51
                           6.2.5     Statement labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     52
                           6.2.6     Delimiters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     52
                   6.3     Source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      53
                           6.3.1     Program units, statements, and lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         53
                           6.3.2     Free source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     53
                           6.3.3     Fixed source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      54
                   6.4     Including source text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      55
                7   Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     57
                   7.1     Characteristics of types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     57
                           7.1.1     The concept of type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      57
                           7.1.2     Type classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     57
                           7.1.3     Set of values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    57
                           7.1.4     Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      57
                           7.1.5     Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     57
                   7.2     Type parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        58
                   7.3     Types, type speciﬁers, and values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        58
                           7.3.1     Relationship of types and values to objects . . . . . . . . . . . . . . . . . . . . . . . . . .        58
                           7.3.2     Type speciﬁers and type compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . .          59
                   7.4     Intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    61
                           7.4.1     Classiﬁcation and speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       61
                                                                                         c
                iv                                                                       ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                           7.4.2     Intrinsic operations on intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      61
                           7.4.3     Numeric intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      61
                           7.4.4     Character type      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  65
                           7.4.5     Logical type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     68
                   7.5     Derived types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      68
                           7.5.1     Derived type concepts       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  68
                           7.5.2     Derived-type deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       69
                           7.5.3     Derived-type parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        73
                           7.5.4     Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       74
                           7.5.5     Type-bound procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        81
                           7.5.6     Final subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      83
                           7.5.7     Type extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       85
                           7.5.8     Derived-type values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      87
                           7.5.9     Derived-type speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      87
                           7.5.10    Construction of derived-type values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        88
                           7.5.11    Derived-type operations and assignment . . . . . . . . . . . . . . . . . . . . . . . . . . .           90
                   7.6     Enumerations and enumerators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           90
                   7.7     Binary, octal, and hexadecimal literal constants . . . . . . . . . . . . . . . . . . . . . . . . . . . .         92
                   7.8     Construction of array values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       92
                8   Attribute declarations and speciﬁcations         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
                   8.1     Attributes of procedures and data objects         . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
                   8.2     Type declaration statement        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
                   8.3     Automatic data objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       97
                   8.4     Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   97
                   8.5     Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     97
                           8.5.1     Attribute speciﬁcation      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  97
                           8.5.2     Accessibility attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    98
                           8.5.3     ALLOCATABLEattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .             98
                           8.5.4     ASYNCHRONOUSattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
                           8.5.5     BIND attribute for data entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       99
                           8.5.6     CODIMENSIONattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .             99
                           8.5.7     CONTIGUOUSattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
                           8.5.8     DIMENSION attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
                           8.5.9     EXTERNALattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
                           8.5.10    INTENT attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
                           8.5.11    INTRINSIC attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
                           8.5.12    OPTIONALattribute. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
                           8.5.13    PARAMETERattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
                           8.5.14    POINTERattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
                           8.5.15    PROTECTEDattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
                           8.5.16    SAVE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
                           8.5.17    TARGETattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
                           8.5.18    VALUEattribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
                           8.5.19    VOLATILE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
                   8.6     Attribute speciﬁcation statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
                           8.6.1     Accessibility statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
                           8.6.2     ALLOCATABLEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
                           8.6.3     ASYNCHRONOUSstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
                           8.6.4     BIND statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
                           8.6.5     CODIMENSIONstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
                           8.6.6     CONTIGUOUSstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
                           8.6.7     DATAstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
                           8.6.8     DIMENSION statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
                           8.6.9     INTENT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
                           8.6.10    OPTIONALstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
                c
                ISO/IEC 2017 – All rights reserved                                                                                          v
              ISO/IEC DIS 1539-1:2017 (E)
                        8.6.11    PARAMETERstatement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
                        8.6.12    POINTERstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
                        8.6.13    PROTECTEDstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
                        8.6.14    SAVE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
                        8.6.15    TARGETstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
                        8.6.16    VALUEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
                        8.6.17    VOLATILE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
                  8.7   IMPLICIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
                  8.8   IMPORTstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
                  8.9   NAMELISTstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
                  8.10  Storage association of data objects    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
                        8.10.1    EQUIVALENCEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
                        8.10.2    COMMONstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
                        8.10.3    Restrictions on common and equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
              9    Use of data objects  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
                  9.1   Designator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
                  9.2   Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
                  9.3   Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
                  9.4   Scalars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
                        9.4.1     Substrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
                        9.4.2     Structure components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
                        9.4.3     Coindexed named objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
                        9.4.4     Complex parts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
                        9.4.5     Type parameter inquiry     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
                  9.5   Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
                        9.5.1     Order of reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
                        9.5.2     Whole arrays    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
                        9.5.3     Array elements and array sections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
                        9.5.4     Simply contiguous array designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
                  9.6   Image selectors   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
                  9.7   Dynamic association     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
                        9.7.1     ALLOCATEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
                        9.7.2     NULLIFY statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
                        9.7.3     DEALLOCATEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
                        9.7.4     STAT=speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
                        9.7.5     ERRMSG=speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
              10 Expressions and assignment       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
                  10.1  Expressions    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
                        10.1.1    Expression semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
                        10.1.2    Form of an expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
                        10.1.3    Precedence of operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
                        10.1.4    Evaluation of operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
                        10.1.5    Intrinsic operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
                        10.1.6    Deﬁned operations    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
                        10.1.7    Evaluation of operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
                        10.1.8    Integrity of parentheses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
                        10.1.9    Type, type parameters, and shape of an expression . . . . . . . . . . . . . . . . . . . . . 162
                        10.1.10 Conformability rules for elemental operations      . . . . . . . . . . . . . . . . . . . . . . . . 163
                        10.1.11 Speciﬁcation expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
                        10.1.12 Constant expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
                  10.2  Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
                        10.2.1    Assignment statement     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
                        10.2.2    Pointer assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
                        10.2.3    Masked array assignment – WHERE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
                                                                                 c
              vi                                                                 ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                        10.2.4    FORALL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
              11 Execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
                  11.1  Executable constructs containing blocks     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
                        11.1.1    Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
                        11.1.2    Rules governing blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
                        11.1.3    ASSOCIATE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
                        11.1.4    BLOCKconstruct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
                        11.1.5    CHANGETEAMconstruct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
                        11.1.6    CRITICAL construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
                        11.1.7    DOconstruct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
                        11.1.8    IF construct and statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
                        11.1.9    SELECT CASE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
                        11.1.10 SELECT RANK construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
                        11.1.11 SELECT TYPE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
                        11.1.12 EXIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
                  11.2  Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
                        11.2.1    Branch concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
                        11.2.2    GOTOstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
                        11.2.3    Computed GO TO statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
                  11.3  CONTINUEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
                  11.4  STOPandERRORSTOPstatements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
                  11.5  FAIL IMAGE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
                  11.6  Image execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
                        11.6.1    Image control statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
                        11.6.2    Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
                        11.6.3    SYNCALLstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
                        11.6.4    SYNCIMAGESstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
                        11.6.5    SYNCMEMORYstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
                        11.6.6    SYNCTEAMstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
                        11.6.7    EVENTPOSTstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
                        11.6.8    EVENTWAITstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
                        11.6.9    FORMTEAMstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
                        11.6.10 LOCK and UNLOCK statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
                        11.6.11 STAT= and ERRMSG= speciﬁers in image control statements . . . . . . . . . . . . . . . 215
              12 Input/output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                  12.1  Input/output concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                  12.2  Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                        12.2.1    Deﬁnition of a record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                        12.2.2    Formatted record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                        12.2.3    Unformatted record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
                        12.2.4    Endﬁle record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
                  12.3  External ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
                        12.3.1    External ﬁle concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
                        12.3.2    File existence  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
                        12.3.3    File access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
                        12.3.4    File position . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
                        12.3.5    File storage units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
                  12.4  Internal ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
                  12.5  File connection   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
                        12.5.1    Referring to a ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
                        12.5.2    Connection modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
                        12.5.3    Unit existence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
                        12.5.4    Connection of a ﬁle to a unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
                        12.5.5    Preconnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
               c
              ISO/IEC 2017 – All rights reserved                                                                              vii
              ISO/IEC DIS 1539-1:2017 (E)
                        12.5.6    OPENstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
                        12.5.7    CLOSEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
                  12.6  Data transfer statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
                        12.6.1    Form of input and output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
                        12.6.2    Control information list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
                        12.6.3    Data transfer input/output list   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
                        12.6.4    Execution of a data transfer input/output statement . . . . . . . . . . . . . . . . . . . . 239
                        12.6.5    Termination of data transfer statements    . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
                  12.7  Waiting on pending data transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
                        12.7.1    Wait operation    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
                        12.7.2    WAITstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
                  12.8  File positioning statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
                        12.8.1    Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
                        12.8.2    BACKSPACEstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
                        12.8.3    ENDFILE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
                        12.8.4    REWINDstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
                  12.9  FLUSHstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
                  12.10 File inquiry statement    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
                        12.10.1 Forms of the INQUIRE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
                        12.10.2 Inquiry speciﬁers    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
                        12.10.3 Inquire by output list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
                  12.11 Error, end-of-record, and end-of-ﬁle conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
                        12.11.1 Occurrence of input/output conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
                        12.11.2 Error conditions and the ERR= speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
                        12.11.3 End-of-ﬁle condition and the END= speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . 261
                        12.11.4 End-of-record condition and the EOR= speciﬁer . . . . . . . . . . . . . . . . . . . . . . . 261
                        12.11.5 IOSTAT= speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
                        12.11.6 IOMSG= speciﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
                  12.12 Restrictions on input/output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
              13 Input/output editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
                  13.1  Format speciﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
                  13.2  Explicit format speciﬁcation methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
                        13.2.1    FORMATstatement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
                        13.2.2    Character format speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
                  13.3  Form of a format item list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
                        13.3.1    Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
                        13.3.2    Edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
                        13.3.3    Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
                  13.4  Interaction between input/output list and format . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
                  13.5  Positioning by format control    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
                  13.6  Decimal symbol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
                  13.7  Data edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
                        13.7.1    Purpose of data edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
                        13.7.2    Numeric editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
                        13.7.3    Logical editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
                        13.7.4    Character editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
                        13.7.5    Generalized editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
                        13.7.6    User-deﬁned derived-type editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
                  13.8  Control edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
                        13.8.1    Position edit descriptors  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
                        13.8.2    Slash editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
                        13.8.3    Colon editing   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
                        13.8.4    SS, SP, and S editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
                        13.8.5    Pediting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
                        13.8.6    BNandBZediting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
                                                                                 c
              viii                                                               ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                        13.8.7    RU, RD, RZ, RN, RC, and RP editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
                        13.8.8    DCandDPediting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
                  13.9  Character string edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
                  13.10 List-directed formatting    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
                        13.10.1 Purpose of list-directed formatting     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
                        13.10.2 Values and value separators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
                        13.10.3 List-directed input    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
                        13.10.4 List-directed output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
                  13.11 Namelist formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
                        13.11.1 Purpose of namelist formatting      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
                        13.11.2 Name-value subsequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
                        13.11.3 Namelist input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
                        13.11.4 Namelist output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
              14 Program units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
                  14.1  Main program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
                  14.2  Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
                        14.2.1    Module syntax and semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
                        14.2.2    The USE statement and use association . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
                        14.2.3    Submodules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
                  14.3  Block data program units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
              15 Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
                  15.1  Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
                  15.2  Procedure classiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
                        15.2.1    Procedure classiﬁcation by reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
                        15.2.2    Procedure classiﬁcation by means of deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . 299
                  15.3  Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
                        15.3.1    Characteristics of procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
                        15.3.2    Characteristics of dummy arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
                        15.3.3    Characteristics of function results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
                  15.4  Procedure interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
                        15.4.1    Interface and abstract interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
                        15.4.2    Implicit and explicit interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
                        15.4.3    Speciﬁcation of the procedure interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
                  15.5  Procedure reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
                        15.5.1    Syntax of a procedure reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
                        15.5.2    Actual arguments, dummy arguments, and argument association . . . . . . . . . . . . . . 313
                        15.5.3    Function reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
                        15.5.4    Subroutine reference   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
                        15.5.5    Resolving named procedure references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
                        15.5.6    Resolving type-bound procedure references . . . . . . . . . . . . . . . . . . . . . . . . . . 326
                  15.6  Procedure deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
                        15.6.1    Intrinsic procedure deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
                        15.6.2    Procedures deﬁned by subprograms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
                        15.6.3    Deﬁnition and invocation of procedures by means other than Fortran . . . . . . . . . . . 332
                        15.6.4    Statement function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
                  15.7  Pure procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
                  15.8  Elemental procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335
                        15.8.1    Elemental procedure declaration and interface . . . . . . . . . . . . . . . . . . . . . . . . 335
                        15.8.2    Elemental function actual arguments and results . . . . . . . . . . . . . . . . . . . . . . . 336
                        15.8.3    Elemental subroutine actual arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
              16 Intrinsic procedures and modules      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
                  16.1  Classes of intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
                  16.2  Arguments to intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
               c
              ISO/IEC 2017 – All rights reserved                                                                               ix
              ISO/IEC DIS 1539-1:2017 (E)
                        16.2.1    General rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
                        16.2.2    The shape of array arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
                        16.2.3    Mask arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
                        16.2.4    DIMarguments and reduction functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
                  16.3  Bit model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
                        16.3.1    General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
                        16.3.2    Bit sequence comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
                        16.3.3    Bit sequences as arguments to INT and REAL . . . . . . . . . . . . . . . . . . . . . . . . 339
                  16.4  Numeric models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
                  16.5  Atomic subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
                  16.6  Collective subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
                  16.7  Standard generic intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
                  16.8  Speciﬁc names for standard intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
                  16.9  Speciﬁcations of the standard intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
                        16.9.1    General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
                  16.10 Standard intrinsic modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
                        16.10.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
                        16.10.2 The ISO_FORTRAN_ENV intrinsic module . . . . . . . . . . . . . . . . . . . . . . . . 436
              17 Exceptions and IEEE arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
                  17.1  Overview of IEEE arithmetic support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
                  17.2  Derived types, constants, and operators deﬁned in the modules       . . . . . . . . . . . . . . . . . . . 444
                  17.3  The exceptions    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 444
                  17.4  The rounding modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
                  17.5  Underﬂow mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
                  17.6  Halting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
                  17.7  The ﬂoating-point modes and status      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
                  17.8  Exceptional values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
                  17.9  IEEE arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
                  17.10 Summary of the procedures      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
                  17.11 Speciﬁcations of the procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
                        17.11.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
                  17.12 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 476
              18 Interoperability with C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
                  18.1  General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
                  18.2  The ISO_C_BINDING intrinsic module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
                        18.2.1    Summary of contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
                        18.2.2    Named constants and derived types in the module . . . . . . . . . . . . . . . . . . . . . . 479
                        18.2.3    Procedures in the module     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480
                  18.3  Interoperability between Fortran and C entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
                        18.3.1    General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
                        18.3.2    Interoperability of intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
                        18.3.3    Interoperability with C pointer types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 486
                        18.3.4    Interoperability of derived types and C struct types . . . . . . . . . . . . . . . . . . . . . 486
                        18.3.5    Interoperability of scalar variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
                        18.3.6    Interoperability of array variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
                        18.3.7    Interoperability of procedures and procedure interfaces . . . . . . . . . . . . . . . . . . . 489
                  18.4  Cdescriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
                  18.5  The source ﬁle ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
                        18.5.1    Summary of contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
                        18.5.2    The CFI_dim_t structure type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
                        18.5.3    The CFI_cdesc_t structure type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
                        18.5.4    Macros and typedefs in ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . 493
                        18.5.5    Functions declared in ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . . 496
                  18.6  Restrictions on C descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
                                                                                 c
              x                                                                  ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                  18.7   Restrictions on formal parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
                  18.8   Restrictions on lifetimes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 504
                  18.9   Interoperation with C global variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
                         18.9.1   General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
                         18.9.2   Binding labels for common blocks and variables . . . . . . . . . . . . . . . . . . . . . . . 506
                  18.10 Interoperation with C functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
                         18.10.1 Deﬁnition and reference of interoperable procedures . . . . . . . . . . . . . . . . . . . . . 506
                         18.10.2 Binding labels for procedures     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
                         18.10.3 Exceptions and IEEE arithmetic procedures . . . . . . . . . . . . . . . . . . . . . . . . . 507
                         18.10.4 Asynchronous communication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
              19 Scope, association, and deﬁnition      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
                  19.1   Scopes, identiﬁers, and entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
                  19.2   Global identiﬁers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
                  19.3   Local identiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
                         19.3.1   Classes of local identiﬁers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
                         19.3.2   Local identiﬁers that are the same as common block names . . . . . . . . . . . . . . . . . 511
                         19.3.3   Function results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
                         19.3.4   Components, type parameters, and bindings . . . . . . . . . . . . . . . . . . . . . . . . . 511
                         19.3.5   Argument keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
                  19.4   Statement and construct entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512
                  19.5   Association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
                         19.5.1   Name association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
                         19.5.2   Pointer association   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
                         19.5.3   Storage association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520
                         19.5.4   Inheritance association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
                         19.5.5   Establishing associations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
                  19.6   Deﬁnition and undeﬁnition of variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
                         19.6.1   Deﬁnition of objects and subobjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
                         19.6.2   Variables that are always deﬁned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
                         19.6.3   Variables that are initially deﬁned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
                         19.6.4   Variables that are initially undeﬁned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
                         19.6.5   Events that cause variables to become deﬁned . . . . . . . . . . . . . . . . . . . . . . . . 524
                         19.6.6   Events that cause variables to become undeﬁned . . . . . . . . . . . . . . . . . . . . . . . 526
                         19.6.7   Variable deﬁnition context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
                         19.6.8   Pointer association context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
              Annex A (informative) Processor dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
                  A.1    Unspeciﬁed items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
                  A.2    Processor dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
              Annex B     (informative) Deleted and obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
                  B.1    Deleted features from Fortran 90    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
                  B.2    Deleted features from Fortran 2008 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
                  B.3    Obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
                         B.3.1    General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
                         B.3.2    Alternate return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
                         B.3.3    Computed GO TO statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
                         B.3.4    Statement functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
                         B.3.5    DATAstatements among executables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
                         B.3.6    Assumed character length functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
                         B.3.7    Fixed form source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
                         B.3.8    CHARACTER*formof CHARACTERdeclaration . . . . . . . . . . . . . . . . . . . . . 542
                         B.3.9    ENTRYstatements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
                         B.3.10   Label DO statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
                         B.3.11   COMMONandEQUIVALENCEstatements and the block data program unit . . . . . . 542
               c
              ISO/IEC 2017 – All rights reserved                                                                                xi
              ISO/IEC DIS 1539-1:2017 (E)
                        B.3.12    Speciﬁc names for intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
                        B.3.13    FORALLconstruct and statement. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
              Annex C (informative) Extended notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
                  C.1   Fortran 2008 features not mentioned in its Introduction . . . . . . . . . . . . . . . . . . . . . . . . 543
                  C.2   Clause 7 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
                        C.2.1     Selection of the approximation methods (7.4.3.2)    . . . . . . . . . . . . . . . . . . . . . . 543
                        C.2.2     Type extension and component accessibility (7.5.2.2, 7.5.4) . . . . . . . . . . . . . . . . . 544
                        C.2.3     Generic type-bound procedures (7.5.5) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545
                        C.2.4     Abstract types (7.5.7.1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546
                        C.2.5     Structure constructors and generic names (7.5.10) . . . . . . . . . . . . . . . . . . . . . . 547
                        C.2.6     Final subroutines (7.5.6, 7.5.6.2, 7.5.6.3, 7.5.6.4) . . . . . . . . . . . . . . . . . . . . . . . 548
                  C.3   Clause 8 notes: The VOLATILE attribute (8.5.19)        . . . . . . . . . . . . . . . . . . . . . . . . . . 550
                  C.4   Clause 9 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551
                        C.4.1     Structure components (9.4.2) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551
                        C.4.2     Allocation with dynamic type (9.7.1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552
                  C.5   Clause 10 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
                        C.5.1     Evaluation of function references (10.1.7) . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
                        C.5.2     Pointers in expressions (10.1.9.2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
                        C.5.3     Pointers in variable deﬁnition contexts (10.2.1.3, 19.6.7)  . . . . . . . . . . . . . . . . . . 553
                  C.6   Clause 11 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
                        C.6.1     The SELECT CASE construct (11.1.9) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
                        C.6.2     Loop control (11.1.7) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554
                        C.6.3     Examples of DO constructs (11.1.7) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554
                        C.6.4     Examples of invalid DO constructs (11.1.7) . . . . . . . . . . . . . . . . . . . . . . . . . . 555
                        C.6.5     Simple example using events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 556
                        C.6.6     Example using three teams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
                        C.6.7     Accessing coarrays in sibling teams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
                        C.6.8     Example involving failed images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 558
                        C.6.9     EVENT_QUERYexample that tolerates image failure . . . . . . . . . . . . . . . . . . . 560
                  C.7   Clause 12 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
                        C.7.1     External ﬁles (12.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
                        C.7.2     Nonadvancing input/output (12.3.4.2)     . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563
                        C.7.3     OPENstatement (12.5.6) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565
                        C.7.4     Connection properties (12.5.4) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
                        C.7.5     Asynchronous input/output (12.6.2.5) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567
                  C.8   Clause 13 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
                        C.8.1     Number of records (13.4, 13.5, 13.8.2) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
                        C.8.2     List-directed input (13.10.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
                  C.9   Clause 14 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
                        C.9.1     Main program and block data program unit (14.1, 14.3)       . . . . . . . . . . . . . . . . . . 569
                        C.9.2     Dependent compilation (14.2) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
                        C.9.3     Examples of the use of modules (14.2.1)    . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
                        C.9.4     Modules with submodules (14.2.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
                  C.10 Clause 15 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582
                        C.10.1    Portability problems with external procedures (15.4.3.5) . . . . . . . . . . . . . . . . . . 582
                        C.10.2    Procedures deﬁned by means other than Fortran (15.6.3) . . . . . . . . . . . . . . . . . . 582
                        C.10.3    Abstract interfaces and procedure pointer components (15.4, 7.5) . . . . . . . . . . . . . 582
                        C.10.4    Pointers and targets as arguments (15.5.2.4, 15.5.2.6, 15.5.2.7) . . . . . . . . . . . . . . . 584
                        C.10.5    Polymorphic Argument Association (15.5.2.9) . . . . . . . . . . . . . . . . . . . . . . . . 586
                        C.10.6    Rules ensuring unambiguous generics (15.4.3.4.5)    . . . . . . . . . . . . . . . . . . . . . . 587
                  C.11 Clause 16 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591
                        C.11.1    Atomic memory consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 591
                        C.11.2    EVENT_QUERYexample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
                        C.11.3    Collective subroutine examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
                  C.12 Clause 18 notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
                                                                                 c
              xii                                                                ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                      C.12.1   Runtime environments (18.1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
                      C.12.2   Example of Fortran calling C (18.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
                      C.12.3   Example of C calling Fortran (18.3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597
                      C.12.4   Example of calling C functions with noninteroperable data (18.10) . . . . . . . . . . . . . 599
                      C.12.5   Example of opaque communication between C and Fortran (18.3) . . . . . . . . . . . . . 599
                      C.12.6   Using assumed type to interoperate with C . . . . . . . . . . . . . . . . . . . . . . . . . . 601
                      C.12.7   Using assumed-type variables in Fortran . . . . . . . . . . . . . . . . . . . . . . . . . . . 603
                      C.12.8   Simplifying interfaces for arbitrary rank procedures . . . . . . . . . . . . . . . . . . . . . 604
                      C.12.9   Processing assumed-shape arrays in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
                      C.12.10 Creating a contiguous copy of an array . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606
                      C.12.11 Changing the attributes of an array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
                      C.12.12 Creating an array section in C using CFI_section . . . . . . . . . . . . . . . . . . . . . . 608
                      C.12.13 Use of CFI_setpointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
                      C.12.14 Mapping of MPI interfaces to Fortran . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
                C.13 Clause 19 notes : Examples of host association (19.5.1.4) . . . . . . . . . . . . . . . . . . . . . . . 613
             Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
              c
             ISO/IEC 2017 – All rights reserved                                                                     xiii
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      xiv                          ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
               List of Tables
                  4.3   Previous editions of the Fortran International Standard . . . . . . . . . . . . . . . . . . . . 30
                  5.1   Requirements on statement ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          39
                  5.2   Statements allowed in scoping units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         40
                  6.1   Special characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  50
                  6.2   Adjacent keywords where separating blanks are optional . . . . . . . . . . . . . . . . . . . 53
                  9.1   Subscript order value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
                  10.1 Categories of operations and relative precedence . . . . . . . . . . . . . . . . . . . . . . . . 151
                  10.2 Type of operands and results for intrinsic operators . . . . . . . . . . . . . . . . . . . . . . 154
                  10.3 Interpretation of the numeric intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . . 155
                  10.4 Interpretation of the character intrinsic operator // . . . . . . . . . . . . . . . . . . . . . . 157
                  10.5 Interpretation of the logical intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . . . 158
                  10.6 The values of operations involving logical intrinsic operators . . . . . . . . . . . . . . . . . 158
                  10.7 Interpretation of the relational intrinsic operators . . . . . . . . . . . . . . . . . . . . . . . 159
                  10.8 Intrinsic assignment type conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
                  10.9 Numeric conversion and the assignment statement . . . . . . . . . . . . . . . . . . . . . . . 169
                  13.1 E and D exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
                  13.2 EN exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
                  13.3 ES exponent forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
                  16.1 Standard generic intrinsic procedure summary . . . . . . . . . . . . . . . . . . . . . . . . . 342
                  16.2 Unrestricted speciﬁc intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
                  16.3 Restricted speciﬁc intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
                  16.4 Default BOUNDARY values for EOSHIFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
                  16.5 Characteristics of the result of NULL ( ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
                  17.1 IEEE relational operator correspondence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
                  17.2 IEEE_ARITHMETIC module procedure summary . . . . . . . . . . . . . . . . . . . . . . 450
               c
               ISO/IEC 2017 – All rights reserved                                                                                  xv
      ISO/IEC DIS 1539-1:2017 (E)
        17.3 IEEE_EXCEPTIONS module procedure summary. . . . . . . . . . . . . . . . . . . . . . . 451
        18.1 Names of C characters with special semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 480
        18.2 Interoperability between Fortran and C types . . . . . . . . . . . . . . . . . . . . . . . . . . 485
        18.3 ISO_Fortran_binding.h macros for attribute codes . . . . . . . . . . . . . . . . . . . . . . 494
        18.4 ISO_Fortran_binding.h macros for type codes . . . . . . . . . . . . . . . . . . . . . . . . . 494
        18.5 ISO_Fortran_binding.h macros for error codes . . . . . . . . . . . . . . . . . . . . . . . . . 495
                                   c
      xvi                          ISO/IEC 2017 – All rights reserved
                                           ISO/IEC DIS 1539-1:2017 (E)
       Foreword
      1 ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commis-
       sion) form the specialized system for worldwide standardization. National bodies that are members of ISO or
       IEC participate in the development of International Standards through technical committees established by the
       respective organization to deal with particular ﬁelds of technical activity. ISO and IEC technical committees
       collaborate in ﬁelds of mutual interest. Other international organizations, governmental and nongovernmental,
       in liaison with ISO and IEC, also take part in the work. In the ﬁeld of information technology, ISO and IEC have
       established a joint technical committee, ISO/IEC JTC 1.
      2 International Standards are drafted in accordance with the rules given in the ISO/IEC Directives, Part 2.
      3 The main task of the joint technical committee is to prepare International Standards. Draft International Stand-
       ards adopted by the joint technical committee are circulated to national bodies for voting. Publication as an
       International Standard requires approval by at least 75 % of the national bodies casting a vote.
      4 Attention is drawn to the possibility that some of the elements of this document may be the subject of patent
       rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights.
      5 ISO/IEC 1539-1 was prepared by Joint Technical Committee ISO/IEC JTC 1, Information technology, Subcom-
       mittee SC 22, Programming languages, their environments and system software interfaces.
      6 This fourth edition cancels and replaces the third edition (ISO/IEC 1539-1:2010), which has been technic-
       ally revised. It also incorporates the Technical Corrigenda ISO/IEC 1539-1:2010/Cor. 1:2012, ISO/IEC 1539-
       1:2010/Cor. 2:2013, ISO/IEC 1539-1:2010/Cor. 3:2014, and ISO/IEC 1539-1:2010/Cor. 4:2016, and the Technical
       Speciﬁcations ISO/IEC TS 29113:2012 and ISO/IEC TS 18508:2015.
      7 ISO/IEC 1539 consists of the following parts, under the general title Information technology — Programming
       languages — Fortran:
      8 —Part 1: Base language
      9 —Part 2: Varying length character strings
       c
       ISO/IEC 2017 – All rights reserved                  xvii
        ISO/IEC DIS 1539-1:2017 (E)
        Introduction
      1 This document comprises the speciﬁcation of the base Fortran language, informally known as Fortran 2018.
        With the limitations noted in 4.3.3, the syntax and semantics of Fortran 2008 are contained entirely within
        Fortran 2018. Therefore, any standard-conforming Fortran 2008 program not aﬀected by such limitations is a
        standard-conforming Fortran 2018 program. New features of Fortran 2018 can be compatibly incorporated into
        such Fortran 2008 programs, with any exceptions indicated in the text of this document.
      2 Fortran 2018 contains several extensions to Fortran 2008; these are listed below.
          • Data declaration:
           Constant properties of an object declared in its entity-decl can be used in its initialization. The EQUIVAL-
           ENCEandCOMMONstatements and the block data program unit have been redundant since Fortran 90
           and are now speciﬁed to be obsolescent. Diagnosis of the appearance of a PROTECTED TARGET variable
           accessed by use association as a data-target in a structure constructor is required.
          • Data usage and computation:
           The declared type of the value supplied for a polymorphic allocatable component in a structure constructor
           is no longer required to be the same as the declared type of the component. FORALL is now speciﬁed to
           be obsolescent. The type and kind of an implied DO variable in an array constructor or DATA statement
           can be speciﬁed within the constructor or statement. The SELECT RANK construct provides structured
           access to the elements of an assumed-rank array. Completing execution of a BLOCK construct can cause
           the association status of a pointer with the PROTECTED attribute to become undeﬁned. The standard
           intrinsic operations <, <=, >, and >= (also known as .LT., .LE., .GT., and .GE.) on IEEE numbers provide
           compareSignaling{relation} operations; the = and /= operations (also known as .EQ. and .NE.) provide
           compareQuiet{relation} operations. Finalization of an allocatable subobject during intrinsic assignment
           has been clariﬁed.
          • Input/output:
           TheSIZE=speciﬁercanbeusedwithadvancinginput. Itisnolongerprohibitedtoopenaﬁleonmorethan
           one unit. The value assigned by the RECL= speciﬁer in an INQUIRE statement has been standardized.
           The values assigned by the POS= and SIZE= speciﬁers in an INQUIRE statement for a unit that has
           pending asynchronous operations have been standardized. The G0.d edit descriptor can be used for list
           items of type Integer, Logical, and Character. The D, E, EN, and ES edit descriptors can have a ﬁeld width
           of zero, analogous to the F edit descriptor. The exponent width e in a data edit descriptor can be zero,
           analogous to a ﬁeld width of zero. Floating-point formatted input accepts hexadecimal-signiﬁcand numbers
           that conform to ISO/IEC/IEEE 60559:2011. The EX edit descriptor provides hexadecimal-signiﬁcand
           formatted output conforming to ISO/IEC/IEEE 60559:2011. An error condition occurs if unacceptable
           characters are presented for logical or numeric editing during execution of a formatted input statement.
          • Execution control:
           The arithmetic IF statement has been deleted. Labeled DO loops have been redundant since Fortran 90
           and are now speciﬁed to be obsolescent. The nonblock DO construct has been deleted. The locality of a
           variable used in a DO CONCURRENT construct can be explicitly speciﬁed. The stop code in a STOP or
           ERRORSTOPstatement can be nonconstant. Output of the stop code and exception summary from the
           STOPandERRORSTOPstatements can be controlled.
          • Intrinsic procedures and modules:
           In a reference to the intrinsic function CMPLX with an actual argument of type complex, no keyword
           is needed for a KIND argument. In references to the intrinsic functions ALL, ANY, FINDLOC, IALL,
           IANY, IPARITY, MAXLOC, MAXVAL, MINLOC, MINVAL, NORM2, PARITY, PRODUCT, SUM, and
           THIS_IMAGE,theactualargumentforDIMcanbeapresentoptionaldummyargument. Thenewintrinsic
           function COSHAPE returns the coshape of a coarray. The new intrinsic function OUT_OF_RANGE tests
           whether a numeric value can be safely converted to a diﬀerent type or kind. The new intrinsic subroutine
           RANDOM_INITestablishes the initial state of the pseudorandom number generator used by RANDOM_-
           NUMBER.ThenewintrinsicfunctionREDUCEperformsuser-speciﬁedarrayreductions. Aprocessorisre-
           quired to report use of a nonstandard intrinsic procedure, use of a nonstandard intrinsic module, and use of a
           nonstandard procedure from a standard intrinsic module. Integer and logical arguments to intrinsic proced-
           ures and intrinsic module procedures that were previously required to be of default kind no longer have that
                                           c
        xviii                              ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
         requirement, except for RANDOM_SEED. Speciﬁc names for intrinsic functions are now deemed obsoles-
         cent. All standard procedures in the intrinsic module ISO_C_BINDING, other than C_F_POINTER, are
         now pure. The arguments to the intrinsic function SIGN can be of diﬀerent kind. Nonpolymorphic pointer
         arguments to the intrinsic functions EXTENDS_TYPE_OF and SAME_TYPE_ASneednothavedeﬁned
         pointer association status. The eﬀects of invoking the intrinsic procedures COMMAND_ARGUMENT_-
         COUNT,GET_COMMAND,andGET_COMMAND_ARGUMENT,onimagesotherthanimageone,are
         no longer processor dependent. Access to error messages from the intrinsic subroutines GET_COMMAND,
         GET_COMMAND_ARGUMENT,andGET_ENVIRONMENT_VARIABLEisprovided by an optional
         ERRMSGargument. The result of NORM2 for a zero-sized array argument has been clariﬁed.
        • Program units and procedures:
         The IMPORT statement can appear in a contained subprogram or BLOCK construct, and can restrict
         access via host association; diagnosis of violation of the IMPORT restrictions is required. The GENERIC
         statement can be used to declare generic interfaces. The number of procedure arguments is used in generic
         resolution. In a module, the default accessibility of entities accessed from another module can be controlled
         separately from the default accessibility of entities declared in the using module. An IMPLICIT NONE
         statement can require explicit declaration of the EXTERNAL attribute throughout a scoping unit and
         its contained scoping units. A deﬁned operation need not specify INTENT (IN) for a dummy argument
         with the VALUE attribute. A deﬁned assignment need not specify INTENT (IN) for the second dummy
         argument if it has the VALUE attribute. Procedures that are not declared with an asterisk type-param-value can
         be invoked recursively by default; the RECURSIVE keyword is advisory only. The NON_RECURSIVE
         keyword speciﬁes that a procedure is not recursive. The ERROR STOP statement can appear in a pure
         subprogram. A dummy argument of a pure function is permitted in a variable deﬁnition context, if it has
         the VALUE attribute. A coarray dummy argument can be referenced or deﬁned by another image.
        • Features previously described by ISO/IEC TS 29113:2012:
         Adummydata object can assume its rank from its eﬀective argument. A dummy data object can assume
         the type from its eﬀective argument, without having the ability to perform type selection. An interoper-
         able procedure can have dummy arguments that are assumed-type and/or assumed-rank. An interoperable
         procedure can have dummy data objects that are allocatable, assumed-shape, optional, or pointers. The
         character length of a dummy data object of an interoperable procedure can be assumed. The argument
         to C_LOC can be a noninteroperable array. The FPTR argument to C_F_POINTER can be a noninter-
         operable array pointer. The argument to C_FUNLOC can be a noninteroperable procedure. The FPTR
         argument to C_F_PROCPOINTER can be a noninteroperable procedure pointer.
         Additionally to ISO/IEC TS 29113:2012, an assumed-rank dummy data object that is not associated with
         an assumed-size array can be used as the argument to the function C_SIZEOF from the intrinsic module
         ISO_C_BINDING.
        • Changes to the intrinsic modules IEEE_ARITHMETIC, IEEE_EXCEPTIONS, and IEEE_FEATURES
         for conformance with ISO/IEC/IEEE 60559:2011:
         There is a new, optional, rounding mode IEEE_AWAY. The new type IEEE_MODES_TYPE encapsu-
         lates all ﬂoating-point modes. Features associated with subnormal numbers can be accessed with func-
         tions and types named ...SUBNORMAL...(the old ...DENORMAL...names remain). The new function
         IEEE_FMA performs fused multiply-add operations. The function IEEE_INT performs rounded conver-
         sions to integer type. The new functions IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_-
         NUM, and IEEE_MIN_NUM_MAG calculate maximum and minimum numeric values. The new func-
         tions IEEE_NEXT_DOWNandIEEE_NEXT_UPreturntheadjacent machine numbers. The new func-
         tions IEEE_QUIET_EQ,IEEE_QUIET_GE,IEEE_QUIET_GT,IEEE_QUIET_LE,IEEE_QUIET_-
         LT, and IEEE_QUIET_NE perform quiet comparisons. The new functions IEEE_SIGNALING_EQ,
         IEEE_SIGNALING_GE, IEEE_SIGNALING_GT, IEEE_SIGNALING_GE, IEEE_SIGNALING_LE,
         IEEE_SIGNALING_LT,andIEEE_SIGNALING_NEperformsignalingcomparisons. Thedecimalround-
         ing mode can be inquired and set independently of the binary rounding mode, using the RADIX argument
         to IEEE_GET_ROUNDING_MODEandIEEE_SET_ROUNDING_MODE.ThenewfunctionIEEE_-
         REALperforms rounded conversions to real type. The function IEEE_REM now requires its arguments to
         have the same radix. The function IEEE_RINT now has a ROUND argument to perform speciﬁc rounding.
         The new function IEEE_SIGNBIT tests the sign bit of an IEEE number.
        • Features previously described by ISO/IEC TS 18508:2015:
         The CRITICAL statement has optional ERRMSG= and STAT= speciﬁers. The intrinsic subroutines
       c
      ISO/IEC 2017 – All rights reserved             xix
             ISO/IEC DIS 1539-1:2017 (E)
                   ATOMIC_DEFINEandATOMIC_REFhaveanoptionalSTATargument. The new intrinsic subroutines
                   ATOMIC_ADD,ATOMIC_AND,ATOMIC_CAS,ATOMIC_FETCH_ADD,ATOMIC_FETCH_AND,
                   ATOMIC_FETCH_OR,ATOMIC_FETCH_XOR,ATOMIC_OR,andATOMIC_XORperformatomic
                   operations. The new intrinsic functions FAILED_IMAGES and STOPPED_IMAGES return indices of im-
                   ages known to have failed or stopped respectively. The new intrinsic function IMAGE_STATUS returns the
                   image execution status of an image. The intrinsic subroutine MOVE_ALLOC has optional ERRMSG and
                   STATarguments. Theintrinsicfunctions IMAGE_INDEXandNUM_IMAGEShaveadditionalformswith
                   a TEAM or TEAM_NUMBER argument. The intrinsic function THIS_IMAGE has an optional TEAM
                   argument. The EVENT POST and EVENT WAIT statements, the intrinsic subroutine EVENT_QUERY,
                   and the type EVENT_TYPE provide an event facility for one-sided segment ordering. The CHANGE
                   TEAM construct, derived type TEAM_TYPE, FORM TEAM and SYNC TEAM statements, intrinsic
                   functions GET_TEAM and TEAM_NUMBER, and the TEAM= and TEAM_NUMBER= speciﬁers on
                   image selectors, provide a team facility for a subset of the program’s images to act in concert as if it were the
                   set of all images. This team facility allows an allocatable coarray to be allocated or deallocated on a sub-
                   set of images. The new intrinsic subroutines CO_BROADCAST, CO_MAX, CO_MIN, CO_REDUCE,
                   and CO_SUM perform collective reduction operations on the images of the current team. The concept
                   of failed images, the FAIL IMAGE statement, the STAT= speciﬁer on image selectors, and the named
                   constant STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV provide support for
                   fault-tolerant parallel execution.
                 • Changes to features previously described by ISO/IEC TS 18508:2015:
                   TheCHANGETEAMandSYNCTEAMstatements,andtheTEAM=speciﬁeronimageselectors,permit
                   the team to be speciﬁed by an expression. The intrinsic functions FAILED_IMAGES and STOPPED_-
                   IMAGES have no restriction on the kind of their result. The name of the function argument to the
                   intrinsic function CO_REDUCE is OPERATION instead of OPERATOR; this argument is not required to
                   be commutative. The named constant STAT_UNLOCKED_FAILED_IMAGE from the intrinsic module
                   ISO_FORTRAN_ENVindicatesthatalockvariablewaslockedbyanimagethatfailed. Theteamnumber
                   for the initial team can be used in image selectors, and in the intrinsic functions NUM_IMAGES and
                   IMAGE_INDEX.Ateamvariable that appears in a CHANGE TEAM statement can no longer be deﬁned
                   or become undeﬁned during execution of the CHANGE TEAM construct. All images of the current team
                   are no longer required to execute the same CHANGE TEAM statement. A variable of type TEAM_TYPE
                   from the intrinsic module ISO_FORTRAN_ENV is not permitted to be a coarray. A variable of type
                   TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV can have a pointer component, and a
                   team variable becomes undeﬁned if assigned a value from another image.
           3 This document is organized in 19 clauses, dealing with 8 conceptual areas. These 8 areas, and the clauses in
             which they are treated, are:
                                          High/low level concepts           Clauses 4, 5, 6
                                          Data concepts                     Clauses 7, 8, 9
                                          Computations                      Clauses 10, 16, 17
                                          Execution control                 Clause 11
                                          Input/output                      Clauses 12, 13
                                          Program units                     Clauses 14, 15
                                          Interoperability with C           Clause 18
                                          Scoping and association rules     Clause 19
           4 It also contains the following nonnormative material:
                                          Processor dependencies            Annex A
                                          Deleted and obsolescent features  Annex B
                                          Extended notes                    Annex C
                                          Index                             Index
                                                                             c
             xx                                                             ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             Information technology — Programming languages —
             Fortran —
             Part 1:
             Base language
             1 Scope
          1 This document speciﬁes the form and establishes the interpretation of programs expressed in the base Fortran
             language.  The purpose of this document is to promote portability, reliability, maintainability, and eﬃcient
             execution of Fortran programs for use on a variety of computing systems.
          2 This document speciﬁes
                 • the forms that a program written in the Fortran language may take,
                 • the rules for interpreting the meaning of a program and its data,
                 • the form of the input data to be processed by such a program, and
                 • the form of the output data resulting from the use of such a program.
          3 Except where stated otherwise, requirements and prohibitions speciﬁed by this document apply to programs
             rather than processors.
          4 This document does not specify
                 • the mechanism by which programs are transformed for use on computing systems,
                 • the operations required for setup and control of the use of programs on computing systems,
                 • the method of transcription of programs or their input or output data to or from a storage medium,
                 • the program and processor behavior when this document fails to establish an interpretation except for the
                   processor detection and reporting requirements in items (2) to (10) of 4.2,
                 • the maximum number of images, or the size or complexity of a program and its data that will exceed the
                   capacity of any particular computing system or the capability of a particular processor,
                 • the mechanism for determining the number of images of a program,
                 • the physical properties of an image or the relationship between images and the computational elements of
                   a computing system,
                 • the physical properties of the representation of quantities and the method of rounding, approximating, or
                   computing numeric values on a particular processor, except by reference to ISO/IEC/IEEE 60559:2011
                   under conditions speciﬁed in Clause 17,
                 • the physical properties of input/output records, ﬁles, and units, or
                 • the physical properties and implementation of storage.
              c
             ISO/IEC 2017 – All rights reserved                                                                       1
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      2                            ISO/IEC 2017 – All rights reserved
                                             ISO/IEC DIS 1539-1:2017 (E)
       2 Normative references
      1 The following documents are referred to in the text in such a way that some or all of their content constitutes
       requirements of this document. For dated references, only the edition cited applies. For undated references, the
       latest edition of the referenced document (including any amendments) applies.
       ISO/IEC 646:1991 (International Reference Version), Information technology—ISO 7-bit coded character set for
       information interchange
       ISO/IEC 9899:2011, Programming languages—C
       ISO/IEC 10646, Information technology—Universal Multiple-Octet Coded Character Set (UCS)
       ISO/IEC/IEEE 60559:2011, Information technology — Microprocessor Systems — Floating-Point arithmetic
        c
       ISO/IEC 2017 – All rights reserved                     3
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      4                            ISO/IEC 2017 – All rights reserved
                                            ISO/IEC DIS 1539-1:2017 (E)
       3 Terms and deﬁnitions
      1 Forthepurposesofthisdocument,thefollowingtermsanddeﬁnitionsapply. ISOandIECmaintainterminological
       databases for use in standardization at the following addresses:
         • IEC Electropedia: available at http://www.electropedia.org/
         • ISO Online browsing platform: available at http://www.iso.org/obp
       3.1
       actual argument
       entity (R1524) that appears in a procedure reference
       3.2
       allocatable
       having the ALLOCATABLE attribute (8.5.3)
       3.3
       array
       set of scalar data, all of the same type and type parameters, whose individual elements are arranged in a
       rectangular pattern (8.5.8, 9.5)
       3.3.1
       array element
       scalar individual element of an array
       3.3.2
       array pointer
       array with the POINTER attribute (8.5.14)
       3.3.3
       array section
       array subobject designated by array-section, and which is itself an array (9.5.3.3)
       3.3.4
       assumed-shape array
       nonallocatable nonpointer dummy argument array that takes its shape from its eﬀective argument (8.5.8.3)
       3.3.5
       assumed-size array
       dummy argument array whose size is assumed from that of its eﬀective argument (8.5.8.5)
       3.3.6
       deferred-shape array
       allocatable array or array pointer, declared with a deferred-shape-spec-list (8.5.8.4)
       3.3.7
       explicit-shape array
       array declared with an explicit-shape-spec-list, which speciﬁes explicit values for the bounds in each dimension of
       the array (8.5.8.2)
       3.4
       ASCII character
       character whose representation method corresponds to ISO/IEC 646:1991 (International Reference Version)
       c
       ISO/IEC 2017 – All rights reserved                    5
      ISO/IEC DIS 1539-1:2017 (E)
      3.5
      associate name
      name of construct entity associated with a selector of an ASSOCIATE, CHANGE TEAM, SELECT RANK, or
      SELECT TYPE construct (11.1.3, 11.1.5, 11.1.10, 11.1.11)
      3.6
      associating entity
      hin a dynamically-established associationi the entity that did not exist prior to the establishment of the association
      (19.5.5)
      3.7
      association
      inheritance association, name association, pointer association, or storage association.
      3.7.1
      argument association
      association between an eﬀective argument and a dummy argument (15.5.2)
      3.7.2
      construct association
      association between a selector and an associate name in an ASSOCIATE, CHANGE TEAM, SELECT RANK,
      or SELECT TYPE construct(11.1.3, 11.1.5, 11.1.10, 11.1.11, 19.5.1.6)
      3.7.3
      host association
      name association, other than argument association, between entities in a submodule or contained scoping unit
      and entities in its host (19.5.1.4)
      3.7.4
      inheritance association
      association between the inherited components of an extended type and the components of its parent component
      (19.5.4)
      3.7.5
      linkage association
      association between a variable or common block with the BIND attribute and a C global variable (18.9, 19.5.1.5)
      3.7.6
      name association
      argument association, construct association, host association, linkage association, or use association (19.5.1)
      3.7.7
      pointer association
      association between a pointer and an entity with the TARGET attribute (19.5.2)
      3.7.8
      storage association
      association between storage sequences (19.5.3)
      3.7.9
      use association
      association between entities in a module and entities in a scoping unit or construct that references that module,
      as speciﬁed by a USE statement (14.2.2)
      3.8
      assumed-rank dummy data object
      dummy data object that assumes the rank, shape, and size of its eﬀective argument (8.5.8.7)
                                   c
      6                            ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.9
      assumed-type
      declared with a TYPE(*) type speciﬁer (7.3.2)
      3.10
      attribute
      property of an entity that determines its uses (8.1)
      3.11
      automatic data object
      nondummy data object with a type parameter or array bound that depends on the value of a speciﬁcation-expr
      that is not a constant expression (8.3)
      3.12
      base object
      hdata-refi object designated by the leftmost part-name (9.4.2)
      3.13
      binding
      type-bound procedure or ﬁnal subroutine (7.5.5)
      3.14
      binding name
      name given to a speciﬁc or generic type-bound procedure in the type deﬁnition (7.5.5)
      3.15
      binding label
      default character value specifying the name by which a global entity with the BIND attribute is known to the
      companion processor (18.10.2, 18.9.2)
      3.16
      block
      sequence of executable constructs formed by the syntactic class block and which is treated as a unit by the
      executable constructs described in 11.1
      3.17
      bound
      array bound
      limit of a dimension of an array (8.5.8)
      3.18
      branch target statement
      action-stmt, associate-stmt, end-associate-stmt, if-then-stmt, end-if-stmt, select-case-stmt, end-select-stmt, select-
      rank-stmt, end-select-rank-stmt, select-type-stmt, end-select-type-stmt, do-stmt, end-do-stmt, block-stmt, end-
      block-stmt, critical-stmt, end-critical-stmt, forall-construct-stmt, where-construct-stmt, end-function-stmt, end-mp-
      subprogram-stmt, end-program-stmt, or end-subroutine-stmt, whose statement label appears as a label in a GO TO
      statement, computed GO TO statement, alt-return-spec, END= speciﬁer, EOR= speciﬁer, or ERR= speciﬁer (11.2.1)
      3.19
      C address
      value identifying the location of a data object or procedure either deﬁned by the companion processor or which
      might be accessible to the companion processor
         NOTE3.1
        This is the concept that ISO/IEC 9899:2011 calls the address.
       c
      ISO/IEC 2017 – All rights reserved              7
          ISO/IEC DIS 1539-1:2017 (E)
          3.20
          C descriptor
          Cstructure of type CFI_cdesc_t deﬁned in the source ﬁle ISO_Fortran_binding.h (18.4, 18.5)
          3.21
          character context
          within a character literal constant (7.4.4) or within a character string edit descriptor (13.3.2)
          3.22
          characteristics
          hdummy argumenti being a dummy data object, dummy procedure, or an asterisk (alternate return indicator)
          3.23
          characteristics
          hdummy data objecti properties listed in 15.3.2.2
          3.24
          characteristics
          hdummy procedure or dummy procedure pointeri properties listed in 15.3.2.3
          3.25
          characteristics
          hfunction resulti properties listed in 15.3.3
          3.26
          characteristics
          hprocedurei properties listed in 15.3.1
          3.27
          coarray
          data entity that has nonzero corank (5.4.7)
          3.27.1
          established coarray
          coarray that is accessible using an image-selector (5.4.8)
          3.28
          cobound
          bound (limit) of a codimension (8.5.6)
          3.29
          codimension
          dimension of the pattern formed by a set of corresponding coarrays (8.5.6)
          3.30
          coindexed object
          data object whose designator includes an image-selector (R924, 9.6)
          3.31
          collating sequence
          one-to-one mapping from a character set into the nonnegative integers (7.4.4.4)
          3.32
          common block
          block of physical storage speciﬁed by a COMMON statement (8.10.2)
          3.32.1
          blank common
          unnamed common block
                                                        c
          8                                             ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.33
      companion processor
      processor-dependent mechanism by which global data and procedures may be referenced or deﬁned (5.5.7)
      3.34
      component
      part of a derived type, or of an object of derived type, deﬁned by a component-def-stmt (7.5.4)
      3.34.1
      direct component
      one of the components, or one of the direct components of a nonpointer nonallocatable component (7.5.1)
      3.34.2
      parent component
      component of an extended type whose type is that of the parent type and whose components are inheritance
      associated with the inherited components of the parent type (7.5.7.2)
      3.34.3
      potential subobject component
      nonpointer component, or potential subobject component of a nonpointer component (7.5.1)
      3.34.4
      subcomponent
      hstructurei direct component that is a subobject of the structure (9.4.2)
      3.34.5
      ultimate component
      component that is of intrinsic type, a pointer, or allocatable; or an ultimate component of a nonpointer nonal-
      locatable component of derived type
      3.35
      component order
      ordering of the nonparent components of a derived type that is used for intrinsic formatted input/output and
      structure constructors (where component keywords are not used) (7.5.4.7)
      3.36
      conformable
      hof two data entitiesi having the same shape, or one being an array and the other being scalar
      3.37
      connected
      relationship between a unit and a ﬁle: each is connected if and only if the unit refers to the ﬁle (12.5.4)
      3.38
      constant
      data object that has a value and which cannot be deﬁned, redeﬁned, or become undeﬁned during execution of a
      program (6.2.3, 9.3)
      3.38.1
      literal constant
      constant that does not have a name (R605, 7.4)
      3.38.2
      named constant
      named data object with the PARAMETER attribute (8.5.13)
       c
      ISO/IEC 2017 – All rights reserved              9
      ISO/IEC DIS 1539-1:2017 (E)
      3.39
      construct entity
      entity whose identiﬁer has the scope of a construct (19.1, 19.4)
      3.40
      constant expression
      expression satisfying the requirements speciﬁed in 10.1.12, thus ensuring that its value is constant
      3.41
      contiguous
      harrayi having array elements in order that are not separated by other data objects, as speciﬁed in 8.5.7
      3.42
      contiguous
      hmulti-part data objecti that the parts in order are not separated by other data objects
      3.43
      corank
      number of codimensions of a coarray (zero for objects that are not coarrays) (8.5.6)
      3.44
      cosubscript
      (R925) scalar integer expression in an image-selector (R924)
      3.45
      data entity
      data object, result of the evaluation of an expression, or the result of the execution of a function reference
      3.46
      data object
      object
      constant (7.1.4), variable (9), or subobject of a constant (5.4.3.2.3)
      3.47
      decimal symbol
      character that separates the whole and fractional parts in the decimal representation of a real number in a ﬁle
      (13.6)
      3.48
      declaration
      speciﬁcation of attributes for various program entities
         NOTE3.2
        Often this involves specifying the type of a named data object or specifying the shape of a named array
        object.
      3.49
      default initialization
      mechanism for automatically initializing pointer components to have a deﬁned pointer association status, and
      nonpointer components to have a particular value (7.5.4.6)
      3.50
      default-initialized
      hsubcomponenti subject to a default initialization speciﬁed in the type deﬁnition for that component (7.5.4.6)
      3.51
      deﬁnable
      capable of deﬁnition and permitted to become deﬁned
                                   c
      10                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.52
      deﬁned
      hdata objecti has a valid value
      3.53
      deﬁned
      hpointeri has a pointer association status of associated or disassociated (19.5.2.2)
      3.54
      deﬁned assignment
      assignment deﬁned by a procedure (10.2.1.4, 15.4.3.4.3)
      3.55
      deﬁned input/output
      input/output deﬁned by a procedure and accessed via a deﬁned-io-generic-spec (R1509, 12.6.4.8)
      3.56
      deﬁned operation
      operation deﬁned by a procedure (10.1.6.1, 15.4.3.4.2)
      3.57
      deﬁnition
      hdata objecti process by which the data object becomes deﬁned (19.6.5)
      3.58
      deﬁnition
      hderived type (7.5.2), enumeration (7.6), or procedure (15.6)i speciﬁcation of the type, enumeration, or procedure
      3.59
      descendant
      hmodule or submodulei submodule that extends that module or submodule or that extends another descendant
      thereof (14.2.3)
      3.60
      designator
      namefollowed by zero or more component selectors, complex part selectors, array section selectors, array element
      selectors, image selectors, and substring selectors (9.1)
      3.60.1
      complex part designator
      designator that designates the real or imaginary part of a complex data object, independently of the other part
      (9.4.4)
      3.60.2
      object designator
      data object designator
      designator for a data object
         NOTE3.3
        An object name is a special case of an object designator.
      3.60.3
      procedure designator
      designator for a procedure
       c
      ISO/IEC 2017 – All rights reserved             11
          ISO/IEC DIS 1539-1:2017 (E)
          3.61
          disassociated
          hpointer associationi pointer association status of not being associated with any target and not being undeﬁned
          (19.5.2.2)
          3.62
          disassociated
          hpointeri has a pointer association status of disassociated
          3.63
          dummy argument
          entity whose identiﬁer appears in a dummy argument list (R1536) in a FUNCTION, SUBROUTINE, ENTRY, or
          statement function statement, or whose name can be used as an argument keyword in a reference to an intrinsic
          procedure or a procedure in an intrinsic module
          3.63.1
          dummy data object
          dummy argument that is a data object
          3.63.2
          dummy function
          dummy procedure that is a function
          3.64
          eﬀective argument
          entity that is argument-associated with a dummy argument (15.5.2.3)
          3.65
          eﬀective item
          scalar object resulting from the application of the rules in 12.6.3 to an input/output list
          3.66
          elemental
          independent scalar application of an action or operation to elements of an array or corresponding elements of a
          set of conformable arrays and scalars, or possessing the capability of elemental operation
             NOTE3.4
             Combination of scalar and array operands or arguments combine the scalar operand(s) with each element
             of the array operand(s).
          3.66.1
          elemental assignment
          assignment that operates elementally
          3.66.2
          elemental operation
          operation that operates elementally
          3.66.3
          elemental operator
          operator in an elemental operation
          3.66.4
          elemental procedure
          elemental intrinsic procedure or procedure deﬁned by an elemental subprogram (15.8)
                                                        c
          12                                            ISO/IEC 2017 – All rights reserved
                                                                ISO/IEC DIS 1539-1:2017 (E)
          3.66.5
          elemental reference
          reference to an elemental procedure with at least one array actual argument
          3.66.6
          elemental subprogram
          subprogram with the ELEMENTAL preﬁx (15.8.1)
          3.67
          ENDstatement
           end-block-data-stmt, end-function-stmt, end-module-stmt, end-mp-subprogram-stmt, end-program-stmt,
          end-submodule-stmt, or end-subroutine-stmt
          3.68
          explicit initialization
          initialization of a data object by a speciﬁcation statement (8.4, 8.6.7)
          3.69
          extent
          number of elements in a single dimension of an array
          3.70
          external ﬁle
          ﬁle that exists in a medium external to the program (12.3)
          3.71
          external unit
          external input/output unit
          entity that can be connected to an external ﬁle (12.5.3, 12.5.4)
          3.72
          ﬁle storage unit
          unit of storage in a stream ﬁle or an unformatted record ﬁle (12.3.5)
          3.73
          ﬁnal subroutine
          subroutine whose name appears in a FINAL statement (7.5.6) in a type deﬁnition, and which can be automatically
          invoked by the processor when an object of that type is ﬁnalized (7.5.6.2)
          3.74
          ﬁnalizable
          htypei has a ﬁnal subroutine or a nonpointer nonallocatable component of ﬁnalizable type
          3.75
          ﬁnalizable
          hnonpointer data entityi of ﬁnalizable type
          3.76
          ﬁnalization
          process of calling ﬁnal subroutines when one of the events listed in 7.5.6.3 occurs
          3.77
          function
          procedure that is invoked by an expression
          3.78
          function result
          entity that returns the value of a function (15.6.2.2)
           c
          ISO/IEC 2017 – All rights reserved                                             13
      ISO/IEC DIS 1539-1:2017 (E)
      3.79
      generic identiﬁer
      lexical token sequence that identiﬁes a generic set of procedures, intrinsic operations, and/or intrinsic assignments
      (15.4.3.4)
      3.80
      host instance
      hinternal procedure, or dummy procedure or procedure pointer associated with an internal procedurei instance
      of the host procedure that supplies the host environment of the internal procedure (15.6.2.4)
      3.81
      host scoping unit
      host
      scoping unit immediately surrounding another scoping unit, or the scoping unit extended by a submodule
      3.82
      IEEE inﬁnity
      ISO/IEC/IEEE 60559:2011 conformant inﬁnite ﬂoating-point value
      3.83
      IEEE NaN
      ISO/IEC/IEEE 60559:2011 conformant ﬂoating-point datum that does not represent a number
      3.84
      image
      instance of a Fortran program (5.3.4)
      3.84.1
      active image
      image that has not failed or stopped (5.3.6)
      3.84.2
      failed image
      image that has not initiated termination but which has ceased to participate in program execution (5.3.6)
      3.84.3
      stopped image
      image that has initiated normal termination (5.3.6)
      3.85
      image index
      integer value identifying an image within a team
      3.86
      image control statement
      statement that aﬀects the execution ordering between images (11.6)
      3.87
      inclusive scope
      nonblock scoping unit plus every block scoping unit whose host is that scoping unit or that is nested within such
      a block scoping unit
         NOTE3.5
        That is, inclusive scope is the scope as if BLOCK constructs were not scoping units.
                                   c
      14                           ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
          3.88
          inherit
          hextended typei acquire entities (components, type-bound procedures, and type parameters) through type exten-
          sion from the parent type (7.5.7.2)
          3.89
          inquiry function
          intrinsic function, or function in an intrinsic module, whose result depends on the properties of one or more of
          its arguments instead of their values
          3.90
          interface
          hprocedurei name, procedure characteristics, dummy argument names, binding label, and generic identiﬁers
          (15.4.1)
          3.90.1
          abstract interface
          set of procedure characteristics with dummy argument names (15.4.1)
          3.90.2
          explicit interface
          interface of a procedure that includes all the characteristics of the procedure and names for its dummy arguments
          except for asterisk dummy arguments (15.4.2)
          3.90.3
          generic interface
          set of procedure interfaces identiﬁed by a generic identiﬁer
          3.90.4
          implicit interface
          interface of a procedure that is not an explicit interface (15.4.2, 15.4.3.8)
          3.90.5
          speciﬁc interface
          interface identiﬁed by a nongeneric name
          3.91
          interface block
          abstract interface block, generic interface block, or speciﬁc interface block (15.4.3.2)
          3.91.1
          abstract interface block
          interface block with the ABSTRACTkeyword; collection of interface bodies that specify named abstract interfaces
          3.91.2
          generic interface block
          interface block with a generic-spec; collection of interface bodies and procedure statements that are to be given
          that generic identiﬁer
          3.91.3
          speciﬁc interface block
          interface block with no generic-spec or ABSTRACT keyword; collection of interface bodies that specify the
          interfaces of procedures
          3.92
          interoperable
          hFortran entityi equivalent to an entity deﬁned by or deﬁnable by the companion processor (18.3)
          c
          ISO/IEC 2017 – All rights reserved                                           15
      ISO/IEC DIS 1539-1:2017 (E)
      3.93
      intrinsic
      type, procedure, module, assignment, operator, or input/output operation deﬁned in this document and accessible
      without further deﬁnition or speciﬁcation, or a procedure or module provided by a processor but not deﬁned in
      this document
      3.93.1
      standard intrinsic
      hprocedure or modulei deﬁned in this document (16)
      3.93.2
      nonstandard intrinsic
      hprocedure or modulei provided by a processor but not deﬁned in this document
      3.94
      internal ﬁle
      character variable that is connected to an internal unit (12.4)
      3.95
      internal unit
      input/output unit that is connected to an internal ﬁle (12.5.4)
      3.96
      ISO 10646 character
      character whose representation method corresponds to UCS-4 in ISO/IEC 10646
      3.97
      keyword
      statement keyword, argument keyword, type parameter keyword, or component keyword
      3.97.1
      argument keyword
      word that identiﬁes the corresponding dummy argument in an actual argument list (15.5.2.1)
      3.97.2
      component keyword
      word that identiﬁes a component in a structure constructor (7.5.10)
      3.97.3
      statement keyword
      word that is part of the syntax of a statement (5.5.2)
      3.97.4
      type parameter keyword
      word that identiﬁes a type parameter in a type parameter list
      3.98
      lexical token
      keyword, name, literal constant other than a complex literal constant, operator, label, delimiter, comma, =, =>,
      :, ::, ;, or % (6.2)
      3.99
      line
      sequence of zero or more characters
      3.100
      main program
      program unit that is not a subprogram, module, submodule, or block data program unit (14.1)
                                   c
      16                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.101
      masked array assignment
      assignment statement in a WHERE statement or WHERE construct (10.2.3)
      3.102
      module
      program unit containing (or accessing from other modules) deﬁnitions that are to be made accessible to other
      program units (14.2)
      3.103
      name
      identiﬁer of a program constituent, formed according to the rules given in 6.2.2
      3.104
      NaN
      Not a Number, a symbolic ﬂoating-point datum (ISO/IEC/IEEE 60559:2011)
      3.105
      operand
      data value that is the subject of an operator
      3.106
      operator
      intrinsic-operator, deﬁned-unary-op, or deﬁned-binary-op (R608, R1003, R1023)
      3.107
      passed-object dummy argument
      dummy argument of a type-bound procedure or procedure pointer component that becomes associated with the
      object through which the procedure is invoked (7.5.4.5)
      3.108
      pointer
      data pointer or procedure pointer
      3.108.1
      data pointer
      data entity with the POINTER attribute (8.5.14)
      3.108.2
      procedure pointer
      procedure with the EXTERNAL and POINTER attributes (8.5.9, 8.5.14)
      3.108.3
      local procedure pointer
      procedure pointer that is part of a local variable, or a named procedure pointer that is not a dummy argument
      or accessed by use or host association
      3.109
      pointer assignment
      association of a pointer with a target, by execution of a pointer assignment statement (10.2.2) or an intrinsic
      assignment statement (10.2.1.2) for a derived-type object that has the pointer as a subobject
      3.110
      polymorphic
      hdata entityi able to be of diﬀering dynamic types during program execution (7.3.2.3)
       c
      ISO/IEC 2017 – All rights reserved             17
      ISO/IEC DIS 1539-1:2017 (E)
      3.111
      preconnected
      hﬁle or uniti connected at the beginning of execution of the program (12.5.5)
      3.112
      procedure
      entity encapsulating an arbitrary sequence of actions that can be invoked directly during program execution
      3.112.1
      dummy procedure
      procedure that is a dummy argument (15.2.2.3)
      3.112.2
      external procedure
      procedure deﬁned by an external subprogram (R503) or by means other than Fortran (15.6.3)
      3.112.3
      internal procedure
      procedure deﬁned by an internal subprogram (R512)
      3.112.4
      module procedure
      procedure deﬁned by a module subprogram, or a procedure provided by an intrinsic module (R1408)
      3.112.5
      pure procedure
      procedure declared or deﬁned to be pure (15.7)
      3.112.6
      type-bound procedure
      procedure that is bound to a derived type and referenced via an object of that type (7.5.5)
      3.113
      processor
      combination of a computing system and mechanism by which programs are transformed for use on that computing
      system
      3.114
      processor dependent
      not completely speciﬁed in this document, having methods and semantics determined by the processor
      3.115
      program
      set of Fortran program units and entities deﬁned by means other than Fortran that includes exactly one main
      program
      3.116
      program unit
      main program, external subprogram, module, submodule, or block data program unit (5.2.1)
      3.117
      rank
      number of array dimensions of a data entity (zero for a scalar entity)
      3.118
      record
      sequence of values or characters in a ﬁle (12.2)
                                   c
      18                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.119
      record ﬁle
      ﬁle composed of a sequence of records (12.1)
      3.120
      reference
      data object reference, procedure reference, or module reference
      3.120.1
      data object reference
      appearance of a data object designator (9.1) in a context requiring its value at that point during execution
      3.120.2
      function reference
      appearance of the procedure designator for a function, or operator symbol for a deﬁned operation, in a context
      requiring execution of the function during expression evaluation (15.5.3)
      3.120.3
      module reference
      appearance of a module name in a USE statement (14.2.2)
      3.120.4
      procedure reference
      appearance of a procedure designator, operator symbol, or assignment symbol in a context requiring execution
      of the procedure at that point during execution; or occurrence of deﬁned input/output (13.7.6) or derived-type
      ﬁnalization (7.5.6.2)
      3.121
      saved
      having the SAVE attribute (8.5.16)
      3.122
      scalar
      data entity that can be represented by a single value of the type and that is not an array (9.5)
      3.123
      scoping unit
      BLOCK construct, derived-type deﬁnition, interface body, program unit, or subprogram, excluding all nested
      scoping units in it
      3.123.1
      block scoping unit
      scoping unit of a BLOCK construct
      3.124
      sequence
      set of elements ordered by a one-to-one correspondence with the numbers 1, 2, to n
      3.125
      sequence structure
      scalar data object of a sequence type (7.5.2.3)
      3.126
      sequence type
      derived type with the SEQUENCE attribute (7.5.2.3)
       c
      ISO/IEC 2017 – All rights reserved             19
      ISO/IEC DIS 1539-1:2017 (E)
      3.126.1
      character sequence type
      sequence type with no allocatable or pointer components, and whose components are all default character or of
      another character sequence type
      3.126.2
      numeric sequence type
      sequence type with no allocatable or pointer components, and whose components are all default complex, default
      integer, default logical, default real, double precision real, or of another numeric sequence type
      3.127
      shape
      array dimensionality of a data entity, represented as a rank-one array whose size is the rank of the data entity
      and whose elements are the extents of the data entity
         NOTE3.6
        Thus the shape of a scalar data entity is an array with rank one and size zero.
      3.128
      simply contiguous
      harray designator or variablei satisfying the conditions speciﬁed in 9.5.4
         NOTE3.7
        These conditions are simple ones which make it clear that the designator or variable designates a contiguous
        array.
      3.129
      size
      harrayi total number of elements in the array
      3.130
      speciﬁcation expression
      expression satisfying the requirements speciﬁed in 10.1.11, thus being suitable for use in speciﬁcations
      3.131
      speciﬁc name
      name that is not a generic name
      3.132
      standard-conforming program
      program that uses only those forms and relationships described in, and has an interpretation according to, this
      document
      3.133
      statement
      sequence of one or more complete or partial lines satisfying a syntax rule that ends in -stmt (6.3)
      3.133.1
      executable statement
      end-function-stmt, end-mp-subprogram-stmt, end-program-stmt, end-subroutine-stmt, or statement that is a mem-
      ber of the syntactic class executable-construct, excluding those in the block-speciﬁcation-part of a BLOCK con-
      struct
      3.133.2
      nonexecutable statement
      statement that is not an executable statement
                                   c
      20                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.134
      statement entity
      entity whose identiﬁer has the scope of a statement or part of a statement (19.1, 19.4)
      3.135
      statement label
      label
      unsigned positive number of up to ﬁve digits that refers to an individual statement (6.2.5)
      3.136
      storage sequence
      contiguous sequence of storage units (19.5.3.2)
      3.137
      storage unit
      character storage unit, numeric storage unit, ﬁle storage unit, or unspeciﬁed storage unit (19.5.3.2)
      3.137.1
      character storage unit
      unit of storage that holds a default character value (19.5.3.2)
      3.137.2
      numeric storage unit
      unit of storage that holds a default real, default integer, or default logical value (19.5.3.2)
      3.137.3
      unspeciﬁed storage unit
      unit of storage that holds a value that is not default character, default real, double precision real, default logical,
      or default complex (19.5.3.2)
      3.138
      stream ﬁle
      ﬁle composed of a sequence of ﬁle storage units (12.1)
      3.139
      structure
      scalar data object of derived type (7.5)
      3.139.1
      structure component
      component of a structure
      3.139.2
      structure constructor
      syntax (structure-constructor, 7.5.10) that speciﬁes a structure value or creates such a value
      3.140
      submodule
      program unit that extends a module or another submodule (14.2.3)
      3.141
      subobject
      portion of data object that can be referenced, and if it is a variable deﬁned, independently of any other portion
      (9.4.2)
      3.142
      subprogram
      function-subprogram (R1529) or subroutine-subprogram (R1534)
       c
      ISO/IEC 2017 – All rights reserved             21
      ISO/IEC DIS 1539-1:2017 (E)
      3.142.1
      external subprogram
      subprogram that is not contained in a main program, module, submodule, or another subprogram
      3.142.2
      internal subprogram
      subprogram that is contained in a main program or another subprogram
      3.142.3
      module subprogram
      subprogram that is contained in a module or submodule but is not an internal subprogram
      3.143
      subroutine
      procedure invoked by a CALL statement, by deﬁned assignment, or by some operations on derived-type entities
      3.143.1
      atomic subroutine
      intrinsic subroutine that performs an action on its ATOM argument atomically (16.5)
      3.143.2
      collective subroutine
      intrinsic subroutine that performs a calculation on a team of images without requiring synchronization
      3.144
      target
      entity that is pointer associated with a pointer (19.5.2.2), entity on the right-hand-side of a pointer assignment
      statement (R1033), or entity with the TARGET attribute (8.5.17)
      3.145
      team
      ordered set of images created by execution of a FORM TEAM statement, or the initial ordered set of all images
      3.145.1
      current team
      team speciﬁed by the most recently executed CHANGE TEAM statement of a CHANGE TEAM construct that
      has not completed execution (11.1.5), or initial team if no CHANGE TEAM construct is being executed
      3.145.2
      initial team
      team existing at the beginning of program execution, consisting of all images
      3.145.3
      parent team
      hteam except for initial teami current team at time of execution of the FORM TEAM statement that created the
      team (11.6.9)
      3.145.4
      team number
      −1 which identiﬁes the initial team, or positive integer that identiﬁes a team within its parent team
      3.146
      transformational function
      intrinsic function, or function in an intrinsic module, that is neither elemental nor an inquiry function
                                   c
      22                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.147
      type
      data type
      namedcategory of data characterized by a set of values, a syntax for denoting these values, and a set of operations
      that interpret and manipulate the values (7.1)
      3.147.1
      abstract type
      type with the ABSTRACT attribute (7.5.7.1)
      3.147.2
      declared type
      type that a data entity is declared to have, either explicitly or implicitly (7.3.2, 10.1.9)
      3.147.3
      derived type
      type deﬁned by a type deﬁnition (7.5) or by an intrinsic module
      3.147.4
      dynamic type
      type of a data entity at a particular point during execution of a program (7.3.2.3, 10.1.9)
      3.147.5
      extended type
      type with the EXTENDS attribute (7.5.7.1)
      3.147.6
      extensible type
      type that may be extended using the EXTENDS clause (7.5.7.1)
      3.147.7
      extension type
      hof one type with respect to anotheri is the same type or is an extended type whose parent type is an extension
      type of the other type
      3.147.8
      intrinsic type
      type deﬁned by this document that is always accessible (7.4)
      3.147.9
      numeric type
      one of the types integer, real, and complex
      3.147.10
      parent type
      hextended typei type named in the EXTENDS clause
      3.147.11
      type compatible
      compatibility of the type of one entity with respect to another for purposes such as argument association, pointer
      association, and allocation (7.3.2)
      3.147.12
      type parameter
      value used to parameterize a type (7.2)
       c
      ISO/IEC 2017 – All rights reserved             23
      ISO/IEC DIS 1539-1:2017 (E)
      3.147.12.1
      assumed type parameter
      length type parameter that assumes the type parameter value from another entity
         NOTE3.8
        The other entity is
          • the selector for an associate name,
          • the constant-expr for a named constant of type character, or
          • the eﬀective argument for a dummy argument.
      3.147.12.2
      deferred type parameter
      length type parameter whose value can change during execution of a program and whose type-param-value is a
      colon
      3.147.12.3
      kind type parameter
      type parameter whose value is required to be defaulted or given by a constant expression
      3.147.12.4
      length type parameter
      type parameter whose value is permitted to be assumed, deferred, or given by a speciﬁcation expression
      3.147.12.5
      type parameter inquiry
      syntax (type-param-inquiry) that is used to inquire the value of a type parameter of a data object (9.4.5)
      3.147.12.6
      type parameter order
      ordering of the type parameters of a type (7.5.3.2) used for derived-type speciﬁers (derived-type-spec, 7.5.9)
      3.148
      ultimate argument
      nondummy entity with which a dummy argument is associated via a chain of argument associations (15.5.2.3)
      3.149
      undeﬁned
      hdata objecti does not have a valid value
      3.150
      undeﬁned
      hpointeri does not have a pointer association status of associated or disassociated (19.5.2.2)
      3.151
      unit
      input/output unit
      means, speciﬁed by an io-unit, for referring to a ﬁle (12.5.1)
      3.152
      unlimited polymorphic
      able to have any dynamic type during program execution (7.3.2.3)
      3.153
      unsaved
      not having the SAVE attribute (8.5.16)
                                   c
      24                           ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
      3.154
      variable
      data entity that can be deﬁned and redeﬁned during execution of a program
      3.154.1
      event variable
      scalar variable of type EVENT_TYPE (16.10.2.10) from the intrinsic module ISO_FORTRAN_ENV
      3.154.2
      local variable
      variable in a scoping unit that is not a dummy argument or part thereof, is not a global entity or part thereof,
      and is not an entity or part of an entity that is accessible outside that scoping unit
      3.154.3
      lock variable
      scalar variable of type LOCK_TYPE (16.10.2.19) from the intrinsic module ISO_FORTRAN_ENV
      3.154.4
      team variable
      scalar variable of type TEAM_TYPE (16.10.2.32) from the intrinsic module ISO_FORTRAN_ENV
      3.155
      vector subscript
      section-subscript that is an array (9.5.3.3.2)
      3.156
      whole array
      array component or array name without further qualiﬁcation (9.5.2)
       c
      ISO/IEC 2017 – All rights reserved             25
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      26                           ISO/IEC 2017 – All rights reserved
                                                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                    4 Notation, conformance, and compatibility
                    4.1         Notation, symbols and abbreviated terms
                    4.1.1         Syntax rules
                1 Syntax rules describe the forms that Fortran lexical tokens, statements, and constructs may take. These syntax
                    rules are expressed in a variation of Backus-Naur form (BNF) with the following conventions.
                         • Characters from the Fortran character set (6.1) are interpreted literally as shown, except where otherwise
                             noted.
                         • Lower-case italicized letters and words (often hyphenated and abbreviated) represent general syntactic
                             classes for which particular syntactic entities shall be substituted in actual statements.
                             Common abbreviations used in syntactic terms are:
                                                                   arg       for      argument            attr       for     attribute
                                                                   decl      for      declaration         def        for     deﬁnition
                                                                   desc      for      descriptor          expr       for     expression
                                                                   int       for      integer             op         for     operator
                                                                   spec      for      speciﬁer            stmt       for     statement
                         • The syntactic metasymbols used are:
                                                                     is         introduces a syntactic class deﬁnition
                                                                     or         introduces a syntactic class alternative
                                                                     [ ]        encloses an optional item
                                                                     [ ] ...    encloses an optionally repeated item
                                                                                    that may occur zero or more times
                                                                                continues a syntax rule
                         • Each syntax rule is given a unique identifying number of the form Rsnn, where s is a one- or two-digit
                             clause number and nn is a two-digit sequence number within that clause. The syntax rules are distributed
                             as appropriate throughout the text, and are referenced by number as needed. Some rules in Clauses 5 and
                             6 are more fully described in later clauses; in such cases, the clause number s is the number of the later
                             clause where the rule is repeated.
                         • The syntax rules are not a complete and accurate syntax description of Fortran, and cannot be used to
                             generate a Fortran parser automatically; where a syntax rule is incomplete, it is restricted by corresponding
                             constraints and text.
                            NOTE4.1
                            An example of the use of the syntax rules is:
                                        digit-string                               is    digit [ digit ] ...
                            The following are examples of forms for a digit string allowed by the above rule:
                                   digit
                                   digit digit
                                   digit digit digit digit
                                   digit digit digit digit digit digit digit digit
                     c
                    ISO/IEC 2017 – All rights reserved                                                                                                                                27
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE4.1 (cont.)
               If particular entities are substituted for digit, actual digit strings might be:
                    4
                    67
                    1999
                    10243852
           4.1.2   Constraints
         1 Each constraint is given a unique identifying number of the form Csnn, where s is a one- or two-digit clause
           number and nn is a two- or three-digit sequence number within that clause.
         2 Often a constraint is associated with a particular syntax rule. Where that is the case, the constraint is annotated
           with the syntax rule number in parentheses. A constraint that is associated with a syntax rule constitutes part of
           the deﬁnition of the syntax term deﬁned by the rule. It thus applies in all places where the syntax term appears.
         3 Some constraints are not associated with particular syntax rules. The eﬀect of such a constraint is similar to
           that of a restriction stated in the text, except that a processor is required to have the capability to detect and
           report violations of constraints (4.2). In some cases, a broad requirement is stated in text and a subset of the
           same requirement is also stated as a constraint. This indicates that a standard-conforming program is required to
           adhere to the broad requirement, but that a standard-conforming processor is required only to have the capability
           of diagnosing violations of the constraint.
           4.1.3   Assumed syntax rules
         1 In order to minimize the number of additional syntax rules and convey appropriate constraint information, the
           following rules are assumed.
           R401   xyz-list                is xyz [ , xyz ] ...
           R402   xyz-name                is name
           R403   scalar-xyz              is xyz
           C401   (R403) scalar-xyz shall be scalar.
         2 The letters “xyz” stand for any syntactic class phrase. An explicit syntax rule for a term overrides an assumed
           rule.
           4.1.4   Syntax conventions and characteristics
         1 Any syntactic class name ending in “-stmt” follows the source form statement rules: it shall be delimited by
           end-of-line or semicolon, and may be labeled unless it forms part of another statement (such as an IF or WHERE
           statement). Conversely, everything considered to be a source form statement is given a “-stmt” ending in the
           syntax rules.
         2 The rules on statement ordering are described rigorously in the deﬁnition of program-unit (R502). Expression
           hierarchy is described rigorously in the deﬁnition of expr (R1022).
         3 The suﬃx “-spec” is used consistently for speciﬁers, such as input/output statement speciﬁers. It also is used for
           type declaration attribute speciﬁcations (for example, “array-spec” in R815), and in a few other cases.
         4 Where reference is made to a type parameter, including the surrounding parentheses, the suﬃx “-selector” is
           used. See, for example, “kind-selector” (R706) and “length-selector” (R722).
                                                                c
           28                                                   ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              4.1.5    Text conventions
           1 In descriptive text, an equivalent English word is frequently used in place of a syntactic term. Particular state-
              mentsandattributes are identiﬁed in the text by an upper-case keyword, e.g., “END statement”. The descriptions
              of obsolescent features appear in a smaller type size.
                   NOTE4.2
                  This sentence is an example of the type size used for obsolescent features.
              4.2     Conformance
           1 Aprogram(5.2.2) is a standard-conforming program if it uses only those forms and relationships described herein
              and if the program has an interpretation according to this document. A program unit (5.2.1) conforms to this
              document if it can be included in a program in a manner that allows the program to be standard conforming.
           2 Aprocessor conforms to this document if:
                    (1)   it executes any standard-conforming program in a manner that fulﬁlls the interpretations herein,
                          subject to any limits that the processor may impose on the size and complexity of the program;
                    (2)   it contains the capability to detect and report the use within a submitted program unit of a form
                          designated herein as obsolescent, insofar as such use can be detected by reference to the numbered
                          syntax rules and constraints;
                    (3)   it contains the capability to detect and report the use within a submitted program unit of a form or
                          relationship that is not permitted by the numbered syntax rules or constraints, including the deleted
                          features described in Annex B;
                    (4)   it contains the capability to detect and report the use within a submitted program unit of an intrinsic
                          type with a kind type parameter value not supported by the processor (7.4);
                    (5)   it contains the capability to detect and report the use within a submitted program unit of source
                          form or characters not permitted by Clause 6;
                    (6)   it contains the capability to detect and report the use within a submitted program of name usage
                          not consistent with the scope rules for names, labels, operators, and assignment symbols in Clause
                          19;
                    (7)   it contains the capability to detect and report the use within a submitted program unit of a non-
                          standard intrinsic procedure (including one with the same name as a standard intrinsic procedure
                          but with diﬀerent requirements);
                    (8)   it contains the capability to detect and report the use within a submitted program unit of a non-
                          standard intrinsic module;
                    (9)   it contains the capability to detect and report the use within a submitted program unit of a procedure
                          from a standard intrinsic module, if the procedure is not deﬁned by this document or the procedure
                          has diﬀerent requirements from those speciﬁed by this document; and
                    (10)  it contains the capability to detect and report the reason for rejecting a submitted program.
           3 However, in a format speciﬁcation that is not part of a FORMAT statement (13.2.1), a processor need not detect
              or report the use of deleted or obsolescent features, or the use of additional forms or relationships.
           4 A standard-conforming processor may allow additional forms and relationships provided that such additions
              do not conﬂict with the standard forms and relationships. However, a standard-conforming processor may allow
              additional intrinsic procedures even though this could cause a conﬂict with the name of a procedure in a standard-
              conforming program. If such a conﬂict occurs and involves the name of an external procedure, the processor is
              permitted to use the intrinsic procedure unless the name has the EXTERNAL attribute (8.5.9) where it is used.
              Astandard-conforming program shall not use nonstandard intrinsic procedures or modules that have been added
              by the processor.
           5 Because a standard-conforming program may place demands on a processor that are not within the scope of this
              document or may include standard items that are not portable, such as external procedures deﬁned by means
              c
              ISO/IEC 2017 – All rights reserved                                                                         29
            ISO/IEC DIS 1539-1:2017 (E)
            other than Fortran, conformance to this document does not ensure that a program will execute consistently on
            all or any standard-conforming processors.
          6 Thesemanticsoffacilities that are identiﬁed as processor dependent are not completely speciﬁed in this document.
            They shall be provided, with methods or semantics determined by the processor.
          7 The processor should be accompanied by documentation that speciﬁes the limits it imposes on the size and com-
            plexity of a program and the means of reporting when these limits are exceeded, that deﬁnes the additional forms
            and relationships it allows, and that deﬁnes the means of reporting the use of additional forms and relationships
            and the use of deleted or obsolescent forms. In this context, the use of a deleted form is the use of an additional
            form.
          8 The processor should be accompanied by documentation that speciﬁes the methods or semantics of processor-
            dependent facilities.
            4.3     Compatibility
            4.3.1   Previous Fortran standards
          1 Table 4.3 lists the previous editions of the Fortran International Standard, along with their informal names.
                             Table 4.3: Previous editions of the Fortran International Standard
                                             Oﬃcial designation   Informal name
                                             ISO R 1539-1972      Fortran 66
                                             ISO 1539-1980        Fortran 77
                                             ISO/IEC 1539:1991    Fortran 90
                                             ISO/IEC 1539-1:1997  Fortran 95
                                             ISO/IEC 1539-1:2004  Fortran 2003
                                             ISO/IEC 1539-1:2010  Fortran 2008
            4.3.2   New intrinsic procedures
          1 Each Fortran International Standard since ISO 1539:1980 (Fortran 77), deﬁnes more intrinsic procedures than
            the previous one. Therefore, a Fortran program conforming to an older standard might have a diﬀerent inter-
            pretation under a newer standard if it invokes an external procedure having the same name as one of the new
            standard intrinsic procedures, unless that procedure is speciﬁed to have the EXTERNAL attribute.
            4.3.3   Fortran 2008 compatibility
          1 Except as identiﬁed in this subclause, and except for the deleted features noted in Annex B.2, this document is
            an upward compatible extension to the preceding Fortran International Standard, ISO/IEC 1539-1:2010 (Fortran
            2008). Any standard-conforming Fortran 2008 program that does not use any deleted features, and does not use
            any feature identiﬁed in this subclause as being no longer permitted, remains standard-conforming under this
            document.
          2 Fortran 2008 speciﬁes that the IOSTAT= variable shall be set to a processor-dependent negative value if the ﬂush
            operation is not supported for the unit speciﬁed. This document speciﬁes that the processor-dependent negative
            integer value shall be diﬀerent from the named constants IOSTAT_EOR or IOSTAT_END from the intrinsic
            module ISO_FORTRAN_ENV.
          3 Fortran 2008 permitted a noncontiguous array that was supplied as an actual argument corresponding to a
            contiguous INTENT (INOUT) dummy argument in one iteration of a DO CONCURRENT construct, without
            being previously deﬁned in that iteration, to be deﬁned in another iteration; this document does not permit this.
                                                                      c
            30                                                       ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
           4 Fortran 2008 permitted a pure statement function to reference a volatile variable, and permitted a local variable
             of a pure subprogram or of a BLOCK construct within a pure subprogram to be volatile (provided it was not
             used); this document does not permit that.
           5 Fortran 2008 permitted a pure function to have a result that has a polymorphic allocatable ultimate component;
             this document does not permit that.
           6 Fortran 2008 permitted a PROTECTED TARGET variable accessed by use association to be used as an initial-
             data-target; this document does not permit that.
           7 Fortran 2008 permitted a named constant to have declared type LOCK_TYPE, or have a noncoarray potential
             subobject component with declared type LOCK_TYPE; this document does not permit that.
           8 Fortran 2008 permitted a polymorphic object to be ﬁnalized within a DO CONCURRENT construct; this docu-
             ment does not permit that.
           9 Fortran 2008 permitted an unallocated allocatable coarray or coindexed object to be allocated by an assignment
             statement, provided it was scalar, nonpolymorphic, and had no deferred type parameters; this document does
             not permit that.
             4.3.4    Fortran 2003 compatibility
           1 Except as identiﬁed in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:2004
             (Fortran 2003). Except as identiﬁed in this subclause, any standard-conforming Fortran 2003 program remains
             standard-conforming under this document.
           2 Fortran 2003 permitted a sequence type to have type parameters; that is not permitted by this document.
           3 Fortran 2003 speciﬁed that array constructors and structure constructors of ﬁnalizable type are ﬁnalized. This
             document speciﬁes that these constructors are not ﬁnalized.
           4 The form produced by the G edit descriptor for some values and some input/output rounding modes diﬀers from
             that speciﬁed by Fortran 2003.
           5 Fortran 2003 required an explicit interface only for a procedure that was actually referenced in the scope, not
             merely passed as an actual argument. This document requires an explicit interface for a procedure under the
             conditions listed in 15.4.2.2, regardless of whether the procedure is referenced in the scope.
           6 Fortran 2003 permitted the function result of a pure function to be a polymorphic allocatable variable, to have
             a polymorphic allocatable ultimate component, or to be ﬁnalizable by an impure ﬁnal subroutine. These are not
             permitted by this document.
           7 Fortran 2003 permitted an INTENT (OUT) argument of a pure subroutine to be polymorphic; that is not
             permitted by this document.
           8 Fortran 2003 interpreted assignment to an allocatable variable from a nonconformable array as intrinsic assign-
             ment, even when an elemental deﬁned assignment was in scope; this document does not permit assignment from
             a nonconformable array in this context.
           9 Fortran 2003 permitted a statement function to be of parameterized derived type; this document does not permit
             that.
          10 Fortran 2003 permitted a pure statement function to reference a volatile variable, and permitted a local variable
             of a pure subprogram to be volatile (provided it was not used); this document does not permit that.
             4.3.5    Fortran 95 compatibility
           1 Except as identiﬁed in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:1997
             (Fortran 95).   Except as identiﬁed in this subclause, any standard-conforming Fortran 95 program remains
             standard-conforming under this document.
              c
             ISO/IEC 2017 – All rights reserved                                                                        31
           ISO/IEC DIS 1539-1:2017 (E)
         2 Fortran 95 permitted deﬁned assignment between character strings of the same rank and diﬀerent kinds. This
           document does not permit that if both of the diﬀerent kinds are ASCII, ISO 10646, or default kind.
         3 The following Fortran 95 features might have diﬀerent interpretations in this document.
              • Earlier Fortran standards had the concept of printing, meaning that column one of formatted output had
                special meaning for a processor-dependent (possibly empty) set of external ﬁles. This could be neither
                detected nor speciﬁed by a standard-speciﬁed means. The interpretation of the ﬁrst column is not speciﬁed
                by this document.
              • This document speciﬁes a diﬀerent output format for real zero values in list-directed and namelist output.
              • If the processor distinguishes between positive and negative real zero, this document requires diﬀerent
                returned values for ATAN2(Y,X) when X < 0 and Y is negative real zero and for LOG(X) and SQRT(X)
                when X is complex with X%RE < 0 and X%IM is negative real zero.
              • This document has fewer restrictions on constant expressions than Fortran 95; this might aﬀect whether a
                variable is considered to be an automatic data object.
              • The form produced by the G edit descriptor with d equal to zero diﬀers from that speciﬁed by Fortran 95
                for some values.
           4.3.6   Fortran 90 compatibility
         1 Except for the deleted features noted in Annex B.1, and except as identiﬁed in this subclause, this document
           is an upward compatible extension to ISO/IEC 1539:1991 (Fortran 90). Any standard-conforming Fortran 90
           program that does not use one of the deleted features remains standard-conforming under this document.
         2 The PAD= speciﬁer in the INQUIRE statement in this document returns the value UNDEFINED if there is no
           connection or the connection is for unformatted input/output. Fortran 90 speciﬁed YES.
         3 Fortran 90 speciﬁed that if the second argument to MOD or MODULO was zero, the result was processor
           dependent. This document speciﬁes that the second argument shall not be zero.
         4 Fortran 90 permitted deﬁned assignment between character strings of the same rank and diﬀerent kinds. This
           document does not permit that if both of the diﬀerent kinds are ASCII, ISO 10646, or default kind.
         5 The following Fortran 90 features have diﬀerent interpretations in this document:
              • if the processor distinguishes between positive and negative real zero, the result value of the intrinsic function
                SIGN when the second argument is a negative real zero;
              • formatted output of negative real values (when the output value is zero);
              • whether an expression is a constant expression (thus whether a variable is considered to be an automatic
                data object);
              • the G edit descriptor with d equal to zero for some values.
           4.3.7   FORTRAN 77 compatibility
         1 Except for the deleted features noted in Annex B.1, and except as identiﬁed in this subclause, this document is an
           upward compatible extension to ISO 1539:1980 (Fortran 77). Any standard-conforming Fortran 77 program
           that does not use one of the deleted features noted in Annex B.1 and that does not depend on the diﬀerences
           speciﬁed here remains standard-conforming under this document. This document restricts the behavior for some
           features that were processor dependent in Fortran 77. Therefore, a standard-conforming Fortran 77 program
           that uses one of these processor-dependent features might have a diﬀerent interpretation under this document, yet
           remain a standard-conforming program. The following Fortran 77 features might have diﬀerent interpretations
           in this document.
              • Fortran 77 permitted a processor to supply more precision derived from a default real constant than can
                be represented in a default real datum when the constant is used to initialize a double precision real data
                object in a DATA statement. This document does not permit a processor this option.
                                                                c
           32                                                   ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
              • If a named variable that was not in a common block was initialized in a DATA statement and did not have
                the SAVE attribute speciﬁed, Fortran 77 left its SAVE attribute processor dependent. This document
                speciﬁes (8.6.7) that this named variable has the SAVE attribute.
              • Fortran 77 speciﬁed that the number of characters required by the input list was to be less than or equal
                to the number of characters in the record during formatted input. This document speciﬁes (12.6.4.5.3) that
                the input record is logically padded with blanks if there are not enough characters in the record, unless the
                PAD=speciﬁer with the value ’NO’ is speciﬁed in an appropriate OPEN or READ statement.
              • A value of 0 for a list item in a formatted output statement will be formatted in a diﬀerent form for some
                Gedit descriptors. In addition, this document speciﬁes how rounding of values will aﬀect the output ﬁeld
                form, but Fortran 77 did not address this issue. Therefore, the form produced for certain combinations
                of values and G edit descriptors might diﬀer from that produced by some Fortran 77 processors.
              • Fortran 77 did not permit a processor to distinguish between positive and negative real zero; if the
                processor does so distinguish, the result will diﬀer for the intrinsic function SIGN when the second argument
                is negative real zero, and formatted output of negative real zero will be diﬀerent.
           4.4    Deleted and obsolescent features
           4.4.1   General
         1 Thisdocumentprotectstheusers’ investment in existing software by including all but six of the language elements
           of Fortran 90 that are not processor dependent. This document identiﬁes two categories of outmoded features.
           The ﬁrst category, deleted features, consists of features considered to have been redundant in Fortran 77 and
           largely unused in Fortran 90. Those in the second category, obsolescent features, are considered to have been
           redundant in Fortran 90 and Fortran 95, but are still frequently used.
           4.4.2   Nature of deleted features
         1 There are two groups of deleted features. The ﬁrst group contains features for which better methods existed in
           Fortran77; these features were not included in Fortran 95, Fortran 2003, or Fortran 2008, and are not included
           in this document. The second group contains features for which better methods existed in Fortran 90; these
           features were included in Fortran 2008, but are not included in this document.
           4.4.3   Nature of obsolescent features
         1 Better methods existed in Fortran 90 and Fortran 95 for each obsolescent feature. It is recommended that
           programmers use these better methods in new programs and convert existing code to these methods.
         2 The obsolescent features are identiﬁed in the text of this document by a distinguishing type font (4.1.5).
         3 Afuture revision of this document might delete an obsolescent feature if its use has become insigniﬁcant.
            c
           ISO/IEC 2017 – All rights reserved                                                      33
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      34                           ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                5 Fortran concepts
                5.1      High level syntax
            1 This subclause introduces the syntax associated with program units and other Fortran concepts above the con-
                struct, statement, and expression levels and illustrates their relationships.
                     NOTE5.1
                     Constraints and other information related to the rules that do not begin with R5 appear in the appropriate
                     clause.
                R501     program                          is  program-unit
                                                                   [ program-unit ] ...
                R502     program-unit                     is  main-program
                                                          or external-subprogram
                                                          or module
                                                          or submodule
                                                          or  block-data
                R1401 main-program                        is  [ program-stmt ]
                                                                   [ speciﬁcation-part ]
                                                                   [ execution-part ]
                                                                   [ internal-subprogram-part ]
                                                                   end-program-stmt
                R503     external-subprogram              is  function-subprogram
                                                          or subroutine-subprogram
                R1529 function-subprogram                 is  function-stmt
                                                                   [ speciﬁcation-part ]
                                                                   [ execution-part ]
                                                                   [ internal-subprogram-part ]
                                                                   end-function-stmt
                R1534 subroutine-subprogram               is  subroutine-stmt
                                                                   [ speciﬁcation-part ]
                                                                   [ execution-part ]
                                                                   [ internal-subprogram-part ]
                                                                   end-subroutine-stmt
                R1404 module                              is  module-stmt
                                                                   [ speciﬁcation-part ]
                                                                   [ module-subprogram-part ]
                                                                   end-module-stmt
                R1416 submodule                           is  submodule-stmt
                                                                   [ speciﬁcation-part ]
                                                                   [ module-subprogram-part ]
                                                                   end-submodule-stmt
                R1420    block-data                       is  block-data-stmt
                                                                   [ speciﬁcation-part ]
                                                                   end-block-data-stmt
                c
                ISO/IEC 2017 – All rights reserved                                                                                         35
              ISO/IEC DIS 1539-1:2017 (E)
              R504    speciﬁcation-part            is   [ use-stmt ] ...
                                                            [ import-stmt ] ...
                                                            [ implicit-part ]
                                                            [ declaration-construct ] ...
              R505    implicit-part                is   [ implicit-part-stmt ] ...
                                                            implicit-stmt
              R506    implicit-part-stmt           is   implicit-stmt
                                                   or parameter-stmt
                                                   or format-stmt
                                                   or entry-stmt
              R507    declaration-construct        is   speciﬁcation-construct
                                                   or data-stmt
                                                   or format-stmt
                                                   or entry-stmt
                                                   or stmt-function-stmt
              R508    speciﬁcation-construct       is   derived-type-def
                                                   or enum-def
                                                   or generic-stmt
                                                   or interface-block
                                                   or parameter-stmt
                                                   or procedure-declaration-stmt
                                                   or other-speciﬁcation-stmt
                                                   or type-declaration-stmt
              R509    execution-part               is   executable-construct
                                                            [ execution-part-construct ] ...
              R510    execution-part-construct     is   executable-construct
                                                   or format-stmt
                                                   or entry-stmt
                                                   or data-stmt
              R511    internal-subprogram-part     is   contains-stmt
                                                            [ internal-subprogram ] ...
              R512    internal-subprogram          is   function-subprogram
                                                   or subroutine-subprogram
              R1407 module-subprogram-part         is   contains-stmt
                                                            [ module-subprogram ] ...
              R1408 module-subprogram              is   function-subprogram
                                                   or subroutine-subprogram
                                                   or separate-module-subprogram
              R1538 separate-module-subprogram is       mp-subprogram-stmt
                                                            [ speciﬁcation-part ]
                                                            [ execution-part ]
                                                            [ internal-subprogram-part ]
                                                            end-mp-subprogram-stmt
              R513    other-speciﬁcation-stmt      is   access-stmt
                                                   or allocatable-stmt
                                                   or asynchronous-stmt
                                                                                c
              36                                                               ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                                                  or bind-stmt
                                                  or codimension-stmt
                                                  or contiguous-stmt
                                                  or dimension-stmt
                                                  or external-stmt
                                                  or intent-stmt
                                                  or intrinsic-stmt
                                                  or namelist-stmt
                                                  or optional-stmt
                                                  or pointer-stmt
                                                  or protected-stmt
                                                  or save-stmt
                                                  or target-stmt
                                                  or volatile-stmt
                                                  or value-stmt
                                                  or  common-stmt
                                                  or  equivalence-stmt
              R514    executable-construct        is  action-stmt
                                                  or associate-construct
                                                  or block-construct
                                                  or case-construct
                                                  or change-team-construct
                                                  or critical-construct
                                                  or do-construct
                                                  or if-construct
                                                  or select-rank-construct
                                                  or select-type-construct
                                                  or where-construct
                                                  or forall-construct
              R515    action-stmt                 is  allocate-stmt
                                                  or assignment-stmt
                                                  or backspace-stmt
                                                  or call-stmt
                                                  or close-stmt
                                                  or continue-stmt
                                                  or cycle-stmt
                                                  or deallocate-stmt
                                                  or endﬁle-stmt
                                                  or error-stop-stmt
                                                  or event-post-stmt
                                                  or event-wait-stmt
                                                  or exit-stmt
                                                  or fail-image-stmt
                                                  or ﬂush-stmt
                                                  or form-team-stmt
                                                  or goto-stmt
                                                  or if-stmt
                                                  or inquire-stmt
                                                  or lock-stmt
                                                  or nullify-stmt
                                                  or open-stmt
                                                  or pointer-assignment-stmt
                                                  or print-stmt
                                                  or read-stmt
              c
              ISO/IEC 2017 – All rights reserved                                                                        37
          ISO/IEC DIS 1539-1:2017 (E)
                                    or return-stmt
                                    or rewind-stmt
                                    or stop-stmt
                                    or sync-all-stmt
                                    or sync-images-stmt
                                    or sync-memory-stmt
                                    or sync-team-stmt
                                    or unlock-stmt
                                    or wait-stmt
                                    or where-stmt
                                    or write-stmt
                                    or computed-goto-stmt
                                    or forall-stmt
          5.2   Program unit concepts
          5.2.1 Program units and scoping units
        1 Program units are the fundamental components of a Fortran program. A program unit is a main program, an
          external subprogram, a module, a submodule, or a block data program unit.
        2 Asubprogram is a function subprogram or a subroutine subprogram. A module contains deﬁnitions that can be
          made accessible to other program units. A submodule is an extension of a module; it may contain the deﬁnitions
          of procedures declared in a module or another submodule. A block data program unit is used to specify initial values for
          data objects in named common blocks.
        3 Each type of program unit is described in Clause 14 or 15.
        4 Aprogram unit consists of a set of nonoverlapping scoping units.
             NOTE5.2
             The module or submodule containing a module subprogram is the host scoping unit of the module subpro-
             gram. The containing main program or subprogram is the host scoping unit of an internal subprogram.
             An internal procedure is local to its host in the sense that its name is accessible within the host scoping
             unit and all its other internal procedures but is not accessible elsewhere.
          5.2.2 Program
        1 Aprogramshallconsistofexactlyonemainprogram, anynumber(includingzero)ofotherkindsofprogramunits,
          any number (including zero) of external procedures, and any number (including zero) of other entities deﬁned by
          means other than Fortran. The main program shall be deﬁned by a Fortran main-program program-unit or by
          means other than Fortran, but not both.
          5.2.3 Procedure
        1 A procedure is either a function or a subroutine. Invocation of a function in an expression causes a value to be
          computed which is then used in evaluating the expression.
        2 Aprocedure that is not pure might change the program state by changing the value of accessible data objects or
          procedure pointers.
        3 Procedures are described further in Clause 15.
                                                        c
          38                                            ISO/IEC 2017 – All rights reserved
                                                                ISO/IEC DIS 1539-1:2017 (E)
          5.2.4  Module
        1 Amodulecontains(oraccessesfromothermodules)deﬁnitionsthatcanbemadeaccessibletootherprogramunits.
          These deﬁnitions include data object declarations, type deﬁnitions, procedure deﬁnitions, and interface blocks.
          Modules are further described in Clause 14.
          5.2.5  Submodule
        1 Asubmodule extends a module or another submodule.
        2 It may provide deﬁnitions (15.6) for procedures whose interfaces are declared (15.4.3.2) in an ancestor module
          or submodule. It may also contain declarations and deﬁnitions of other entities, which are accessible in its
          descendants. An entity declared in a submodule is not accessible by use association unless it is a module procedure
          whose interface is declared in the ancestor module. Submodules are further described in Clause 14.
              NOTE5.3
              Asubmodule has access to entities in its parent module or submodule by host association.
          5.3   Execution concepts
          5.3.1  Statement classiﬁcation
        1 Each Fortran statement is classiﬁed as either an executable statement or a nonexecutable statement.
        2 An executable statement is an instruction to perform or control an action. Thus, the executable statements of a
          program unit determine the behavior of the program unit.
        3 Nonexecutable statements are used to conﬁgure the program environment in which actions take place.
          5.3.2  Statement order
                                Table 5.1: Requirements on statement ordering
                                   PROGRAM,FUNCTION,SUBROUTINE,
                               MODULE,SUBMODULE,orBLOCKDATAstatement
                                             USE statements
                                            IMPORTstatements
                                                  IMPLICIT NONE
                                       PARAMETER           IMPLICIT
                                        statements         statements
                                                      Derived-type deﬁnitions,
                             FORMAT                      interface blocks,
                                and    PARAMETER    type declaration statements,
                              ENTRY     and DATA      enumeration deﬁnitions,
                             statements statements    procedure declarations,
                                                      speciﬁcation statements,
                                                    and statement function statements
                                          DATA             Executable
                                         statements        constructs
                                           CONTAINS statement
                                           Internal subprograms
                                           or module subprograms
                                              ENDstatement
           c
          ISO/IEC 2017 – All rights reserved                                             39
            ISO/IEC DIS 1539-1:2017 (E)
          1 The syntax rules of subclause 5.1 specify the statement order within program units and subprograms. These
            rules are illustrated in Table 5.1 and Table 5.2. Table 5.1 shows the ordering rules for statements and applies
            to all program units, subprograms, and interface bodies. Vertical lines delineate varieties of statements that
            may be interspersed and horizontal lines delineate varieties of statements that shall not be interspersed. Internal
            or module subprograms shall follow a CONTAINS statement. Between USE and CONTAINS statements in a
            subprogram, nonexecutable statements generally precede executable statements, although the ENTRY statement,
            FORMATstatement, and DATA statement may appear among the executable statements. Table 5.2 shows which
            statements are allowed in some kinds of scoping units.
                                       Table 5.2: Statements allowed in scoping units
                                                             Kind of scoping unit
                                  Main     Module or  Block    External     Module       Internal   Interface
               Statement type   program   submodule    data  subprogram   subprogram   subprogram    body
               USE                Yes         Yes      Yes       Yes          Yes          Yes        Yes
               IMPORT              No     Submodule    No        No           Yes          Yes        Yes
               ENTRY               No         No       No        Yes          Yes          No          No
               FORMAT             Yes         No       No        Yes          Yes          Yes        No
               Misc. decl.s 1     Yes         Yes      Yes       Yes          Yes          Yes        Yes
               DATA               Yes         Yes      Yes       Yes          Yes          Yes        No
               Derived-type       Yes         Yes      Yes       Yes          Yes          Yes        Yes
               Interface          Yes         Yes      No        Yes          Yes          Yes        Yes
               Executable         Yes         No       No        Yes          Yes          Yes        No
               CONTAINS           Yes         Yes      No        Yes          Yes          No         No
               Statement function  Yes        No       No        Yes          Yes          Yes         No
               (1) Miscellaneous declarations are PARAMETER statements, IMPLICIT statements, type declaration
               statements, enumeration deﬁnitions, procedure declaration statements, and speciﬁcation statements.
            5.3.3   The END statement
          1 Each program unit, module subprogram, and internal subprogram shall have exactly one END statement. The
            end-program-stmt, end-function-stmt, end-subroutine-stmt, and end-mp-subprogram-stmt statements are execut-
            able, and may be branch target statements (11.2). Executing an end-program-stmt initiates normal termination.
            Executing an end-function-stmt, end-subroutine-stmt, or end-mp-subprogram-stmt is equivalent to executing a
            return-stmt with no scalar-int-expr.
          2 The end-module-stmt, end-submodule-stmt, and end-block-data-stmt statements are nonexecutable.
            5.3.4   Program execution
          1 Executionofaprogramconsistsoftheasynchronousexecutionofaﬁxednumber(whichmaybeone)ofitsimages.
            Each image has its own execution state, ﬂoating-point status (17.7), and set of data objects, input/output units,
            and procedure pointers. The image index that identiﬁes an image is an integer value in the range one to the
            number of images in a team.
          2 Ateamis an ordered set of images that is either the initial team, consisting of all images, or a subset of a parent
            team formed by execution of a FORM TEAM statement. The initial team has no parent; every other team has a
            unique parent team. Within its parent team, each team is identiﬁed by its team number; this is the integer value
            that was speciﬁed in the FORM TEAM statement.
          3 During execution, each image has a current team, which is only changed by execution of CHANGE TEAM
            and END TEAM statements. Image indices, and thus coindexing of variable names with an image-selector, are
            relative to the current team unless a diﬀerent team is speciﬁed. Initially, the current team is the initial team.
                                                                     c
            40                                                       ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
               NOTE5.4
               Fortran control constructs (11.1, 11.2) control the progress of execution in each image. Image control
               statements (11.6.1) aﬀect the relative progress of execution between images. Coarrays (5.4.7) provide a
               mechanism for accessing data on one image from another image.
               NOTE5.5
               Aprocessor might allow the number of images to be chosen at compile time, link time, or run time. It might
               be the same as the number of CPUs but this is not required. Compiling for a single image might permit
               the optimizer to eliminate overhead associated with parallel execution. A program that makes assumptions
               about the number of images is unlikely to be portable.
           5.3.5   Execution sequence
         1 Following the creation of a ﬁxed number of images, execution begins on each image. Image execution is a
           sequence, in time, of actions. Actions take place during execution of the statement that performs them (except
           whenexplicitly stated otherwise). Segments (11.6.2) executed by a single image are totally ordered, and segments
           executed by separate images are partially ordered by image control statements (11.6.1).
         2 If the program contains a Fortran main program, each image begins execution with the ﬁrst executable construct
           of the main program. The execution of a main program or subprogram involves execution of the executable
           constructs within its scoping unit. When a Fortran procedure is invoked, the speciﬁcation expressions within
           the speciﬁcation-part of the invoked procedure, if any, are evaluated in a processor dependent order. Thereafter,
           execution proceeds to the ﬁrst executable construct appearing within the scoping unit of the procedure after the
           invoked entry point. With the following exceptions, the eﬀect of execution is as if the executable constructs are
           executed in the order in which they appear in the main program or subprogram until a STOP, ERROR STOP,
           RETURN, or END statement is executed.
              • Execution of a branching statement (11.2) changes the execution sequence. These statements explicitly
                specify a new starting place for the execution sequence.
              • DOconstructs, IFconstructs, SELECTCASEconstructs, SELECTRANKconstructs,andSELECTTYPE
                constructs contain an internal statement structure and execution of these constructs involves implicit in-
                ternal transfer of control. See Clause 11 for the detailed semantics of each of these constructs.
              • ABLOCKconstructmaycontainspeciﬁcationexpressions; see11.1.4fordetailedsemanticsofthisconstruct.
              • An END=, ERR=, or EOR= speciﬁer (12.11) might result in a branch.
              • An alternate return might result in a branch.
           5.3.6   Image execution states
         1 There are three image execution states: active, stopped, and failed. An image that has initiated normal termin-
           ation of execution is a stopped image. An image that has ceased participating in program execution but has not
           initiated termination is a failed image. All other images are active images.
         2 A failed image remains failed for the remainder of the execution of the program. The conditions that cause an
           image to fail are processor dependent.
         3 Deﬁning a coindexed object on a failed image has no eﬀect other than deﬁning the stat-variable, if one appears,
           with the value STAT_FAILED_IMAGE (16.10.2.26). The value of a reference to a coindexed object on a failed
           image is processor dependent. Execution continues after such a reference.
         4 When an image fails during the execution of a segment, a data object on a nonfailed image becomes undeﬁned
           if it is not a lock variable or event variable and it might be deﬁned or become undeﬁned by execution of a
           statement of the segment other than an invocation of an atomic subroutine with the object as an actual argument
           corresponding to the ATOM dummy argument.
            c
           ISO/IEC 2017 – All rights reserved                                                      41
              ISO/IEC DIS 1539-1:2017 (E)
              5.3.7    Termination of execution
           1 Termination of execution of a program is either normal termination or error termination. Normal termination
              occurs only when all images initiate normal termination and occurs in three steps: initiation, synchronization,
              and completion. In this case, all images synchronize execution at the second step so that no image starts the
              completion step until all images have ﬁnished the initiation step. Error termination occurs when any image
              initiates error termination. Once error termination has been initiated on an image, error termination is initiated
              on all images that have not already initiated error termination. Termination of execution of the program occurs
              when all images have terminated execution.
           2 NormalterminationofexecutionofanimageisinitiatedwhenaSTOPstatementorend-program-stmt isexecuted.
              Normal termination of execution of an image also may be initiated during execution of a procedure deﬁned by a
              companion processor (ISO/IEC 9899:2011 5.1.2.2.3 and 7.22.4.4). If normal termination of execution is initiated
              within a Fortran program unit and the program incorporates procedures deﬁned by a companion processor, the
              process of execution termination shall include the eﬀect of executing the C exit() function (ISO/IEC 9899:2011
              7.22.4.4) during the completion step.
           3 Error termination of execution of an image is initiated if an ERROR STOP statement is executed or as speciﬁed
              elsewhere in this document. When error termination on an image has been initiated, the processor should initiate
              error termination on other images as quickly as possible.
           4 If the processor supports the concept of a process exit status, it is recommended that error termination initiated
              other than by an ERROR STOP statement supplies a processor-dependent nonzero value as the process exit
              status.
                   NOTE5.6
                  As well as in the circumstances speciﬁed in this document, error termination might be initiated by means
                  other than Fortran.
                   NOTE5.7
                  If an image has initiated normal termination, its data remain available for possible reference or deﬁnition
                  by other images that are still executing.
              5.4     Data concepts
              5.4.1    Type
           1 A type is a named categorization of data that, together with its type parameters, determines the set of values,
              syntax for denoting these values, and the set of operations that interpret and manipulate the values. This central
              concept is described in 7.1.
           2 Atype is either an intrinsic type or a derived type.
              5.4.1.1  Intrinsic type
           1 Theintrinsictypesareinteger, real, complex, character, and logical. The properties of intrinsic types are described
              in 7.4.
           2 All intrinsic types have a kind type parameter called KIND, which determines the representation method for the
              speciﬁed type. The intrinsic type character also has a length type parameter called LEN, which determines the
              length of the character string.
              5.4.1.2  Derived type
           1 Derived types may be parameterized. A scalar object of derived type is a structure; assignment of structures
              is deﬁned intrinsically (10.2.1.3), but there are no intrinsic operations for structures. For each derived type, a
                                                                              c
              42                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              structure constructor is available to create values (7.5.10). In addition, objects of derived type may be used as
              procedure arguments and function results, and may appear in input/output lists. If additional operations are
              needed for a derived type, they shall be deﬁned by procedures (10.1.6).
           2 Derived types are described further in 7.5.
              5.4.2    Data value
           1 Each intrinsic type has associated with it a set of values that a datum of that type may take, depending on the
              values of the type parameters. The values for each intrinsic type are described in 7.4. The values that objects of
              a derived type may assume are determined by the type deﬁnition, type parameter values, and the sets of values
              of its components.
              5.4.3    Data entity
              5.4.3.1  General
           1 Adataentity has a type and type parameters; it might have a data value (an exception is an undeﬁned variable).
              Every data entity has a rank and is thus either a scalar or an array.
           2 Adata entity that is the result of the execution of a function reference is called the function result.
              5.4.3.2  Data object
           1 A data object is either a constant, variable, or a subobject of a constant. The type and type parameters of a
              named data object may be speciﬁed explicitly (8.2) or implicitly (8.7).
           2 Subobjects are portions of data objects that may be referenced and deﬁned (variables only) independently of the
              other portions.
           3 These include portions of arrays (array elements and array sections), portions of character strings (substrings),
              portions of complex objects (real and imaginary parts), and portions of structures (components). Subobjects
              are themselves data objects, but subobjects are referenced only by object designators or intrinsic functions. A
              subobject of a variable is a variable. Subobjects are described in Clause 9.
           4 The following objects are referenced by a name:
                  • a named scalar                (a scalar object);
                  • a named array                 (an array object).
           5 The following subobjects are referenced by an object designator:
                  • an array element              (a scalar subobject);
                  • an array section              (an array subobject);
                  • a complex part designator     (the real or imaginary part of a complex object);
                  • a structure component         (a scalar or an array subobject);
                  • a substring                   (a scalar subobject).
              5.4.3.2.1  Variable
           1 Avariable can have a value or be undeﬁned; during execution of a program it can be deﬁned, redeﬁned, or become
              undeﬁned.
           2 A local variable of a module, submodule, main program, subprogram, or BLOCK construct is accessible only in
              that scoping unit or construct and in any contained scoping units and constructs.
                   NOTE5.8
                  Asubobject of a local variable is also a local variable.
              c
              ISO/IEC 2017 – All rights reserved                                                                         43
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE5.8 (cont.)
                   Alocal variable cannot be in COMMON or have the BIND attribute, because common blocks and variables with
                   the BIND attribute are global entities.
              5.4.3.2.2  Constant
           1 Aconstant is either a named constant or a literal constant.
           2 Named constants are deﬁned using the PARAMETER attribute (8.5.13, 8.6.11). The syntax of literal constants
              is described in 7.4.
              5.4.3.2.3  Subobject of a constant
           1 Asubobject of a constant is a portion of a constant.
           2 Inanobjectdesignatorfor a subobject of a constant, the portion referenced may depend on the value of a variable.
                   NOTE5.9
                   For example, given:
                   CHARACTER (LEN = 10), PARAMETER :: DIGITS = ’0123456789’
                   CHARACTER (LEN = 1)                   :: DIGIT
                   INTEGER :: I
                      ...
                   DIGIT = DIGITS (I:I)
                   DIGITS is a named constant and DIGITS (I:I) designates a subobject of the constant DIGITS.
              5.4.3.3  Expression
           1 An expression (10.1) produces a data entity when evaluated. An expression represents either a data object
              reference or a computation; it is formed from operands, operators, and parentheses. The type, type parameters,
              value, and rank of an expression result are determined by the rules in Clause 10.
              5.4.3.4  Function reference
           1 A function reference produces a data entity when the function is executed during expression evaluation. The
              type, type parameters, and rank of a function result are determined by the interface of the function (15.3.3). The
              value of a function result is determined by execution of the function.
              5.4.4    Deﬁnition of objects and pointers
           1 When an object is given a valid value during program execution, it becomes deﬁned. This is often accomplished
              by execution of an assignment or input statement. When a variable does not have a predictable value, it is
              undeﬁned.
           2 Similarly, when a pointer is associated with a target or nulliﬁed, its pointer association status becomes deﬁned.
              When the association status of a pointer is not predictable, its pointer association status is undeﬁned.
           3 Clause 19 describes the ways in which variables become deﬁned and undeﬁned and the association status of
              pointers becomes deﬁned and undeﬁned.
              5.4.5    Reference
           1 A data object is referenced when its value is required during execution. A procedure is referenced when it is
              executed.
                                                                              c
              44                                                              ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
         2 The appearance of a data object designator or procedure designator as an actual argument does not constitute
           a reference to that data object or procedure unless such a reference is necessary to complete the speciﬁcation of
           the actual argument.
           5.4.6   Array
         1 An array may have up to ﬁfteen dimensions minus its corank, and any extent in any dimension. The size of an
           array is the total number of elements, which is equal to the product of the extents. An array may have zero
           size. The shape of an array is determined by its rank and its extent in each dimension, and is represented as
           a rank-one array whose elements are the extents. All named arrays shall be declared, and the rank of a named
           array is speciﬁed in its declaration. Except for an assumed-rank array, the rank of a named array, once declared,
           is constant; the extents may be constant or may vary during execution.
         2 Any intrinsic operation deﬁned for scalar objects may be applied to conformable objects. Such operations are
           performedelementallytoproducearesultantarrayconformablewiththearrayoperands. Ifanelementaloperation
           is intrinsically pure or is implemented by a pure elemental function (15.8), the element operations may be
           performed simultaneously or in any order.
         3 Arank-onearray may be constructed from scalars and other arrays and may be reshaped into any allowable array
           shape (7.8).
         4 Arrays may be of any type and are described further in 9.5.
           5.4.7   Coarray
         1 A coarray is a data entity that has nonzero corank; it can be directly referenced or deﬁned by other images. It
           may be a scalar or an array.
         2 For each coarray on an image, there is a corresponding coarray with the same type, type parameters, and bounds
           on every other image of a team in which it is established (5.4.8).
         3 Thesetofcorresponding coarrays on all images in a team is arranged in a rectangular pattern. The dimensions of
           this pattern are the codimensions; the number of codimensions is the corank. The bounds for each codimension
           are the cobounds.
               NOTE5.10
               If the total number of images is not a multiple of the product of the sizes of each but the rightmost of the
               codimensions, the rectangular pattern will be incomplete.
         4 Acoarray on any image can be accessed directly by using cosubscripts. On its own image, a coarray can also be
           accessed without use of cosubscripts.
         5 Asubobjectofacoarrayisacoarrayifitdoesnothaveanycosubscripts, vector subscripts, allocatable component
           selection, or pointer component selection.
         6 For a coindexed object, its cosubscript list determines the image index (9.6) in the same way that a subscript list
           determines the subscript order value for an array element (9.5.3.2).
         7 Intrinsic procedures are provided for mapping between an image index and a list of cosubscripts.
               NOTE5.11
               The mechanism for an image to reference and deﬁne a coarray on another image might vary according
               to the hardware. On a shared-memory machine, a coarray on an image and the corresponding coarrays
               on other images could be implemented as a sequence of arrays with evenly spaced starting addresses. On
               a distributed-memory machine with separate physical memory for each image, a processor might store a
               coarray at the same virtual address in each physical memory.
            c
           ISO/IEC 2017 – All rights reserved                                                      45
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE5.12
               Except in contexts where coindexed objects are disallowed, accessing a coarray on its own image by using
               a set of cosubscripts that specify that image has the same eﬀect as accessing it without cosubscripts. In
               particular, the segment ordering rules (11.6.2) apply whether or not cosubscripts are used to access the
               coarray.
           5.4.8   Established coarrays
         1 Anonallocatable coarray with the SAVE attribute is established in the initial team.
         2 Anallocated allocatable coarray is established in the team in which it was allocated. An unallocated allocatable
           coarray is not established.
         3 A coarray that is an associating entity in a coarray-association of a CHANGE TEAM statement is established
           in the team of its CHANGE TEAM construct.
         4 Anonallocatable coarray that is an associating entity in an ASSOCIATE, SELECT RANK, or SELECT TYPE
           construct is established in the team in which the ASSOCIATE, SELECT RANK, or SELECT TYPE statement
           is executed.
         5 A nonallocatable coarray that is a dummy argument or host associated with a dummy argument is established
           in the team in which the procedure was invoked. A coarray dummy argument is not established in any ancestor
           team even if the corresponding actual argument is established in one or more of them.
           5.4.9   Pointer
         1 Apointer has an association status which is either associated, disassociated, or undeﬁned (19.5.2.2).
         2 Apointer that is not associated shall not be referenced or deﬁned.
         3 If a data pointer is an array, the rank is declared, but the bounds are determined when it is associated with a
           target.
           5.4.10   Allocatable variables
         1 Theallocation status of an allocatable variable is either allocated or unallocated. An allocatable variable becomes
           allocated as described in 9.7.1.3. It becomes unallocated as described in 9.7.3.2.
         2 An unallocated allocatable variable shall not be referenced or deﬁned.
         3 If an allocatable variable is an array, the rank is declared, but the bounds are determined when it is allocated. If
           an allocatable variable is a coarray, the corank is declared, but the cobounds are determined when it is allocated.
           5.4.11   Storage
         1 Many of the facilities of this document make no assumptions about the physical storage characteristics of data
           objects. However, program units that include storage association dependent features shall observe the storage
           restrictions described in 19.5.3.
           5.5    Fundamental concepts
           5.5.1   Names and designators
         1 A name is used to identify a program constituent, such as a program unit, named variable, named constant,
           dummy argument, or derived type.
                                                                c
           46                                                   ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
         2 Adesignator is used to identify a program constituent or a part thereof.
           5.5.2   Statement keyword
         1 A statement keyword is not a reserved word; that is, a name with the same spelling is allowed. In the syntax
           rules, such keywords appear literally. In descriptive text, this meaning is denoted by the term “keyword” without
           any modiﬁer. Examples of statement keywords are IF, READ, UNIT, KIND, and INTEGER.
           5.5.3   Other keywords
         1 Other keywords denote names that identify items in a list. In this case, items are identiﬁed by a preceding
           keyword= rather than their position within the list.
         2 Anargument keyword is the name of a dummy argument in the interface for the procedure being referenced, and
           may appear in an actual argument list. A type parameter keyword is the name of a type parameter in the type
           being speciﬁed, and may appear in a type parameter list. A component keyword is the name of a component in
           a structure constructor.
           R516   keyword                 is name
               NOTE5.13
               Use of keywords rather than position to identify items in a list can make such lists more readable and allows
               them to be reordered. This facilitates speciﬁcation of a list in cases where optional items are omitted.
           5.5.4   Association
         1 Name association (19.5.1) permits an entity to be identiﬁed by diﬀerent names in the same scoping unit or by
           the same name or diﬀerent names in diﬀerent scoping units.
         2 Pointer association (19.5.2) between a pointer and a target allows the target to be denoted by the pointer.
         3 Storage association (19.5.3) causes diﬀerent entities to use the same storage.
         4 Inheritance association (19.5.4) occurs between components of the parent component and components inherited
           by type extension.
           5.5.5   Intrinsic
         1 All intrinsic types, procedures, assignments, and operators may be used in any scoping unit without further
           deﬁnition or speciﬁcation. Intrinsic modules (16.10, 17, 18.2) may be accessed by use association.
           5.5.6   Operator
         1 This document speciﬁes a number of intrinsic operators (e.g., the arithmetic operators +, –, *, /, and ** with
           numeric operands and the logical operators .AND., .OR., etc. with logical operands). Additional operators may
           be deﬁned within a program (7.5.5, 15.4.3.4).
           5.5.7   Companion processors
         1 Aprocessor has one or more companion processors. A companion processor may be a mechanism that references
           and deﬁnes such entities by a means other than Fortran (15.6.3), it may be the Fortran processor itself, or it may
           be another Fortran processor. If there is more than one companion processor, the means by which the Fortran
           processor selects among them are processor dependent.
         2 If a procedure is deﬁned by means of a companion processor that is not the Fortran processor itself, this document
           refers to the C function that deﬁnes the procedure, although the procedure need not be deﬁned by means of the
           Cprogramming language.
            c
           ISO/IEC 2017 – All rights reserved                                                      47
      ISO/IEC DIS 1539-1:2017 (E)
         NOTE5.14
        Acompanion processor might or might not be a mechanism that conforms to the requirements of ISO/IEC
        9899:2011. If it does, 5.3.7 states that a program unit that is deﬁned by means other than Fortran and that
        initiates normal termination is required to include the eﬀect of executing the C exit() function.
        For example, a processor might allow a procedure deﬁned by some language other than Fortran or C to be
        invoked if it can be described by a C prototype as deﬁned in 6.7.6.3 of ISO/IEC 9899:2011.
                                   c
      48                           ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
           6 Lexical tokens and source form
           6.1    Processor character set
           6.1.1   Characters
         1 Theprocessor character set is processor dependent. Each character in a processor character set is either a control
           character or a graphic character. The set of graphic characters is further divided into letters (6.1.2), digits (6.1.3),
           underscore (6.1.4), special characters (6.1.5), and other characters (6.1.6).
         2 The letters, digits, underscore, and special characters make up the Fortran character set. Together, the set of
           letters, digits, and underscore deﬁne the syntax class alphanumeric-character.
           R601   alphanumeric-character  is letter
                                          or digit
                                          or underscore
         3 Except for the currency symbol, the graphics used for the characters shall be as given in 6.1.2, 6.1.3, 6.1.4, and
           6.1.5. However, the style of any graphic is not speciﬁed.
           6.1.2   Letters
         1 The twenty-six letters are:
         2     ABCDEFGHIJKLMNOPQRSTUVWXYZ
         3 Thesetofletters deﬁnes the syntactic class letter. The processor character set shall include lower-case and upper-
           case letters. A lower-case letter is equivalent to the corresponding upper-case letter in program units except in a
           character context (3.21).
               NOTE6.1
               The following statements are equivalent:
               CALL BIG_COMPLEX_OPERATION (NDATE)
               call big_complex_operation (ndate)
               Call Big_Complex_Operation (NDate)
           6.1.3   Digits
         1 The ten digits are:
         2     0 1 2 3 4 5 6 7 8 9
         3 The ten digits deﬁne the syntactic class digit.
           6.1.4   Underscore
           R602   underscore              is _
           6.1.5   Special characters
         1 The special characters are shown in Table 6.1.
            c
           ISO/IEC 2017 – All rights reserved                                                      49
             ISO/IEC DIS 1539-1:2017 (E)
                                                 Table 6.1: Special characters
                            Character   Name of character       Character   Name of character
                                        Blank                       ;       Semicolon
                                =       Equals                      !       Exclamation point
                                +       Plus                        "       Quotation mark or quote
                                 -      Minus                       %       Percent
                                *       Asterisk                    &       Ampersand
                                /       Slash                       ~       Tilde
                                \       Backslash                   <       Less than
                                 (      Left parenthesis            >       Greater than
                                 )      Right parenthesis           ?       Question mark
                                 [      Left square bracket         ’       Apostrophe
                                 ]      Right square bracket        `       Grave accent
                                {       Left curly bracket          ^       Circumﬂex accent
                                }       Right curly bracket         |       Vertical line
                                 ,      Comma                       $       Currency symbol
                                 .      Decimal point or period     #       Number sign
                                 :      Colon                       @       Commercial at
          2 Some of the special characters are used for operator symbols, bracketing, and various forms of separating and
             delimiting other lexical tokens.
             6.1.6   Other characters
          1 Additional characters may be representable in the processor, but may appear only in comments (6.3.2.3, 6.3.3.2),
             character constants (7.4.4), input/output records (12.2.2), and character string edit descriptors (13.3.2).
             6.2    Low-level syntax
             6.2.1   Tokens
          1 The low-level syntax describes the fundamental lexical tokens of a program unit. A lexical token is a keyword,
             name, literal constant other than a complex literal constant, operator, statement label, delimiter, comma, =, =>,
             :, ::, ;, .., or %.
             6.2.2   Names
          1 Names are used for various entities such as variables, program units, dummy arguments, named constants, and
             derived types.
             R603   name                      is  letter [ alphanumeric-character ] ...
             C601   (R603) The maximum length of a name is 63 characters.
                 NOTE6.2
                 Examples of names:
                  A1
                  NAME_LENGTH           (single underscore)
                  S_P_R_E_A_D__O_U_T    (two consecutive underscores)
                  TRAILER_              (trailing underscore)
                                                                        c
             50                                                        ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
               NOTE6.3
               Theword“name”alwaysdenotesthisparticular syntactic form. The word “identiﬁer” is used where entities
               can be identiﬁed by other syntactic forms or by values; its particular meaning depends on the context in
               which it is used.
           6.2.3   Constants
           R604   constant                is literal-constant
                                          or named-constant
           R605   literal-constant        is int-literal-constant
                                          or real-literal-constant
                                          or complex-literal-constant
                                          or logical-literal-constant
                                          or char-literal-constant
                                          or boz-literal-constant
           R606   named-constant          is name
           R607   int-constant            is constant
           C602   (R607) int-constant shall be of type integer.
           6.2.4   Operators
           R608   intrinsic-operator      is power-op
                                          or mult-op
                                          or add-op
                                          or concat-op
                                          or rel-op
                                          or not-op
                                          or and-op
                                          or or-op
                                          or equiv-op
           R1007 power-op                 is **
           R1008 mult-op                  is *
                                          or /
           R1009 add-op                   is +
                                          or –
           R1011 concat-op                is //
           R1013 rel-op                   is .EQ.
                                          or .NE.
                                          or .LT.
                                          or .LE.
                                          or .GT.
                                          or .GE.
                                          or ==
                                          or /=
                                          or <
                                          or <=
                                          or >
                                          or >=
            c
           ISO/IEC 2017 – All rights reserved                                                      51
                ISO/IEC DIS 1539-1:2017 (E)
                R1018 not-op                              is  .NOT.
                R1019 and-op                              is  .AND.
                R1020 or-op                               is  .OR.
                R1021 equiv-op                            is  .EQV.
                                                          or .NEQV.
                R609     deﬁned-operator                  is  deﬁned-unary-op
                                                          or deﬁned-binary-op
                                                          or extended-intrinsic-op
                R1003 deﬁned-unary-op                     is  . letter [ letter ] ... .
                R1023 deﬁned-binary-op                    is  . letter [ letter ] ... .
                R610     extended-intrinsic-op            is  intrinsic-operator
                6.2.5     Statement labels
            1 Astatement label provides a means of referring to an individual statement.
                R611     label                            is  digit [ digit [ digit [ digit [ digit ] ] ] ]
                C603     (R611) At least one digit in a label shall be nonzero.
            2 If a statement is labeled, the statement shall contain a nonblank character. The same statement label shall not
                be given to more than one statement in its scope. Leading zeros are not signiﬁcant in distinguishing between
                statement labels. There are 99999 possible unique statement labels and a processor shall accept any of them as
                a statement label. However, a processor may have a limit on the total number of unique statement labels in one
                program unit.
                     NOTE6.4
                     For example:
                     99999
                     10
                      010
                     are all statement labels. The last two are equivalent.
            3 Any statement that is not part of another statement, and that is not preceded by a semicolon in ﬁxed form, may begin
                with a statement label, but the labels are used only in the following ways.
                   • The label on a branch target statement (11.2) is used to identify that statement as the possible destination
                      of a branch.
                   • The label on a FORMAT statement (13.2.1) is used to identify that statement as the format speciﬁcation
                      for a data transfer statement (12.6).
                   • In some forms of the DO construct (11.1.7), the terminal statement of the construct is identiﬁed by a label.
                6.2.6     Delimiters
            1 Alexical token that is a delimiter is a (, ), /, [, ], (/, or /).
                                                                                         c
                52                                                                       ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              6.3     Source form
              6.3.1    Program units, statements, and lines
           1 A Fortran program unit is a sequence of one or more lines, organized as Fortran statements, comments, and
              INCLUDElines. A line is a sequence of zero or more characters. Lines following a program unit END statement
              are not part of that program unit. A Fortran statement is a sequence of one or more complete or partial lines.
           2 Acomment may contain any character that may occur in any character context.
           3 There are two source forms. Subclause 6.3.2 applies only to free form source. Subclause 6.3.3 applies only to ﬁxed source
              form. Free form and ﬁxed form shall not be mixed in the same program unit. The means for specifying the source form of a program
              unit are processor dependent.
              6.3.2    Free source form
              6.3.2.1  Free form line length
           1 In free source form there are no restrictions on where a statement (or portion of a statement) may appear within
              a line. A line may contain zero characters. If a line consists entirely of characters of default kind (7.4.4), it may
              contain at most 132 characters. If a line contains any character that is not of default kind, the maximum number
              of characters allowed on the line is processor dependent.
              6.3.2.2  Blank characters in free form
           1 In free source form blank characters shall not appear within lexical tokens other than in a character context or in
              a format speciﬁcation. Blanks may be inserted freely between tokens to improve readability; for example, blanks
              may occur between the tokens that form a complex literal constant. A sequence of blank characters outside of a
              character context is equivalent to a single blank character.
           2 Ablankshall be used to separate names, constants, or labels from adjacent keywords, names, constants, or labels.
                   NOTE6.5
                  For example, the blanks after REAL, READ, 30, and DO are required in the following:
                  REAL X
                  READ 10
                  30 DO K=1,3
           3 One or more blanks shall be used to separate adjacent keywords except in the following cases, where blanks are
              optional:
                                Table 6.2: Adjacent keywords where separating blanks are optional
                                  BLOCKDATA                 ENDFILE                ENDSUBROUTINE
                                  DOUBLEPRECISION ENDFORALL                        ENDTEAM
                                  ELSE IF                   ENDFUNCTION            ENDTYPE
                                  ELSE WHERE                ENDIF                  ENDWHERE
                                  ENDASSOCIATE              ENDINTERFACE           GOTO
                                  ENDBLOCK                  ENDMODULE              IN OUT
                                  ENDBLOCKDATA              ENDPROCEDURE SELECTCASE
                                  ENDCRITICAL               ENDPROGRAM             SELECT TYPE
                                  ENDDO                     ENDSELECT
                                  ENDENUM                   ENDSUBMODULE
              c
              ISO/IEC 2017 – All rights reserved                                                                         53
              ISO/IEC DIS 1539-1:2017 (E)
              6.3.2.3  Free form commentary
           1 Thecharacter “!” initiates a comment except where it appears within a character context. The comment extends
              to the end of the line. If the ﬁrst nonblank character on a line is an “!”, the line is a comment line. Lines
              containing only blanks or containing no characters are also comment lines. Comments may appear anywhere in
              a program unit and may precede the ﬁrst statement of a program unit or follow the last statement of a program
              unit. Comments have no eﬀect on the interpretation of the program unit.
                   NOTE6.6
                  This document does not restrict the number of consecutive comment lines.
              6.3.2.4  Free form statement continuation
           1 The character “&” is used to indicate that the statement is continued on the next line that is not a comment
              line. Comment lines cannot be continued; an “&” in a comment has no eﬀect. Comments may occur within a
              continued statement. When used for continuation, the “&” is not part of the statement. No line shall contain
              a single “&” as the only nonblank character or as the only nonblank character before an “!” that initiates a
              comment.
           2 If a noncharacter context is to be continued, an “&” shall be the last nonblank character on the line, or the last
              nonblank character before an “!”. There shall be a later line that is not a comment; the statement is continued
              on the next such line. If the ﬁrst nonblank character on that line is an “&”, the statement continues at the next
              character position following that “&”; otherwise, it continues with the ﬁrst character position of that line.
           3 If a lexical token is split across the end of a line, the ﬁrst nonblank character on the ﬁrst following noncomment
              line shall be an “&” immediately followed by the successive characters of the split token.
           4 If a character context is to be continued, an “&” shall be the last nonblank character on the line. There shall be
              a later line that is not a comment; an “&” shall be the ﬁrst nonblank character on the next such line and the
              statement continues with the next character following that “&”.
              6.3.2.5  Free form statement termination
           1 If a statement is not continued, a comment or the end of the line terminates the statement.
           2 A statement may alternatively be terminated by a “;” character that appears other than in a character context
              or in a comment. The “;” is not part of the statement. After a “;” terminator, another statement may appear
              on the same line, or begin on that line and be continued. A sequence consisting only of zero or more blanks and
              one or more “;” terminators, in any order, is equivalent to a single “;” terminator.
              6.3.2.6  Free form statements
           1 Alabel may precede any statement not forming part of another statement.
                   NOTE6.7
                  No Fortran statement begins with a digit.
           2 Astatement shall not have more than 255 continuation lines.
              6.3.3    Fixed source form
              6.3.3.1  General
           1 In ﬁxed source form, there are restrictions on where a statement may appear within a line. If a source line contains only characters
              of default kind, it shall contain exactly 72 characters; otherwise, its maximum number of characters is processor dependent.
           2 Except in a character context, blanks are insigniﬁcant and may be used freely throughout the program.
                                                                              c
              54                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              6.3.3.2  Fixed form commentary
           1 The character “!” initiates a comment except where it appears within a character context or in character position 6. The comment
              extends to the end of the line. If the ﬁrst nonblank character on a line is an “!” in any character position other than character
              position 6, the line is a comment line. Lines beginning with a “C” or “*” in character position 1 and lines containing only blanks are
              also comment lines. Comments may appear anywhere in a program unit and may precede the ﬁrst statement of the program unit or
              follow the last statement of a program unit. Comments have no eﬀect on the interpretation of the program unit.
                   NOTE6.8
                  This document does not restrict the number of consecutive comment lines.
              6.3.3.3  Fixed form statement continuation
           1 Except within commentary, character position 6 is used to indicate continuation. If character position 6 contains a blank or zero, the
              line is the initial line of a new statement, which begins in character position 7. If character position 6 contains any character other
              than blank or zero, character positions 7–72 of the line constitute a continuation of the preceding noncomment line.
                   NOTE6.9
                  An“!” or “;” in character position 6 is interpreted as a continuation indicator unless it appears within commentary indicated
                  by a “C” or “*” in character position 1 or by an “!” in character positions 1–5.
           2 Comment lines cannot be continued. Comment lines may occur within a continued statement.
              6.3.3.4  Fixed form statement termination
           1 If a statement is not continued, a comment or the end of the line terminates the statement.
           2 Astatement may alternatively be terminated by a “;” character that appears other than in a character context, in a comment, or in
              character position 6. The “;” is not part of the statement. After a “;” terminator, another statement may begin on the same line, or
              begin on that line and be continued. A “;” shall not appear as the ﬁrst nonblank character on an initial line. A sequence consisting
              only of zero or more blanks and one or more “;” terminators, in any order, is equivalent to a single “;” terminator.
              6.3.3.5  Fixed form statements
           1 Alabel, if it appears, shall occur in character positions 1 through 5 of the ﬁrst line of a statement; otherwise, positions 1 through
              5 shall be blank. Blanks may appear anywhere within a label. A statement following a “;” on the same line shall not be labeled.
              Character positions 1 through 5 of any continuation lines shall be blank. A statement shall not have more than 255 continuation
              lines. The program unit END statement shall not be continued. A statement whose initial line appears to be a program unit END
              statement shall not be continued.
              6.4     Including source text
           1 Additionaltextmaybeincorporatedintothesourcetextofaprogramunitduringprocessing. Thisisaccomplished
              with the INCLUDE line, which has the form
                    INCLUDE char-literal-constant
           2 The char-literal-constant shall not have a kind type parameter value that is a named-constant.
           3 An INCLUDE line is not a Fortran statement.
           4 An INCLUDE line shall appear on a single source line where a statement may appear; it shall be the only
              nonblank text on this line other than an optional trailing comment. Thus, a statement label is not allowed.
           5 The eﬀect of the INCLUDE line is as if the referenced source text physically replaced the INCLUDE line prior
              to program processing. Included text may contain any source text, including additional INCLUDE lines; such
              nested INCLUDE lines are similarly replaced with the speciﬁed source text. The maximum depth of nesting of
              any nested INCLUDE lines is processor dependent. Inclusion of the source text referenced by an INCLUDE line
              shall not, at any level of nesting, result in inclusion of the same source text.
              c
              ISO/IEC 2017 – All rights reserved                                                                         55
          ISO/IEC DIS 1539-1:2017 (E)
        6 WhenanINCLUDElineisresolved, the ﬁrst included statement line shall not be a continuation line and the last
          included statement line shall not be continued.
        7 The interpretation of char-literal-constant is processor dependent. An example of a possible valid interpretation
          is that char-literal-constant is the name of a ﬁle that contains the source text to be included.
             NOTE6.10
             In some circumstances, for example where source code is maintained in an INCLUDE ﬁle for use in programs whose source
             form might be either ﬁxed or free, observing the following rules allows the code to be used with either source form.
                • Conﬁne statement labels to character positions 1 to 5 and statements to character positions 7 to 72.
                • Treat blanks as being signiﬁcant.
                • Use only the exclamation mark (!) to indicate a comment, but do not start the comment in character position 6.
                • For continued statements, place an ampersand (&) in both character position 73 of a continued line and character
                 position 6 of a continuation line.
                                                        c
          56                                            ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
           7 Types
           7.1    Characteristics of types
           7.1.1   The concept of type
         1 Fortran provides an abstract means whereby data can be categorized without relying on a particular physical
           representation. This abstract means is the concept of type.
         2 A type has a name, a set of valid values, a means to denote such values (constants), and a set of operations to
           manipulate the values.
           7.1.2   Type classiﬁcation
         1 Atype is either an intrinsic type or a derived type.
         2 This document deﬁnes ﬁve intrinsic types: integer, real, complex, character, and logical.
         3 A derived type is one that is deﬁned by a derived-type deﬁnition (7.5.2) or by an intrinsic module. It shall be
           used only where it is accessible (7.5.2.2). An intrinsic type is always accessible.
           7.1.3   Set of values
         1 For each type, there is a set of valid values. The set of valid values for logical is completely determined by this
           document. The sets of valid values for integer, character, and real are processor dependent. The set of valid
           values for complex consists of the set of all the combinations of the values of the real and imaginary parts. The
           set of valid values for a derived type is as deﬁned in 7.5.8.
           7.1.4   Constants
         1 The syntax for denoting a value indicates the type, type parameters, and the particular value.
         2 The syntax for literal constants of each intrinsic type is speciﬁed in 7.4.
         3 Astructure constructor (7.5.10) that is a constant expression (10.1.12) denotes a scalar constant value of derived
           type. An array constructor (7.8) that is a constant expression denotes a constant array value of intrinsic or
           derived type.
         4 Aconstant value can be named (8.5.13, 8.6.11).
           7.1.5   Operations
         1 For each of the intrinsic types, a set of operations and corresponding operators is deﬁned intrinsically. These are
           described in Clause 10. The intrinsic set can be augmented with operations and operators deﬁned by functions
           with the OPERATOR interface (15.4.3.2). Operator deﬁnitions are described in Clauses 10 and 15.
         2 For derived types, there are no intrinsic operations. Operations on derived types can be deﬁned by the program
           (7.5.11).
            c
           ISO/IEC 2017 – All rights reserved                                                      57
              ISO/IEC DIS 1539-1:2017 (E)
              7.2     Type parameters
           1 Atype might be parameterized. In this case, the set of values, the syntax for denoting the values, and the set of
              operations on the values of the type depend on the values of the parameters.
           2 A type parameter is either a kind type parameter or a length type parameter. All type parameters are of type
              integer. A kind type parameter participates in generic resolution (15.5.5.2), but a length type parameter does
              not.
           3 Each intrinsic type has a kind type parameter named KIND. The intrinsic character type has a length type
              parameter named LEN. A derived type can have type parameters.
           4 Atype parameter value may be speciﬁed by a type speciﬁcation (7.4, 7.5.9).
              R701    type-param-value             is   scalar-int-expr
                                                   or *
                                                   or :
              C701    (R701) The type-param-value for a kind type parameter shall be a constant expression.
              C702    (R701) A colon shall not be used as a type-param-value except in the declaration of an entity that has
                      the POINTER or ALLOCATABLE attribute.
           5 Acolon as a type-param-value speciﬁes a deferred type parameter.
           6 Thevalues of the deferred type parameters of an object are determined by successful execution of an ALLOCATE
              statement (9.7.1), execution of an intrinsic assignment statement (10.2.1.3), execution of a pointer assignment
              statement (10.2.2), or by argument association (15.5.2).
                   NOTE7.1
                   Deferred type parameters of functions, including function procedure pointers, have no values. Instead, they
                   indicate that those type parameters of the function result will be determined by execution of the function,
                   if it returns an allocated allocatable result or an associated pointer result.
           7 Anasterisk as a type-param-value speciﬁes that a length type parameter is an assumed type parameter. It is used
              for a dummy argument to assume the type parameter value from the eﬀective argument, for an associate name
              in a SELECT TYPE construct to assume the type parameter value from the corresponding selector, and for a
              named constant of type character to assume the character length from the constant-expr.
                   NOTE7.2
                   The value of a kind type parameter is always known at compile time. Some parameterizations that involve
                   multiple representation forms need to be distinguished at compile time for practical implementation and
                   performance. Examples include the multiple precisions of the intrinsic real type and the possible multiple
                   character sets of the intrinsic character type.
                   The adjective “length” is used for type parameters other than kind type parameters because they often
                   specify a length, as for intrinsic character type.  However, they can be used for other purposes. The
                   important diﬀerence from kind type parameters is that their values need not be known at compile time and
                   might change during execution.
              7.3     Types, type speciﬁers, and values
              7.3.1    Relationship of types and values to objects
           1 The name of a type serves as a type speciﬁer and may be used to declare objects of that type. A declaration
              speciﬁes the type of a named object. A data object may be declared explicitly or implicitly. A data object has
                                                                                c
              58                                                               ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              attributes in addition to its type. Clause 8 describes the way in which a data object is declared and how its type
              and other attributes are speciﬁed.
           2 Scalar data of any intrinsic or derived type may be shaped in a rectangular pattern to compose an array of the
              same type and type parameters. An array object has a type and type parameters just as a scalar object does.
           3 A variable is a data object. The type and type parameters of a variable determine which values that variable
              may take. Assignment (10.2) provides one means of changing the value of a variable of any type.
           4 The type of a variable determines the operations that may be used to manipulate the variable.
              7.3.2    Type speciﬁers and type compatibility
              7.3.2.1  Type speciﬁer syntax
           1 Atype speciﬁer speciﬁes a type and type parameter values. It is either a type-spec or a declaration-type-spec.
              R702    type-spec                   is  intrinsic-type-spec
                                                  or derived-type-spec
              C703    (R702) The derived-type-spec shall not specify an abstract type (7.5.7).
              R703    declaration-type-spec       is  intrinsic-type-spec
                                                  or TYPE ( intrinsic-type-spec )
                                                  or TYPE ( derived-type-spec )
                                                  or CLASS ( derived-type-spec )
                                                  or CLASS ( * )
                                                  or TYPE ( * )
              C704    (R703) In a declaration-type-spec, every type-param-value that is not a colon or an asterisk shall be a
                      speciﬁcation-expr.
              C705    (R703) In a declaration-type-spec that uses the CLASS keyword, derived-type-spec shall specify an ex-
                      tensible type (7.5.7).
              C706    (R703) TYPE(derived-type-spec) shall not specify an abstract type (7.5.7).
              C707    (R702) In TYPE(intrinsic-type-spec) the intrinsic-type-spec shall not end with a comma.
              C708    An entity declared with the CLASS keyword shall be a dummy argument or have the ALLOCATABLE
                      or POINTER attribute.
           2 An intrinsic-type-spec speciﬁes the named intrinsic type and its type parameter values. A derived-type-spec
              speciﬁes the named derived type and its type parameter values.
                   NOTE7.3
                  Atype-spec is used in an array constructor, a SELECT TYPE construct, or an ALLOCATE statement. An
                  integer-type-spec is used in a DO CONCURRENT or FORALL statement. Elsewhere, a declaration-type-spec
                  is used.
              7.3.2.2  TYPE type speciﬁer
           1 ATYPEtypespeciﬁer is used to declare entities that are assumed-type, or of an intrinsic or derived type.
           2 A derived-type-spec in a TYPE type speciﬁer in a type declaration statement shall specify a previously deﬁned
              derived type. If the data entity is a function result, the derived type may be speciﬁed in the FUNCTION
              statement provided the derived type is deﬁned within the body of the function or is accessible there by use or
              host association. If the derived type is speciﬁed in the FUNCTION statement and is deﬁned within the body
              of the function, it is as if the function result were declared with that derived type immediately following the
              derived-type-def of the speciﬁed derived type.
              c
              ISO/IEC 2017 – All rights reserved                                                                         59
              ISO/IEC DIS 1539-1:2017 (E)
           3 An entity that is declared using the TYPE(*) type speciﬁer is assumed-type and is an unlimited polymorphic
              entity. It is not declared to have a type, and is not considered to have the same declared type as any other entity,
              including another unlimited polymorphic entity. Its dynamic type and type parameters are assumed from its
              eﬀective argument.
              C709    An assumed-type entity shall be a dummy data object that does not have the ALLOCATABLE, CODI-
                      MENSION, INTENT (OUT), POINTER, or VALUE attribute and is not an explicit-shape array.
              C710    An assumed-type variable name shall not appear in a designator or expression except as an actual
                      argument corresponding to a dummy argument that is assumed-type, or as the ﬁrst argument to the
                      intrinsic function IS_CONTIGUOUS, LBOUND, PRESENT, RANK, SHAPE, SIZE, or UBOUND, or
                      the function C_LOC from the intrinsic module ISO_C_BINDING.
              C711    An assumed-type actual argument that corresponds to an assumed-rank dummy argument shall be
                      assumed-shape or assumed-rank.
              7.3.2.3  CLASS type speciﬁer
           1 The CLASS type speciﬁer is used to declare polymorphic entities. A polymorphic entity is a data entity that is
              able to be of diﬀering dynamic types during program execution.
           2 A derived-type-spec in a CLASS type speciﬁer in a type declaration statement shall specify a previously deﬁned
              derived type. If the data entity is a function result, the derived type may be speciﬁed in the FUNCTION
              statement provided the derived type is deﬁned within the body of the function or is accessible there by use or
              host association. If the derived type is speciﬁed in the FUNCTION statement and is deﬁned within the body
              of the function, it is as if the function result were declared with that derived type immediately following its
              derived-type-def.
           3 Thedeclared type of a polymorphic entity is the speciﬁed type if the CLASS type speciﬁer contains a type name.
           4 An entity declared with the CLASS(*) speciﬁer is an unlimited polymorphic entity. It is not declared to have
              a type, and is not considered to have the same declared type as any other entity, including another unlimited
              polymorphic entity.
           5 A nonpolymorphic entity is type compatible only with entities of the same declared type. A polymorphic entity
              that is not an unlimited polymorphic entity is type compatible with entities of the same declared type or any of
              its extensions. Even though an unlimited polymorphic entity is not considered to have a declared type, it is type
              compatible with all entities. An entity is type compatible with a type if it is type compatible with entities of that
              type.
                   NOTE7.4
                  Given
                     TYPE TROOT
                     ...
                     TYPE,EXTENDS(TROOT) :: TEXTENDED
                     ...
                     CLASS(TROOT) A
                     CLASS(TEXTENDED) B
                     ...
                  Ais type compatible with B but B is not type compatible with A.
           6 A polymorphic allocatable object may be allocated to be of any type with which it is type compatible. A
              polymorphic pointer or dummy argument may, during program execution, be associated with objects with which
              it is type compatible.
                                                                              c
              60                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           7 The dynamic type of an allocated allocatable polymorphic object is the type with which it was allocated. The
              dynamic type of an associated polymorphic pointer is the dynamic type of its target. The dynamic type of a
              nonallocatable nonpointer polymorphic dummy argument is the dynamic type of its eﬀective argument. The
              dynamic type of an unallocated allocatable object or a disassociated pointer is the same as its declared type. The
              dynamic type of an entity identiﬁed by an associate name (11.1.3) is the dynamic type of the selector with which
              it is associated. The dynamic type of an object that is not polymorphic is its declared type.
              7.4     Intrinsic types
              7.4.1    Classiﬁcation and speciﬁcation
           1 Each intrinsic type is classiﬁed as a numeric type or a nonnumeric type. The numeric types are integer, real, and
              complex. The nonnumeric intrinsic types are character and logical.
           2 Each intrinsic type has a kind type parameter named KIND; this type parameter is of type integer with default
              kind.
              R704    intrinsic-type-spec         is  integer-type-spec
                                                  or REAL [ kind-selector ]
                                                  or DOUBLEPRECISION
                                                  or COMPLEX[kind-selector ]
                                                  or CHARACTER[char-selector ]
                                                  or LOGICAL [ kind-selector ]
              R705    integer-type-spec           is  INTEGER[ kind-selector ]
              R706    kind-selector               is  ( [ KIND = ] scalar-int-constant-expr )
              C712    (R706) The value of scalar-int-constant-expr shall be nonnegative and shall specify a representation
                      method that exists on the processor.
              7.4.2    Intrinsic operations on intrinsic types
           1 Intrinsic numeric operations are deﬁned as speciﬁed in 10.1.5.2.1 for the numeric intrinsic types. Relational
              intrinsic operations are deﬁned as speciﬁed in 10.1.5.5 for numeric and character intrinsic types. The intrinsic
              concatenation operation is deﬁned as speciﬁed in 10.1.5.3 for the character type. Logical intrinsic operations are
              deﬁned as speciﬁed in 10.1.5.4 for the logical type.
              7.4.3    Numeric intrinsic types
              7.4.3.1  Integer type
           1 The set of values for the integer type is a subset of the mathematical integers. The processor shall provide one or
              morerepresentation methods that deﬁne sets of values for data of type integer. Each such method is characterized
              by a value for the kind type parameter KIND. The kind type parameter of a representation method is returned
              by the intrinsic function KIND (16.9.108). The decimal exponent range of a representation method is returned
              by the intrinsic function RANGE (16.9.158). The intrinsic function SELECTED_INT_KIND (16.9.169) returns
              a kind value based on a speciﬁed decimal exponent range requirement. The integer type includes a zero value,
              which is considered to be neither negative nor positive. The value of a signed integer zero is the same as the
              value of an unsigned integer zero.
           2 The processor shall provide at least one representation method with a decimal exponent range greater than or
              equal to 18.
           3 The type speciﬁer for the integer type uses the keyword INTEGER.
              c
              ISO/IEC 2017 – All rights reserved                                                                         61
               ISO/IEC DIS 1539-1:2017 (E)
            4 The keyword INTEGER with no kind-selector speciﬁes type integer with default kind; the kind type parameter
               value is equal to KIND (0). The decimal exponent range of default integer shall be at least 5.
            5 Any integer value may be represented as a signed-int-literal-constant.
               R707     signed-int-literal-constant   is   [ sign ] int-literal-constant
               R708     int-literal-constant          is   digit-string [ _ kind-param ]
               R709     kind-param                    is   digit-string
                                                      or scalar-int-constant-name
               R710     signed-digit-string           is   [ sign ] digit-string
               R711     digit-string                  is   digit [ digit ] ...
               R712     sign                          is   +
                                                      or –
               C713     (R709) A scalar-int-constant-name shall be a named constant of type integer.
               C714     (R709) The value of kind-param shall be nonnegative.
               C715     (R708) The value of kind-param shall specify a representation method that exists on the processor.
            6 Theoptional kind type parameter following digit-string speciﬁes the kind type parameter of the integer constant;
               if it does not appear, the constant is default integer.
            7 An integer constant is interpreted as a decimal value.
                    NOTE7.5
                    Examples of signed integer literal constants are:
                    473
                    +56
                    -101
                    21_2
                    21_SHORT
                    1976354279568241_8
                    where SHORT is a scalar integer named constant. A program that uses a digit-string as a kind-param is
                    unlikely to be portable.
               7.4.3.2   Real type
            1 The real type has values that approximate the mathematical real numbers. The processor shall provide two
               or more approximation methods that deﬁne sets of values for data of type real. Each such method has a
               representation methodandischaracterizedbyavalueforthekindtypeparameterKIND.Thekindtypeparameter
               of an approximation method is returned by the intrinsic function KIND (16.9.108).
            2 The decimal precision, decimal exponent range, and radix of an approximation method are returned by the
               intrinsic functions PRECISION (16.9.151), RANGE (16.9.158), and RADIX (16.9.154). The intrinsic function
               SELECTED_REAL_KIND (16.9.170) returns a kind value based on speciﬁed precision, range, and radix re-
               quirements.
                    NOTE7.6
                    See C.2.1 for remarks concerning selection of approximation methods.
                                                                                    c
               62                                                                  ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
            3 The real type includes a zero value. Processors that distinguish between positive and negative zeros shall treat
               them as mathematically equivalent
                  • in all intrinsic relational operations, and
                  • as actual arguments to intrinsic procedures other than those for which it is explicitly speciﬁed that negative
                     zero is distinguished.
                    NOTE7.7
                    Onaprocessor that distinguishes between 0.0 and −0.0,
                        ( X >= 0.0 )
                    evaluates to true if X = 0.0 or if X = −0.0,
                        ( X < 0.0 )
                    evaluates to false for X = −0.0.
                    In order to distinguish between 0.0 and −0.0, a program can use the intrinsic function SIGN. SIGN (1.0, X)
                    will return −1.0 if X < 0.0 or if the processor distinguishes between 0.0 and −0.0 and X has the value −0.0.
            4 ThetypespeciﬁerfortherealtypeusesthekeywordREAL.ThekeywordDOUBLEPRECISIONisanalternative
               speciﬁer for one kind of real type.
            5 If the type keyword REAL is used without a kind type parameter, the real type with default real kind is speciﬁed
               and the kind value is KIND (0.0). The type speciﬁer DOUBLE PRECISION speciﬁes type real with double
               precision kind; the kind value is KIND (0.0D0). The decimal precision of the double precision real approximation
               method shall be greater than that of the default real method.
            6 The decimal precision of double precision real shall be at least 10, and its decimal exponent range shall be at
               least 37. It is recommended that the decimal precision of default real be at least 6, and that its decimal exponent
               range be at least 37.
               R713     signed-real-literal-constant   is  [ sign ] real-literal-constant
               R714     real-literal-constant          is  signiﬁcand [ exponent-letter exponent ] [ _ kind-param ]
                                                       or digit-string exponent-letter exponent [ _ kind-param ]
               R715     signiﬁcand                     is  digit-string . [ digit-string ]
                                                       or . digit-string
               R716     exponent-letter                is  E
                                                       or D
               R717     exponent                       is  signed-digit-string
               C716     (R714) If both kind-param and exponent-letter appear, exponent-letter shall be E.
               C717     (R714) The value of kind-param shall specify an approximation method that exists on the processor.
            7 Areal literal constant without a kind type parameter is a default real constant if it is without an exponent part
               or has exponent letter E, and is a double precision real constant if it has exponent letter D. A real literal constant
               written with a kind type parameter is a real constant with the speciﬁed kind type parameter.
            8 The exponent represents the power of ten scaling to be applied to the signiﬁcand or digit string. The meaning of
               these constants is as in decimal scientiﬁc notation.
            9 Thesigniﬁcandmaybewrittenwithmoredigitsthanaprocessorwillusetoapproximatethevalueoftheconstant.
                c
               ISO/IEC 2017 – All rights reserved                                                                                  63
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE7.8
                  Examples of signed real literal constants are:
                  -12.78
                  +1.6E3
                  2.1
                  -16.E4_8
                  0.45D-4
                  10.93E7_QUAD
                  .123
                  3E4
                  where QUAD is a scalar integer named constant.
              7.4.3.3  Complex type
           1 The complex type has values that approximate the mathematical complex numbers. The values of a complex
              type are ordered pairs of real values. The ﬁrst real value is called the real part, and the second real value is called
              the imaginary part.
           2 Each approximation method used to represent data entities of type real shall be available for both the real and
              imaginary parts of a data entity of type complex. The (default integer) kind type parameter KIND for a complex
              entity speciﬁes for both parts the real approximation method characterized by this kind type parameter value.
              The kind type parameter of an approximation method is returned by the intrinsic function KIND (16.9.108).
           3 The type speciﬁer for the complex type uses the keyword COMPLEX. There is no keyword for double precision
              complex. If the type keyword COMPLEX is used without a kind type parameter, the complex type with default
              complex kind is speciﬁed, the kind value is KIND (0.0), and both parts are default real.
              R718    complex-literal-constant    is  ( real-part , imag-part )
              R719    real-part                   is  signed-int-literal-constant
                                                  or signed-real-literal-constant
                                                  or named-constant
              R720    imag-part                   is  signed-int-literal-constant
                                                  or signed-real-literal-constant
                                                  or named-constant
              C718    (R718) Each named constant in a complex literal constant shall be of type integer or real.
           4 If the real part and the imaginary part of a complex literal constant are both real, the kind type parameter value
              of the complex literal constant is the kind type parameter value of the part with the greater decimal precision; if
              the precisions are the same, it is the kind type parameter value of one of the parts as determined by the processor.
              If a part has a kind type parameter value diﬀerent from that of the complex literal constant, the part is converted
              to the approximation method of the complex literal constant.
           5 If both the real and imaginary parts are integer, they are converted to the default real approximation method
              and the constant is default complex. If only one of the parts is an integer, it is converted to the approximation
              method selected for the part that is real and the kind type parameter value of the complex literal constant is
              that of the part that is real.
                   NOTE7.9
                  Examples of complex literal constants are:
                                                                              c
              64                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
                   NOTE7.9 (cont.)
                  (1.0, -1.0)
                  (3, 3.1E6)
                  (4.0_4, 3.6E7_8)
                  ( 0., PI)             ! where PI is a previously declared named real constant.
              7.4.4    Character type
              7.4.4.1  Character sets
           1 Thecharactertypehasasetofvaluescomposedofcharacterstrings. Acharacterstringisasequenceofcharacters,
              numbered from left to right 1, 2, 3, ... up to the number of characters in the string. The number of characters in
              the string is called the length of the string. The length is a type parameter; its kind is processor dependent and
              its value is greater than or equal to zero.
           2 The processor shall provide one or more representation methods that deﬁne sets of values for data of type
              character. Each such method is characterized by a value for the (default integer) kind type parameter KIND.
              The kind type parameter of a representation method is returned by the intrinsic function KIND (16.9.108). The
              intrinsic function SELECTED_CHAR_KIND (16.9.168) returns a kind value based on the name of a character
              type. Any character of a particular representation method representable in the processor may occur in a character
              string of that representation method.
           3 The character set speciﬁed in ISO/IEC 646:1991 (International Reference Version) is referred to as the ASCII
              character set and its corresponding representation method is ASCII character kind. The character set UCS-4 as
              speciﬁed in ISO/IEC 10646 is referred to as the ISO 10646 character set and its corresponding representation
              method is the ISO 10646 character kind.
              7.4.4.2  Character type speciﬁer
           1 The type speciﬁer for the character type uses the keyword CHARACTER.
           2 If the type keyword CHARACTER is used without a kind type parameter, the character type with default
              character kind is speciﬁed and the kind value is KIND (’A’).
           3 The default character kind shall support a character set that includes the characters in the Fortran character
              set (6.1). By supplying nondefault character kinds, the processor may support additional character sets. The
              characters available in nondefault character kinds are not speciﬁed by this document, except that one character
              in each nondefault character set shall be designated as a blank character to be used as a padding character.
              R721    char-selector               is  length-selector
                                                  or ( LEN = type-param-value ,
                                                         KIND = scalar-int-constant-expr )
                                                  or ( type-param-value ,
                                                         [ KIND = ] scalar-int-constant-expr )
                                                  or ( KIND = scalar-int-constant-expr
                                                         [ , LEN =type-param-value ] )
              R722    length-selector             is  ( [ LEN = ] type-param-value )
                                                  or *char-length [ , ]
              R723    char-length                 is  ( type-param-value )
                                                  or int-literal-constant
              C719    (R721) The value of scalar-int-constant-expr shall be nonnegative and shall specify a representation
                      method that exists on the processor.
              C720    (R723) The int-literal-constant shall not include a kind-param.
              c
              ISO/IEC 2017 – All rights reserved                                                                         65
              ISO/IEC DIS 1539-1:2017 (E)
              C721    (R723) A type-param-value in a char-length shall be a colon, asterisk, or speciﬁcation-expr.
              C722    (R721 R722 R723) A type-param-value of * shall be used only
                       • to declare a dummy argument,
                       • to declare a named constant,
                       • in the type-spec of an ALLOCATE statement wherein each allocate-object is a dummy argument of
                          type CHARACTER with an assumed character length,
                       • in the type-spec or derived-type-spec of a type guard statement (11.1.11), or
                       • in an external function, to declare the character length parameter of the function result.
              C723    Afunctionnameshallnotbedeclaredwithanasterisktype-param-value unlessitisoftypeCHARACTER
                      and is the name of a dummy function or the name of the result of an external function.
              C724    Afunction name declared with an asterisk type-param-value shall not be an array, a pointer, elemental, or pure. A function
                      name declared with an asterisk type-param-value shall not have the RECURSIVE attribute.
              C725    (R722) The optional comma in a length-selector is permitted only in a declaration-type-spec in a type-declaration-stmt.
              C726    (R722) The optional comma in a length-selector is permitted only if no double-colon separator appears in the type-
                      declaration-stmt.
              C727    (R721) The length speciﬁed for a character statement function or for a statement function dummy argument of type
                      character shall be a constant expression.
           4 Thechar-selector in a CHARACTERintrinsic-type-spec andthe*char-length in an entity-decl or in a component-
              decl of a type deﬁnition specify character length. The * char-length in an entity-decl or a component-decl speciﬁes
              anindividual length and overrides the length speciﬁed in the char-selector, if any. If a * char-length is not speciﬁed
              in an entity-decl or a component-decl, the length-selector or type-param-value speciﬁed in the char-selector is the
              character length. If the length is not speciﬁed in a char-selector or a * char-length, the length is 1.
           5 If the character length parameter value evaluates to a negative value, the length of character entities declared
              is zero. A character length parameter value of : indicates a deferred type parameter (7.2). A char-length type
              parameter value of * has the following meanings.
                 • If used to declare a dummy argument of a procedure, the dummy argument assumes its length from its
                   eﬀective argument.
                 • If used to declare a named constant, the length is that of the constant value.
                 • If used in the type-spec of an ALLOCATE statement, each allocate-object assumes its length from its eﬀective
                   argument.
                 • If used in the type-spec of a type guard statement, the associating entity assumes its length from the selector.
                 • If used to specify the character length parameter of a function result, any scoping unit invoking the function or passing it as
                   an actual argument shall declare the function name with a character length parameter value other than * or access such a
                   deﬁnition by argument, host, or use association. When the function is invoked, the length of the function result is assumed
                   from the value of this type parameter.
              7.4.4.3  Character literal constant
           1 The syntax of a character literal constant is given by R724.
              R724    char-literal-constant       is  [ kind-param _ ] ’ [ rep-char ] ... ’
                                                  or [ kind-param _ ] " [ rep-char ] ... "
              C728    (R724) The value of kind-param shall specify a representation method that exists on the processor.
           2 The optional kind type parameter preceding the leading delimiter speciﬁes the kind type parameter of the char-
              acter constant; if it does not appear, the constant is default character.
                                                                              c
              66                                                             ISO/IEC 2017 – All rights reserved
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ISO/IEC DIS 1539-1:2017 (E)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          3 For the type character with kind kind-param, if it appears, and for default character otherwise, a representable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     character, rep-char, is deﬁned as follows.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                • In free source form, it is any graphic character in the processor-dependent character set.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                • In ﬁxed source form, it is any character in the processor-dependent character set. A processor may restrict the occurrence of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       some or all of the control characters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          4 The delimiting apostrophes or quotation marks are not part of the value of the character literal constant.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          5 Anapostrophe character within a character constant delimited by apostrophes is represented by two consecutive
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     apostrophes (without intervening blanks); in this case, the two apostrophes are counted as one character. Sim-
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ilarly, a quotation mark character within a character constant delimited by quotation marks is represented by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     two consecutive quotation marks (without intervening blanks) and the two quotation marks are counted as one
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     character.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          6 Azero-lengthcharacterliteralconstantisrepresentedbytwoconsecutiveapostrophes(withoutinterveningblanks)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     or two consecutive quotation marks (without intervening blanks) outside of a character context.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     NOTE7.10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Examples of character literal constants are:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "DON’T"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ’DON’’T’
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 both of which have the value DON’T and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ’’
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 which has the zero-length character string as its value.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     NOTE7.11
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 An example of a nondefault character literal constant, where the processor supports the corresponding
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 character set, is:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 NIHONGO_’                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ✁                                                                                                                                                                                          ✂                                                                                                                                                                                                                                                           ✄                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ☎                                                                                                                                                                                        ✂                                                                                                                                                                                                                                                                 ✆                                                                                                                                                                                                                                                                                                                                                                                                                                                              ✝                                                                                                                                                                                                                  ✞                                                                               ’
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 where NIHONGO is a named constant whose value is the kind type parameter for Nihongo (Japanese)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 characters. This means “Without her, nothing is possible”.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     7.4.4.4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Collating sequence
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          1 The processor deﬁnes a collating sequence for the character set of each kind of character. The collating sequence
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     is an isomorphism between the character set and the set of integers {I : 0 ≤ I < N}, where N is the number of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     characters in the set. The intrinsic functions CHAR (16.9.44) and ICHAR (16.9.95) provide conversions between
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     the characters and the integers according to this mapping.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     NOTE7.12
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 For example:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ICHAR ( ’X’ )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 returns the integer value of the character ’X’ according to the collating sequence of the processor.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          2 The collating sequence of the default character kind shall satisfy the following constraints.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                • ICHAR (’A’) < ICHAR (’B’) < ... < ICHAR (’Z’) for the twenty-six upper-case letters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ISO/IEC 2017 – All rights reserved                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           67
               ISO/IEC DIS 1539-1:2017 (E)
                   • ICHAR (’0’) < ICHAR (’1’) < ... < ICHAR (’9’) for the ten digits.
                   • ICHAR (’ ’) < ICHAR (’0’) < ICHAR (’9’) < ICHAR (’A’) or
                     ICHAR (’ ’) < ICHAR (’A’) < ICHAR (’Z’) < ICHAR (’0’).
                   • ICHAR (’a’) < ICHAR (’b’) < ... < ICHAR (’z’) for the twenty-six lower-case letters.
                   • ICHAR (’ ’) < ICHAR (’0’) < ICHAR (’9’) < ICHAR (’a’) or
                     ICHAR (’ ’) < ICHAR (’a’) < ICHAR (’z’) < ICHAR (’0’).
            3 Therearenoconstraints on the location of any other character in the collating sequence, nor is there any speciﬁed
               collating sequence relationship between the upper-case and lower-case letters.
            4 Thecollating sequence for the ASCII character kind is as speciﬁed in ISO/IEC 646:1991 (International Reference
               Version); this collating sequence is called the ASCII collating sequence in this document. The collating sequence
               for the ISO 10646 character kind is as speciﬁed in ISO/IEC 10646.
                     NOTE7.13
                     The intrinsic functions ACHAR (16.9.3) and IACHAR (16.9.88) provide conversions between characters
                     and corresponding integer values according to the ASCII collating sequence.
            5 Theintrinsic functions LGT, LGE, LLE, and LLT (16.9.114-16.9.117) provide comparisons between strings based
               on the ASCII collating sequence. International portability is guaranteed if the set of characters used is limited
               to the Fortran character set (6.1).
               7.4.5     Logical type
            1 The logical type has two values, which represent true and false.
            2 The processor shall provide one or more representation methods for data of type logical. Each such method
               is characterized by a value for the (default integer) kind type parameter KIND. The kind type parameter of a
               representation method is returned by the intrinsic function KIND (16.9.108).
            3 The type speciﬁer for the logical type uses the keyword LOGICAL.
            4 The keyword LOGICAL with no kind-selector speciﬁes type logical with default kind; the kind type parameter
               value is equal to KIND (.FALSE.).
               R725     logical-literal-constant        is   .TRUE. [ _ kind-param ]
                                                        or .FALSE. [ _ kind-param ]
               C729     (R725) The value of kind-param shall specify a representation method that exists on the processor.
            5 The optional kind type parameter speciﬁes the kind type parameter of the logical constant; if it does not appear,
               the constant has the default logical kind.
               7.5      Derived types
               7.5.1     Derived type concepts
            1 Additional types can be derived from the intrinsic types and other derived types. A type deﬁnition deﬁnes the
               name of the type and the names and attributes of its components and type-bound procedures.
            2 A derived type can be parameterized by one or more type parameters, each of which is deﬁned to be either a
               kind or length type parameter and can have a default value.
            3 The ultimate components of a derived type are the components that are of intrinsic type or have the ALLOC-
               ATABLEorPOINTERattribute, plus the ultimate components of the components that are of derived type and
               have neither the ALLOCATABLE nor POINTER attribute.
                                                                                       c
               68                                                                     ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           4 The direct components of a derived type are the components of that type, plus the direct components of the
              components that are of derived type and have neither the ALLOCATABLE nor POINTER attribute.
           5 The potential subobject components of a derived type are the nonpointer components of that type together with
              the potential subobject components of the nonpointer components that are of derived type. This includes all the
              components that could be a subobject of an object of the type (9.4.2).
           6 The components, direct components, potential subobject components, and ultimate components of an object of
              derived type are the components, direct components, potential subobject components, and ultimate components
              of its type, respectively.
           7 Bydefault, no storage sequence is implied by the order of the component deﬁnitions. However, a storage sequence
              is implied for a sequence type (7.5.2.3). If the derived type has the BIND attribute, the storage sequence is that
              required by the companion processor (5.5.7, 18.3.4).
           8 Ascalar entity of derived type is a structure. If a derived type has the SEQUENCE attribute, a scalar entity of
              the type is a sequence structure.
                   NOTE7.14
                  The ultimate components of an object of the derived type kids deﬁned below are oldest_child%name,
                  oldest_child%age, and other_kids. The direct components of such an object are oldest_child%name,
                  oldest_child%age, other_kids, and oldest_child.
                  type :: person
                     character(len=20) :: name
                     integer :: age
                  end type person
                  type :: kids
                     type(person) :: oldest_child
                     type(person), allocatable, dimension(:) :: other_kids
                  end type kids
              7.5.2    Derived-type deﬁnition
              7.5.2.1  Syntax of a derived-type deﬁnition
              R726    derived-type-def            is  derived-type-stmt
                                                           [ type-param-def-stmt ] ...
                                                           [ private-or-sequence ] ...
                                                           [ component-part ]
                                                           [ type-bound-procedure-part ]
                                                           end-type-stmt
              R727    derived-type-stmt           is  TYPE[[, type-attr-spec-list ] :: ] type-name
                                                         [ ( type-param-name-list ) ]
              R728    type-attr-spec              is  ABSTRACT
                                                  or access-spec
                                                  or BIND (C)
                                                  or EXTENDS(parent-type-name )
              C730    (R727) A derived type type-name shall not be DOUBLEPRECISION or the same as the name of any
                      intrinsic type deﬁned in this document.
              C731    (R727) The same type-attr-spec shall not appear more than once in a given derived-type-stmt.
              C732    The same type-param-name shall not appear more than once in a given derived-type-stmt.
              c
              ISO/IEC 2017 – All rights reserved                                                                         69
              ISO/IEC DIS 1539-1:2017 (E)
              C733    (R728) A parent-type-name shall be the name of a previously deﬁned extensible type (7.5.7).
              C734    (R726) If the type deﬁnition contains or inherits (7.5.7.2) a deferred type-bound procedure (7.5.5), AB-
                      STRACTshall appear.
              C735    (R726) If ABSTRACT appears, the type shall be extensible.
              C736    (R726) If EXTENDS appears, SEQUENCE shall not appear.
              C737    (R726) If EXTENDS appears and the type being deﬁned has a coarray ultimate component, its parent
                      type shall have a coarray ultimate component.
              C738    (R726) If EXTENDS appears and the type being deﬁned has a potential subobject component of type
                      EVENT_TYPE or LOCK_TYPE from the intrinsic module ISO_FORTRAN_ENV, its parent type
                      shall be EVENT_TYPE or LOCK_TYPE or have a potential subobject component of type EVENT_-
                      TYPEorLOCK_TYPE.
              R729    private-or-sequence         is  private-components-stmt
                                                  or sequence-stmt
              C739    (R726) The same private-or-sequence shall not appear more than once in a given derived-type-def.
              R730    end-type-stmt               is  ENDTYPE[type-name ]
              C740    (R730) If END TYPE is followed by a type-name, the type-name shall be the same as that in the
                      corresponding derived-type-stmt.
           1 Derived types with the BIND attribute are subject to additional constraints as speciﬁed in 18.3.4.
                   NOTE7.15
                  An example of a derived-type deﬁnition is:
                  TYPE PERSON
                      INTEGER AGE
                      CHARACTER (LEN = 50) NAME
                  END TYPE PERSON
                  An example of declaring a variable CHAIRMAN of type PERSON is:
                  TYPE (PERSON) :: CHAIRMAN
              7.5.2.2  Accessibility
           1 The accessibility of a type name is determined as speciﬁed in 8.5.2. The accessibility of a type name does not
              aﬀect, and is not aﬀected by, the accessibility of its components and type-bound procedures.
           2 If a derived type is deﬁned in the scoping unit of a module, and its name is private in that module, then the type
              name, and thus the structure constructor (7.5.10) for the type, are accessible only within that module and its
              descendants.
                   NOTE7.16
                  An example of a type with a private name is:
                  TYPE, PRIVATE :: AUXILIARY
                      LOGICAL :: DIAGNOSTIC
                      CHARACTER (LEN = 20) :: MESSAGE
                  END TYPE AUXILIARY
                  Such a type would be accessible only within the module in which it is deﬁned, and within its descendants.
                                                                              c
              70                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              7.5.2.3  Sequence type
              R731    sequence-stmt               is  SEQUENCE
              C741    (R726) If SEQUENCE appears, the type shall have at least one component, each data component shall
                      be declared to be of an intrinsic type or of a sequence type, the derived type shall not have any type
                      parameter, and a type-bound-procedure-part shall not appear.
           1 If the SEQUENCE statement appears, the type has the SEQUENCE attribute and is a sequence type. The order
              of the component deﬁnitions in a sequence type speciﬁes a storage sequence for objects of that type. The type
              is a numeric sequence type if there are no pointer or allocatable components, and each component is default
              integer, default real, double precision real, default complex, default logical, or of numeric sequence type. The
              type is a character sequence type if there are no pointer or allocatable components, and each component is default
              character or of character sequence type.
                   NOTE7.17
                  An example of a numeric sequence type is:
                  TYPE NUMERIC_SEQ
                      SEQUENCE
                      INTEGER :: INT_VAL
                      REAL      :: REAL_VAL
                      LOGICAL :: LOG_VAL
                  END TYPE NUMERIC_SEQ
                   NOTE7.18
                  Astructure resolves into a sequence of components. Unless the structure includes a SEQUENCE statement,
                  the use of this terminology in no way implies that these components are stored in this, or any other, order.
                  Nor is there any requirement that contiguous storage be used. The sequence merely refers to the fact that
                  in writing the deﬁnitions there will necessarily be an order in which the components appear, and this will
                  deﬁne a sequence of components. This order is of limited signiﬁcance because a component of an object of
                  derived type will always be accessed by a component name except in the following contexts: the sequence of
                  expressions in a derived-type value constructor, intrinsic assignment, the data values in namelist input data,
                  and the inclusion of the structure in an input/output list of a formatted data transfer, where it is expanded
                  to this sequence of components. Provided the processor adheres to the deﬁned order in these cases, it is
                  otherwise free to organize the storage of the components for any nonsequence structure in memory as best
                  suited to the particular architecture.
              7.5.2.4  Determination of derived types
           1 Derived-type deﬁnitions with the same type name may appear in diﬀerent scoping units, in which case they might
              be independent and describe diﬀerent derived types or they might describe the same type.
           2 Twodataentities have the same type if they are declared with reference to the same derived-type deﬁnition. Data
              entities also have the same type if they are declared with reference to diﬀerent derived-type deﬁnitions that specify
              the same type name, all have the SEQUENCE attribute or all have the BIND attribute, have no components
              with PRIVATE accessibility, and have components that agree in order, name, and attributes. Otherwise, they
              are of diﬀerent derived types. A data entity declared using a type with the SEQUENCE attribute or with the
              BIND attribute is not of the same type as an entity of a type that has any components that are PRIVATE.
                   NOTE7.19
                  An example of declaring two entities with reference to the same derived-type deﬁnition is:
                  TYPE POINT
                      REAL   X,   Y
              c
              ISO/IEC 2017 – All rights reserved                                                                         71
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE7.19 (cont.)
                END TYPE POINT
                TYPE (POINT) :: X1
                CALL SUB (X1)
                   ...
                CONTAINS
                   SUBROUTINE SUB (A)
                      TYPE (POINT) :: A
                         ...
                   END SUBROUTINE SUB
                The deﬁnition of derived type POINT is known in subroutine SUB by host association. Because the
                declarations of X1 and A both reference the same derived-type deﬁnition, X1 and A have the same type.
                X1andAalsowouldhave the same type if the derived-type deﬁnition were in a module and both SUB and
                its containing program unit accessed that derived type from the module.
                NOTE7.20
                An example of data entities in diﬀerent scoping units having the same type is:
                PROGRAM PGM
                   TYPE EMPLOYEE
                      SEQUENCE
                      INTEGER        ID_NUMBER
                      CHARACTER (50) NAME
                   END TYPE EMPLOYEE
                   TYPE (EMPLOYEE) PROGRAMMER
                   CALL SUB (PROGRAMMER)
                      ...
                END PROGRAM PGM
                SUBROUTINE SUB (POSITION)
                   TYPE EMPLOYEE
                      SEQUENCE
                      INTEGER        ID_NUMBER
                      CHARACTER (50) NAME
                   END TYPE EMPLOYEE
                   TYPE (EMPLOYEE) POSITION
                   ...
                END SUBROUTINE SUB
                The actual argument PROGRAMMER and the dummy argument POSITION have the same type because
                they are declared with reference to a derived-type deﬁnition with the same name, the SEQUENCE attribute,
                and components that agree in order, name, and attributes.
                Suppose the component name ID_NUMBER was ID_NUM in the subroutine. Because all the component
                names are not identical to the component names in derived type EMPLOYEE in the main program, the
                actual argument PROGRAMMER would not be of the same type as the dummy argument POSITION.
                Thus, the program would not be standard-conforming.
                NOTE7.21
                Therequirement that the two types have the same name applies to the type-names in the respective derived
                type deﬁnitions, not to local names introduced via renaming in USE statements.
                                                                  c
            72                                                   ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              7.5.3    Derived-type parameters
              7.5.3.1  Type parameter deﬁnition statement
              R732    type-param-def-stmt         is  integer-type-spec, type-param-attr-spec ::
                                                         type-param-decl-list
              R733    type-param-decl             is  type-param-name [ = scalar-int-constant-expr ]
              C742    (R732) A type-param-name in a type-param-def-stmt in a derived-type-def shall be one of the type-param-
                      names in the derived-type-stmt of that derived-type-def.
              C743    (R732) Each type-param-name in the derived-type-stmt in a derived-type-def shall appear exactly once as
                      a type-param-name in a type-param-def-stmt in that derived-type-def.
              R734    type-param-attr-spec        is  KIND
                                                  or LEN
           1 The derived type is parameterized if the derived-type-stmt has any type-param-names.
           2 Each type parameter is itself of type integer. If its kind selector is omitted, the kind type parameter is default
              integer.
           3 Thetype-param-attr-spec explicitly speciﬁes whether a type parameter is a kind parameter or a length parameter.
           4 If a type-param-decl has a scalar-int-constant-expr, the type parameter has a default value which is speciﬁed by
              the expression. If necessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a
              value of the same kind as the type parameter.
           5 A type parameter may be used as a primary in a speciﬁcation expression (10.1.11) in the derived-type-def. A
              kind type parameter may also be used as a primary in a constant expression (10.1.12) in the derived-type-def.
                   NOTE7.22
                  The following example uses derived-type parameters.
                        TYPE humongous_matrix(k, d)
                           INTEGER, KIND :: k = KIND (0.0)
                           INTEGER (SELECTED_INT_KIND (12)), LEN :: d
                             !-- Specify a potentially nondefault kind for d.
                           REAL (k) :: element (d, d)
                        END TYPE
                  In the following example, dim is declared to be a kind parameter, allowing generic overloading of procedures
                  distinguished only by dim.
                        TYPE general_point(dim)
                           INTEGER, KIND :: dim
                           REAL :: coordinates(dim)
                        END TYPE
              7.5.3.2  Type parameter order
           1 Typeparameterorderisanorderingofthetypeparametersofaderivedtype; it is used for derived-type speciﬁers.
           2 The type parameter order of a nonextended type is the order of the type parameter list in the derived-type
              deﬁnition. The type parameter order of an extended type (7.5.7) consists of the type parameter order of its
              parent type followed by any additional type parameters in the order of the type parameter list in the derived-type
              deﬁnition.
              c
              ISO/IEC 2017 – All rights reserved                                                                         73
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE7.23
                  Given
                        TYPE :: t1 (k1, k2)
                           INTEGER, KIND :: k1, k2
                           REAL (k1) a (k2)
                        END TYPE
                        TYPE, EXTENDS(t1) :: t2 (k3)
                           INTEGER, KIND :: k3
                           LOGICAL (k3) flag
                        END TYPE
                  the type parameter order for type t1 is k1 then k2, and the type parameter order for type t2 is k1 then k2
                  then k3.
              7.5.4    Components
              7.5.4.1  Component deﬁnition statement
              R735    component-part              is  [ component-def-stmt ] ...
              R736    component-def-stmt          is  data-component-def-stmt
                                                  or proc-component-def-stmt
              R737    data-component-def-stmt     is  declaration-type-spec [ [ , component-attr-spec-list ] :: ]
                                                         component-decl-list
              R738    component-attr-spec         is  access-spec
                                                  or ALLOCATABLE
                                                  or CODIMENSION lbracket coarray-spec rbracket
                                                  or CONTIGUOUS
                                                  or DIMENSION ( component-array-spec )
                                                  or POINTER
              R739    component-decl              is  component-name [ ( component-array-spec ) ]
                                                         [ lbracket coarray-spec rbracket ]
                                                         [ * char-length ] [ component-initialization ]
              R740    component-array-spec        is  explicit-shape-spec-list
                                                  or deferred-shape-spec-list
              C744    (R737) No component-attr-spec shall appear more than once in a given component-def-stmt.
              C745    (R737) If neither the POINTER nor the ALLOCATABLE attribute is speciﬁed, the declaration-type-spec
                      in the component-def-stmt shall specify an intrinsic type or a previously deﬁned derived type.
              C746    (R737) If the POINTER or ALLOCATABLE attribute is speciﬁed, each component-array-spec shall be
                      a deferred-shape-spec-list.
              C747    (R737) If a coarray-spec appears, it shall be a deferred-coshape-spec-list and the component shall have
                      the ALLOCATABLE attribute.
              C748    (R737) If a coarray-spec appears, the component shall not be of type C_PTR or C_FUNPTR from
                      the intrinsic module ISO_C_BINDING (18.2), or of type TEAM_TYPE from the intrinsic module
                      ISO_FORTRAN_ENV(16.10.2).
                                                                              c
              74                                                             ISO/IEC 2017 – All rights reserved
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
             C749    A data component whose type has a coarray ultimate component shall be a nonpointer nonallocatable
                     scalar and shall not be a coarray.
             C750    (R737) If neither the POINTER nor the ALLOCATABLE attribute is speciﬁed, each component-array-
                     spec shall be an explicit-shape-spec-list.
             C751    (R740) Each bound in the explicit-shape-spec shall be a speciﬁcation expression in which there are no ref-
                     erences to speciﬁcation functions or the intrinsic functions ALLOCATED, ASSOCIATED, EXTENDS_-
                     TYPE_OF, PRESENT, or SAME_TYPE_AS, every speciﬁcation inquiry reference is a constant ex-
                     pression, and the value does not depend on the value of a variable.
             C752    (R737) A component shall not have both the ALLOCATABLE and POINTER attributes.
             C753    (R737) If the CONTIGUOUS attribute is speciﬁed, the component shall be an array with the POINTER
                     attribute.
             C754    (R739) The * char-length option is permitted only if the component is of type character.
             C755    (R736) Each type-param-value within a component-def-stmt shall be a colon or a speciﬁcation expres-
                     sion in which there are no references to speciﬁcation functions or the intrinsic functions ALLOCATED,
                     ASSOCIATED,EXTENDS_TYPE_OF,PRESENT,orSAME_TYPE_AS,everyspeciﬁcationinquiry
                     reference is a constant expression, and the value does not depend on the value of a variable.
                  NOTE7.24
                  Because a type parameter is not an object, a type-param-value or a bound in an explicit-shape-spec can
                  contain a type-param-name.
             R741    proc-component-def-stmt    is  PROCEDURE([proc-interface ] ) ,
                                                      proc-component-attr-spec-list :: proc-decl-list
                  NOTE7.25
                  See 15.4.3.6 for deﬁnitions of proc-interface and proc-decl.
             R742    proc-component-attr-spec   is  access-spec
                                                or NOPASS
                                                or PASS [ (arg-name) ]
                                                or POINTER
             C756    (R741) The same proc-component-attr-spec shall not appear more than once in a given proc-component-
                     def-stmt.
             C757    (R741) POINTER shall appear in each proc-component-attr-spec-list.
             C758    (R741) If the procedure pointer component has an implicit interface or has no arguments, NOPASS shall
                     be speciﬁed.
             C759    (R741)IfPASS(arg-name)appears,theinterfaceoftheprocedurepointercomponentshallhaveadummy
                     argument named arg-name.
             C760    (R741) PASS and NOPASS shall not both appear in the same proc-component-attr-spec-list.
          1 The declaration-type-spec in the data-component-def-stmt speciﬁes the type and type parameters of the com-
             ponents in the component-decl-list, except that the character length parameter may be speciﬁed or overridden
             for a component by the appearance of * char-length in its entity-decl. The component-attr-spec-list in the data-
             component-def-stmt speciﬁes the attributes whose keywords appear for the components in the component-decl-list,
             except that the DIMENSION attribute may be speciﬁed or overridden for a component by the appearance of a
             component-array-spec in its component-decl, and the CODIMENSION attribute may be speciﬁed or overridden
             for a component by the appearance of a coarray-spec in its component-decl.
              c
             ISO/IEC 2017 – All rights reserved                                                                    75
              ISO/IEC DIS 1539-1:2017 (E)
              7.5.4.2  Array components
           1 A data component is an array if its component-decl contains a component-array-spec or its data-component-def-
              stmt contains a DIMENSION clause. If the component-decl contains a component-array-spec, it speciﬁes the
              array rank, and if the array is explicit shape (8.5.8.2), the array bounds; otherwise, the component-array-spec in
              the DIMENSION clause speciﬁes the array rank, and if the array is explicit shape, the array bounds.
                   NOTE7.26
                  An example of a derived type deﬁnition with an array component is:
                  TYPE LINE
                      REAL, DIMENSION (2, 2) :: COORD           !
                                                                ! COORD(:,1) has the value of [X1, Y1]
                                                                ! COORD(:,2) has the value of [X2, Y2]
                      REAL                       :: WIDTH       ! Line width in centimeters
                      INTEGER                    :: PATTERN     ! 1 for solid, 2 for dash, 3 for dot
                  END TYPE LINE
                  An example of declaring a variable LINE_SEGMENT to be of the type LINE is:
                  TYPE (LINE)             :: LINE_SEGMENT
                  The scalar variable LINE_SEGMENT has a component that is an array. In this case, the array is a
                  subobject of a scalar. The double colon in the deﬁnition for COORD is required; the double colon in the
                  deﬁnition for WIDTH and PATTERN is optional.
                   NOTE7.27
                  An example of a derived type deﬁnition with an allocatable component is:
                  TYPE STACK
                      INTEGER                  :: INDEX
                      INTEGER, ALLOCATABLE :: CONTENTS (:)
                  END TYPE STACK
                  For each scalar variable of type STACK, the shape of the component CONTENTS is determined by execu-
                  tion of an ALLOCATE statement or assignment statement, or by argument association.
                   NOTE7.28
                  Default initialization of an explicit-shape array component can be speciﬁed by a constant expression con-
                  sisting of an array constructor (7.8), or of a single scalar that becomes the value of each array element.
              7.5.4.3  Coarray components
           1 A data component is a coarray if its component-decl contains a coarray-spec or its data-component-def-stmt
              containsaCODIMENSIONclause. Ifthecomponent-decl containsacoarray-spec itspeciﬁesthecorank; otherwise,
              the coarray-spec in the CODIMENSION clause speciﬁes the corank.
                   NOTE7.29
                  An example of a derived type deﬁnition with a coarray component is:
                      TYPE GRID_TYPE
                          REAL, ALLOCATABLE, CODIMENSION [:, :, :] :: GRID (:, :, :)
                      END TYPE GRID_TYPE
                  An object of type grid_type cannot be an array, an allocatable object, a coarray, or a pointer.
                                                                              c
              76                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              7.5.4.4  Pointer components
           1 Adatacomponentisapointer(5.4.9)ifitscomponent-attr-spec-list contains the POINTERkeyword. Aprocedure
              pointer component has the POINTER keyword in its proc-component-attr-spec-list.
                   NOTE7.30
                  An example of a derived type deﬁnition with a pointer component is:
                  TYPE REFERENCE
                      INTEGER                                       :: VOLUME, YEAR, PAGE
                      CHARACTER (LEN = 50)                          :: TITLE
                      PROCEDURE (printer_interface), POINTER :: PRINT => NULL()
                      CHARACTER, DIMENSION (:), POINTER             :: SYNOPSIS
                  END TYPE REFERENCE
                  Anyobject of type REFERENCE will have the four nonpointer components VOLUME, YEAR, PAGE, and
                  TITLE, the procedure pointer PRINT, which has an explicit interface the same as printer_interface, plus
                  a pointer to an array of characters holding SYNOPSIS. The size of this target array will be determined by
                  the length of the synopsis. The space for the target could be allocated (9.7.1) or the pointer component
                  could be associated with a target by a pointer assignment statement (10.2.2).
              7.5.4.5  The passed-object dummy argument
           1 A passed-object dummy argument is a distinguished dummy argument of a procedure pointer component or
              type-bound procedure (7.5.5). It aﬀects procedure overriding (7.5.7.3) and argument association (15.5.2.2).
           2 If NOPASS is speciﬁed, the procedure pointer component or type-bound procedure has no passed-object dummy
              argument.
           3 If neither PASS nor NOPASS is speciﬁed or PASS is speciﬁed without arg-name, the ﬁrst dummy argument of a
              procedure pointer component or type-bound procedure is its passed-object dummy argument.
           4 If PASS (arg-name) is speciﬁed, the dummy argument named arg-name is the passed-object dummy argument of
              the procedure pointer component or named type-bound procedure.
              C761    The passed-object dummy argument shall be a scalar, nonpointer, nonallocatable dummy data object
                      with the same declared type as the type being deﬁned; all of its length type parameters shall be assumed;
                      it shall be polymorphic (7.3.2.3) if and only if the type being deﬁned is extensible (7.5.7). It shall not
                      have the VALUE attribute.
                   NOTE7.31
                  If a procedure is bound to several types as a type-bound procedure, diﬀerent dummy arguments might be
                  the passed-object dummy argument in diﬀerent contexts.
              7.5.4.6  Default initialization for components
           1 Default initialization provides a means of automatically initializing pointer components to be disassociated or
              associated with speciﬁc targets, and nonpointer nonallocatable components to have a particular value. Allocatable
              components are always initialized to unallocated.
           2 A pointer variable or component is data-pointer-initialization compatible with a target if the pointer is type
              compatible with the target, they have the same rank, all nondeferred type parameters of the pointer have the
              same values as the corresponding type parameters of the target, and the target is contiguous if the pointer has
              the CONTIGUOUS attribute.
              R743    component-initialization    is  =constant-expr
                                                  or =>null-init
                                                  or =>initial-data-target
              c
              ISO/IEC 2017 – All rights reserved                                                                         77
           ISO/IEC DIS 1539-1:2017 (E)
           R744  initial-data-target    is designator
           C762  (R737) If component-initialization appears, a double-colon separator shall appear before the component-
                 decl-list.
           C763  (R737) If component-initialization appears, every type parameter and array bound of the component
                 shall be a colon or constant expression.
           C764  (R737) If => appears in component-initialization, POINTER shall appear in the component-attr-spec-
                 list. If = appears in component-initialization, neither POINTER nor ALLOCATABLE shall appear in
                 the component-attr-spec-list.
           C765  If initial-data-target appears in a component-initialization in a component-decl, component-name shall be
                 data-pointer-initialization compatible with it.
           C766  A designator that is an initial-data-target shall designate a nonallocatable, noncoindexed variable that
                 has the TARGET and SAVE attributes and does not have a vector subscript. Every subscript, sec-
                 tion subscript, substring starting point, and substring ending point in designator shall be a constant
                 expression.
         3 If null-init appears for a pointer component, that component in any object of the type has an initial association
           status of disassociated (3.61) or becomes disassociated as speciﬁed in 19.5.2.4.
         4 If initial-data-target appears for a data pointer component, that component in any object of the type is initially
           associated with the target or becomes associated with the target as speciﬁed in 19.5.2.3.
         5 If initial-proc-target (15.4.3.6) appears in proc-decl for a procedure pointer component, that component in any
           object of the type is initially associated with the target or becomes associated with the target as speciﬁed in
           19.5.2.3.
         6 If constant-expr appears for a nonpointer component, that component in any object of the type is initially deﬁned
           (19.6.3) or becomes deﬁned as speciﬁed in 19.6.5 with the value determined from constant-expr. If necessary,
           the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type,
           type parameters, and shape with the component. If the component is of a type for which default initialization is
           speciﬁed for a component, the default initialization speciﬁed by constant-expr overrides the default initialization
           speciﬁed for that component. When one initialization overrides another it is as if only the overriding initialization
           were speciﬁed (see NOTE 7.33). Explicit initialization in a type declaration statement (8.2) overrides default
           initialization (see NOTE 7.32). Unlike explicit initialization, default initialization does not imply that the object
           has the SAVE attribute.
         7 Asubcomponent (9.4.2) is default-initialized if the type of the object of which it is a component speciﬁes default
           initialization for that component, and the subcomponent is not a subobject of an object that is default-initialized
           or explicitly initialized.
         8 Atype has default initialization if component-initialization is speciﬁed for any direct component of the type. An
           object has default initialization if it is of a type that has default initialization.
               NOTE7.32
               It is not required that initialization be speciﬁed for each component of a derived type. For example:
                     TYPE DATE
                         INTEGER DAY
                         CHARACTER (LEN = 5) MONTH
                         INTEGER :: YEAR = 2008     ! Partial default initialization
                     END TYPE DATE
               In the following example, the default initial value for the YEAR component of TODAY is overridden by
               explicit initialization in the type declaration statement:
                     TYPE (DATE), PARAMETER :: TODAY = DATE (21, "Feb.", 2009)
                                                              c
           78                                                ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE7.33
                The default initial value of a component of derived type can be overridden by default initialization speciﬁed
                in the deﬁnition of the type. Continuing the example of NOTE 7.32:
                       TYPE SINGLE_SCORE
                           TYPE(DATE) :: PLAY_DAY = TODAY
                           INTEGER SCORE
                           TYPE(SINGLE_SCORE), POINTER :: NEXT => NULL ( )
                       END TYPE SINGLE_SCORE
                       TYPE(SINGLE_SCORE) SETUP
                The PLAY_DAYcomponentofSETUPreceivesits initial value from TODAY, overriding the initialization
                for the YEAR component.
                NOTE7.34
                Arrays of structures can be declared with elements that are partially or totally initialized by default.
                Continuing the example of NOTE 7.33 :
                       TYPE MEMBER (NAME_LEN)
                           INTEGER, LEN :: NAME_LEN
                           CHARACTER (LEN = NAME_LEN) :: NAME = ’’
                           INTEGER :: TEAM_NO, HANDICAP = 0
                           TYPE (SINGLE_SCORE), POINTER :: HISTORY => NULL ( )
                       END TYPE MEMBER
                       TYPE (MEMBER(9)) LEAGUE (36)        ! Array of partially initialized elements
                       TYPE (MEMBER(9)) :: ORGANIZER = MEMBER (9) ("I. Manage",1,5,NULL ( ))
                ORGANIZERis explicitly initialized, overriding the default initialization for an object of type MEMBER.
                Allocated objects can also be initialized partially or totally. For example:
                       ALLOCATE (ORGANIZER % HISTORY)   ! A partially initialized object of type
                                                        ! SINGLE_SCORE is created.
                NOTE7.35
                A pointer component of a derived type can have as its target an object of that derived type. The type
                deﬁnition can specify that in objects declared to be of this type, such a pointer is default initialized to
                disassociated. For example:
                       TYPE NODE
                          INTEGER              :: VALUE = 0
                          TYPE (NODE), POINTER :: NEXT_NODE => NULL ( )
                       END TYPE
                Atype such as this can be used to construct linked lists of objects of type NODE. Linked lists can also be
                constructed using allocatable components.
                NOTE7.36
                Apointer component of a derived type can be default initialized to have an initial target.
                      TYPE NODE
                         INTEGER               :: VALUE = 0
                         TYPE (NODE), POINTER  :: NEXT_NODE => SENTINEL
                      END TYPE
                      TYPE(NODE), SAVE, TARGET :: SENTINEL
            c
            ISO/IEC 2017 – All rights reserved                                                        79
              ISO/IEC DIS 1539-1:2017 (E)
              7.5.4.7  Component order
           1 Component order is an ordering of the nonparent components of a derived type; it is used for intrinsic format-
              ted input/output and structure constructors where component keywords are not used. Parent components are
              excluded from the component order of an extended type (7.5.7).
           2 Thecomponentorderofanonextendedtypeistheorderofthedeclarations of the components in the derived-type
              deﬁnition. The component order of an extended type consists of the component order of its parent type followed
              by any additional components in the order of their declarations in the extended derived-type deﬁnition.
                   NOTE7.37
                  Given the same type deﬁnitions as in NOTE 7.23, the component order of type T1 is just A (there is only
                  one component), and the component order of type T2 is A then FLAG. The parent component (T1) does
                  not participate in the component order.
              7.5.4.8  Component accessibility
              R745    private-components-stmt     is  PRIVATE
              C767    (R745) A private-components-stmt is permitted only if the type deﬁnition is within the speciﬁcation part
                      of a module.
           1 The default accessibility for the components that are declared in a type’s component-part is private if the type
              deﬁnition contains a private-components-stmt, and public otherwise. The accessibility of a component may be
              explicitly declared by an access-spec; otherwise its accessibility is the default for the type deﬁnition in which it is
              declared.
           2 If a component is private, that component name is accessible only within the module containing the deﬁnition,
              and within its descendants.
                   NOTE7.38
                  Type parameters are not components. They are eﬀectively always public.
                   NOTE7.39
                  The accessibility of the components of a type is independent of the accessibility of the type name. It is
                  possible to have all four combinations: a public type name with a public component, a private type name
                  with a private component, a public type name with a private component, and a private type name with a
                  public component.
                   NOTE7.40
                  An example of a public type with private components is:
                      TYPE, PUBLIC :: POINT
                          PRIVATE
                          REAL :: X, Y
                      END TYPE POINT
                  Such a type deﬁnition can be accessed by use association; however, the components X and Y are accessible
                  only within the module and its descendants.
                                                                              c
              80                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
                   NOTE7.41
                  The following example illustrates the use of an individual component access-spec to override the default
                  accessibility:
                        TYPE MIXED
                           PRIVATE
                           INTEGER :: I
                           INTEGER, PUBLIC :: J
                        END TYPE MIXED
                        TYPE (MIXED) :: M
                  The component M%J is accessible in any scoping unit where M is accessible; M%I is accessible only within
                  the module containing the TYPE MIXED deﬁnition, and within its descendants.
              7.5.5    Type-bound procedures
              R746    type-bound-procedure-part   is  contains-stmt
                                                           [ binding-private-stmt ]
                                                           [ type-bound-proc-binding ] ...
              R747    binding-private-stmt        is  PRIVATE
              C768    (R746) A binding-private-stmt is permitted only if the type deﬁnition is within the speciﬁcation part of
                      a module.
              R748    type-bound-proc-binding     is  type-bound-procedure-stmt
                                                  or type-bound-generic-stmt
                                                  or ﬁnal-procedure-stmt
              R749    type-bound-procedure-stmt   is  PROCEDURE[[,binding-attr-list ] :: ] type-bound-proc-decl-list
                                                  or PROCEDURE(interface-name), binding-attr-list :: binding-name-list
              R750    type-bound-proc-decl        is  binding-name [ => procedure-name ]
              C769    (R749) If => procedure-name appears in a type-bound-proc-decl, the double-colon separator shall appear.
              C770    (R750) The procedure-name shall be the name of an accessible module procedure or an external procedure
                      that has an explicit interface.
              C771    Abinding-name in a type-bound-proc-decl in a derived type deﬁnition shall not be the same as any other
                      binding-name within that derived type deﬁnition.
           1 If =>procedure-name does not appear in a type-bound-proc-decl, it is as though => procedure-name had appeared
              with a procedure name the same as the binding name.
              R751    type-bound-generic-stmt     is  GENERIC[ , access-spec ] :: generic-spec => binding-name-list
              C772    (R751) Within the speciﬁcation-part of a module, each type-bound-generic-stmt shall specify, either im-
                      plicitly or explicitly, the same accessibility as every other type-bound-generic-stmt with that generic-spec
                      in the same derived type.
              C773    (R751) Each binding-name in binding-name-list shall be the name of a speciﬁc binding of the type.
              C774    A binding-name in a type-bound GENERIC statement shall not specify a speciﬁc binding that was
                      inherited or speciﬁed previously for the same generic identiﬁer in that derived type deﬁnition.
              C775    (R751) If generic-spec is not generic-name, each of its speciﬁc bindings shall have a passed-object dummy
                      argument (7.5.4.5).
              c
              ISO/IEC 2017 – All rights reserved                                                                         81
           ISO/IEC DIS 1539-1:2017 (E)
           C776   (R751) If generic-spec is OPERATOR ( deﬁned-operator ), the interface of each binding shall be as
                  speciﬁed in 15.4.3.4.2.
           C777   (R751) If generic-spec is ASSIGNMENT ( = ), the interface of each binding shall be as speciﬁed in
                  15.4.3.4.3.
           C778   (R751) If generic-spec is deﬁned-io-generic-spec, the interface of each binding shall be as speciﬁed in
                  12.6.4.8. The type of the dtv argument shall be type-name.
           R752   binding-attr          is  access-spec
                                        or DEFERRED
                                        or NON_OVERRIDABLE
                                        or NOPASS
                                        or PASS [ (arg-name) ]
           C779   (R752) The same binding-attr shall not appear more than once in a given binding-attr-list.
           C780   (R749) If the interface of the binding has no dummy argument of the type being deﬁned, NOPASS shall
                  appear.
           C781   (R749) If PASS (arg-name) appears, the interface of the binding shall have a dummy argument named
                  arg-name.
           C782   (R752) PASS and NOPASS shall not both appear in the same binding-attr-list.
           C783   (R752) NON_OVERRIDABLE and DEFERRED shall not both appear in the same binding-attr-list.
           C784   (R752) DEFERRED shall appear if and only if interface-name appears.
           C785   (R749) An overriding binding (7.5.7.3) shall have the DEFERRED attribute only if the binding it over-
                  rides is deferred.
           C786   (R749) A binding shall not override an inherited binding (7.5.7.2) that has the NON_OVERRIDABLE
                  attribute.
         2 A type-bound procedure statement declares one or more speciﬁc type-bound procedures. A speciﬁc type-bound
           procedure can have a passed-object dummy argument (7.5.4.5). A type-bound procedure with the DEFERRED
           attribute is a deferred type-bound procedure. The DEFERRED keyword shall appear only in the deﬁnition of
           an abstract type.
         3 AGENERICstatement declares a generic type-bound procedure, which is a type-bound generic interface for its
           speciﬁc type-bound procedures.
         4 A binding of a type is a type-bound procedure (speciﬁc or generic), a generic type-bound interface, or a ﬁnal
           subroutine. These are referred to as speciﬁc bindings, generic bindings, and ﬁnal bindings respectively.
         5 Atype-boundproceduremaybeidentiﬁedbyabindingnameinthescopeofthetypedeﬁnition. This name is the
           binding-name for a speciﬁc type-bound procedure, and the generic-name for a generic binding whose generic-spec
           is generic-name. A ﬁnal binding, or a generic binding whose generic-spec is not generic-name, has no binding
           name.
         6 The interface of a speciﬁc type-bound procedure is that of the procedure speciﬁed by procedure-name or the
           interface speciﬁed by interface-name.
         7 Thesamegeneric-spec may be used in several GENERIC statements within a single derived-type deﬁnition. Each
           additional GENERIC statement with the same generic-spec extends the generic interface.
               NOTE7.42
               Unlike the situation with generic procedure names, a generic type-bound procedure name is not permitted
               to be the same as a speciﬁc type-bound procedure name in the same type (19.3).
                                                              c
           82                                                 ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           8 Thedefaultaccessibility for the type-bound procedures of a type is private if the type deﬁnition contains a binding-
              private-stmt, and public otherwise. The accessibility of a type-bound procedure may be explicitly declared by an
              access-spec; otherwise its accessibility is the default for the type deﬁnition in which it is declared.
           9 Apublictype-boundprocedureisaccessible via any accessible object of the type. A private type-bound procedure
              is accessible only within the module containing the type deﬁnition, and within its descendants.
                   NOTE7.43
                  Theaccessibility of a type-bound procedure is not aﬀected by a PRIVATE statement in the component-part;
                  the accessibility of a data component is not aﬀected by a PRIVATE statement in the type-bound-procedure-
                  part.
                   NOTE7.44
                  An example of a type and a type-bound procedure is:
                           TYPE POINT
                             REAL :: X, Y
                           CONTAINS
                             PROCEDURE, PASS :: LENGTH => POINT_LENGTH
                           END TYPE POINT
                           ...
                  and in the module-subprogram-part of the same module:
                           REAL FUNCTION POINT_LENGTH (A, B)
                             CLASS (POINT), INTENT (IN) :: A, B
                             POINT_LENGTH = SQRT ( (A%X - B%X)**2 + (A%Y - B%Y)**2 )
                           END FUNCTION POINT_LENGTH
              7.5.6    Final subroutines
              7.5.6.1  FINAL statement
              R753    ﬁnal-procedure-stmt         is  FINAL [ :: ] ﬁnal-subroutine-name-list
              C787    (R753) A ﬁnal-subroutine-name shall be the name of a module procedure with exactly one dummy
                      argument. That argument shall be nonoptional and shall be a noncoarray, nonpointer, nonallocatable,
                      nonpolymorphic variable of the derived type being deﬁned. All length type parameters of the dummy
                      argument shall be assumed. The dummy argument shall not have the INTENT (OUT) or VALUE
                      attribute.
              C788    (R753) A ﬁnal-subroutine-name shall not be one previously speciﬁed as a ﬁnal subroutine for that type.
              C789    (R753) A ﬁnal subroutine shall not have a dummy argument with the same kind type parameters and
                      rank as the dummy argument of another ﬁnal subroutine of that type.
              C790    (R753) If a ﬁnal subroutine has an assumed-rank dummy argument, no other ﬁnal subroutine of that
                      type shall have a dummy argument with the same kind type parameters.
           1 The FINAL statement speciﬁes that each procedure it names is a ﬁnal subroutine. A ﬁnal subroutine might be
              executed when a data entity of that type is ﬁnalized (7.5.6.2).
           2 Aderived type is ﬁnalizable if and only if it has a ﬁnal subroutine or a nonpointer, nonallocatable component of
              ﬁnalizable type. A nonpointer data entity is ﬁnalizable if and only if it is of ﬁnalizable type. No other entity is
              ﬁnalizable.
              c
              ISO/IEC 2017 – All rights reserved                                                                         83
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE7.45
                  Final subroutines are eﬀectively always “accessible”. They are called for entity ﬁnalization regardless of the
                  accessibility of the type, its other type-bound procedures, or the subroutine name itself.
                   NOTE7.46
                  Final subroutines are not inherited through type extension and cannot be overridden. The ﬁnal subroutines
                  of the parent type are called after any additional ﬁnal subroutines of an extended type are called.
              7.5.6.2  The ﬁnalization process
           1 Only ﬁnalizable entities are ﬁnalized. When an entity is ﬁnalized, the following steps are carried out in sequence.
                    (1)   If the dynamic type of the entity has a ﬁnal subroutine whose dummy argument has the same kind
                          type parameters and rank as the entity being ﬁnalized, it is called with the entity as an actual
                          argument. Otherwise, if there is an elemental ﬁnal subroutine whose dummy argument has the same
                          kind type parameters as the entity being ﬁnalized, or a ﬁnal subroutine whose dummy argument is
                          assumed-rank with the same kind type parameters as the entity being ﬁnalized, it is called with the
                          entity as an actual argument. Otherwise, no subroutine is called at this point.
                    (2)   All ﬁnalizable components that appear in the type deﬁnition are ﬁnalized in a processor-dependent
                          order. If the entity being ﬁnalized is an array, each ﬁnalizable component of each element of that
                          entity is ﬁnalized separately.
                    (3)   If the entity is of extended type and the parent type is ﬁnalizable, the parent component is ﬁnalized.
           2 If several entities are to be ﬁnalized as a consequence of an event speciﬁed in 7.5.6.3, the order in which they
              are ﬁnalized is processor dependent. During this process, execution of a ﬁnal subroutine for one of these entities
              shall not reference or deﬁne any of the other entities that have already been ﬁnalized.
                   NOTE7.47
                  Animplementationmightneedtoensurethatwhenaneventcausesmorethanonecoarraytobedeallocated,
                  they are deallocated in the same order on all images in the current team.
              7.5.6.3  When ﬁnalization occurs
           1 When an intrinsic assignment statement is executed (10.2.1.3), if the variable is not an unallocated allocatable
              variable, it is ﬁnalized after evaluation of expr and before the deﬁnition of the variable. If the variable is an
              allocated allocatable variable, or has an allocated allocatable subobject, that would be deallocated by intrinsic
              assignment, the ﬁnalization occurs before the deallocation.
           2 When a pointer is deallocated its target is ﬁnalized. When an allocatable entity is deallocated, it is ﬁnalized
              unless it is the variable in an intrinsic assignment statement or a subobject thereof. If an error condition occurs
              during deallocation, it is processor dependent whether ﬁnalization occurs.
           3 A nonpointer, nonallocatable object that is not a dummy argument or function result is ﬁnalized immediately
              before it would become undeﬁned due to execution of a RETURN or END statement (19.6.6, item (3)).
           4 Anonpointer nonallocatable local variable of a BLOCK construct is ﬁnalized immediately before it would become
              undeﬁned due to termination of the BLOCK construct (19.6.6, item (23)).
           5 If an executable construct references a nonpointer function, the result is ﬁnalized after execution of the innermost
              executable construct containing the reference.
           6 If a speciﬁcation expression in a scoping unit references a function, the result is ﬁnalized before execution of the
              executable constructs in the scoping unit.
           7 Whenaprocedureisinvoked, a nonpointer, nonallocatable, INTENT (OUT) dummy argument of that procedure
              is ﬁnalized before it becomes undeﬁned. The ﬁnalization caused by INTENT (OUT) is considered to occur within
                                                                              c
              84                                                             ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              the invoked procedure; so for elemental procedures, an INTENT (OUT) argument will be ﬁnalized only if a scalar
              or elemental ﬁnal subroutine is available, regardless of the rank of the actual argument.
           8 If an object is allocated via pointer allocation and later becomes unreachable due to all pointers associated with
              that object having their pointer association status changed, it is processor dependent whether it is ﬁnalized. If it
              is ﬁnalized, it is processor dependent as to when the ﬁnal subroutines are called.
                   NOTE7.48
                  If ﬁnalization is used for storage management, it often needs to be combined with deﬁned assignment.
              7.5.6.4  Entities that are not ﬁnalized
           1 If image execution is terminated, either by an error (e.g. an allocation failure) or by execution of a stop-stmt,
              error-stop-stmt, or end-program-stmt, entities existing immediately prior to termination are not ﬁnalized.
                   NOTE7.49
                  Anonpointer, nonallocatable object that has the SAVE attribute is never ﬁnalized as a direct consequence
                  of the execution of a RETURN or END statement.
              7.5.7    Type extension
              7.5.7.1  Extensible, extended, and abstract types
           1 Aderived type, other than the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, that
              does not have the BIND attribute or the SEQUENCE attribute is an extensible type.
           2 A type with the EXTENDS attribute is an extended type; its parent type is the type named in the EXTENDS
              type-attr-spec.
                   NOTE7.50
                  The name of the parent type might be a local name introduced via renaming in a USE statement.
           3 An extensible type that does not have the EXTENDS attribute is an extension type of itself only. An extended
              type is an extension of itself and of all types for which its parent type is an extension.
           4 An abstract type is a type that has the ABSTRACT attribute.
                   NOTE7.51
                  The DEFERRED attribute (7.5.5) defers the implementation of a type-bound procedure to extensions of
                  the type; it can appear only in an abstract type. The dynamic type of an object cannot be abstract;
                  therefore, a deferred type-bound procedure cannot be invoked. An extension of an abstract type need not
                  be abstract if it has no deferred type-bound procedures. A short example of an abstract type is:
                     TYPE, ABSTRACT :: FILE_HANDLE
                     CONTAINS
                        PROCEDURE(OPEN_FILE), DEFERRED, PASS(HANDLE) :: OPEN
                        ...
                     END TYPE
                  For a more elaborate example see C.2.4.
              7.5.7.2  Inheritance
           1 An extended type includes all of the type parameters, all of the components, and the nonoverridden (7.5.7.3)
              type-bound procedures of its parent type. These are inherited by the extended type from the parent type. They
              c
              ISO/IEC 2017 – All rights reserved                                                                         85
            ISO/IEC DIS 1539-1:2017 (E)
            retain all of the attributes that they had in the parent type. Additional type parameters, components, and
            procedure bindings may be declared in the derived-type deﬁnition of the extended type.
                NOTE7.52
                Inaccessible components and bindings of the parent type are also inherited, but they remain inaccessible in
                the extended type. Inaccessible entities occur if the type being extended is accessed via use association and
                has a private entity.
                NOTE7.53
                An extensible derived type is not required to have any components, bindings, or parameters; an extended
                type is not required to have more components, bindings, or parameters than its parent type.
         2 Anextended type has a scalar, nonpointer, nonallocatable, parent component with the type and type parameters
            of the parent type. The name of this component is the parent type name. If the extended type is deﬁned in a
            module, the parent component has the accessibility of the parent type in the module in which the parent type
            was deﬁned. Components of the parent component are inheritance associated (19.5.4) with the corresponding
            components inherited from the parent type. An ancestor component of a type is the parent component of the
            type or an ancestor component of the parent component.
         3 If a generic binding speciﬁed in a type deﬁnition has the same generic-spec as an inherited binding, it extends
            the generic interface and shall satisfy the requirements speciﬁed in 15.4.3.4.5.
                NOTE7.54
                Acomponent or type parameter declared in an extended type cannot have the same name as any accessible
                component or type parameter of its parent type.
                NOTE7.55
                Examples:
                TYPE POINT                            ! A base type
                  REAL :: X, Y
                END TYPE POINT
                TYPE, EXTENDS(POINT) :: COLOR_POINT   ! An extension of TYPE(POINT)
                  ! Components X and Y, and component name POINT, inherited from parent
                  INTEGER :: COLOR
                END TYPE COLOR_POINT
            7.5.7.3 Type-bound procedure overriding
         1 If a speciﬁc type-bound procedure speciﬁed in a type deﬁnition has the same binding name as an accessible
            type-bound procedure from the parent type then the binding speciﬁed in the type deﬁnition overrides the one
            from the parent type.
         2 The overriding and overridden type-bound procedures shall satisfy the following conditions.
              • Either both shall have a passed-object dummy argument or neither shall.
              • If the overridden type-bound procedure is pure then the overriding one shall also be pure.
              • Either both shall be elemental or neither shall.
              • They shall have the same number of dummy arguments.
              • Passed-object dummy arguments, if any, shall correspond by name and position.
              • Dummy arguments that correspond by position shall have the same names and characteristics, except for
                the type of the passed-object dummy arguments.
              • Either both shall be subroutines or both shall be functions having the same result characteristics (15.3.3).
              • If the overridden type-bound procedure is PUBLIC then the overriding one shall not be PRIVATE.
                                                                  c
            86                                                   ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
         3 Abindingofatypeandabindingofanextensionofthattypecorrespond if the latter binding is the same binding
           as the former, overrides a corresponding binding, or is an inherited corresponding binding.
               NOTE7.56
               The following is an example of procedure overriding, expanding on the example in NOTE 7.44.
               TYPE, EXTENDS (POINT) :: POINT_3D
                 REAL :: Z
               CONTAINS
                 PROCEDURE, PASS :: LENGTH => POINT_3D_LENGTH
               END TYPE POINT_3D
               ...
               and in the module-subprogram-part of the same module:
               REAL FUNCTION POINT_3D_LENGTH ( A, B )
                 CLASS (POINT_3D), INTENT (IN) :: A
                 CLASS (POINT), INTENT (IN) :: B
                 SELECT TYPE(B)
                   CLASS IS(POINT_3D)
                     POINT_3D_LENGTH = SQRT( (A%X-B%X)**2 + (A%Y-B%Y)**2 + (A%Z-B%Z)**2 )
                     RETURN
                 END SELECT
                 PRINT *, ’In POINT_3D_LENGTH, dynamic type of argument is incorrect.’
                 STOP
               END FUNCTION POINT_3D_LENGTH
           7.5.8   Derived-type values
         1 The component value of
              • a pointer component is its pointer association,
              • anallocatable componentis its allocation status and, if it is allocated, its dynamic type and type parameters,
                bounds and value, and
              • a nonpointer nonallocatable component is its value.
         2 The set of values of a particular derived type consists of all possible sequences of the component values of its
           components.
           7.5.9   Derived-type speciﬁer
         1 Aderived-type speciﬁer is used in several contexts to specify a particular derived type and type parameters.
           R754   derived-type-spec       is type-name [ ( type-param-spec-list ) ]
           R755   type-param-spec         is [ keyword = ] type-param-value
           C791   (R754) type-name shall be the name of an accessible derived type.
           C792   (R754) type-param-spec-list shall appear only if the type is parameterized.
           C793   (R754) There shall be at most one type-param-spec corresponding to each parameter of the type. If a
                  type parameter does not have a default value, there shall be a type-param-spec corresponding to that
                  type parameter.
           C794   (R755) The keyword= may be omitted from a type-param-spec only if the keyword= has been omitted
                  from each preceding type-param-spec in the type-param-spec-list.
            c
           ISO/IEC 2017 – All rights reserved                                                      87
           ISO/IEC DIS 1539-1:2017 (E)
           C795   (R755) Each keyword shall be the name of a parameter of the type.
           C796   (R755) An asterisk may be used as a type-param-value in a type-param-spec only in the declaration of a
                  dummy argument or associate name or in the allocation of a dummy argument.
         2 Typeparametervaluesthatdonothavetypeparameterkeywordsspeciﬁedcorrespondtotypeparametersintype
           parameter order (7.5.3.2). If a type parameter keyword appears, the value corresponds to the type parameter
           namedbythekeyword. Ifnecessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3)
           to a value of the same kind as the type parameter.
         3 The value of a type parameter for which no type-param-value has been speciﬁed is its default value.
           7.5.10  Construction of derived-type values
         1 A derived-type deﬁnition implicitly deﬁnes a corresponding structure constructor that allows construction of
           scalar values of that derived type. The type and type parameters of a constructed value are speciﬁed by a derived
           type speciﬁer.
           R756   structure-constructor is  derived-type-spec ( [ component-spec-list ] )
           R757   component-spec        is  [ keyword = ] component-data-source
           R758   component-data-source is  expr
                                        or data-target
                                        or proc-target
           C797   (R756) The derived-type-spec shall not specify an abstract type (7.5.7).
           C798   (R756) At most one component-spec shall be provided for a component.
           C799   (R756)Ifacomponent-spec isprovidedforanancestorcomponent, acomponent-spec shallnotbeprovided
                  for any component that is inheritance associated with a subcomponent of that ancestor component.
           C7100 (R756) A component-spec shall be provided for a nonallocatable component unless it has default initializ-
                  ation or is inheritance associated with a subcomponent of another component for which a component-spec
                  is provided.
           C7101 (R757) The keyword= may be omitted from a component-spec only if the keyword= has been omitted
                  from each preceding component-spec in the constructor.
           C7102 (R757) Each keyword shall be the name of a component of the type.
           C7103 (R756) The type name and all components of the type for which a component-spec appears shall be
                  accessible in the scoping unit containing the structure constructor.
           C7104 (R756) If derived-type-spec is a type name that is the same as a generic name, the component-spec-list
                  shall not be a valid actual-arg-spec-list for a function reference that is resolvable as a generic reference to
                  that name (15.5.5.2).
           C7105 (R758) A data-target shall correspond to a data pointer component; a proc-target shall correspond to a
                  procedure pointer component.
           C7106 (R758) A data-target shall have the same rank as its corresponding component.
               NOTE7.57
               Theform’name(...)’ is interpreted as a generic function-reference if possible; it is interpreted as a structure-
               constructor only if it cannot be interpreted as a generic function-reference.
                                                              c
           88                                                 ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         2 In the absence of a component keyword, each component-data-source is assigned to the corresponding component
            in component order (7.5.4.7). If a component keyword appears, the expr is assigned to the component named
            by the keyword. For a nonpointer component, the declared type and type parameters of the component and
            expr shall conform in the same way as for a variable and expr in an intrinsic assignment statement (10.2.1.2).
            If necessary, each value of intrinsic type is converted according to the rules of intrinsic assignment (10.2.1.3) to
            a value that agrees in type and type parameters with the corresponding component of the derived type. For a
            nonpointer nonallocatable component, the shape of the expression shall conform with the shape of the component.
         3 If a component with default initialization has no corresponding component-data-source, then the default initial-
            ization is applied to that component. If an allocatable component has no corresponding component-data-source,
            then that component has an allocation status of unallocated.
                NOTE7.58
                Because no parent components appear in the deﬁned component ordering, a value for a parent component
                can be speciﬁed only with a component keyword. Examples of equivalent values using types deﬁned in
                NOTE7.55:
                ! Create values with components x = 1.0, y = 2.0, color = 3.
                TYPE(POINT) :: PV = POINT(1.0, 2.0)        ! Assume components of TYPE(POINT)
                                                           ! are accessible here.
                ...
                COLOR_POINT( point=point(1,2), color=3)    ! Value for parent component
                COLOR_POINT( point=PV, color=3)            ! Available even if TYPE(point)
                                                           ! has private components
                COLOR_POINT( 1, 2, 3)                      ! All components of TYPE(point)
                                                           ! need to be accessible.
         4 Astructure constructor shall not appear before the referenced type is deﬁned.
         5 For a pointer component, the corresponding component-data-source shall be an allowable data-target or proc-
            target for such a pointer in a pointer assignment statement (10.2.2). If the component data source is a pointer,
            the association of the component is that of the pointer; otherwise, the component is pointer associated with the
            component data source.
                NOTE7.59
                For example, if the variable TEXT were declared (8.2) to be
                       CHARACTER, DIMENSION (1:400), TARGET :: TEXT
                and BIBLIO were declared using the derived-type deﬁnition REFERENCE in NOTE 7.30
                       TYPE (REFERENCE) :: BIBLIO
                the statement
                       BIBLIO = REFERENCE (1, 1987, 1, "This is the title of the referenced &
                                                       &paper", SYNOPSIS=TEXT)
                is valid and associates the pointer component SYNOPSIS of the object BIBLIO with the target object
                TEXT. The keyword SYNOPSIS is required because the ﬁfth component of the type REFERENCE is a
                procedure pointer component, not a data pointer component of type character. It is not necessary to specify
                a proc-target for the procedure pointer component because it has default initialization.
         6 If a component of a derived type is allocatable, the corresponding constructor expression shall be a reference
            to the intrinsic function NULL with no arguments, an allocatable entity of the same rank, or shall evaluate to
            an entity of the same rank. If the expression is a reference to the intrinsic function NULL, the corresponding
            component of the constructor has a status of unallocated.
            c
            ISO/IEC 2017 – All rights reserved                                                        89
           ISO/IEC DIS 1539-1:2017 (E)
         7 If the component is allocatable and the expression is an allocatable entity, the corresponding component of the
           constructor has the same allocation status as that allocatable entity. If it is allocated, it has the same bounds;
           if a length parameter of the component is deferred, its value is the same as the corresponding parameter of the
           expression. If the component is polymorphic, it has the same dynamic type and value; otherwise, it has the value
           converted, if necessary, to the declared type of the component.
         8 If the component is allocatable and the expression is not an allocatable entity, the component has an allocation
           status of allocated and the same bounds as the expression; if a length parameter of the component is deferred,
           its value is the same as the corresponding parameter of the expression. If the component is polymorphic, it has
           the same dynamic type and value; otherwise, it has the value converted, if necessary, to the declared type of the
           component.
               NOTE7.60
               This example illustrates a derived-type constant expression using a derived type deﬁned in NOTE 7.15:
                     PERSON (21, ’JOHN SMITH’)
               This could also be written as
                     PERSON (NAME = ’JOHN SMITH’, AGE = 21)
               NOTE7.61
               An example constructor using the derived type GENERAL_POINT deﬁned in NOTE 7.22 is
                     general_point(dim=3) ( [ 1., 2., 3. ] )
           7.5.11  Derived-type operations and assignment
         1 Intrinsic assignment of derived-type entities is described in 10.2.1. This document does not specify any intrinsic
           operations on derived-type entities. Any operation on derived-type entities or deﬁned assignment (10.2.1.4) for
           derived-type entities shall be deﬁned explicitly by a function or a subroutine, and a generic interface (7.5.5,
           15.4.3.2).
           7.6   Enumerations and enumerators
         1 Anenumeration is a set of enumerators. An enumerator is a named integer constant. An enumeration deﬁnition
           speciﬁes the enumeration and its set of enumerators of the corresponding integer kind.
           R759  enum-def               is enum-def-stmt
                                               enumerator-def-stmt
                                               [ enumerator-def-stmt ] ...
                                               end-enum-stmt
           R760  enum-def-stmt          is ENUM,BIND(C)
           R761  enumerator-def-stmt    is ENUMERATOR[:: ] enumerator-list
           R762  enumerator             is named-constant [ = scalar-int-constant-expr ]
           R763  end-enum-stmt          is ENDENUM
           C7107 (R761) If = appears in an enumerator, a double-colon separator shall appear before the enumerator-list.
         2 Foranenumeration, the kind is selected such that an integer type with that kind is interoperable (18.3.2) with the
           corresponding C enumeration type. The corresponding C enumeration type is the type that would be declared
           by a C enumeration speciﬁer (6.7.2.2 of ISO/IEC 9899:2011) that speciﬁed C enumeration constants with the
           same values as those speciﬁed by the enum-def, in the same order as speciﬁed by the enum-def.
                                                              c
           90                                                ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
           3 The companion processor (5.5.7) shall be one that uses the same representation for the types declared by all C
              enumeration speciﬁers that specify the same values in the same order.
                   NOTE7.62
                   If a companion processor uses an unsigned type to represent a given enumeration type, the Fortran processor
                   will use the signed integer type of the same width for the enumeration, even though some of the values of the
                   Cenumerators might not be representable in this signed integer type. The types of any such enumerators
                   will be interoperable with the type declared in the C enumeration.
                   NOTE7.63
                   ISO/IEC 9899:2011 guarantees the enumeration constants ﬁt in a C int (6.7.2.2 of ISO/IEC 9899:2011).
                   Therefore, the Fortran processor can evaluate all enumerator values using the integer type with kind para-
                   meter C_INT, and then determine the kind parameter of the integer type that is interoperable with the
                   corresponding C enumerated type.
                   NOTE7.64
                   ISO/IEC 9899:2011 speciﬁes that two enumeration types are compatible only if they specify enumeration
                   constants with the same names and same values in the same order. This document further requires that
                   a C processor that is to be a companion processor of a Fortran processor use the same representation for
                   two enumeration types if they both specify enumeration constants with the same values in the same order,
                   even if the names are diﬀerent.
           4 An enumerator is treated as if it were explicitly declared with the PARAMETER attribute. The enumerator is
              deﬁned in accordance with the rules of intrinsic assignment (10.2) with the value determined as follows.
                     (1)   If scalar-int-constant-expr is speciﬁed, the value of the enumerator is the result of scalar-int-constant-
                           expr.
                     (2)   If scalar-int-constant-expr is not speciﬁed and the enumerator is the ﬁrst enumerator in enum-def,
                           the enumerator has the value 0.
                     (3)   If scalar-int-constant-expr is not speciﬁed and the enumerator is not the ﬁrst enumerator in enum-
                           def, its value is the result of adding 1 to the value of the enumerator that immediately precedes it
                           in the enum-def.
                   NOTE7.65
                   Example of an enumeration deﬁnition:
                   ENUM, BIND(C)
                      ENUMERATOR :: RED = 4, BLUE = 9
                      ENUMERATOR YELLOW
                   END ENUM
                   Thekindtypeparameterfor this enumeration is processor dependent, but the processor is required to select
                   a kind suﬃcient to represent the values 4, 9, and 10, which are the values of its enumerators. The following
                   declaration might be equivalent to the above enumeration deﬁnition.
                   INTEGER (SELECTED_INT_KIND (2)), PARAMETER :: RED = 4, BLUE = 9, YELLOW = 10
                   An entity of the same kind type parameter value can be declared using the intrinsic function KIND with
                   one of the enumerators as its argument, for example
                   INTEGER (KIND (RED)) :: X
               c
              ISO/IEC 2017 – All rights reserved                                                                              91
               ISO/IEC DIS 1539-1:2017 (E)
                    NOTE7.66
                    There is no diﬀerence in the eﬀect of declaring the enumerators in multiple ENUMERATOR statements or
                    in a single ENUMERATOR statement. The order in which the enumerators in an enumeration deﬁnition
                    are declared is signiﬁcant, but the number of ENUMERATOR statements is not.
               7.7      Binary, octal, and hexadecimal literal constants
            1 A binary, octal, or hexadecimal constant (boz-literal-constant) is a sequence of digits that represents an ordered
               sequence of bits. Such a constant has no type.
               R764     boz-literal-constant           is  binary-constant
                                                       or octal-constant
                                                       or hex-constant
               R765     binary-constant                is  B’digit [ digit ] ... ’
                                                       or B " digit [ digit ] ... "
               C7108 (R765) digit shall have one of the values 0 or 1.
               R766     octal-constant                 is  O’digit [ digit ] ... ’
                                                       or O " digit [ digit ] ... "
               C7109 (R766) digit shall have one of the values 0 through 7.
               R767     hex-constant                   is  Z ’ hex-digit [ hex-digit ] ... ’
                                                       or Z " hex-digit [ hex-digit ] ... "
               R768     hex-digit                      is  digit
                                                       or A
                                                       or B
                                                       or C
                                                       or D
                                                       or E
                                                       or F
            2 The hex-digits A through F represent the numbers ten through ﬁfteen, respectively; they may be represented
               by their lower-case equivalents. Each digit of a boz-literal-constant represents a sequence of bits, according to
               its numerical interpretation, using the model of 16.3, with z equal to one for binary constants, three for octal
               constants or four for hexadecimal constants. A boz-literal-constant represents a sequence of bits that consists of
               the concatenation of the sequences of bits represented by its digits, in the order the digits are speciﬁed. The
               positions of bits in the sequence are numbered from right to left, with the position of the rightmost bit being zero.
               The length of a sequence of bits is the number of bits in the sequence. The processor shall allow the position
               of the leftmost nonzero bit to be at least z − 1, where z is the maximum value that could result from invoking
               the intrinsic function STORAGE_SIZE (16.9.184) with an argument that is a real or integer scalar of any kind
               supported by the processor.
               C7110 (R764) A boz-literal-constant shall appear only as a data-stmt-constant in a DATA statement, or where
                        explicitly allowed in subclause 16.9 as an actual argument of an intrinsic procedure.
               7.8      Construction of array values
            1 Anarrayconstructor constructs a rank-one array value from a sequence of scalar values, array values, and implied
               DOloops.
               R769     array-constructor              is  (/ ac-spec /)
                                                       or lbracket ac-spec rbracket
                                                                                     c
               92                                                                   ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           R770  ac-spec                is type-spec ::
                                        or [type-spec ::] ac-value-list
           R771  lbracket               is [
           R772  rbracket               is ]
           R773  ac-value               is expr
                                        or ac-implied-do
           R774  ac-implied-do          is ( ac-value-list , ac-implied-do-control )
           R775  ac-implied-do-control  is [ integer-type-spec :: ] ac-do-variable = scalar-int-expr ,
                                              scalar-int-expr [ , scalar-int-expr ]
           R776  ac-do-variable         is do-variable
           C7111 (R770) If type-spec is omitted, each ac-value expression in the array-constructor shall have the same
                 declared type and kind type parameters.
           C7112 (R770) If type-spec speciﬁes an intrinsic type, each ac-value expression in the array-constructor shall be
                 of an intrinsic type that is in type conformance with a variable of type type-spec as speciﬁed in Table
                 10.8.
           C7113 (R770) If type-spec speciﬁes a derived type, the declared type of each ac-value expression in the array-
                 constructor shall be that derived type and shall have the same kind type parameter values as speciﬁed
                 by type-spec.
           C7114 (R773) An ac-value shall not be unlimited polymorphic.
           C7115 (R773) The declared type of an ac-value shall not be abstract.
           C7116 (R774) The ac-do-variable of an ac-implied-do that is in another ac-implied-do shall not appear as the
                 ac-do-variable of the containing ac-implied-do.
         2 If type-spec is omitted, corresponding length type parameters of the declared type of each ac-value expression
           shall have the same value; in this case, the declared type and type parameters of the array constructor are those
           of the ac-value expressions.
         3 If type-spec appears, it speciﬁes the declared type and type parameters of the array constructor. Each ac-value
           expression in the array-constructor shall be compatible with intrinsic assignment to a variable of this type and
           type parameters. Each value is converted to the type and type parameters of the array-constructor in accordance
           with the rules of intrinsic assignment (10.2.1.3).
         4 The dynamic type of an array constructor is the same as its declared type.
         5 The character length of an ac-value in an ac-implied-do whose iteration count is zero shall not depend on the
           value of the ac-do-variable and shall not depend on the value of an expression that is not a constant expression.
         6 If an ac-value is a scalar expression, its value speciﬁes an element of the array constructor. If an ac-value is
           an array expression, the values of the elements of the expression, in array element order (9.5.3.2), specify the
           corresponding sequence of elements of the array constructor. If an ac-value is an ac-implied-do, it is expanded to
           form a sequence of elements under the control of the ac-do-variable, as in the DO construct (11.1.7.4).
         7 For an ac-implied-do, the loop initialization and execution is the same as for a DO construct.
         8 An empty sequence forms a zero-sized array.
           c
           ISO/IEC 2017 – All rights reserved                                                  93
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE7.67
                Aone-dimensional array can be reshaped into any allowable array shape using the intrinsic function RE-
                SHAPE(16.9.163). An example is:
                X = (/ 3.2, 4.01, 6.5 /)
                Y = RESHAPE (SOURCE = [ 2.0, [ 4.5, 4.5 ], X ], SHAPE = [ 3, 2 ])
                This results in Y having the 3 × 2 array of values:
                2.0   3.2
                4.5   4.01
                4.5   6.5
                NOTE7.68
                Examples of array constructors containing an implied DO are:
                (/ (I, I = 1, 1075) /)
                and
                [ 3.6, (3.6 / I, I = 1, N) ]
                NOTE7.69
                Using the type deﬁnition for PERSON in NOTE 7.15, an example of the construction of a derived-type
                array value is:
                [ PERSON (40, ’SMITH’), PERSON (20, ’JONES’) ]
                NOTE7.70
                Using the type deﬁnition for LINE in NOTE 7.26, an example of the construction of a derived-type scalar
                value with a rank-2 array component is:
                LINE (RESHAPE ( [ 0.0, 0.0, 1.0, 2.0 ], [ 2, 2 ] ), 0.1, 1)
                The intrinsic function RESHAPE is used to construct a value that represents a solid line from (0, 0) to (1,
                2) of width 0.1 centimeters.
                NOTE7.71
                Examples of zero-size array constructors are:
                   [ INTEGER :: ]
                   [ ( I, I = 1, 0) ]
                NOTE7.72
                An example of an array constructor that speciﬁes a length type parameter:
                   [ CHARACTER(LEN=7) :: ’Takata’, ’Tanaka’, ’Hayashi’ ]
                Inthisconstructor, withoutthetypespeciﬁcation, itwouldhavebeennecessarytospecifyalloftheconstants
                with the same character length.
                                                                  c
            94                                                   ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              8 Attribute declarations and speciﬁcations
              8.1     Attributes of procedures and data objects
           1 Every data object has a type and rank and may have type parameters and other properties that determine the
              uses of the object. Collectively, these properties are the attributes of the object. The declared type of a named
              data object is either speciﬁed explicitly in a type declaration statement or determined implicitly by the ﬁrst letter
              of its name (8.7). All of its attributes may be speciﬁed in a type declaration statement or individually in separate
              speciﬁcation statements.
           2 A function has a type and rank and may have type parameters and other attributes that determine the uses of
              the function. The type, rank, and type parameters are the same as those of the function result.
           3 A subroutine does not have a type, rank, or type parameters, but may have other attributes that determine the
              uses of the subroutine.
              8.2     Type declaration statement
              R801    type-declaration-stmt         is  declaration-type-spec [ [ , attr-spec ] ... :: ] entity-decl-list
           1 The type declaration statement speciﬁes the declared type of the entities in the entity declaration list. The type
              and type parameters are those speciﬁed by declaration-type-spec, except that the character length type parameter
              may be overridden for an entity by the appearance of * char-length in its entity-decl.
              R802    attr-spec                     is  access-spec
                                                    or ALLOCATABLE
                                                    or ASYNCHRONOUS
                                                    or CODIMENSION lbracket coarray-spec rbracket
                                                    or CONTIGUOUS
                                                    or DIMENSION ( array-spec )
                                                    or EXTERNAL
                                                    or INTENT ( intent-spec )
                                                    or INTRINSIC
                                                    or language-binding-spec
                                                    or OPTIONAL
                                                    or PARAMETER
                                                    or POINTER
                                                    or PROTECTED
                                                    or SAVE
                                                    or TARGET
                                                    or VALUE
                                                    or VOLATILE
              C801    (R801) The same attr-spec shall not appear more than once in a given type-declaration-stmt.
              C802    (R801) If a language-binding-spec with a NAME= speciﬁer appears, the entity-decl-list shall consist of a
                      single entity-decl.
              C803    (R801) If a language-binding-spec is speciﬁed, the entity-decl-list shall not contain any procedure names.
               c
              ISO/IEC 2017 – All rights reserved                                                                            95
                ISO/IEC DIS 1539-1:2017 (E)
            2 The type declaration statement also speciﬁes the attributes whose keywords appear in the attr-spec, except that
                the DIMENSION attribute may be speciﬁed or overridden for an entity by the appearance of array-spec in its
                entity-decl, and the CODIMENSION attribute may be speciﬁed or overridden for an entity by the appearance of
                coarray-spec in its entity-decl.
                R803     entity-decl                      is  object-name [ ( array-spec ) ]
                                                                  [ lbracket coarray-spec rbracket ]
                                                                  [ * char-length ] [ initialization ]
                                                          or function-name [ * char-length ]
                C804     (R803) If the entity is not of type character, * char-length shall not appear.
                C805     (R801) If initialization appears, a double-colon separator shall appear before the entity-decl-list.
                C806     (R801) If the PARAMETER keyword appears, initialization shall appear in each entity-decl.
                C807     (R803) An initialization shall not appear if object-name is a dummy argument, a function result, an object
                         in a named common block unless the type declaration is in a block data program unit, an object in blank common, an
                         allocatable variable, or an automatic data object.
                C808     (R803) The function-name shall be the name of an external function, an intrinsic function, a dummy
                         function, a procedure pointer, or a statement function.
                R804     object-name                      is  name
                C809     (R804) The object-name shall be the name of a data object.
                R805     initialization                   is  =constant-expr
                                                          or =>null-init
                                                          or =>initial-data-target
                R806     null-init                        is  function-reference
                C810     (R803) If => appears in initialization, the entity shall have the POINTER attribute. If = appears in
                         initialization, the entity shall not have the POINTER attribute.
                C811     (R803) If initial-data-target appears, object-name shall be data-pointer-initialization compatible with it
                         (7.5.4.6).
                C812     (R806) The function-reference shall be a reference to the intrinsic function NULL with no arguments.
            3 A name that identiﬁes a speciﬁc intrinsic function has a type as speciﬁed in 16.8. An explicit type declaration statement is not
                required; however, it is permitted. Specifying a type for a generic intrinsic function name in a type declaration
                statement has no eﬀect.
            4 If initialization appears for a nonpointer entity,
                   • its type and type parameters shall conform as speciﬁed for intrinsic assignment (10.2.1.2);
                   • if the entity has implied shape, the rank of initialization shall be the same as the rank of the entity;
                   • if the entity does not have implied shape, initialization shall either be scalar or have the same shape as the
                      entity.
                     NOTE8.1
                     Examples of type declaration statements:
                               REAL A (10)
                               LOGICAL, DIMENSION (5, 5) :: MASK1, MASK2
                               COMPLEX :: CUBE_ROOT = (-0.5, 0.866)
                               INTEGER, PARAMETER :: SHORT = SELECTED_INT_KIND (4)
                                                                                         c
                96                                                                       ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE8.1 (cont.)
                       INTEGER (SHORT) K     !  Range at least -9999 to 9999.
                       REAL (KIND (0.0D0)) B1
                       REAL (KIND = 2) B2
                       COMPLEX (KIND = KIND (0.0D0)) :: C
                       CHARACTER (LEN = 10, KIND = 2)  TEXT2
                       CHARACTER CHAR, STRING *20
                       TYPE (PERSON) :: CHAIRMAN
                       TYPE(NODE), POINTER :: HEAD => NULL ( )
                       TYPE (humongous_matrix (k=8, d=1000)) :: MAT
                (The last line above uses a type deﬁnition from NOTE 7.22.)
            8.3   Automatic data objects
         1 An automatic data object is a nondummy data object with a type parameter or array bound that depends on
            the value of a speciﬁcation-expr that is not a constant expression.
            C813  An automatic data object shall not have the SAVE attribute.
         2 If a type parameter in a declaration-type-spec or in a char-length in an entity-decl for a local variable of a
            subprogramorBLOCKconstructisdeﬁnedbyanexpressionthatisnotaconstantexpression, thetypeparameter
            value is established on entry to a procedure deﬁned by the subprogram, or on execution of the BLOCK statement,
            and is not aﬀected by any redeﬁnition or undeﬁnition of the variables in the expression during execution of the
            procedure or BLOCK construct.
            8.4   Initialization
         1 Theappearance of initialization in an entity-decl for an entity without the PARAMETER attribute speciﬁes that
            the entity is a variable with explicit initialization. Explicit initialization alternatively may be speciﬁed in a DATA
            statement unless the variable is of a derived type for which default initialization is speciﬁed. If initialization is
            =constant-expr, the variable is initially deﬁned with the value speciﬁed by the constant-expr; if necessary, the
            value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
            parameters, and shape with the variable. A variable, or part of a variable, shall not be explicitly initialized more
            than once in a program. If the variable is an array, it shall have its shape speciﬁed in either the type declaration
            statement or a previous attribute speciﬁcation statement in the same scoping unit.
         2 If null-init appears, the initial association status of the object is disassociated. If initial-data-target appears, the
            object is initially associated with the target.
         3 Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be conﬁrmed
            by explicit speciﬁcation.
            8.5   Attributes
            8.5.1  Attribute speciﬁcation
         1 An attribute may be explicitly speciﬁed by an attr-spec in a type declaration statement or by an attribute
            speciﬁcation statement (8.6). The following constraints apply to attributes.
            C814  An entity shall not be explicitly given any attribute more than once in a scoping unit.
            C815  An array-spec for a nonallocatable nonpointer function result shall be an explicit-shape-spec-list.
            c
            ISO/IEC 2017 – All rights reserved                                                        97
           ISO/IEC DIS 1539-1:2017 (E)
           8.5.2   Accessibility attribute
         1 The accessibility attribute speciﬁes the accessibility of an entity via a particular identiﬁer.
           R807   access-spec             is PUBLIC
                                          or PRIVATE
           C816   An access-spec shall appear only in the speciﬁcation-part of a module.
         2 An access-spec in a type declaration statement speciﬁes the accessibility of the names of all the entities declared
           by that statement. An access-spec in a derived-type-stmt speciﬁes the accessibility of the derived type name.
           Accessibility can also be speciﬁed by an access-stmt.
         3 An identiﬁer that is speciﬁed in a module or is accessible in a module by use association has either the PUB-
           LIC attribute or PRIVATE attribute. An identiﬁer whose accessibility is not explicitly speciﬁed has default
           accessibility (8.6.1).
         4 Thedefault accessibility attribute for a module is PUBLIC unless it has been changed by a PRIVATE statement.
           Only an identiﬁer that has the PUBLIC attribute in that module is available to be accessed from that module
           by use association.
               NOTE8.2
               An identiﬁer can only be accessed by use association if it has the PUBLIC attribute in the module from
               which it is accessed. It can nonetheless have the PRIVATE attribute in a module in which it is accessed by
               use association, and therefore not be available by use association from that module.
               NOTE8.3
               An example of an accessibility speciﬁcation is:
               REAL, PRIVATE :: X, Y, Z
           8.5.3   ALLOCATABLE attribute
         1 Avariable with the ALLOCATABLE attribute is a variable for which space is allocated during execution.
               NOTE8.4
               Only variables and components can have the ALLOCATABLE attribute. The result of referencing a func-
               tion whose result variable has the ALLOCATABLE attribute is a value that does not itself have the
               ALLOCATABLEattribute.
           8.5.4   ASYNCHRONOUSattribute
         1 Anentity with the ASYNCHRONOUS attribute is a variable that may be subject to asynchronous input/output
           or asynchronous communication.
         2 The base object of a variable shall have the ASYNCHRONOUS attribute in a scoping unit if
              • the variable is a dummy argument or appears in an executable statement or speciﬁcation expression in that
                scoping unit, and
              • any statement of the scoping unit is executed while the variable is a pending input/output storage sequence
                aﬀector (12.6.2.5) or a pending communication aﬀector (18.10.4).
         3 Use of a variable in an asynchronous data transfer statement can imply the ASYNCHRONOUS attribute; see
           subclause 12.6.2.5.
         4 An object with the ASYNCHRONOUS attribute may be associated with an object that does not have the
           ASYNCHRONOUSattribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
                                                                c
           98                                                   ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
              local variable of a BLOCK construct is speciﬁed to have the ASYNCHRONOUS attribute in the speciﬁcation-
              part of the construct, the object has the attribute within the construct even if it does not have the attribute
              outside the construct. If an object has the ASYNCHRONOUS attribute, then all of its subobjects also have the
              ASYNCHRONOUSattribute.
                  NOTE8.5
                  The ASYNCHRONOUS attribute speciﬁes the variables that might be associated with a pending in-
                  put/output storage sequence (the actual memory locations on which asynchronous input/output is being
                  performed) while the scoping unit is in execution. This information could be used by the compiler to disable
                  certain code motion optimizations.
              8.5.5    BIND attribute for data entities
           1 The BIND attribute for a variable or common block speciﬁes that it is capable of interoperating with a C variable
              whose name has external linkage (18.9).
              R808    language-binding-spec       is  BIND (C [ , NAME = scalar-default-char-constant-expr ])
              C817    An entity with the BIND attribute shall be a common block, variable, type, or procedure.
              C818    Avariable with the BIND attribute shall be declared in the speciﬁcation part of a module.
              C819    Avariable with the BIND attribute shall be interoperable (18.3).
              C820    Each variable of a common block with the BIND attribute shall be interoperable.
           2 If the value of the scalar-default-char-constant-expr after discarding leading and trailing blanks has nonzero
              length, it shall be valid as an identiﬁer on the companion processor.
                  NOTE8.6
                  ISO/IEC 9899:2011 provides a facility for creating C identiﬁers whose characters are not restricted to the
                  C basic character set. Such a C identiﬁer is referred to as a universal character name (6.4.3 of ISO/IEC
                  9899:2011). The name of such a C identiﬁer might include characters that are not part of the representation
                  method used by the processor for default character. If so, the C entity cannot be referenced from Fortran.
           3 The BIND attribute for a common block implies the SAVE attribute, which may be conﬁrmed by explicit speciﬁcation.
              8.5.6    CODIMENSION attribute
              8.5.6.1  General
           1 The CODIMENSION attribute speciﬁes that an entity is a coarray. The coarray-spec speciﬁes its corank or
              corank and cobounds.
              R809    coarray-spec                is  deferred-coshape-spec-list
                                                  or explicit-coshape-spec
              C821    The sum of the rank and corank of an entity shall not exceed ﬁfteen.
              C822    Acoarray shall be a component or a variable that is not a function result.
              C823    A coarray shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING
                      (18.3.3), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2.32).
              C824    Anentity whose type has a coarray ultimate component shall be a nonpointer nonallocatable scalar, shall
                      not be a coarray, and shall not be a function result.
              C825    Acoarrayoranobjectwithacoarrayultimatecomponentshallbeanassociatename,adummyargument,
                      or have the ALLOCATABLE or SAVE attribute.
              c
              ISO/IEC 2017 – All rights reserved                                                                        99
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE8.7
                Acoarray is permitted to be of a derived type with pointer or allocatable components. The target of such
                a pointer component is always on the same image as the pointer.
                NOTE8.8
                This requirement for the SAVE attribute has the eﬀect that automatic coarrays are not permitted; for
                example, the coarray WORK in the following code fragment is not valid.
                SUBROUTINE SOLVE3(N,A,B)
                INTEGER :: N
                REAL    :: A(N)[*], B(N)
                REAL    :: WORK(N)[*]    ! Not permitted
                If this were permitted, it would require an implicit synchronization on entry to the procedure.
                Explicit-shape coarrays that are declared in a subprogram and are not dummy arguments are required to
                have the SAVE attribute because otherwise they might be implemented as if they were automatic coarrays.
                NOTE8.9
                Examples of CODIMENSION attribute speciﬁcations are:
                   REAL  W(100,100)[0:2,*]                    ! Explicit-shape coarray
                   REAL, CODIMENSION[*] :: X                  ! Scalar coarray
                   REAL, CODIMENSION[3,*] :: Y(:)             ! Assumed-shape coarray
                   REAL, CODIMENSION[:],ALLOCATABLE :: Z(:,:) ! Allocatable coarray
            8.5.6.2 Allocatable coarray
         1 A coarray with the ALLOCATABLE attribute has a speciﬁed corank, but its cobounds are determined by
            allocation or argument association.
            R810  deferred-coshape-spec    is :
            C826  Acoarray with the ALLOCATABLE attribute shall have a coarray-spec that is a deferred-coshape-spec-
                  list.
         2 The corank of an allocatable coarray is equal to the number of colons in its deferred-coshape-spec-list.
         3 The cobounds of an unallocated allocatable coarray are undeﬁned. No part of such a coarray shall be referenced
            or deﬁned; however, the coarray may appear as an argument to an intrinsic inquiry function as speciﬁed in 16.1.
         4 The cobounds of an allocated allocatable coarray are those speciﬁed when the coarray is allocated.
         5 The cobounds of an allocatable coarray are unaﬀected by any subsequent redeﬁnition or undeﬁnition of the
            variables on which the cobounds’ expressions depend.
            8.5.6.3 Explicit-coshape coarray
         1 Anexplicit-coshape coarray is a named coarray that has its corank and cobounds declared by an explicit-coshape-
            spec.
            R811  explicit-coshape-spec    is [ [ lower-cobound : ] upper-cobound, ]...
                                                [ lower-cobound : ] *
            C827  Anonallocatable coarray shall have a coarray-spec that is an explicit-coshape-spec.
         2 The corank is equal to one plus the number of upper-cobounds.
                                                                  c
            100                                                  ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           R812  lower-cobound          is speciﬁcation-expr
           R813  upper-cobound          is speciﬁcation-expr
           C828  (R811) A lower-cobound or upper-cobound that is not a constant expression shall appear only in a sub-
                 program, BLOCK construct, or interface body.
         3 If an explicit-coshape coarray is a local variable of a subprogram or BLOCK construct and has cobounds that are
           not constant expressions, the cobounds are determined on entry to a procedure deﬁned by the subprogram, or
           on execution of the BLOCK statement, by evaluating the cobounds expressions. The cobounds of such a coarray
           are unaﬀected by the redeﬁnition or undeﬁnition of any variable during execution of the procedure or BLOCK
           construct.
         4 The values of each lower-cobound and upper-cobound determine the cobounds of the coarray along a particular
           codimension. The cosubscript range of the coarray in that codimension is the set of integer values between and
           including the lower and upper cobounds. If the lower cobound is omitted, the default value is 1. The upper
           cobound shall not be less than the lower cobound.
           8.5.7  CONTIGUOUS attribute
           C829  An entity with the CONTIGUOUS attribute shall be an array pointer, an assumed-shape array, or an
                 assumed-rank dummy data object.
         1 The CONTIGUOUS attribute speciﬁes that an assumed-shape array is contiguous, that an array pointer can
           only be pointer associated with a contiguous target, or that an assumed-rank dummy data object is contiguous.
         2 An object is contiguous if it is
                (1)  an object with the CONTIGUOUS attribute,
                (2)  a nonpointer whole array that is not assumed-shape,
                (3)  an assumed-shape array that is argument associated with an array that is contiguous,
                (4)  an assumed-rank dummy data object whose eﬀective argument is contiguous,
                (5)  an array allocated by an ALLOCATE statement,
                (6)  a pointer associated with a contiguous target, or
                (7)  a nonzero-sized array section (9.5.3) provided that
                     (a) its base object is contiguous,
                     (b) it does not have a vector subscript,
                     (c) the array element ordering of the elements of the section is the same as the array element
                         ordering of those elements of the base object,
                     (d) in the array element ordering of the base object, every element of the base object that is not
                         an element of the section either precedes every element of the section or follows every element
                         of the section,
                     (e) if the array is of type character and a substring-range appears, the substring-range speciﬁes all
                         of the characters of the parent-string (9.4.1),
                     (f) only its ﬁnal part-ref has nonzero rank, and
                     (g) it is not the real or imaginary part (9.4.4) of an array of type complex.
         3 An object is not contiguous if it is an array subobject, and
              • the object has two or more elements,
              • the elements of the object in array element order are not consecutive in the elements of the base object,
              • the object is not of type character with length zero, and
              • the object is not of a derived type that has no ultimate components other than zero-sized arrays and
               characters with length zero.
           c
           ISO/IEC 2017 – All rights reserved                                                 101
            ISO/IEC DIS 1539-1:2017 (E)
         4 It is processor dependent whether any other object is contiguous.
                NOTE8.10
                If a derived type has only one component that is not zero-sized, it is processor dependent whether a structure
                componentofacontiguousarrayofthattypeiscontiguous. That is, the derived type might contain padding
                on some processors.
                NOTE8.11
                The CONTIGUOUS attribute makes it easier for a processor to enable optimizations that depend on
                the memory layout of the object occupying a contiguous block of memory. Examples of CONTIGUOUS
                attribute speciﬁcations are:
                   REAL, POINTER, CONTIGUOUS        :: SPTR(:)
                   REAL, CONTIGUOUS, DIMENSION(:,:) :: D
            8.5.8  DIMENSION attribute
            8.5.8.1 General
         1 The DIMENSION attribute speciﬁes that an entity is assumed-rank or an array. An assumed-rank dummy data
            object has the rank, shape, and size of its eﬀective argument; otherwise, the rank or rank and shape is speciﬁed
            by its array-spec.
            R814  dimension-spec           is DIMENSION ( array-spec )
            R815  array-spec               is explicit-shape-spec-list
                                           or assumed-shape-spec-list
                                           or deferred-shape-spec-list
                                           or assumed-size-spec
                                           or implied-shape-spec
                                           or implied-shape-or-assumed-size-spec
                                           or assumed-rank-spec
                NOTE8.12
                The maximum rank of an entity is ﬁfteen minus the corank.
                NOTE8.13
                Examples of DIMENSION attribute speciﬁcations are:
                SUBROUTINE EX (N, A, B)
                   REAL, DIMENSION (N, 10) :: W           ! Automatic explicit-shape array
                   REAL A (:), B (0:)                     ! Assumed-shape arrays
                   REAL, POINTER :: D (:, :)              ! Array pointer
                   REAL, DIMENSION (:), POINTER :: P      ! Array pointer
                   REAL, ALLOCATABLE, DIMENSION (:) :: E  ! Allocatable array
                   REAL, PARAMETER :: V(0:*) = [0.1, 1.1] ! Implied-shape array
            8.5.8.2 Explicit-shape array
            R816  explicit-shape-spec      is [ lower-bound : ] upper-bound
            R817  lower-bound              is speciﬁcation-expr
            R818  upper-bound              is speciﬁcation-expr
                                                                  c
            102                                                  ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              C830    (R816) An explicit-shape-spec whose bounds are not constant expressions shall appear only in a subpro-
                      gram, derived type deﬁnition, BLOCK construct, or interface body.
           1 An explicit-shape array is an array whose shape is explicitly declared by an explicit-shape-spec-list. The rank is
              equal to the number of explicit-shape-specs.
           2 An explicit-shape array that is a named local variable of a subprogram or BLOCK construct may have bounds
              that are not constant expressions. The bounds, and hence shape, are determined on entry to a procedure deﬁned
              by the subprogram, or on execution of the BLOCK statement, by evaluating the bounds’ expressions. The
              bounds of such an array are unaﬀected by the redeﬁnition or undeﬁnition of any variable during execution of the
              procedure or BLOCK construct.
           3 The values of each lower-bound and upper-bound determine the bounds of the array along a particular dimension
              andhencetheextentofthearrayinthatdimension. If lower-bound appears it speciﬁes the lower bound; otherwise
              the lower bound is 1. The value of a lower bound or an upper bound may be positive, negative, or zero. The
              subscript range of the array in that dimension is the set of integer values between and including the lower and
              upper bounds, provided the upper bound is not less than the lower bound. If the upper bound is less than the
              lower bound, the range is empty, the extent in that dimension is zero, and the array is of zero size.
              8.5.8.3  Assumed-shape array
           1 An assumed-shape array is a nonallocatable nonpointer dummy argument array that takes its shape from its
              eﬀective argument.
              R819    assumed-shape-spec          is  [ lower-bound ] :
           2 The rank is equal to the number of colons in the assumed-shape-spec-list.
           3 The extent of a dimension of an assumed-shape array dummy argument is the extent of the corresponding
              dimension of its eﬀective argument. If the lower bound value is d and the extent of the corresponding dimension
              of its eﬀective argument is s, then the value of the upper bound is s + d − 1. If lower-bound appears it speciﬁes
              the lower bound; otherwise the lower bound is 1.
              8.5.8.4  Deferred-shape array
           1 Adeferred-shape array is an allocatable array or an array pointer. (An allocatable array has the ALLOCATABLE
              attribute; an array pointer has the POINTER attribute.)
              R820    deferred-shape-spec         is  :
              C831    An array with the POINTER or ALLOCATABLE attribute shall have an array-spec that is a deferred-
                      shape-spec-list.
           2 The rank is equal to the number of colons in the deferred-shape-spec-list.
           3 The size, bounds, and shape of an unallocated allocatable array or a disassociated array pointer are undeﬁned.
              No part of such an array shall be referenced or deﬁned; however, the array may appear as an argument to an
              intrinsic inquiry function as speciﬁed in 16.1.
           4 The bounds of each dimension of an allocated allocatable array are those speciﬁed when the array is allocated
              or, if it is a dummy argument, when it is argument associated with an allocated eﬀective argument.
           5 The bounds of each dimension of an associated array pointer, and hence its shape, may be speciﬁed
                 • in an ALLOCATE statement (9.7.1) when the target is allocated,
                 • by pointer assignment (10.2.2), or
                 • if it is a dummy argument, by argument association with a nonpointer actual argument or an associated
                   pointer eﬀective argument.
              c
              ISO/IEC 2017 – All rights reserved                                                                       103
              ISO/IEC DIS 1539-1:2017 (E)
           6 The bounds of an array pointer or allocatable array are unaﬀected by any subsequent redeﬁnition or undeﬁnition
              of variables on which the bounds’ expressions depend.
              8.5.8.5  Assumed-size array
           1 An assumed-size array is a dummy argument array whose size is assumed from that of its eﬀective argument, or
              the associate name of a RANK ( * ) block in a SELECT RANK construct. The rank and extents may diﬀer for
              the eﬀective and dummy arguments; only the size of the eﬀective argument is assumed by the dummy argument.
              A dummy argument is declared to be an assumed-size array by an assumed-size-spec or an implied-shape-or-
              assumed-size-spec.
              R821    assumed-implied-spec        is  [ lower-bound : ] *
              R822    assumed-size-spec           is  explicit-shape-spec-list, assumed-implied-spec
              C832    An object whose array bounds are speciﬁed by an assumed-size-spec shall be a dummy data object.
              C833    An assumed-size array with the INTENT (OUT) attribute shall not be polymorphic, ﬁnalizable, of a
                      type with an allocatable ultimate component, or of a type for which default initialization is speciﬁed.
              R823    implied-shape-or-assumed-size-spec   is  assumed-implied-spec
              C834    An object whose array bounds are speciﬁed by an implied-shape-or-assumed-size-spec shall be a dummy
                      data object or a named constant.
           2 The size of an assumed-size array is determined as follows.
                 • If the eﬀective argument associated with the assumed-size dummy array is an array of any type other than
                   default character, the size is that of the eﬀective argument.
                 • If the actual argument corresponding to the assumed-size dummy array is an array element of any type
                   other than default character with a subscript order value of r (9.5.3.2) in an array of size x, the size of the
                   dummy array is x−r+1.
                 • If the actual argument is a default character array, default character array element, or a default character
                   array element substring (9.4.1), and if it begins at character storage unit t of an array with c character
                   storage units, the size of the dummy array is MAX (INT ((c − t + 1)/e), 0), where e is the length of an
                   element in the dummy character array.
                 • If the actual argument is a default character scalar that is not an array element or array element substring
                   designator, the size of the dummy array is MAX (INT (l/e), 0), where e is the length of an element in the
                   dummy character array and l is the length of the actual argument.
           3 The rank is equal to one plus the number of explicit-shape-specs.
           4 Anassumed-size array has no upper bound in its last dimension and therefore has no extent in its last dimension
              and no shape. An assumed-size array shall not appear in a context that requires its shape.
           5 If a list of explicit-shape-specs appears, it speciﬁes the bounds of the ﬁrst rank−1 dimensions. If lower-bound
              appears it speciﬁes the lower bound of the last dimension; otherwise that lower bound is 1. An assumed-size
              array can be subscripted or sectioned (9.5.3).
           6 If an assumed-size array has bounds that are not constant expressions, the bounds are determined on entry to
              the procedure. The bounds of such an array are unaﬀected by the redeﬁnition or undeﬁnition of any variable
              during execution of the procedure.
              8.5.8.6  Implied-shape array
           1 An implied-shape array is a named constant that takes its shape from the constant-expr in its declaration. A
              named constant is declared to be an implied-shape array with an array-spec that is an implied-shape-or-assumed-
              size-spec or an implied-shape-spec.
                                                                              c
              104                                                            ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                R824     implied-shape-spec               is  assumed-implied-spec, assumed-implied-spec-list
                C835     An implied-shape array shall be a named constant.
            2 The rank of an implied-shape array is the number of assumed-implied-specs in its array-spec.
            3 The extent of each dimension of an implied-shape array is the same as the extent of the corresponding dimension
                of the constant-expr. The lower bound of each dimension is lower-bound, if it appears, and 1 otherwise; the upper
                bound is one less than the sum of the lower bound and the extent.
                8.5.8.7    Assumed-rank entity
            1 Anassumed-rankentityisadummydataobjectwhoserankisassumedfromitseﬀectiveargument,ortheassociate
                name of a RANK DEFAULT block in a SELECT RANK construct; this rank can be zero. An assumed-rank
                entity is declared with an array-spec that is an assumed-rank-spec.
                R825     assumed-rank-spec                is  ..
                C836     Anassumed-rankentityshallbeadummydataobjectthatdoesnothavetheCODIMENSIONorVALUE
                         attribute.
                C837     An assumed-rank variable name shall not appear in a designator or expression except as an actual
                         argument that corresponds to a dummy argument that is assumed-rank, the argument of the function
                         C_LOCorC_SIZEOFfromthe intrinsic module ISO_C_BINDING (18.2), the ﬁrst dummy argument
                         of an intrinsic inquiry function, or the selector of a SELECT RANK statement.
                C838     If an assumed-size or nonallocatable nonpointer assumed-rank array is an actual argument that corres-
                         ponds to a dummy argument that is an INTENT (OUT) assumed-rank array, it shall not be polymorphic,
                         ﬁnalizable, of a type with an allocatable ultimate component, or of a type for which default initialization
                         is speciﬁed.
                8.5.9     EXTERNAL attribute
            1 TheEXTERNALattributespeciﬁesthatanentityisanexternalprocedure,dummyprocedure,procedurepointer,
                or block data subprogram.
                C839     An entity shall not have both the EXTERNAL attribute and the INTRINSIC attribute.
                C840     In an external subprogram, the EXTERNAL attribute shall not be speciﬁed for a procedure deﬁned by
                         the subprogram.
                C841     In an interface body, the EXTERNAL attribute shall not be speciﬁed for the procedure declared by the
                         interface body.
            2 If an external procedure or dummy procedure is used as an actual argument or is the target of a procedure pointer
                assignment, it shall be declared to have the EXTERNAL attribute.
            3 Aprocedure that has both the EXTERNAL and POINTER attributes is a procedure pointer.
                     NOTE8.14
                     TheEXTERNALattributecanbespeciﬁedinatypedeclarationstatement, byaninterfacebody(15.4.3.2),
                     by an EXTERNAL statement (15.4.3.5), or by a procedure declaration statement (15.4.3.6).
                8.5.10      INTENT attribute
            1 The INTENT attribute speciﬁes the intended use of a dummy argument. An INTENT (IN) dummy argument
                is suitable for receiving data from the invoking scoping unit, an INTENT (OUT) dummy argument is suitable
                for returning data to the invoking scoping unit, and an INTENT (INOUT) dummy argument is suitable for use
                both to receive data from and to return data to the invoking scoping unit.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       105
           ISO/IEC DIS 1539-1:2017 (E)
           R826  intent-spec            is IN
                                        or OUT
                                        or INOUT
           C842  An entity with the INTENT attribute shall be a dummy data object or a dummy procedure pointer.
           C843  (R826) A nonpointer object with the INTENT (IN) attribute shall not appear in a variable deﬁnition
                 context (19.6.7).
           C844  Apointer with the INTENT (IN) attribute shall not appear in a pointer association context (19.6.8).
           C845  AnINTENT(OUT)dummyargumentofanonintrinsic procedure shall not be an allocatable coarray or
                 have a subobject that is an allocatable coarray.
           C846  Anentity with the INTENT (OUT) attribute shall not be of, or have a subcomponent of, type EVENT_-
                 TYPE(16.10.2.10) or LOCK_TYPE (16.10.2.19) from the intrinsic module ISO_FORTRAN_ENV.
         2 The INTENT (IN) attribute for a nonpointer dummy argument speciﬁes that it shall neither be deﬁned nor
           become undeﬁned during the invocation and execution of the procedure. The INTENT (IN) attribute for a
           pointer dummy argument speciﬁes that during the invocation and execution of the procedure its association shall
           not be changed except that it may become undeﬁned if the target is deallocated other than through the pointer
           (19.5.2.5).
         3 The INTENT (OUT) attribute for a nonpointer dummy argument speciﬁes that the dummy argument becomes
           undeﬁnedoninvocationoftheprocedure, except for any subcomponents that are default-initialized (7.5.4.6). Any
           actual argument that corresponds to such a dummy argument shall be deﬁnable. The INTENT (OUT) attribute
           for a pointer dummy argument speciﬁes that on invocation of the procedure the pointer association status of
           the dummy argument becomes undeﬁned. Any actual argument that corresponds to such a pointer dummy shall
           be a pointer variable or a procedure pointer that is not the result of a function reference. Any undeﬁnition or
           deﬁnition implied by association of an actual argument with an INTENT (OUT) dummy argument shall not
           aﬀect any other entity within the statement that invokes the procedure.
         4 The INTENT (INOUT) attribute for a nonpointer dummy argument speciﬁes that any actual argument that
           corresponds to the dummy argument shall be deﬁnable. The INTENT (INOUT) attribute for a pointer dummy
           argument speciﬁes that any actual argument that corresponds to the dummy argument shall be a pointer variable
           or a procedure pointer that is not the result of a function reference.
               NOTE8.15
               The INTENT attribute for an allocatable dummy argument applies to both the allocation status and the
               deﬁnition status. An actual argument that corresponds to an INTENT (OUT) allocatable dummy argument
               is deallocated on procedure invocation (9.7.3.2). To avoid this deallocation for coarrays, INTENT (OUT) is
               not allowed for a dummy argument that is an allocatable coarray or has a subobject that is an allocatable
               coarray.
         5 If no INTENT attribute is speciﬁed for a dummy argument, its use is subject to the limitations of its eﬀective
           argument (15.5.2).
         6 If a nonpointer object has an INTENT attribute, then all of its subobjects have the same INTENT attribute.
               NOTE8.16
               An example of INTENT speciﬁcation is:
               SUBROUTINE MOVE (FROM, TO)
                  USE PERSON_MODULE
                  TYPE (PERSON), INTENT (IN) :: FROM
                  TYPE (PERSON), INTENT (OUT) :: TO
                                                              c
           106                                               ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
              NOTE8.17
              If a dummy argument is a nonpointer derived-type object with a pointer component, then the pointer as
              a pointer is a subobject of the dummy argument, but the target of the pointer is not. Therefore, the
              restrictions on subobjects of the dummy argument apply to the pointer in contexts where it is used as a
              pointer, but not in contexts where it is dereferenced to indicate its target. For example, if X is a nonpointer
              dummy argument of derived type with an integer pointer component P, and X is INTENT (IN), then the
              statement
              X%P => NEW_TARGET
              is prohibited, but
              X%P = 0
              is allowed (provided that X%P is associated with a deﬁnable target).
              Similarly, the INTENT restrictions on pointer dummy arguments apply only to the association of the
              dummy argument; they do not restrict the operations allowed on its target.
              NOTE8.18
              Argumentintentspeciﬁcationsserveseveralpurposesinadditiontodocumentingtheintendeduseofdummy
              arguments. A processor can check whether an INTENT (IN) dummy argument is used in a way that could
              redeﬁne it. A slightly more sophisticated processor could check to see whether an INTENT (OUT) dummy
              argument could possibly be referenced before it is deﬁned. If the procedure’s interface is explicit, the
              processor can also verify that actual arguments corresponding to INTENT (OUT) or INTENT (INOUT)
              dummy arguments are deﬁnable. A more sophisticated processor could use this information to optimize
              the translation of the referencing scoping unit by taking advantage of the fact that actual arguments
              corresponding to INTENT (IN) dummy arguments will not be changed and that any prior value of an
              actual argument corresponding to an INTENT (OUT) dummy argument will not be referenced and could
              thus be discarded.
              INTENT (OUT) means that the value of the argument after invoking the procedure is entirely the result
              of executing that procedure. If an argument might not be redeﬁned and it is desired to have the argument
              retain its value in that case, INTENT (OUT) cannot be used because it would cause the argument to
              become undeﬁned; however, INTENT (INOUT) can be used, even if there is no explicit reference to the
              value of the dummy argument.
              INTENT(INOUT)isnotequivalenttoomittingtheINTENTattribute. Theactualargumentcorresponding
              to an INTENT (INOUT) dummy argument is always required to be deﬁnable, while an actual argument
              corresponding to a dummy argument without an INTENT attribute need be deﬁnable only if the dummy
              argument is actually redeﬁned.
          8.5.11  INTRINSIC attribute
        1 The INTRINSIC attribute speciﬁes that the entity is an intrinsic procedure. The procedure name may be a
          generic name (16.7), a speciﬁc name (16.8), or both.
        2 If the speciﬁc name of an intrinsic procedure (16.8) is used as an actual argument, the name shall be explicitly speciﬁed to have the
          INTRINSIC attribute. Note that a speciﬁc intrinsic procedure listed in Table 16.3 is not permitted to be used as an actual argument
          (C1534).
          C847  If the generic name of an intrinsic procedure is explicitly declared to have the INTRINSIC attribute,
                and it is also the generic name of one or more generic interfaces (15.4.3.2) accessible in the same scoping
                unit, the procedures in the interfaces and the generic intrinsic procedure shall all be functions or all be
                subroutines.
           c
          ISO/IEC 2017 – All rights reserved                                          107
           ISO/IEC DIS 1539-1:2017 (E)
           8.5.12  OPTIONAL attribute
         1 The OPTIONAL attribute speciﬁes that the dummy argument need not have a corresponding actual argument
           in a reference to the procedure (15.5.2.12).
           C848  An entity with the OPTIONAL attribute shall be a dummy argument.
               NOTE8.19
               Theintrinsic function PRESENT(16.9.152)canbeusedtodeterminewhetheranoptionaldummyargument
               has a corresponding actual argument.
           8.5.13  PARAMETER attribute
         1 The PARAMETER attribute speciﬁes that an entity is a named constant. The entity has the value speciﬁed by
           its constant-expr, converted, if necessary, to the type, type parameters and shape of the entity.
           C849  An entity with the PARAMETER attribute shall not be a variable, a coarray, or a procedure.
           C850  An expression that speciﬁes a length type parameter or array bound of a named constant shall be a
                 constant expression.
         2 A named constant shall not be referenced unless it has been deﬁned previously; it may be deﬁned previously in
           the same statement.
               NOTE8.20
               Examples of declarations with a PARAMETER attribute are:
               REAL, PARAMETER :: ONE = 1.0, Y = 4.1 / 3.0
               INTEGER, DIMENSION (3), PARAMETER :: ORDER = (/ 1, 2, 3 /)
               TYPE(NODE), PARAMETER :: DEFAULT = NODE(0, NULL ( ))
           8.5.14  POINTER attribute
         1 Entities with the POINTERattribute can be associated with diﬀerent data objects or procedures during execution
           of a program. A pointer is either a data pointer or a procedure pointer.
           C851  An entity with the POINTER attribute shall not have the ALLOCATABLE, INTRINSIC, or TARGET
                 attribute, and shall not be a coarray.
           C852  Aprocedure with the POINTER attribute shall have the EXTERNAL attribute.
         2 Adata pointer shall not be referenced unless it is pointer associated with a target object that is deﬁned. A data
           pointer shall not be deﬁned unless it is pointer associated with a target object that is deﬁnable.
         3 If a data pointer is associated, the values of its deferred type parameters are the same as the values of the
           corresponding type parameters of its target.
         4 Aprocedure pointer shall not be referenced unless it is pointer associated with a target procedure.
               NOTE8.21
               Examples of POINTER attribute speciﬁcations are:
               TYPE (NODE), POINTER :: CURRENT, TAIL
               REAL, DIMENSION (:, :), POINTER :: IN, OUT, SWAP
                                                              c
           108                                               ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
          8.5.15  PROTECTED attribute
        1 The PROTECTED attribute imposes limitations on the usage of module entities.
          C853  The PROTECTED attribute shall be speciﬁed only in the speciﬁcation part of a module.
          C854  An entity with the PROTECTED attribute shall be a procedure pointer or variable.
          C855  An entity with the PROTECTED attribute shall not be in a common block.
          C856  A nonpointer object that has the PROTECTED attribute and is accessed by use association shall not
                appear in a variable deﬁnition context (19.6.7) or as a data-target or initial-data-target.
          C857  Apointer that has the PROTECTED attribute and is accessed by use association shall not appear in a
                pointer association context (19.6.8).
        2 Other than within the module in which an entity is given the PROTECTED attribute, or within any of its
          descendants,
            • if it is a nonpointer object, it is not deﬁnable, and
            • if it is a pointer, its association status shall not be changed except that it may become undeﬁned if its target
              is deallocated other than through the pointer (19.5.2.5), or if its target becomes undeﬁned by completing
              execution of a BLOCK construct or by execution of a RETURN or END statement.
        3 If an object has the PROTECTED attribute, all of its subobjects have the PROTECTED attribute.
             NOTE8.22
             An example of the PROTECTED attribute:
                  MODULE temperature
                   REAL, PROTECTED :: temp_c, temp_f
                  CONTAINS
                   SUBROUTINE set_temperature_c(c)
                     REAL, INTENT(IN) :: c
                     temp_c = c
                     temp_f = temp_c*(9.0/5.0) + 32
                   END SUBROUTINE
                  END MODULE
             The PROTECTEDattribute ensures that the variables temp_c and temp_f cannot be modiﬁed other than
             via the set_temperature_c procedure, thus keeping them consistent with each other.
          8.5.16  SAVE attribute
        1 TheSAVEattribute speciﬁes that a local variable of a program unit or subprogram retains its association status,
          allocation status, deﬁnition status, and value after execution of a RETURN or END statement unless it is a
          pointer and its target becomes undeﬁned (19.5.2.5(6)). If it is a local variable of a subprogram it is shared by all
          instances (15.6.2.4) of the subprogram.
        2 TheSAVEattribute speciﬁes that a local variable of a BLOCK construct retains its association status, allocation
          status, deﬁnition status, and value after termination of the construct unless it is a pointer and its target becomes
          undeﬁned (19.5.2.5(7)). If the BLOCK construct is within a subprogram the variable is shared by all instances
          (15.6.2.4) of the subprogram.
        3 Giving a common block the SAVE attribute confers the attribute on all entities in the common block.
          C858  An entity with the SAVE attribute shall be a common block, variable, or procedure pointer.
          c
          ISO/IEC 2017 – All rights reserved                                         109
          ISO/IEC DIS 1539-1:2017 (E)
          C859  The SAVE attribute shall not be speciﬁed for a dummy argument, a function result, an automatic data
                object, or an object that is in a common block.
        4 A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or
          submodule implicitly has the SAVE attribute, which may be conﬁrmed by explicit speciﬁcation. If a common block
          has the SAVE attribute in any other kind of scoping unit, it shall have the SAVE attribute in every scoping unit that is not of a
          main program, module, or submodule.
          8.5.17  TARGET attribute
        1 The TARGET attribute speciﬁes that a data object may have a pointer associated with it (10.2.2). An object
          without the TARGET attribute shall not have a pointer associated with it.
          C860  An entity with the TARGET attribute shall be a variable.
          C861  An entity with the TARGET attribute shall not have the POINTER attribute.
        2 If an object has the TARGET attribute, then all of its nonpointer subobjects also have the TARGET attribute.
             NOTE8.23
             In addition to variables explicitly declared to have the TARGET attribute, the objects created by allocation
             of pointers (9.7.1.4) have the TARGET attribute.
             NOTE8.24
             Examples of TARGET attribute speciﬁcations are:
             TYPE (NODE), TARGET :: HEAD
             REAL, DIMENSION (1000, 1000), TARGET :: A, B
             NOTE8.25
             EveryobjectdesignatorthatstartsfromanobjectwiththeTARGETattributewillhaveeithertheTARGET
             or POINTER attribute. If pointers are involved, the designator might not necessarily be a subobject of the
             original object, but because a pointer can point only to an entity with the TARGET attribute, there is no
             way to end up at a nonpointer that does not have the TARGET attribute.
          8.5.18  VALUE attribute
        1 The VALUE attribute speciﬁes a type of argument association (15.5.2.4) for a dummy argument.
          C862  An entity with the VALUE attribute shall be a dummy data object. It shall not be an assumed-size
                array, a coarray, or a variable with a coarray ultimate component.
          C863  Anentity with the VALUE attribute shall not have the ALLOCATABLE, INTENT (INOUT), INTENT
                (OUT), POINTER, or VOLATILE attributes.
          C864  Adummy argument of a procedure with the BIND attribute shall not have both the OPTIONAL and
                VALUEattributes.
          8.5.19  VOLATILE attribute
        1 The VOLATILE attribute speciﬁes that an object may be referenced, deﬁned, or become undeﬁned, by means
          not speciﬁed by the program. A pointer with the VOLATILE attribute may additionally have its association
          status, dynamic type and type parameters, and array bounds changed by means not speciﬁed by the program.
          An allocatable object with the VOLATILE attribute may additionally have its allocation status, dynamic type
          and type parameters, and array bounds changed by means not speciﬁed by the program.
                                                        c
          110                                           ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                C865     An entity with the VOLATILE attribute shall be a variable that is not an INTENT (IN) dummy argu-
                         ment.
                C866     The VOLATILE attribute shall not be speciﬁed for a coarray, or a variable with a coarray ultimate
                         component, that is accessed by use (14.2.2) or host (19.5.1.4) association.
                C867     Within a BLOCK construct (11.1.4), the VOLATILE attribute shall not be speciﬁed for a coarray, or a
                         variable with a coarray ultimate component, that is not a construct entity (19.4) of that construct.
            2 A noncoarray object that has the VOLATILE attribute may be associated with an object that does not have
                the VOLATILE attribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
                local variable of a BLOCK construct is speciﬁed to have the VOLATILE attribute in the speciﬁcation-part of
                the construct, the object has the attribute within the construct even if it does not have the attribute outside the
                construct. The relationship between coarrays, the VOLATILE attribute, and argument association is described
                in 15.5.2.8. The relationship between between coarrays, the VOLATILE attribute, and pointer association is
                described in 10.2.2.3.
            3 A pointer should have the VOLATILE attribute if its target has the VOLATILE attribute. If, by means not
                speciﬁed by the program, the target is referenced, deﬁned, or becomes undeﬁned, the pointer shall have the
                VOLATILE attribute. All members of an EQUIVALENCE group should have the VOLATILE attribute if any member has the
                VOLATILE attribute.
            4 If an object has the VOLATILE attribute, then all of its subobjects also have the VOLATILE attribute.
            5 The Fortran processor should use the most recent deﬁnition of a volatile object each time its value is required.
                Whenavolatile object is deﬁned by means of Fortran, it should make that deﬁnition available to the non-Fortran
                parts of the program as soon as possible.
                8.6      Attribute speciﬁcation statements
                8.6.1     Accessibility statement
                R827     access-stmt                      is  access-spec [ [ :: ] access-id-list ]
                R828     access-id                        is  access-name
                                                          or generic-spec
                C868     (R827) An access-stmt shall appear only in the speciﬁcation-part of a module. Only one accessibility
                         statement with an omitted access-id-list is permitted in the speciﬁcation-part of a module.
                C869     (R828) Each access-name shall be the name of a module, variable, procedure, derived type, named
                         constant, or namelist group.
                C870     Amodule whose name appears in an access-stmt shall be referenced by a USE statement in the scoping
                         unit that contains the access-stmt.
                C871     The name of a module shall appear at most once in all of the access-stmts in a module.
            1 Anaccess-stmt with an access-id-list speciﬁes the accessibility attribute, PUBLIC or PRIVATE, of each access-id
                in the list that is not a module name. An access-stmt without an access-id list speciﬁes the default accessibility
                of the identiﬁers of entities declared in the module, and of entities accessed from a module whose name does
                not appear in any access-stmt in the module. If an identiﬁer is accessed from another module and also declared
                locally, it has the default accessibility of a locally declared identiﬁer. The statement
                   PUBLIC
                speciﬁes a default of public accessibility. The statement
                   PRIVATE
                speciﬁes a default of private accessibility.       If no such statement appears in a module, the default is public
                accessibility.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       111
                ISO/IEC DIS 1539-1:2017 (E)
            2 If an identiﬁer is accessed by use association and not declared in the module, and the name of every module
                from which it is accessed appears in an access-stmt in the scoping unit, its default accessibility is PRIVATE if
                the access-spec in every such access-stmt is PRIVATE, or PUBLIC if the access-spec in any such access-stmt is
                PUBLIC.
                     NOTE8.26
                     Examples of accessibility statements are:
                     MODULE EX
                         PRIVATE
                         PUBLIC :: A, B, C, ASSIGNMENT (=), OPERATOR (+)
                     NOTE8.27
                     The following is an example of using an accessibility statement on a module name.
                         MODULE m2
                            USE m1
                            ! We want to use the types and procedures in m1, but we only want to
                            ! re-export m_type from m1, and export our own procedures.
                            PRIVATE m1
                            PUBLIC m_type
                            ... definitions for our own entities and module procedures.
                         END MODULE
                8.6.2     ALLOCATABLE statement
                R829     allocatable-stmt                 is  ALLOCATABLE[:: ] allocatable-decl-list
                R830     allocatable-decl                 is  object-name [ ( array-spec ) ]
                                                                  [ lbracket coarray-spec rbracket ]
            1 The ALLOCATABLE statement speciﬁes the ALLOCATABLE attribute (8.5.3) for a list of objects.
                     NOTE8.28
                     An example of an ALLOCATABLE statement is:
                     REAL A, B (:), SCALAR
                     ALLOCATABLE :: A (:, :), B, SCALAR
                8.6.3     ASYNCHRONOUSstatement
                R831     asynchronous-stmt                is  ASYNCHRONOUS[:: ] object-name-list
            1 The ASYNCHRONOUS statement speciﬁes the ASYNCHRONOUS attribute (8.5.4) for a list of objects.
                8.6.4     BIND statement
                R832     bind-stmt                        is  language-binding-spec [ :: ] bind-entity-list
                R833     bind-entity                      is  entity-name
                                                          or  / common-block-name /
                C872     (R832) If the language-binding-spec has a NAME= speciﬁer, the bind-entity-list shall consist of a single
                         bind-entity.
            1 The BIND statement speciﬁes the BIND attribute for a list of variables and common blocks.
                                                                                         c
                112                                                                      ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                8.6.5     CODIMENSION statement
                R834     codimension-stmt                 is  CODIMENSION[:: ] codimension-decl-list
                R835     codimension-decl                 is  coarray-name lbracket coarray-spec rbracket
            1 The CODIMENSION statement speciﬁes the CODIMENSION attribute (8.5.6) for a list of objects.
                     NOTE8.29
                     An example of a CODIMENSION statement is:
                        CODIMENSION a[*], b[3,*], c[:]
                8.6.6     CONTIGUOUS statement
                R836     contiguous-stmt                  is  CONTIGUOUS[:: ] object-name-list
            1 The CONTIGUOUS statement speciﬁes the CONTIGUOUS attribute (8.5.7) for a list of objects.
                8.6.7     DATA statement
                R837     data-stmt                        is  DATAdata-stmt-set [ [ , ] data-stmt-set ] ...
            1 The DATA statement speciﬁes explicit initialization (8.4).
            2 If a nonpointer variable has default initialization, it shall not appear in a data-stmt-object-list.
            3 Avariable that appears in a DATA statement and has not been typed previously may appear in a subsequent type
                declaration only if that declaration conﬁrms the implicit typing. An array name, array section, or array element
                that appears in a DATA statement shall have had its array properties established by a previous speciﬁcation
                statement.
            4 Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is initialized
                in a DATA statement, and this may be conﬁrmed by explicit speciﬁcation.
                R838     data-stmt-set                    is  data-stmt-object-list / data-stmt-value-list /
                R839     data-stmt-object                 is  variable
                                                          or data-implied-do
                R840     data-implied-do                  is  ( data-i-do-object-list , [ integer-type-spec :: ] data-i-do-variable =
                                                                  scalar-int-constant-expr ,
                                                                  scalar-int-constant-expr
                                                                  [ , scalar-int-constant-expr ] )
                R841     data-i-do-object                 is  array-element
                                                          or scalar-structure-component
                                                          or data-implied-do
                R842     data-i-do-variable               is  do-variable
                C873     Adata-stmt-object or data-i-do-object shall not be a coindexed variable.
                C874     (R839) A data-stmt-object that is a variable shall be a designator. Each subscript, section subscript,
                         substring starting point, and substring ending point in the variable shall be a constant expression.
                C875     (R839) A variable whose designator appears as a data-stmt-object or a data-i-do-object shall not be a
                         dummy argument, accessed by use or host association, in a named common block unless the DATA statement is
                         in a block data program unit, in blank common, a function name, a function result name, an automatic data
                         object, or an allocatable variable.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       113
              ISO/IEC DIS 1539-1:2017 (E)
              C876     (R839)Adata-i-do-object oravariable that appears as a data-stmt-object shall not be an object designator
                       in which a pointer appears other than as the entire rightmost part-ref.
              C877     (R841) The array-element shall be a variable.
              C878     (R841) The scalar-structure-component shall be a variable.
              C879     (R841) The scalar-structure-component shall contain at least one part-ref that contains a subscript-list.
              C880     (R841) In an array-element or scalar-structure-component that is a data-i-do-object, any subscript shall
                       be a constant expression, and any primary within that subscript that is a data-i-do-variable shall be a
                       DOvariable of this data-implied-do or of a containing data-implied-do.
              R843     data-stmt-value               is  [ data-stmt-repeat * ] data-stmt-constant
              R844     data-stmt-repeat              is  scalar-int-constant
                                                     or scalar-int-constant-subobject
              C881     (R844) The data-stmt-repeat shall be positive or zero. If the data-stmt-repeat is a named constant, it
                       shall have been deﬁned previously.
              R845     data-stmt-constant            is  scalar-constant
                                                     or scalar-constant-subobject
                                                     or signed-int-literal-constant
                                                     or signed-real-literal-constant
                                                     or null-init
                                                     or initial-data-target
                                                     or structure-constructor
              C882     (R845) If a DATA statement constant value is a named constant or a structure constructor, the named
                       constant or derived type shall have been deﬁned previously.
              C883     (R845) If a data-stmt-constant is a structure-constructor, it shall be a constant expression.
              R846     int-constant-subobject        is  constant-subobject
              C884     (R846) int-constant-subobject shall be of type integer.
              R847     constant-subobject            is  designator
              C885     (R847) constant-subobject shall be a subobject of a constant.
              C886     (R847) Any subscript, substring starting point, or substring ending point shall be a constant expression.
           5 Thedata-stmt-object-list is expanded to form a sequence of pointers and scalar variables, referred to as “sequence
              of variables” in subsequent text. A nonpointer array whose unqualiﬁed name appears as a data-stmt-object or
              data-i-do-object is equivalent to a complete sequence of its array elements in array element order (9.5.3.2). An
              array section is equivalent to the sequence of its array elements in array element order. A data-implied-do is
              expanded to form a sequence of array elements and structure components, under the control of the data-i-do-
              variable, as in the DO construct (11.1.7.4).
           6 The data-stmt-value-list is expanded to form a sequence of data-stmt-constants. A data-stmt-repeat indicates the
              number of times the following data-stmt-constant is to be included in the sequence; omission of a data-stmt-repeat
              has the eﬀect of a repeat factor of 1.
           7 A zero-sized array or a data-implied-do with an iteration count of zero contributes no variables to the expanded
              sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded
              sequence. A data-stmt-constant with a repeat factor of zero contributes no data-stmt-constants to the expanded
              sequence of scalar data-stmt-constants.
                                                                                 c
              114                                                                ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         8 The expanded sequences of variables and data-stmt-constants are in one-to-one correspondence. Each data-stmt-
            constant speciﬁes the initial value, initial data target, or null-init for the corresponding variable. The lengths of
            the two expanded sequences shall be the same.
         9 Adata-stmt-constant shall be null-init or initial-data-target if and only if the corresponding data-stmt-object has
            the POINTERattribute. If data-stmt-constant is null-init, the initial association status of the corresponding data
            statement object is disassociated. If data-stmt-constant is initial-data-target the corresponding data statement
            object shall be data-pointer-initialization compatible (7.5.4.6) with the initial data target; the data statement
            object is initially associated with the target.
        10 A data-stmt-constant other than boz-literal-constant, null-init, or initial-data-target shall be compatible with its
            corresponding variable according to the rules of intrinsic assignment (10.2.1.2). The variable is initially deﬁned
            with the value speciﬁed by the data-stmt-constant; if necessary, the value is converted according to the rules of
            intrinsic assignment (10.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.
        11 If a data-stmt-constant is a boz-literal-constant, the corresponding variable shall be of type integer. The boz-
            literal-constant is treated as if it were converted by the intrinsic function INT (16.9.100) to type integer with the
            kind type parameter of the variable.
                NOTE8.30
                Examples of DATA statements are:
                CHARACTER (LEN = 10)  NAME
                INTEGER, DIMENSION (0:9) :: MILES
                REAL, DIMENSION (100, 100) :: SKEW
                TYPE (NODE), POINTER :: HEAD_OF_LIST
                TYPE (PERSON) MYNAME, YOURNAME
                DATA NAME / ’JOHN DOE’ /, MILES / 10 * 0 /
                DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /
                DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /
                DATA HEAD_OF_LIST / NULL() /
                DATA MYNAME / PERSON (21, ’JOHN SMITH’) /
                DATA YOURNAME % AGE, YOURNAME % NAME / 35, ’FRED BROWN’ /
                The character variable NAME is initialized with the value JOHN DOE with padding on the right because
                the length of the constant is less than the length of the variable. All ten elements of the integer array
                MILES are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle
                of SKEW is zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are
                declared using the derived type PERSON from NOTE 7.15. The pointer HEAD_OF_LIST is declared
                using the derived type NODE from NOTE 7.35; it is initially disassociated. MYNAME is initialized by a
                structure constructor. YOURNAME is initialized by supplying a separate value for each component.
            8.6.8  DIMENSION statement
            R848  dimension-stmt           is DIMENSION [ :: ] array-name ( array-spec )
                                                 [ , array-name ( array-spec ) ] ...
         1 The DIMENSION statement speciﬁes the DIMENSION attribute (8.5.8) for a list of objects.
                NOTE8.31
                An example of a DIMENSION statement is:
                DIMENSION A (10), B (10, 70), C (:)
            c
            ISO/IEC 2017 – All rights reserved                                                      115
           ISO/IEC DIS 1539-1:2017 (E)
           8.6.9   INTENT statement
           R849   intent-stmt             is INTENT ( intent-spec ) [ :: ] dummy-arg-name-list
         1 The INTENT statement speciﬁes the INTENT attribute (8.5.10) for the dummy arguments in the list.
               NOTE8.32
               An example of an INTENT statement is:
               SUBROUTINE EX (A, B)
                  INTENT (INOUT) :: A, B
           8.6.10   OPTIONAL statement
           R850   optional-stmt           is OPTIONAL[:: ] dummy-arg-name-list
         1 The OPTIONAL statement speciﬁes the OPTIONAL attribute (8.5.12) for the dummy arguments in the list.
               NOTE8.33
               An example of an OPTIONAL statement is:
               SUBROUTINE EX (A, B)
                  OPTIONAL :: B
           8.6.11   PARAMETER statement
         1 The PARAMETER statement speciﬁes the PARAMETER attribute (8.5.13) and the values for the named con-
           stants in the list.
           R851   parameter-stmt          is PARAMETER(named-constant-def-list )
           R852   named-constant-def      is named-constant = constant-expr
         2 If a named constant is deﬁned by a PARAMETER statement, it shall not be subsequently declared to have a
           type or type parameter value that diﬀers from the type and type parameters it would have if declared implicitly
           (8.7). A named array constant deﬁned by a PARAMETER statement shall have its rank speciﬁed in a prior
           speciﬁcation statement.
         3 Theconstant expression that corresponds to a named constant shall have type and type parameters that conform
           with the named constant as speciﬁed for intrinsic assignment (10.2.1.2). If the named constant has implied shape,
           the expression shall have the same rank as the named constant; otherwise, the expression shall either be scalar
           or have the same shape as the named constant.
         4 The value of each named constant is that speciﬁed by the corresponding constant expression; if necessary, the
           value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
           parameters, and shape with the named constant.
               NOTE8.34
               An example of a PARAMETER statement is:
               PARAMETER (MODULUS = MOD (28, 3), NUMBER_OF_SENATORS = 100)
           8.6.12   POINTER statement
           R853   pointer-stmt            is POINTER[ :: ] pointer-decl-list
           R854   pointer-decl            is object-name [ ( deferred-shape-spec-list ) ]
                                          or proc-entity-name
                                                                c
           116                                                  ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                C887     Aproc-entity-name shall have the EXTERNAL attribute.
            1 The POINTER statement speciﬁes the POINTER attribute (8.5.14) for a list of entities.
                     NOTE8.35
                     An example of a POINTER statement is:
                     TYPE (NODE) :: CURRENT
                     POINTER :: CURRENT, A (:, :)
                8.6.13      PROTECTED statement
                R855     protected-stmt                   is  PROTECTED[:: ] entity-name-list
            1 The PROTECTED statement speciﬁes the PROTECTED attribute (8.5.15) for a list of entities.
                8.6.14      SAVE statement
                R856     save-stmt                        is  SAVE [ [ :: ] saved-entity-list ]
                R857     saved-entity                     is  object-name
                                                          or proc-pointer-name
                                                          or  / common-block-name /
                R858     proc-pointer-name                is  name
                C888     (R856) If a SAVE statement with an omitted saved entity list appears in a scoping unit, no other
                         appearance of the SAVE attr-spec or SAVE statement is permitted in that scoping unit.
                C889     Aproc-pointer-name shall be the name of a procedure pointer.
            1 A SAVE statement with a saved entity list speciﬁes the SAVE attribute (8.5.16) for a list of entities. A SAVE
                statement without a saved entity list is treated as though it contained the names of all allowed items in the same
                scoping unit.
                     NOTE8.36
                     An example of a SAVE statement is:
                     SAVE A, B, C, / BLOCKA /, D
                8.6.15      TARGET statement
                R859     target-stmt                      is  TARGET[:: ] target-decl-list
                R860     target-decl                      is  object-name [ ( array-spec ) ]
                                                                  [ lbracket coarray-spec rbracket ]
            1 The TARGET statement speciﬁes the TARGET attribute (8.5.17) for a list of objects.
                     NOTE8.37
                     An example of a TARGET statement is:
                     TARGET :: A (1000, 1000), B
                8.6.16      VALUE statement
                R861     value-stmt                       is  VALUE[:: ] dummy-arg-name-list
                c
                ISO/IEC 2017 – All rights reserved                                                                                       117
           ISO/IEC DIS 1539-1:2017 (E)
         1 The VALUE statement speciﬁes the VALUE attribute (8.5.18) for a list of dummy arguments.
           8.6.17  VOLATILE statement
           R862  volatile-stmt          is VOLATILE [ :: ] object-name-list
         1 The VOLATILE statement speciﬁes the VOLATILE attribute (8.5.19) for a list of objects.
           8.7   IMPLICIT statement
         1 In a scoping unit, an IMPLICIT statement speciﬁes a type, and possibly type parameters, for all implicitly
           typed data entities whose names begin with one of the letters speciﬁed in the statement. An IMPLICIT NONE
           statement can indicate that no implicit typing rules are to apply in a particular scoping unit, or that external
           and dummy procedures need to be explicitly given the EXTERNAL attribute.
           R863  implicit-stmt          is IMPLICIT implicit-spec-list
                                        or IMPLICIT NONE [ ( [ implicit-none-spec-list ] ) ]
           R864  implicit-spec          is declaration-type-spec ( letter-spec-list )
           R865  letter-spec            is letter [ – letter ]
           R866  implicit-none-spec     is EXTERNAL
                                        or TYPE
           C890  (R863) If an IMPLICIT NONE statement appears in a scoping unit, it shall precede any PARAMETER
                 statements that appear in the scoping unit. No more than one IMPLICIT NONE statement shall appear
                 in a scoping unit.
           C891  The same implicit-none-spec shall not appear more than once in a given implicit-stmt.
           C892  If an IMPLICIT NONEstatementinascopingunithasanimplicit-none-spec of TYPEorhasnoimplicit-
                 none-spec-list, there shall be no other IMPLICIT statements in the scoping unit.
           C893  (R865) If the minus and second letter appear, the second letter shall follow the ﬁrst letter alphabetically.
           C894  If IMPLICIT NONE with an implicit-none-spec of EXTERNAL appears within a scoping unit, the
                 name of an external or dummy procedure in that scoping unit or in a contained subprogram or BLOCK
                 construct shall have an explicit interface or be explicitly declared to have the EXTERNAL attribute.
         2 Aletter-spec consisting of two letters separated by a minus is equivalent to writing a list containing all of the letters
           in alphabetical order in the alphabetic sequence from the ﬁrst letter through the second letter. For example, A–C
           is equivalent to A, B, C. The same letter shall not appear as a single letter, or be included in a range of letters,
           more than once in all of the IMPLICIT statements in a scoping unit.
         3 In each scoping unit, there is a mapping, which may be null, between each of the letters A, B, ..., Z and a
           type (and type parameters). An IMPLICIT statement speciﬁes the mapping for the letters in its letter-spec-
           list. IMPLICIT NONE with an implicit-none-spec of TYPE or with no implicit-none-spec-list speciﬁes the null
           mapping for all the letters. If a mapping is not speciﬁed for a letter, the default for a program unit or an interface
           body is default integer if the letter is I, J, ..., or N and default real otherwise, and the default for a BLOCK
           construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.
         4 Any data entity that is not explicitly declared by a type declaration statement, is not an intrinsic function, is
           not a component, and is not accessed by use or host association is declared implicitly to be of the type (and
           type parameters) mapped from the ﬁrst letter of its name, provided the mapping is not null. The mapping for
           the ﬁrst letter of the data entity shall either have been established by a prior IMPLICIT statement or be the
           default mapping for the letter. An explicit type speciﬁcation in a FUNCTION statement overrides an IMPLICIT
           statement for the result of that function.
                                                              c
           118                                               ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE8.38
                The following are examples of the use of IMPLICIT statements:
                       MODULE EXAMPLE_MODULE
                          IMPLICIT NONE
                          ...
                          INTERFACE
                             FUNCTION FUN (I)   ! Not all data entities need to
                                INTEGER FUN     ! be declared explicitly
                             END FUNCTION FUN
                          END INTERFACE
                       CONTAINS
                          FUNCTION JFUN (J)     ! All data entities need to
                             INTEGER JFUN, J    ! be declared explicitly.
                             ...
                          END FUNCTION JFUN
                       END MODULE EXAMPLE_MODULE
                       SUBROUTINE SUB
                          IMPLICIT COMPLEX (C)
                          C = (3.0, 2.0)        ! C is implicitly declared COMPLEX
                          ...
                       CONTAINS
                          SUBROUTINE SUB1
                             IMPLICIT INTEGER (A, C)
                             C = (0.0, 0.0)     ! C is host associated and of
                                                ! type complex
                             Z = 1.0            ! Z is implicitly declared REAL
                             A = 2              ! A is implicitly declared INTEGER
                             CC = 1             ! CC is implicitly declared INTEGER
                             ...
                          END SUBROUTINE SUB1
                          SUBROUTINE SUB2
                             Z = 2.0            ! Z is implicitly declared REAL and
                                                ! is different from the variable of
                                                ! the same name in SUB1
                             ...
                          END SUBROUTINE SUB2
                          SUBROUTINE SUB3
                             USE EXAMPLE_MODULE ! Accesses integer function FUN
                                                ! by use association
                             Q = FUN (K)        ! Q is implicitly declared REAL and
                             ...                ! K is implicitly declared INTEGER
                          END SUBROUTINE SUB3
                       END SUBROUTINE SUB
                NOTE8.39
                The following is an example of a mapping to a derived type that is inaccessible in the local scope:
                       PROGRAM MAIN
                         IMPLICIT TYPE(BLOB) (A)
                         TYPE BLOB
                           INTEGER :: I
                         END TYPE BLOB
                         TYPE(BLOB) :: B
                         CALL STEVE
            c
            ISO/IEC 2017 – All rights reserved                                                      119
                ISO/IEC DIS 1539-1:2017 (E)
                     NOTE8.39 (cont.)
                               CONTAINS
                                 SUBROUTINE STEVE
                                    INTEGER :: BLOB
                                    ...
                                    AA = B
                                    ...
                                 END SUBROUTINE STEVE
                               END PROGRAM MAIN
                     In the subroutine STEVE, it is not possible to explicitly declare a variable to be of type BLOB because
                     BLOBhasbeen given a diﬀerent meaning, but implicit mapping for the letter A still maps to type BLOB,
                     so AA is of type BLOB.
                     NOTE8.40
                     Implicit typing is not aﬀected by BLOCK constructs. For example, in
                            SUBROUTINE S(N)
                               ...
                               IF (N>0) THEN
                                 BLOCK
                                    NSQP = CEILING (SQRT (DBLE (N)))
                                 END BLOCK
                               END IF
                               ...
                               IF (N>0) THEN
                                 BLOCK
                                    PRINT *,NSQP
                                 END BLOCK
                               END IF
                            END SUBROUTINE
                     even if the only two appearances of NSQP are within the BLOCK constructs, the scope of NSQP is the whole
                     subroutine S.
                     NOTE8.41
                     In the subprogram
                               SUBROUTINE EXAMPLE (X, Y)
                                 IMPLICIT NONE (EXTERNAL)
                                 REAL, EXTERNAL :: G
                                 REAL :: X, Y
                                 X = F (Y)                           ! Invalid: F lacks the EXTERNAL attribute.
                                 X = G (Y)                           ! Valid: G has the EXTERNAL attribute.
                               END SUBROUTINE
                     the referenced function F needs to have the EXTERNAL attribute (8.5.9).
                8.8      IMPORT statement
                R867     import-stmt                      is  IMPORT[[ :: ] import-name-list ]
                                                          or IMPORT, ONLY : import-name-list
                                                          or IMPORT, NONE
                                                          or IMPORT, ALL
                C895     (R867) An IMPORT statement shall not appear in the scoping unit of a main-program, external-
                         subprogram, module, or block-data.
                                                                                         c
                120                                                                      ISO/IEC 2017 – All rights reserved
                                                                      ISO/IEC DIS 1539-1:2017 (E)
           C896   (R867) Each import-name shall be the name of an entity in the host scoping unit.
           C897   If any IMPORT statement in a scoping unit has an ONLY speciﬁer, all IMPORT statements in that
                  scoping unit shall have an ONLY speciﬁer.
           C898   IMPORT, NONE shall not appear in the scoping unit of a submodule.
           C899   If an IMPORT, NONE or IMPORT, ALL statement appears in a scoping unit, no other IMPORT
                  statement shall appear in that scoping unit.
           C8100 Within an interface body, an entity that is accessed by host association shall be accessible by host or use
                  association within the host scoping unit, or explicitly declared prior to the interface body.
           C8101 An entity whose name appears as an import-name or which is made accessible by an IMPORT, ALL
                  statement shall not appear in any context described in 19.5.1.4 that would cause the host entity of that
                  name to be inaccessible.
         1 If the ONLY speciﬁer appears on an IMPORT statement in a scoping unit other than a BLOCK construct,
           an entity is only accessible by host association if its name appears as an import-name in that scoping unit. If
           a BLOCK construct contains one or more IMPORT statements with ONLY speciﬁers, identiﬁers of local and
           construct entities in the host scoping unit that are not in the import-name-list of at least one of the IMPORT
           statements are inaccessible in the BLOCK construct.
         2 AnIMPORT,NONEstatementinascoping unit speciﬁes that no entities in the host scoping unit are accessible
           by host association in that scoping unit. This is the default for an interface body for an external or dummy
           procedure. An IMPORT, NONE statement in a BLOCK construct speciﬁes that the identiﬁers of local and
           construct entities in the host scoping unit are inaccessible in the BLOCK construct.
         3 AnIMPORT,ALLstatementinascoping unit speciﬁes that all entities from the host scoping unit are accessible
           in that scoping unit.
         4 If an IMPORT statement with no speciﬁer and no import-name-list appears in a scoping unit, every entity in
           the host scoping unit is accessible unless its name appears in a context described in 19.5.1.4 that causes it to be
           inaccessible. This is the default for a nested scoping unit other than an interface body for an external or dummy
           procedure.
         5 If an IMPORT statement with an import-name-list appears in a scoping unit other than a BLOCK construct,
           each entity named in the list is accessible.
               NOTE8.42
               The IMPORT, NONE statement can be used to prevent accidental host association:
                 SUBROUTINE s(x,n)
                   IMPLICIT NONE
                   IMPORT, NONE
                   ...
                   DO i=1,n ! Forces I to be locally declared.
               NOTE8.43
               TheIMPORT,ALLstatementcanbeusedtoconﬁrmthedefaultrules and prevent accidental “shadowing”
               of host entities:
                   SUBROUTINE outer
                      REAL x
                      ...
                    CONTAINS
                      SUBROUTINE inner
            c
           ISO/IEC 2017 – All rights reserved                                                  121
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE8.43 (cont.)
                         IMPORT, ALL
                         ...
                         x = x + 1 ! X was prevented from being locally declared...
                                   ! so this is the host X.
                NOTE8.44
                The IMPORT, ONLY statement can be used to document deliberate access via host association whilst
                blocking accidental access:
                     SUBROUTINE sub
                       IMPORT,ONLY : x, y
                       ...
                       x = y + z ! Only X and Y are imported, so Z is local.
                NOTE8.45
                The program
                       PROGRAM MAIN
                         BLOCK
                           IMPORT, NONE
                           !IMPORT, ONLY: X
                           X = 1.0
                         END BLOCK
                       END
                is not conformant. The variable X is implicitly declared in the scoping unit of the main program. The
                statement IMPORT, NONE makes X inaccessible in the BLOCK construct. If the IMPORT, NONE
                statement is replaced with the IMPORT statement in the comment, the program is conformant.
                NOTE8.46
                The IMPORT statement can be used to allow module procedures to have dummy arguments that are
                procedures with assumed-shape arguments of an opaque type. For example:
                MODULE M
                  TYPE T
                    PRIVATE    ! T is an opaque type
                    ...
                  END TYPE
                CONTAINS
                  SUBROUTINE PROCESS(X,Y,RESULT,MONITOR)
                    TYPE(T),INTENT(IN) :: X(:,:),Y(:,:)
                    TYPE(T),INTENT(OUT) :: RESULT(:,:)
                    INTERFACE
                      SUBROUTINE MONITOR(ITERATION_NUMBER,CURRENT_ESTIMATE)
                        IMPORT T
                        INTEGER,INTENT(IN) :: ITERATION_NUMBER
                        TYPE(T),INTENT(IN) :: CURRENT_ESTIMATE(:,:)
                      END SUBROUTINE
                    END INTERFACE
                    ...
                  END SUBROUTINE
                END MODULE
                                                                  c
            122                                                  ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                     NOTE8.46 (cont.)
                     The MONITOR dummy procedure requires an explicit interface because it has an assumed-shape array
                     argument, but TYPE(T) would not be available inside the interface body without the IMPORT statement.
                8.9      NAMELIST statement
            1 ANAMELISTstatement speciﬁes a group of named data objects, which may be referred to by a single name for
                the purpose of data transfer (12.6, 13.11).
                R868     namelist-stmt                    is  NAMELIST
                                                                  / namelist-group-name / namelist-group-object-list
                                                                  [ [ , ] / namelist-group-name /
                                                                  namelist-group-object-list ] ...
                C8102 (R868) The namelist-group-name shall not be a name accessed by use association.
                R869     namelist-group-object            is  variable-name
                C8103 (R869) A namelist-group-object shall not be an assumed-size array.
                C8104 (R868) A namelist-group-object shall not have the PRIVATE attribute if the namelist-group-name has
                         the PUBLIC attribute.
            2 The order in which the values appear on output is the same as the order of the namelist-group-objects in the
                namelist group object list; if a variable appears more than once as a namelist-group-object for the same namelist
                group, its value appears once for each occurrence.
            3 Any namelist-group-name may occur more than once in the NAMELIST statements in a scoping unit. The
                namelist-group-object-list following each successive appearance of the same namelist-group-name in a scoping
                unit is treated as a continuation of the list for that namelist-group-name.
            4 Anamelist group object may be a member of more than one namelist group.
            5 A namelist group object shall either be accessed by use or host association or shall have its declared type, kind
                type parameters of the declared type, and rank speciﬁed by previous speciﬁcation statements or the procedure
                heading in the same scoping unit or by the implicit typing rules in eﬀect for the scoping unit. If a namelist group
                object is typed by the implicit typing rules, its appearance in any subsequent type declaration statement shall
                conﬁrm the implied type and type parameters.
                     NOTE8.47
                     An example of a NAMELIST statement is:
                     NAMELIST /NLIST/ A, B, C
                8.10       Storage association of data objects
                8.10.1      EQUIVALENCE statement
                8.10.1.1    General
            1 AnEQUIVALENCEstatement is used to specify the sharing of storage units by two or more objects in a scoping unit. This causes
                storage association (19.5.3) of the objects that share the storage units.
            2 If the equivalenced objects have diﬀering type or type parameters, the EQUIVALENCE statement does not cause type conversion or
                imply mathematical equivalence. If a scalar and an array are equivalenced, the scalar does not have array properties and the array
                does not have the properties of a scalar.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       123
                  ISO/IEC DIS 1539-1:2017 (E)
                  R870       equivalence-stmt                       is   EQUIVALENCEequivalence-set-list
                  R871       equivalence-set                        is   ( equivalence-object , equivalence-object-list )
                  R872       equivalence-object                     is   variable-name
                                                                    or   array-element
                                                                    or   substring
                  C8105      (R872) An equivalence-object shall not be a designator with a base object that is a dummy argument, a function result,
                             a pointer, an allocatable variable, a derived-type object that has an allocatable or pointer ultimate component, an object
                             of a nonsequence derived type, an automatic data object, a coarray, a variable with the BIND attribute, a variable in a
                             common block that has the BIND attribute, or a named constant.
                  C8106      (R872) An equivalence-object shall not be a designator that has more than one part-ref.
                  C8107      (R872) An equivalence-object shall not have the TARGET attribute.
                  C8108      (R872) Each subscript or substring range expression in an equivalence-object shall be an integer constant expression
                             (10.1.12).
                  C8109      (R871) If an equivalence-object is default integer, default real, double precision real, default complex, default logical, or of
                             numeric sequence type, all of the objects in the equivalence set shall be of these types and kinds.
                  C8110      (R871) If an equivalence-object is default character or of character sequence type, all of the objects in the equivalence set
                             shall be of these types and kinds.
                  C8111      (R871) If an equivalence-object is of a sequence type that is not a numeric sequence or character sequence type, all of the
                             objects in the equivalence set shall be of that type.
                  C8112      (R871) If an equivalence-object is of an intrinsic type but is not default integer, default real, double precision real, default
                             complex, default logical, or default character, all of the objects in the equivalence set shall be of the same type with the
                             same kind type parameter value.
                  C8113      (R872) If an equivalence-object has the PROTECTED attribute, all of the objects in the equivalence set shall have the
                             PROTECTEDattribute.
                  C8114      (R872) The name of an equivalence-object shall not be a name made accessible by use association.
                  C8115      (R872) A substring shall not have length zero.
                         NOTE8.48
                         The EQUIVALENCE statement allows the equivalencing of sequence structures and the equivalencing of objects of intrinsic
                         type with nondefault type parameters, but there are strict rules regarding the appearance of these objects in an EQUIVAL-
                         ENCEstatement.
                         In addition to the above constraints, further rules on the interaction of EQUIVALENCE statements and default initialization
                         are given in 19.5.3.4.
                  8.10.1.2       Equivalence association
              1 AnEQUIVALENCEstatement speciﬁes that the storage sequences (19.5.3.2) of the data objects speciﬁed in an equivalence-set are
                  storage associated. All of the nonzero-sized sequences in the equivalence-set, if any, have the same ﬁrst storage unit, and all of
                  the zero-sized sequences in the equivalence-set, if any, are storage associated with one another and with the ﬁrst storage unit of
                  any nonzero-sized sequences. This causes the storage association of the data objects in the equivalence-set and may cause storage
                  association of other data objects.
              2 If any data object in an equivalence-set has the SAVE attribute, all other objects in the equivalence-set have the SAVE attribute;
                  this may be conﬁrmed by explicit speciﬁcation.
                  8.10.1.3       Equivalence of default character objects
              1 Adefault character data object shall not be equivalenced to an object that is not default character and not of a character sequence
                  type. The lengths of equivalenced default character objects need not be the same.
              2 AnEQUIVALENCEstatementspeciﬁesthatthestoragesequencesofallthedefaultcharacterdataobjectsspeciﬁedinanequivalence-
                  set are storage associated. All of the nonzero-sized sequences in the equivalence-set, if any, have the same ﬁrst character storage unit,
                  and all of the zero-sized sequences in the equivalence-set, if any, are storage associated with one another and with the ﬁrst character
                  storage unit of any nonzero-sized sequences. This causes the storage association of the data objects in the equivalence-set and may
                  cause storage association of other data objects.
                                                                                                         c
                  124                                                                                   ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                 NOTE8.49
                 For example, using the declarations:
                        CHARACTER (LEN = 4) :: A, B
                        CHARACTER (LEN = 3) :: C (2)
                        EQUIVALENCE (A, C (1)), (B, C (2))
                 the association of A, B, and C can be illustrated graphically as:
                          1     2     3      4     5     6      7
                        |---   --- A ---    ---|
                                           |---   --- B ---    ---|
                        |---   C(1)  ---|  |---   C(2)  ---|
             8.10.1.4  Array names and array element designators
          1 For a nonzero-sized array, the use of the array name unqualiﬁed by a subscript list as an equivalence-object has the same eﬀect as
             using an array element designator that identiﬁes the ﬁrst element of the array.
             8.10.1.5  Restrictions on EQUIVALENCE statements
          1 AnEQUIVALENCEstatement shall not specify that the same storage unit is to occur more than once in a storage sequence.
          2 AnEQUIVALENCEstatement shall not specify that consecutive storage units are to be nonconsecutive.
             8.10.2    COMMONstatement
             8.10.2.1  General
          1 The COMMON statement speciﬁes blocks of physical storage, called common blocks, that can be accessed by any of the scoping
             units in a program. Thus, the COMMON statement provides a global data facility based on storage association (19.5.3).
          2 Acommonblock that does not have a name is called blank common.
             R873    common-stmt               is  COMMON
                                                      [ / [ common-block-name ] / ] common-block-object-list
                                                      [ [ , ] / [ common-block-name ] /
                                                      common-block-object-list ] ...
             R874    common-block-object       is  variable-name [ ( array-spec ) ]
             C8116   (R874) An array-spec in a common-block-object shall be an explicit-shape-spec-list.
             C8117   (R874) Only one appearance of a given variable-name is permitted in all common-block-object-lists within a scoping unit.
             C8118   (R874) A common-block-object shall not be a dummy argument, a function result, an allocatable variable, a derived-type
                     object with an ultimate component that is allocatable, a procedure pointer, an automatic data object, a variable with the
                     BIND attribute, an unlimited polymorphic pointer, or a coarray.
             C8119   (R874) If a common-block-object is of a derived type, the type shall have the BIND attribute or the SEQUENCE attribute
                     and it shall have no default initialization.
             C8120   (R874) A variable-name shall not be a name made accessible by use association.
          3 In each COMMON statement, the data objects whose names appear in a common block object list following a common block name
             are declared to be in that common block. If the ﬁrst common block name is omitted, all data objects whose names appear in the
             ﬁrst common block object list are speciﬁed to be in blank common. Alternatively, the appearance of two slashes with no common
             block name between them declares the data objects whose names appear in the common block object list that follows to be in blank
             common.
          4 AnycommonblocknameoranomittedcommonblocknameforblankcommonmayoccurmorethanonceinoneormoreCOMMON
             statements in a scoping unit. The common block list following each successive appearance of the same common block name in a
             scoping unit is treated as a continuation of the list for that common block name. Similarly, each blank common block object list in
             a scoping unit is treated as a continuation of blank common.
          5 The form variable-name (array-spec) speciﬁes the DIMENSION attribute for that variable.
          6 If derived-type objects of numeric sequence type or character sequence type (7.5.2.3) appear in common, it is as if the individual
             components were enumerated directly in the common list.
             c
             ISO/IEC 2017 – All rights reserved                                                                 125
             ISO/IEC DIS 1539-1:2017 (E)
             8.10.2.2   Common block storage sequence
          1 For each common block in a scoping unit, a common block storage sequence is formed as follows:
                   (1)   Astorage sequence is formed consisting of the sequence of storage units in the storage sequences (19.5.3.2) of all data
                         objects in the common block object lists for the common block. The order of the storage sequences is the same as the
                         order of the appearance of the common block object lists in the scoping unit.
                   (2)   The storage sequence formed in (1) is extended to include all storage units of any storage sequence associated with it
                         by equivalence association. The sequence shall be extended only by adding storage units beyond the last storage unit.
                         Data objects associated with an entity in a common block are considered to be in that common block.
          2 Only COMMON statements and EQUIVALENCE statements appearing in the scoping unit contribute to common block storage
             sequences formed in that scoping unit.
             8.10.2.3   Size of a common block
          1 Thesize of a common block is the size of its common block storage sequence, including any extensions of the sequence resulting from
             equivalence association.
             8.10.2.4   Common association
          1 Within a program, the common block storage sequences of all nonzero-sized common blocks with the same name have the same ﬁrst
             storage unit, and the common block storage sequences of all zero-sized common blocks with the same name are storage associated
             with one another. Within a program, the common block storage sequences of all nonzero-sized blank common blocks have the same
             ﬁrst storage unit and the storage sequences of all zero-sized blank common blocks are associated with one another and with the ﬁrst
             storage unit of any nonzero-sized blank common blocks. This results in the association of objects in diﬀerent scoping units. Use or
             host association may cause these associated objects to be accessible in the same scoping unit.
          2 Anonpointerobject that is default integer, default real, double precision real, default complex, default logical, or of numeric sequence
             type shall be associated only with nonpointer objects of these types and kinds.
          3 Anonpointer object that is default character or of character sequence type shall be associated only with nonpointer objects of these
             types and kinds.
          4 A nonpointer object of a derived type that is not a numeric sequence or character sequence type shall be associated only with
             nonpointer objects of the same type.
          5 A nonpointer object of intrinsic type but which is not default integer, default real, double precision real, default complex, default
             logical, or default character shall be associated only with nonpointer objects of the same type and type parameters.
          6 A data pointer shall be storage associated only with data pointers of the same type and rank. Data pointers that are storage
             associated shall have deferred the same type parameters; corresponding nondeferred type parameters shall have the same value.
          7 Anobject with the TARGET attribute shall be storage associated only with another object that has the TARGET attribute and the
             same type and type parameters.
                  NOTE8.50
                  A common block is permitted to contain sequences of diﬀerent storage units, provided each scoping unit that accesses the
                  commonblock speciﬁes an identical sequence of storage units for the common block. For example, this allows a single common
                  block to contain both numeric and character storage units.
                  Association in diﬀerent scoping units between objects of default type, objects of double precision real type, and sequence
                  structures is permitted according to the rules for equivalence objects (8.10.1).
             8.10.2.5   Diﬀerences between named common and blank common
          1 Ablank common block has the same properties as a named common block, except for the following.
                 • Execution of a RETURN or END statement might cause data objects in a named common block to become undeﬁned unless
                   the common block has the SAVE attribute, but never causes nonpointer data objects in blank common to become undeﬁned
                   (19.6.6).
                 • Named common blocks of the same name shall be of the same size in all scoping units of a program in which they appear, but
                   blank common blocks may be of diﬀerent sizes.
                 • Adataobject in a named common block may be initially deﬁned by means of a DATA statement or type declaration statement
                   in a block data program unit (14.3), but objects in blank common shall not be initially deﬁned.
             8.10.3     Restrictions on common and equivalence
          1 AnEQUIVALENCEstatement shall not cause the storage sequences of two diﬀerent common blocks to be associated.
                                                                            c
             126                                                           ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
        2 Equivalence association shall not cause a derived-type object with default initialization to be associated with an object in a common
          block.
        3 Equivalence association shall not cause a common block storage sequence to be extended by adding storage units preceding the ﬁrst
          storage unit of the ﬁrst object speciﬁed in a COMMON statement for the common block.
          c
          ISO/IEC 2017 – All rights reserved                                         127
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      128                          ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                9 Use of data objects
                9.1      Designator
                R901     designator                       is  object-name
                                                          or array-element
                                                          or array-section
                                                          or coindexed-named-object
                                                          or complex-part-designator
                                                          or structure-component
                                                          or substring
            1 The appearance of a data object designator in a context that requires its value is termed a reference.
                9.2      Variable
                R902     variable                         is  designator
                                                          or function-reference
                C901     (R902) designator shall not be a constant or a subobject of a constant.
                C902     (R902) function-reference shall have a data pointer result.
            1 Avariableiseither the data object denoted by designator or the target of the pointer resulting from the evaluation
                of function-reference; this pointer shall be associated.
            2 A reference is permitted only if the variable is deﬁned. A reference to a data pointer is permitted only if the
                pointer is associated with a target object that is deﬁned. A variable becomes deﬁned with a value when events
                described in 19.6.5 occur.
                R903     variable-name                    is  name
                C903     (R903) variable-name shall be the name of a variable.
                R904     logical-variable                 is  variable
                C904     (R904) logical-variable shall be of type logical.
                R905     char-variable                    is  variable
                C905     (R905) char-variable shall be of type character.
                R906     default-char-variable            is  variable
                C906     (R906) default-char-variable shall be default character.
                R907     int-variable                     is  variable
                C907     (R907) int-variable shall be of type integer.
                     NOTE9.1
                     For example, given the declarations:
                               CHARACTER (10) A, B (10)
                               TYPE (PERSON)       P             ! See NOTE 7.15
                     then A, B, B (1), B (1:5), P % AGE, and A (1:1) are all variables.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       129
           ISO/IEC DIS 1539-1:2017 (E)
           9.3    Constants
         1 Aconstant (6.2.3) is a literal constant or a named constant. A literal constant is a scalar denoted by a syntactic
           form, which indicates its type, type parameters, and value. A named constant is a constant that has a name; the
           namehasthePARAMETERattribute(8.5.13, 8.6.11). A reference to a constant is always permitted; redeﬁnition
           of a constant is never permitted.
           9.4    Scalars
           9.4.1   Substrings
         1 Asubstring is a contiguous portion of a character string (7.4.4).
           R908   substring               is parent-string ( substring-range )
           R909   parent-string           is scalar-variable-name
                                          or array-element
                                          or coindexed-named-object
                                          or scalar-structure-component
                                          or scalar-constant
           R910   substring-range         is [ scalar-int-expr ] : [ scalar-int-expr ]
           C908   (R909) parent-string shall be of type character.
         2 The value of the ﬁrst scalar-int-expr in substring-range is the starting point of the substring and the value of
           the second one is the ending point of the substring. The length of a substring is the number of characters in the
           substring and is MAX (l −f +1, 0), where f and l are the starting and ending points, respectively.
         3 Let the characters in the parent string be numbered 1, 2, 3, ..., n, where n is the length of the parent string.
           Then the characters in the substring are those from the parent string from the starting point and proceeding in
           sequence up to and including the ending point. If the starting point is greater than the ending point, the substring
           has length zero; otherwise, both the starting point and the ending point shall be within the range 1, 2, ..., n. If
           the starting point is not speciﬁed, the default value is 1. If the ending point is not speciﬁed, the default value is
           n.
               NOTE9.2
               Examples of character substrings are:
                    B(1)(1:5)            array element as parent string
                    P%NAME(1:1)          structure component as parent string
                    ID(4:9)              scalar variable name as parent string
                    ’0123456789’(N:N)    character constant as parent string
           9.4.2   Structure components
         1 A structure component is part of an object of derived type; it may be referenced by an object designator. A
           structure component may be a scalar or an array.
           R911   data-ref                is part-ref [ % part-ref ] ...
           R912   part-ref                is part-name [ ( section-subscript-list ) ] [ image-selector ]
           C909   (R911) Each part-name except the rightmost shall be of derived type.
           C910   (R911) Each part-name except the leftmost shall be the name of a component of the declared type of the
                  preceding part-name.
                                                                c
           130                                                  ISO/IEC 2017 – All rights reserved
                                                                      ISO/IEC DIS 1539-1:2017 (E)
           C911   (R911) If the rightmost part-name is of abstract type, data-ref shall be polymorphic.
           C912   (R911) The leftmost part-name shall be the name of a data object.
           C913   (R912) If a section-subscript-list appears, the number of section-subscripts shall equal the rank of part-
                  name.
           C914   (R912) If image-selector appears, the number of cosubscripts shall be equal to the corank of part-name.
           C915   A data-ref shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BIND-
                  ING(18.2), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2), if one
                  of its part-refs has an image-selector.
           C916   (R912) If image-selector appears and part-name is an array, section-subscript-list shall appear.
           C917   (R911) Except as an actual argument to an intrinsic inquiry function or as the designator in a type
                  parameter inquiry, a data-ref shall not be a coindexed object that has a polymorphic allocatable potential
                  subobject component.
           C918   Except as an actual argument to an intrinsic inquiry function or as the designator in a type parameter
                  inquiry, if the rightmost part-ref is polymorphic, no other part-ref shall be coindexed.
         2 The rank of a part-ref of the form part-name is the rank of part-name. The rank of a part-ref that has a section
           subscript list is the number of subscript triplets and vector subscripts in the list.
           C919   (R911) There shall not be more than one part-ref with nonzero rank. A part-name to the right of a
                  part-ref with nonzero rank shall not have the ALLOCATABLE or POINTER attribute.
         3 The rank of a data-ref is the rank of the part-ref with nonzero rank, if any; otherwise, the rank is zero. The base
           object of a data-ref is the data object whose name is the leftmost part name.
         4 The type and type parameters, if any, of a data-ref are those of the rightmost part name.
         5 A data-ref with more than one part-ref is a subobject of its base object if none of the part-names, except for
           possibly the rightmost, is a pointer. If the rightmost part-name is the only pointer, then the data-ref is a subobject
           of its base object in contexts that pertain to its pointer association status but not in any other contexts.
               NOTE9.3
               If X is an object of derived type with a pointer component P, then the pointer X%P is a subobject of X
               when considered as a pointer – that is in contexts where it is not dereferenced.
               However the target of X%P is not a subobject of X. Thus, in contexts where X%P is dereferenced to refer
               to the target, it is not a subobject of X.
           R913   structure-component   is  data-ref
           C920   (R913)Thereshallbemorethanonepart-ref andtherightmostpart-ref shallnothaveasection-subscript-
                  list.
         6 A structure component shall be neither referenced nor deﬁned before the declaration of the base object. A
           structure component is a pointer only if the rightmost part name has the POINTER attribute.
               NOTE9.4
               Examples of structure components are:
                      SCALAR_PARENT%SCALAR_FIELD     scalar component of scalar parent
                      ARRAY_PARENT(J)%SCALAR_FIELD   component of array element parent
                      ARRAY_PARENT(1:N)%SCALAR_FIELD component of array section parent
               For a more elaborate example see C.4.1.
            c
           ISO/IEC 2017 – All rights reserved                                                  131
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE9.5
                  The syntax rules are structured such that a data-ref that ends in a component name without a following
                  subscript list is a structure component, even when other component names in the data-ref are followed by
                  a subscript list. A data-ref that ends in a component name with a following subscript list is either an array
                  element or an array section. A data-ref of nonzero rank that ends with a substring-range is an array section.
                  Adata-ref of zero rank that ends with a substring-range is a substring.
             9.4.3    Coindexed named objects
           1 Acoindexed-named-object is a named scalar coarray variable followed by an image selector.
             R914    coindexed-named-object       is  data-ref
             C921    (R914) The data-ref shall contain exactly one part-ref. The part-ref shall contain an image-selector.
                     The part-name shall be the name of a scalar coarray.
             9.4.4    Complex parts
             R915    complex-part-designator      is  designator % RE
                                                  or designator % IM
             C922    (R915) The designator shall be of complex type.
           1 If complex-part-designator is designator%RE it designates the real part of designator. If it is designator%IM
             it designates the imaginary part of designator. The type of a complex-part-designator is real, and its kind and
             shape are those of the designator, which can be an array or scalar.
                  NOTE9.6
                  The following are examples of complex part designators:
                      impedance%re         !-- Same value as REAL(impedance)
                      fft%im               !-- Same value as AIMAG(fft)
                      x%im = 0.0           !-- Sets the imaginary part of X to zero
             9.4.5    Type parameter inquiry
           1 Atype parameter inquiry is used to inquire about a type parameter of a data object. It applies to both intrinsic
             and derived types.
             R916    type-param-inquiry           is  designator % type-param-name
             C923    (R916) The type-param-name shall be the name of a type parameter of the declared type of the object
                     designated by the designator.
           2 A deferred type parameter of a pointer that is not associated or of an unallocated allocatable variable shall not
             be inquired about.
                  NOTE9.7
                  Atype-param-inquiry has a syntax like that of a structure component reference, but it does not have the
                  same semantics. It is not a variable and thus can never be assigned to. It can be used only as a primary in
                  an expression. It is scalar even if designator is an array.
                  The intrinsic type parameters can also be inquired about by using the intrinsic functions KIND and LEN.
                                                                             c
             132                                                            ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE9.8
                The following are examples of type parameter inquiries:
                     a%kind      !-- A is real.  Same value as KIND(a).
                     s%len       !-- S is character.  Same value as LEN(s).
                     b(10)%kind  !-- Inquiry about an array element.
                     p%dim       !-- P is of the derived type general_point.
                See NOTE 7.22 for the deﬁnition of the general_point type used in the last example above.
            9.5   Arrays
            9.5.1  Order of reference
         1 No order of reference to the elements of an array is indicated by the appearance of the array designator, except
            where array element ordering (9.5.3.2) is speciﬁed.
            9.5.2  Whole arrays
         1 A whole array is a named array or a structure component whose ﬁnal part-ref is an array component name; no
            subscript list is appended.
         2 Theappearance of a whole array variable in an executable construct speciﬁes all the elements of the array (5.4.6).
            The appearance of a whole array designator in a nonexecutable statement speciﬁes the entire array except for the
            appearance of a whole array designator in an equivalence set (8.10.1.4). An assumed-size array (8.5.8.5) is permitted to
            appear as a whole array in an executable construct or speciﬁcation expression only as an actual argument in a
            procedure reference that does not require the shape.
            9.5.3  Array elements and array sections
            9.5.3.1 Syntax
            R917  array-element            is data-ref
            C924  (R917) Every part-ref shall have rank zero and the last part-ref shall contain a subscript-list.
            R918  array-section            is data-ref [ ( substring-range ) ]
                                           or complex-part-designator
            C925  (R918) Exactly one part-ref shall have nonzero rank, and either the ﬁnal part-ref shall have a section-
                  subscript-list with nonzero rank, another part-ref shall have nonzero rank, or the complex-part-designator
                  shall be an array.
            C926  (R918) If a substring-range appears, the rightmost part-name shall be of type character.
            R919  subscript                is scalar-int-expr
            R920  section-subscript        is subscript
                                           or subscript-triplet
                                           or vector-subscript
            R921  subscript-triplet        is [ subscript ] : [ subscript ] [ : stride ]
            R922  stride                   is scalar-int-expr
            R923  vector-subscript         is int-expr
            c
            ISO/IEC 2017 – All rights reserved                                                      133
            ISO/IEC DIS 1539-1:2017 (E)
            C927  (R923) A vector-subscript shall be an integer array expression of rank one.
            C928  (R921) The second subscript shall not be omitted from a subscript-triplet in the last dimension of an
                  assumed-size array.
         1 An array element is a scalar. An array section is an array. If a substring-range appears in an array-section, each
            element is the designated substring of the corresponding element of the array section.
         2 The value of a subscript in an array element shall be within the bounds for its dimension.
                NOTE9.9
                For example, with the declarations:
                REAL A (10, 10)
                CHARACTER (LEN = 10) B (5, 5, 5)
                A(1, 2) is an array element, A (1:N:2, M) is a rank-one array section, and B (:, :, :) (2:3) is an array of
                shape (5, 5, 5) whose elements are substrings of length 2 of the corresponding elements of B.
                NOTE9.10
                Unless otherwise speciﬁed, an array element or array section does not have an attribute of the whole array.
                In particular, an array element or an array section does not have the POINTER or ALLOCATABLE
                attribute.
                NOTE9.11
                Examples of array elements and array sections are:
                     ARRAY_A(1:N:2)%ARRAY_B(I, J)%STRING(K)(:)     array section
                     SCALAR_PARENT%ARRAY_FIELD(J)                  array element
                     SCALAR_PARENT%ARRAY_FIELD(1:N)                array section
                     SCALAR_PARENT%ARRAY_FIELD(1:N)%SCALAR_FIELD   array section
            9.5.3.2 Array element order
         1 The elements of an array form a sequence known as the array element order. The position of an array element
            in this sequence is determined by the subscript order value of the subscript list designating the element. The
            subscript order value is computed from the formulas in Table 9.1.
                                           Table 9.1: Subscript order value
                           Rank    Subscript bounds   Subscript list  Subscript order value
                           1       j :k               s               1+(s −j )
                                    1 1                1                   1   1
                                                                      1+(s −j )
                           2       j :k ,j :k         s ,s                 1   1
                                    1 1 2 2            1  2           +(s −j )×d
                                                                          2   2    1
                                                                      1+(s −j )
                           3       j :k ,j :k ,j :k   s ,s ,s              1   1
                                    1 1  2 2 3  3      1  2 3         +(s −j )×d
                                                                          2   2    1
                                                                      +(s −j )×d ×d
                                                                          3   3    2   1
                           ·        ·                   ·                ·
                           ·        ·                   ·                ·
                           ·        ·                   ·                ·
                                                                      1+(s −j )
                                                                           1   1
                                                                      +(s −j )×d
                                                                          2   2    1
                                                                      +(s −j )×d ×d
                           15      j1:k1,...,j15:k15  s1,...,s15          3   3    2   1
                                                                      +...
                                                                      +(s −j )×d
                                                                          15  15    14
                                                                      ×d13 ×...×d1
                                                                  c
            134                                                  ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
                                                 Subscript order value                       (cont.)
                              Rank    Subscript bounds      Subscript list    Subscript order value
                              Notes for Table 9.1:
                                      1) d = max (k −j +1, 0) is the size of the ith dimension.
                                         i         i   i
                                      2) If the size of the array is nonzero, j ≤ s ≤ k for all
                                      i = 1, 2, ..., 15.                  i    i    i
             9.5.3.3  Array sections
          1 In an array-section having a section-subscript-list, each subscript-triplet and vector-subscript in the section sub-
             script list indicates a sequence of subscripts, which may be empty. Each subscript in such a sequence shall be
             within the bounds for its dimension unless the sequence is empty. The array section is the set of elements from
             the array determined by all possible subscript lists obtainable from the single subscripts or sequences of subscripts
             speciﬁed by each section subscript.
          2 In an array-section with no section-subscript-list, the rank and shape of the array is the rank and shape of the
             part-ref with nonzero rank; otherwise, the rank of the array section is the number of subscript triplets and vector
             subscripts in the section subscript list. The shape is the rank-one array whose ith element is the number of
             integer values in the sequence indicated by the ith subscript triplet or vector subscript. If any of these sequences
             is empty, the array section has size zero. The subscript order of the elements of an array section is that of the
             array data object that the array section represents.
             9.5.3.3.1 Subscript triplet
          1 A subscript triplet designates a regular sequence of subscripts consisting of zero or more subscript values. The
             stride in the subscript triplet speciﬁes the increment between the subscript values. The subscripts and stride of a
             subscript triplet are optional. An omitted ﬁrst subscript in a subscript triplet is equivalent to a subscript whose
             value is the lower bound for the array and an omitted second subscript is equivalent to the upper bound. An
             omitted stride is equivalent to a stride of 1.
          2 The stride shall not be zero.
          3 When the stride is positive, the subscripts speciﬁed by a triplet form a regularly spaced sequence of integers
             beginning with the ﬁrst subscript and proceeding in increments of the stride to the largest such integer not
             greater than the second subscript; the sequence is empty if the ﬁrst subscript is greater than the second.
                 NOTE9.12
                 For example, suppose an array is declared as A (5, 4, 3). The section A (3 : 5, 2, 1 : 2) is the array of shape
                 (3, 2):
                 A (3, 2, 1)       A (3, 2, 2)
                 A (4, 2, 1)       A (4, 2, 2)
                 A (5, 2, 1)       A (5, 2, 2)
          4 Whenthe stride is negative, the sequence begins with the ﬁrst subscript and proceeds in increments of the stride
             down to the smallest such integer equal to or greater than the second subscript; the sequence is empty if the
             second subscript is greater than the ﬁrst.
                 NOTE9.13
                 For example, if an array is declared B (10), the section B (9 : 1 : −2) is the array of shape (5) whose
                 elements are B (9), B (7), B (5), B (3), and B (1), in that order.
             c
             ISO/IEC 2017 – All rights reserved                                                                135
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE9.14
                   Asubscript in a subscript triplet need not be within the declared bounds for that dimension if all values
                   used in selecting the array elements are within the declared bounds.
                   For example, if an array is declared as B (10), the array section B (3 : 11 : 7) is the array of shape (2)
                   consisting of the elements B (3) and B (10), in that order.
              9.5.3.3.2  Vector subscript
           1 Avectorsubscriptdesignatesasequenceofsubscriptscorrespondingtothevaluesoftheelementsoftheexpression.
              Each element of the expression shall be deﬁned.
           2 An array section with a vector subscript shall not be ﬁnalized by a nonelemental ﬁnal subroutine.
           3 If a vector subscript has two or more elements with the same value, an array section with that vector subscript
              is not deﬁnable and shall not be deﬁned or become undeﬁned.
                   NOTE9.15
                   For example, suppose Z is a two-dimensional array of shape [5, 7] and U and V are one-dimensional arrays
                   of shape (3) and (4), respectively. Assume the values of U and V are:
                   U = [ 1, 3, 2 ]
                   V = [ 2, 1, 1, 3 ]
                   Then Z (3, V) consists of elements from the third row of Z in the order:
                   Z (3, 2)     Z (3, 1)     Z (3, 1)     Z (3, 3)
                   and Z (U, 2) consists of the column elements:
                   Z (1, 2)     Z (3, 2)     Z (2, 2)
                   and Z (U, V) consists of the elements:
                   Z (1, 2)     Z (1, 1)     Z (1, 1)     Z (1, 3)
                   Z (3, 2)     Z (3, 1)     Z (3, 1)     Z (3, 3)
                   Z (2, 2)     Z (2, 1)     Z (2, 1)     Z (2, 3)
                   Because Z (3, V) and Z (U, V) contain duplicate elements from Z, the sections Z (3, V) and Z (U, V) shall
                   not be redeﬁned as sections.
              9.5.4    Simply contiguous array designators
           1 Asection-subscript-list speciﬁes a simply contiguous section if and only if it does not have a vector subscript and
                 • all but the last subscript-triplet is a colon,
                 • the last subscript-triplet does not have a stride, and
                 • no subscript-triplet is preceded by a section-subscript that is a subscript.
           2 An array designator is simply contiguous if and only if it is
                 • an object-name that has the CONTIGUOUS attribute,
                 • an object-name that is not a pointer, not assumed-shape, and not assumed-rank,
                 • a structure-component whose ﬁnal part-name is an array and that either has the CONTIGUOUS attribute
                   or is not a pointer, or
                                                                              c
              136                                                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
              • an array section
                  – that is not a complex-part-designator,
                  – that does not have a substring-range,
                  – whose ﬁnal part-ref has nonzero rank,
                  – whoserightmostpart-name hastheCONTIGUOUSattributeorisneitherassumed-shapenorapointer,
                     and
                  – which either does not have a section-subscript-list, or has a section-subscript-list which speciﬁes a
                     simply contiguous section.
         3 An array variable is simply contiguous if and only if it is a simply contiguous array designator or a reference to
            a function that returns a pointer with the CONTIGUOUS attribute.
                NOTE9.16
                Array sections that are simply contiguous include column, plane, cube, and hypercube subobjects of a
                simply contiguous base object, for example:
                   ARRAY1 (10:20, 3)   ! passes part of the third column of ARRAY1.
                   X3D (:, i:j, 2)     ! passes part of the second plane of X3D (or the whole
                                       ! plane if i==LBOUND(X3D,2) and j==UBOUND(X3D,2).
                   Y5D (:, :, :, :, 7) ! passes the seventh hypercube of Y5D.
                All simply contiguous designators designate contiguous objects.
            9.6   Image selectors
         1 An image selector determines the image index for a coindexed object.
            R924  image-selector           is lbracket cosubscript-list [ , image-selector-spec-list ] rbracket
            R925  cosubscript              is scalar-int-expr
            R926  image-selector-spec      is STAT = stat-variable
                                           or TEAM=team-value
                                           or TEAM_NUMBER=scalar-int-expr
            C929  No speciﬁer shall appear more than once in a given image-selector-spec-list.
            C930  TEAMandTEAM_NUMBERshallnotbothappear in the same image-selector-spec-list.
            C931  Astat-variable in an image-selector shall not be a coindexed object.
         2 The number of cosubscripts shall be equal to the corank of the object. The value of a cosubscript in an image
            selector shall be within the cobounds for its codimension. Taking account of the cobounds, the cosubscript list in
            an image selector determines the image index in the same way that a subscript list in an array element determines
            the subscript order value (9.5.3.2), taking account of the bounds.
         3 If a TEAM= speciﬁer appears in an image-selector, the team of the image selector is speciﬁed by team-value,
            which shall identify the current or an ancestor team; the object shall be an established coarray in that team
            or an ancestor thereof. If a TEAM_NUMBER= speciﬁer appears in an image-selector and the current team
            is not the initial team, the value of the scalar-int-expr shall be equal to the value of a team number for one of
            the teams that were formed by execution of the FORM TEAM statement for the current team and the team of
            the image selector is that team; the object shall be an established coarray in an ancestor of the current team,
            or an associating entity of the CHANGE TEAM construct. If a TEAM_NUMBER= speciﬁer appears in an
            image-selector and the current team is the initial team, the value of scalar-int-expr shall be the team number for
            the initial team; the object shall be an established coarray in the initial team. Otherwise, the team of the image
            selector is the current team.
            c
            ISO/IEC 2017 – All rights reserved                                                      137
              ISO/IEC DIS 1539-1:2017 (E)
           4 An image selector shall specify an image index value that is not greater than the number of images in the team
              of the image selector, and identiﬁes the image with that index in that team.
           5 Execution of a statement containing an image-selector with a STAT= speciﬁer causes the stat-variable to become
              deﬁned. If the designator is part of an operand that is evaluated or is a variable that is being deﬁned or partly
              deﬁned, and the object designated is on a failed image, the stat-variable is deﬁned with the value STAT_-
              FAILED_IMAGE (16.10.2.26) in the intrinsic module ISO_FORTRAN_ENV; otherwise, it is deﬁned with the
              value zero.
           6 The denotation of a stat-variable in an image-selector shall not depend on the evaluation of any entity in the
              same statement. The value of an expression shall not depend on the value of any stat-variable that appears in
              the same statement. The value of a stat-variable in an image-selector shall not be aﬀected by the execution of
              any part of the statement, other than by whether the image speciﬁed by the image-selector has failed.
                   NOTE9.17
                  For example, if there are 16 images and the coarray A is declared
                           REAL :: A(10)[5,*]
                  A(:)[1,4] is valid because it speciﬁes image 16, but A(:)[2,4] is invalid because it speciﬁes image 17.
              9.7     Dynamic association
              9.7.1    ALLOCATE statement
              9.7.1.1  Form of the ALLOCATE statement
           1 The ALLOCATE statement dynamically creates pointer targets and allocatable variables.
              R927    allocate-stmt               is  ALLOCATE([type-spec :: ] allocation-list
                                                         [ , alloc-opt-list ] )
              R928    alloc-opt                   is  ERRMSG=errmsg-variable
                                                  or MOLD=source-expr
                                                  or SOURCE=source-expr
                                                  or STAT = stat-variable
              R929    errmsg-variable             is  scalar-default-char-variable
              R930    source-expr                 is  expr
              R931    allocation                  is  allocate-object [ ( allocate-shape-spec-list ) ]
                                                         [ lbracket allocate-coarray-spec rbracket ]
              R932    allocate-object             is  variable-name
                                                  or structure-component
              R933    allocate-shape-spec         is  [ lower-bound-expr : ] upper-bound-expr
              R934    lower-bound-expr            is  scalar-int-expr
              R935    upper-bound-expr            is  scalar-int-expr
              R936    allocate-coarray-spec       is  [ allocate-coshape-spec-list , ] [ lower-bound-expr : ] *
              R937    allocate-coshape-spec       is  [ lower-bound-expr : ] upper-bound-expr
              C932    (R932) Each allocate-object shall be a data pointer or an allocatable variable.
                                                                              c
              138                                                            ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            C933  (R927) If any allocate-object has a deferred type parameter, is unlimited polymorphic, or is of abstract
                  type, either type-spec or source-expr shall appear.
            C934  (R927) If type-spec appears, it shall specify a type with which each allocate-object is type compatible.
            C935  (R927) A type-param-value in a type-spec shall be an asterisk if and only if each allocate-object is a dummy
                  argument for which the corresponding type parameter is assumed.
            C936  (R927) If type-spec appears, the kind type parameter values of each allocate-object shall be the same as
                  the corresponding type parameter values of the type-spec.
            C937  (R927) type-spec shall not specify a type that has a coarray ultimate component.
            C938  (R927) If an allocate-object is a coarray, type-spec shall not specify type C_PTR or C_FUNPTR from
                  the intrinsic module ISO_C_BINDING, or type TEAM_TYPE from the intrinsic module ISO_FOR-
                  TRAN_ENV.
            C939  (R927) If an allocate-object is an array, either allocate-shape-spec-list shall appear in its allocation, or
                  source-expr shall appear in the ALLOCATE statement and have the same rank as the allocate-object.
            C940  (R931) If allocate-object is scalar, allocate-shape-spec-list shall not appear.
            C941  (R931) An allocate-coarray-spec shall appear if and only if the allocate-object is a coarray.
            C942  (R931) The number of allocate-shape-specs in an allocate-shape-spec-list shall be the same as the rank
                  of the allocate-object. The number of allocate-coshape-specs in an allocate-coarray-spec shall be one less
                  than the corank of the allocate-object.
            C943  (R928) No alloc-opt shall appear more than once in a given alloc-opt-list.
            C944  (R927) At most one of source-expr and type-spec shall appear.
            C945  (R927) Each allocate-object shall be type compatible (7.3.2.3) with source-expr. If SOURCE= appears,
                  source-expr shall be a scalar or have the same rank as each allocate-object.
            C946  (R927) If source-expr appears, the kind type parameters of each allocate-object shall have the same values
                  as the corresponding type parameters of source-expr.
            C947  (R927) The declared type of source-expr shall not be C_PTR or C_FUNPTR from the intrinsic module
                  ISO_C_BINDING, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, if an allocate-
                  object is a coarray.
            C948  (R927) If SOURCE= appears, the declared type of source-expr shall not be EVENT_TYPE or LOCK_-
                  TYPE from the intrinsic module ISO_FORTRAN_ENV, or have a potential subobject component of
                  type EVENT_TYPE or LOCK_TYPE.
            C949  (R930) The declared type of source-expr shall not have a coarray ultimate component.
            C950  (R932) An allocate-object shall not be a coindexed object.
                NOTE9.18
                If a coarray is of a derived type that has an allocatable component, the component can only be allocated
                by its own image:
                       TYPE(SOMETHING), ALLOCATABLE ::  T[:]
                       ...
                       ALLOCATE(T[*])          !  Allowed - implies synchronization
                       ALLOCATE(T%AAC(N))      !  Allowed - allocated by its own image
                       ALLOCATE(T[Q]%AAC(N))   !  Not allowed, because it is not
                                               !  necessarily executed on image Q.
            c
            ISO/IEC 2017 – All rights reserved                                                      139
              ISO/IEC DIS 1539-1:2017 (E)
           2 Anallocate-object or a bound or type parameter of an allocate-object shall not depend on the value of stat-variable,
              the value of errmsg-variable, or on the value, bounds, length type parameters, allocation status, or association
              status of any allocate-object in the same ALLOCATE statement.
           3 source-expr shall not be allocated within the ALLOCATE statement in which it appears; nor shall it depend on
              the value, bounds, deferred type parameters, allocation status, or association status of any allocate-object in that
              statement.
           4 If an ALLOCATE statement has a SOURCE= speciﬁer and an allocate-object that is a coarray, source-expr
              shall not have a dynamic type of C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, or
              EVENT_TYPE, LOCK_TYPE, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, or have
              a subcomponent whose dynamic type is EVENT_TYPE, LOCK_TYPE, or TEAM_TYPE.
           5 If type-spec is speciﬁed, each allocate-object is allocated with the speciﬁed dynamic type and type parameter
              values; if source-expr is speciﬁed, each allocate-object is allocated with the dynamic type and type parameter
              values of source-expr; otherwise, each allocate-object is allocated with its dynamic type the same as its declared
              type.
           6 If a type-param-value in a type-spec in an ALLOCATE statement is an asterisk, it denotes the current value of
              that assumed type parameter. If it is an expression, subsequent redeﬁnition or undeﬁnition of any entity in the
              expression does not aﬀect the type parameter value.
                   NOTE9.19
                  An example of an ALLOCATE statement is:
                  ALLOCATE (X (N), B (-3 : M, 0:9), STAT = IERR_ALLOC)
              9.7.1.2  Execution of an ALLOCATE statement
           1 WhenanALLOCATEstatementisexecutedforanarrayforwhich allocate-shape-spec-list is speciﬁed, the values
              of the lower bound and upper bound expressions determine the bounds of the array. Subsequent redeﬁnition
              or undeﬁnition of any entities in the bound expressions do not aﬀect the array bounds. If the lower bound is
              omitted, the default value is 1. If the upper bound is less than the lower bound, the extent in that dimension is
              zero and the array has zero size.
           2 When an ALLOCATE statement is executed for a coarray, the values of the lower cobound and upper cobound
              expressions determine the cobounds of the coarray. Subsequent redeﬁnition or undeﬁnition of any entities in the
              cobound expressions do not aﬀect the cobounds. If the lower cobound is omitted, the default value is 1. The
              upper cobound shall not be less than the lower cobound.
           3 If an allocation speciﬁes a coarray, its dynamic type and the values of corresponding type parameters shall be the
              sameoneveryactive image in the current team. The values of corresponding bounds and corresponding cobounds
              shall be the same on those images. If the coarray is a dummy argument, its ultimate argument (15.5.2.3) shall
              be the same coarray on those images.
           4 When an ALLOCATE statement is executed for which an allocate-object is a coarray, there is an implicit syn-
              chronization of all active images in the current team. If the current team contains a stopped or failed image,
              an error condition occurs. If no other error condition occurs, execution on the active images of the segment
              (11.6.2) following the statement is delayed until all other active images in the current team have executed the
              same statement the same number of times in this team. The segments that executed before the ALLOCATE
              statement on an active image of this team precede the segments that execute after the ALLOCATE statement on
              another active image of this team. The coarray shall not become allocated on an image unless it is successfully
              allocated on all active images in this team.
                   NOTE9.20
                  Whenanimage executes an ALLOCATE statement, communication is not necessarily involved apart from
                  any required for synchronization.   The image allocates its coarray and records how the corresponding
                                                                              c
              140                                                            ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
                   NOTE9.20 (cont.)
                  coarrays on other images are to be addressed. The processor is not required to detect violations of the
                  rule that the bounds are the same on all images of the current team, nor is it responsible for detecting or
                  resolving deadlock problems (such as two images waiting on diﬀerent ALLOCATE statements.).
           5 If source-expr is a pointer, it shall be associated with a target. If source-expr is allocatable, it shall be allocated.
           6 When an ALLOCATE statement is executed for an array with no allocate-shape-spec-list, the bounds of source-
              expr determine the bounds of the array. Subsequent changes to the bounds of source-expr do not aﬀect the array
              bounds.
           7 If SOURCE= appears, source-expr shall be conformable with allocation. If an allocate-object is not polymorphic
              and the source-expr is polymorphic with a dynamic type that diﬀers from its declared type, the value provided for
              that allocate-object is the ancestor component of the source-expr that has the type of the allocate-object; otherwise
              the value provided is the value of the source-expr. On successful allocation, if allocate-object and source-expr
              have the same rank the value of allocate-object becomes the value provided, otherwise the value of each element
              of allocate-object becomes the value provided. The source-expr is evaluated exactly once for each execution of an
              ALLOCATEstatement.
           8 If MOLD= appears and source-expr is a variable, its value need not be deﬁned.
           9 If type-spec appears and the value of a length type parameter it speciﬁes diﬀers from the value of the corresponding
              nondeferred type parameter speciﬁed in the declaration of any allocate-object, an error condition occurs. If the
              value of a nondeferred length type parameter of an allocate-object diﬀers from the value of the corresponding type
              parameter of source-expr, an error condition occurs.
          10 The set of error conditions for an ALLOCATE statement is processor dependent. If an error condition occurs
              during execution of an ALLOCATE statement that does not contain the STAT= speciﬁer, error termination is
              initiated. The STAT= speciﬁer is described in 9.7.4. The ERRMSG= speciﬁer is described in 9.7.5.
              9.7.1.3  Allocation of allocatable variables
           1 The allocation status of an allocatable entity is one of the following at any time.
                 • The status of an allocatable variable becomes “allocated” if it is allocated by an ALLOCATE statement, if
                   it is allocated during assignment, or if it is given that status by the intrinsic subroutine MOVE_ALLOC
                   (16.9.137). An allocatable variable with this status may be referenced, deﬁned, or deallocated; allocating it
                   causes an error condition in the ALLOCATE statement. The result of the intrinsic function ALLOCATED
                   (16.9.11) is true for such a variable.
                 • An allocatable variable has a status of “unallocated” if it is not allocated. The status of an allocatable
                   variable becomes unallocated if it is deallocated (9.7.3) or if it is given that status by the intrinsic sub-
                   routine MOVE_ALLOC.Anallocatable variable with this status shall not be referenced or deﬁned. It shall
                   not be supplied as an actual argument corresponding to a nonallocatable nonoptional dummy argument,
                   except to certain intrinsic inquiry functions. It may be allocated with the ALLOCATE statement. Deal-
                   locating it causes an error condition in the DEALLOCATE statement. The result of the intrinsic function
                   ALLOCATED(16.9.11) is false for such a variable.
           2 At the beginning of execution of a program, allocatable variables are unallocated.
           3 When the allocation status of an allocatable variable changes, the allocation status of any associated allocat-
              able variable changes accordingly. Allocation of an allocatable variable establishes values for the deferred type
              parameters of all associated allocatable variables.
           4 Anunsavedallocatablelocalvariableofaprocedurehasastatusofunallocatedatthebeginningofeachinvocation
              of the procedure. An unsaved allocatable local variable of a construct has a status of unallocated at the beginning
              of each execution of the construct.
              c
              ISO/IEC 2017 – All rights reserved                                                                       141
              ISO/IEC DIS 1539-1:2017 (E)
           5 When an object of derived type is created by an ALLOCATE statement, any allocatable ultimate components
              have an allocation status of unallocated unless the SOURCE= speciﬁer appears and the corresponding component
              of the source-expr is allocated.
           6 If the evaluation of a function would change the allocation status of a variable and if a reference to the function
              appears in an expression in which the value of the function is not needed to determine the value of the expression,
              the allocation status of the variable after evaluation of the expression is processor dependent.
              9.7.1.4  Allocation of pointer targets
           1 AllocationofapointercreatesanobjectthatimplicitlyhastheTARGETattribute. Followingsuccessfulexecution
              of an ALLOCATE statement for a pointer, the pointer is associated with the target and may be used to reference
              or deﬁne the target. Additional pointers may become associated with the pointer target or a part of the pointer
              target by pointer assignment. It is not an error to allocate a pointer that is already associated with a target.
              In this case, a new pointer target is created as required by the attributes of the pointer and any array bounds,
              type, and type parameters speciﬁed by the ALLOCATE statement. The pointer is then associated with this
              new target. Any previous association of the pointer with a target is broken. If the previous target had been
              created by allocation, it becomes inaccessible unless other pointers are associated with it. The intrinsic function
              ASSOCIATED (16.9.16) may be used to determine whether a pointer that does not have undeﬁned association
              status is associated.
           2 At the beginning of execution of a function whose result is a pointer, the association status of the result pointer
              is undeﬁned. Before such a function returns, it shall either associate a target with this pointer or cause the
              association status of this pointer to become disassociated.
              9.7.2    NULLIFY statement
              R938    nullify-stmt                is  NULLIFY ( pointer-object-list )
              R939    pointer-object              is  variable-name
                                                  or structure-component
                                                  or proc-pointer-name
              C951    (R939) Each pointer-object shall have the POINTER attribute.
           1 A pointer-object shall not depend on the value, bounds, or association status of another pointer-object in the
              same NULLIFY statement.
           2 Execution of a NULLIFY statement causes each pointer-object to become disassociated.
                   NOTE9.21
                  When a NULLIFY statement is applied to a polymorphic pointer (7.3.2.3), its dynamic type becomes the
                  same as its declared type.
              9.7.3    DEALLOCATE statement
              9.7.3.1  Form of the DEALLOCATE statement
           1 The DEALLOCATE statement causes allocatable variables to be deallocated; it causes pointer targets to be
              deallocated and the pointers to be disassociated.
              R940    deallocate-stmt             is  DEALLOCATE(allocate-object-list [ , dealloc-opt-list ] )
              R941    dealloc-opt                 is  STAT = stat-variable
                                                  or ERRMSG=errmsg-variable
              C952    (R941) No dealloc-opt shall appear more than once in a given dealloc-opt-list.
                                                                              c
              142                                                            ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           2 An allocate-object shall not depend on the value, bounds, allocation status, or association status of another
              allocate-object in the same DEALLOCATE statement; it also shall not depend on the value of the stat-variable
              or errmsg-variable in the same DEALLOCATE statement.
           3 The set of error conditions for a DEALLOCATE statement is processor dependent. If an error condition occurs
              during execution of a DEALLOCATE statement that does not contain the STAT= speciﬁer, error termination is
              initiated. The STAT= speciﬁer is described in 9.7.4. The ERRMSG= speciﬁer is described in 9.7.5.
           4 When more than one allocated object is deallocated by execution of a DEALLOCATE statement, the order of
              deallocation is processor dependent.
                   NOTE9.22
                  An example of a DEALLOCATE statement is:
                  DEALLOCATE (X, B)
              9.7.3.2  Deallocation of allocatable variables
           1 Deallocating an unallocated allocatable variable causes an error condition in the DEALLOCATE statement.
              Deallocating an allocatable variable with the TARGET attribute causes the pointer association status of any
              pointer associated with it to become undeﬁned. An allocatable variable shall not be deallocated if it or any
              subobject of it is argument associated with a dummy argument or construct associated with an associate name.
           2 When the execution of a procedure is terminated by execution of a RETURN or END statement, an unsaved
              allocatable local variable of the procedure retains its allocation and deﬁnition status if it is a function result or a
              subobject thereof; otherwise, if it is allocated it will be deallocated.
           3 When a BLOCK construct terminates, any unsaved allocated allocatable local variable of the construct is deal-
              located.
           4 If an executable construct references a function whose result is allocatable or has an allocatable subobject, and
              the function reference is executed, an allocatable result and any allocated allocatable subobject of the result is
              deallocated after execution of the innermost executable construct containing the reference.
           5 If a function whose result is allocatable or has an allocatable subobject is referenced in the speciﬁcation part of a
              scoping unit, and the function reference is executed, an allocatable result and any allocated allocatable subobject
              of the result is deallocated before execution of the executable constructs of the scoping unit.
           6 When a procedure is invoked, any allocated allocatable object that is an actual argument corresponding to an
              INTENT(OUT)allocatable dummy argument is deallocated; any allocated allocatable object that is a subobject
              of an actual argument corresponding to an INTENT (OUT) dummy argument is deallocated. If a Fortran proced-
              ure that has an INTENT (OUT) allocatable dummy argument is invoked by a C function and the corresponding
              argument in the C function call is a C descriptor that describes an allocated allocatable variable, the variable
              is deallocated on entry to the Fortran procedure. If a C function is invoked from a Fortran procedure via an
              interface with an INTENT (OUT) allocatable dummy argument and the corresponding actual argument in the
              reference to the C function is an allocated allocatable variable, the variable is deallocated on invocation (before
              execution of the C function begins).
           7 Whenanintrinsic assignment statement (10.2.1.3) is executed, any noncoarray allocated allocatable subobject of
              the variable is deallocated before the assignment takes place.
           8 When a variable of derived type is deallocated, any allocated allocatable subobject is deallocated. If an error
              condition occurs during deallocation, it is processor dependent whether an allocated allocatable subobject is
              deallocated.
           9 If an allocatable component is a subobject of a ﬁnalizable object, that object is ﬁnalized before the component is
              automatically deallocated.
              c
              ISO/IEC 2017 – All rights reserved                                                                       143
              ISO/IEC DIS 1539-1:2017 (E)
          10 Whenastatement that deallocates a coarray is executed, there is an implicit synchronization of all active images
              in the current team. If the current team contains a stopped or failed image, an error condition occurs. If no
              other error condition occurs, execution on the active images of the segment (11.6.2) following the statement is
              delayed until all other active images in the current team have executed the same statement the same number of
              times in this team. The segments that executed before the statement on an active image of this team precede
              the segments that execute after the statement on another active image of this team. A coarray shall not become
              deallocated on an image unless it is successfully deallocated on all active images in this team.
          11 If an allocate-object is a coarray dummy argument, its ultimate argument (15.5.2.3) shall be the same coarray on
              those images.
          12 Theeﬀect of automatic deallocation is the same as that of a DEALLOCATE statement without a dealloc-opt-list.
                   NOTE9.23
                  In the following example:
                  SUBROUTINE PROCESS
                     REAL, ALLOCATABLE :: TEMP(:)
                     REAL, ALLOCATABLE, SAVE :: X(:)
                     ...
                  END SUBROUTINE PROCESS
                  on return from subroutine PROCESS, the allocation status of X is preserved because X has the SAVE
                  attribute. TEMP does not have the SAVE attribute, so it will be deallocated if it was allocated. On the
                  next invocation of PROCESS, TEMP will have an allocation status of unallocated.
                   NOTE9.24
                  For example, executing a RETURN, END, or END BLOCK statement, or deallocating an object that has
                  an allocatable subobject, can cause deallocation of a coarray, and thus an implicit synchronization of all
                  active images in the current team.
              9.7.3.3  Deallocation of pointer targets
           1 If a pointer appears in a DEALLOCATE statement, its association status shall be deﬁned. Deallocating a pointer
              that is disassociated or whose target was not created by an ALLOCATE statement causes an error condition
              in the DEALLOCATE statement. If a pointer is associated with an allocatable entity, the pointer shall not be
              deallocated. A pointer shall not be deallocated if its target or any subobject thereof is argument associated with
              a dummy argument or construct associated with an associate name.
           2 If a pointer appears in a DEALLOCATE statement, it shall be associated with the whole of an object that was
              created by allocation. The pointer shall have the same dynamic type and type parameters as the allocated object,
              and if the allocated object is an array the pointer shall be an array whose elements are the same as those of the
              allocated object in array element order. Deallocating a pointer target causes the pointer association status of any
              other pointer that is associated with the target or a portion of the target to become undeﬁned.
              9.7.4    STAT= speciﬁer
              R942    stat-variable               is  scalar-int-variable
           1 A stat-variable should have a decimal exponent range of at least four; otherwise the processor-dependent error
              code might not be representable in the variable.
           2 This rest of this subclause applies where an alloc-opt or dealloc-opt that is a STAT= speciﬁer appears in an
              ALLOCATEorDEALLOCATEstatement.
           3 The stat-variable shall not be allocated or deallocated within the ALLOCATE or DEALLOCATE statement
              in which it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or
                                                                              c
              144                                                            ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
           association status of any allocate-object in that statement. The stat-variable shall not depend on the value of the
           errmsg-variable.
         4 Successful execution of the ALLOCATE or DEALLOCATE statement causes the stat-variable to become deﬁned
           with a value of zero.
         5 If an ALLOCATEorDEALLOCATEstatementwithacoarrayallocate-object is executed when the current team
           contains a stopped image, the stat-variable becomes deﬁned with the value STAT_STOPPED_IMAGE from the
           intrinsic module ISO_FORTRAN_ENV (16.10.2). Otherwise, if an allocate-object is a coarray, the current team
           contains a failed image, and no other error condition occurs, the stat-variable becomes deﬁned with value STAT_-
           FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV. If any other error condition occurs during
           execution of the ALLOCATE or DEALLOCATE statement, the stat-variable becomes deﬁned with a processor-
           dependent positive integer value diﬀerent from STAT_STOPPED_IMAGE and STAT_FAILED_IMAGE.
         6 If stat-variable became deﬁned with the value STAT_FAILED_IMAGE, each allocate-object is successfully al-
           located or deallocated on all the active images of the current team. If any other error condition occurs, each
           allocate-object has a processor-dependent status:
              • each allocate-object that was successfully allocated shall have an allocation status of allocated or a pointer
                association status of associated;
              • each allocate-object that was successfully deallocated shall have an allocation status of unallocated or a
                pointer association status of disassociated;
              • each allocate-object that was not successfully allocated or deallocated shall retain its previous allocation
                status or pointer association status.
               NOTE9.25
               The status of objects that were not successfully allocated or deallocated can be individually checked with
               the intrinsic functions ALLOCATED or ASSOCIATED.
           9.7.5   ERRMSG=speciﬁer
         1 The errmsg-variable shall not be allocated or deallocated within the ALLOCATE or DEALLOCATE statement
           in which it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or
           association status of any allocate-object in that statement. The errmsg-variable shall not depend on the value of
           the stat-variable.
         2 IfanerrorconditionoccursduringexecutionofanALLOCATEorDEALLOCATEstatementwithanERRMSG=
           speciﬁer, the errmsg-variable is assigned an explanatory message, truncated or padded according to the rules of
           intrinsic assignment. If no such condition occurs, the deﬁnition status and value of errmsg-variable are unchanged.
            c
           ISO/IEC 2017 – All rights reserved                                                     145
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      146                          ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             10 Expressions and assignment
             10.1      Expressions
             10.1.1     Expression semantics
          1 An expression represents either a data object reference or a computation, and its value is either a scalar or an
             array. Evaluation of an expression produces a value, which has a type, type parameters (if appropriate), and a
             shape (10.1.9). The corank of an expression that is not a variable is zero.
             10.1.2     Form of an expression
             10.1.2.1   Overall expression syntax
          1 An expression is formed from operands, operators, and parentheses. An operand is either a scalar or an array.
             An operation is either intrinsic (10.1.5) or deﬁned (10.1.6). More complicated expressions can be formed using
             operands which are themselves expressions.
          2 An expression is deﬁned in terms of several categories: primary, level-1 expression, level-2 expression, level-3
             expression, level-4 expression, and level-5 expression.
          3 These categories are related to the diﬀerent operator precedence levels and, in general, are deﬁned in terms of
             other categories. The simplest form of each expression category is a primary.
             10.1.2.2   Primary
             R1001 primary                       is  literal-constant
                                                 or designator
                                                 or array-constructor
                                                 or structure-constructor
                                                 or function-reference
                                                 or type-param-inquiry
                                                 or type-param-name
                                                 or ( expr )
             C1001 (R1001) The type-param-name shall be the name of a type parameter.
             C1002 (R1001) The designator shall not be a whole assumed-size array.
             C1003 (R1001) The expr shall not be a function reference that returns a procedure pointer.
                  NOTE10.1
                  Examples of a primary are:
                       Example                                        Syntactic class
                       1.0                                            constant
                       ’ABCDEFGHIJKLMNOPQRSTUVWXYZ’ (I:I)             designator
                       [ 1.0, 2.0 ]                                   array-constructor
                       PERSON (’Jones’, 12)                           structure-constructor
                       F (X, Y)                                       function-reference
                       X%KIND                                         type-param-inquiry
                       KIND                                           type-param-name
                       (S + T)                                        (expr)
              c
             ISO/IEC 2017 – All rights reserved                                                                     147
             ISO/IEC DIS 1539-1:2017 (E)
             10.1.2.3   Level-1 expressions
          1 Deﬁned unary operators have the highest operator precedence (Table 10.1). Level-1 expressions are primaries
             optionally operated on by deﬁned unary operators:
             R1002 level-1-expr                  is  [ deﬁned-unary-op ] primary
             R1003 deﬁned-unary-op               is  . letter [ letter ] ... .
             C1004 (R1003) A deﬁned-unary-op shall not contain more than 63 letters and shall not be the same as any
                     intrinsic-operator or logical-literal-constant.
                  NOTE10.2
                  Simple examples of a level-1 expression are:
                       Example                                        Syntactic class
                       A                                              primary (R1001)
                       .INVERSE. B                                    level-1-expr (R1002)
                  Amore complicated example of a level-1 expression is:
                       .INVERSE. (A + B)
             10.1.2.4   Level-2 expressions
          1 Level-2 expressions are level-1 expressions optionally involving the numeric operators power-op, mult-op, and
             add-op.
             R1004 mult-operand                  is  level-1-expr [ power-op mult-operand ]
             R1005 add-operand                   is  [ add-operand mult-op ] mult-operand
             R1006 level-2-expr                  is  [ [ level-2-expr ] add-op ] add-operand
             R1007 power-op                      is  **
             R1008 mult-op                       is  *
                                                 or /
             R1009 add-op                        is  +
                                                 or –
                  NOTE10.3
                  Simple examples of a level-2 expression are:
                       Example               Syntactic class      Remarks
                       A                     level-1-expr         Ais a primary. (R1002)
                       B ** C                mult-operand         Bis a level-1-expr, ** is a power-op,
                                                                    and C is a mult-operand. (R1004)
                       D * E                 add-operand          Dis an add-operand, * is a mult-op,
                                                                    and E is a mult-operand. (R1005)
                       +1                    level-2-expr         +is an add-op
                                                                    and 1 is an add-operand. (R1006)
                       F - I                 level-2-expr         F is a level-2-expr, – is an add-op,
                                                                    and I is an add-operand. (R1006)
                                                                            c
             148                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE10.3 (cont.)
                  Amore complicated example of a level-2 expression is:
                        - A + D * E + B ** C
             10.1.2.5   Level-3 expressions
          1 Level-3 expressions are level-2 expressions optionally involving the character operator concat-op.
             R1010 level-3-expr                  is  [ level-3-expr concat-op ] level-2-expr
             R1011 concat-op                     is  //
                  NOTE10.4
                  Simple examples of a level-3 expression are:
                       Example                                        Syntactic class
                       A                                              level-2-expr (R1006)
                       B // C                                         level-3-expr (R1010)
                  Amore complicated example of a level-3 expression is:
                       X // Y // ’ABCD’
             10.1.2.6   Level-4 expressions
          1 Level-4 expressions are level-3 expressions optionally involving the relational operators rel-op.
             R1012 level-4-expr                  is  [ level-3-expr rel-op ] level-3-expr
             R1013 rel-op                        is  .EQ.
                                                 or .NE.
                                                 or .LT.
                                                 or .LE.
                                                 or .GT.
                                                 or .GE.
                                                 or ==
                                                 or /=
                                                 or <
                                                 or <=
                                                 or >
                                                 or >=
                  NOTE10.5
                  Simple examples of a level-4 expression are:
                       Example                                        Syntactic class
                       A                                              level-3-expr (R1010)
                       B == C                                         level-4-expr (R1012)
                       D < E                                          level-4-expr (R1012)
                  Amore complicated example of a level-4 expression is:
                        (A + B) /= C
              c
             ISO/IEC 2017 – All rights reserved                                                                     149
             ISO/IEC DIS 1539-1:2017 (E)
             10.1.2.7   Level-5 expressions
          1 Level-5 expressions are level-4 expressions optionally involving the logical operators not-op, and-op, or-op, and
             equiv-op.
             R1014 and-operand                   is  [ not-op ] level-4-expr
             R1015 or-operand                    is  [ or-operand and-op ] and-operand
             R1016 equiv-operand                 is  [ equiv-operand or-op ] or-operand
             R1017 level-5-expr                  is  [ level-5-expr equiv-op ] equiv-operand
             R1018 not-op                        is  .NOT.
             R1019 and-op                        is  .AND.
             R1020 or-op                         is  .OR.
             R1021 equiv-op                      is  .EQV.
                                                 or .NEQV.
                  NOTE10.6
                  Simple examples of a level-5 expression are:
                       Example                                        Syntactic class
                       A                                              level-4-expr (R1012)
                       .NOT. B                                        and-operand (R1014)
                       C .AND. D                                      or-operand (R1015)
                       E .OR. F                                       equiv-operand (R1016)
                       G .EQV. H                                      level-5-expr (R1017)
                       S .NEQV. T                                     level-5-expr (R1017)
                  Amore complicated example of a level-5 expression is:
                       A .AND. B .EQV. .NOT. C
             10.1.2.8   General form of an expression
          1 Expressions are level-5 expressions optionally involving deﬁned binary operators. Deﬁned binary operators have
             the lowest operator precedence (Table 10.1).
             R1022 expr                          is  [ expr deﬁned-binary-op ] level-5-expr
             R1023 deﬁned-binary-op              is  . letter [ letter ] ... .
             C1005 (R1023) A deﬁned-binary-op shall not contain more than 63 letters and shall not be the same as any
                     intrinsic-operator or logical-literal-constant.
                  NOTE10.7
                  Simple examples of an expression are:
                       Example                                        Syntactic class
                       A                                              level-5-expr (R1017)
                       B.UNION.C                                      expr (R1022)
                                                                            c
             150                                                           ISO/IEC 2017 – All rights reserved
                                                                                                     ISO/IEC DIS 1539-1:2017 (E)
                     NOTE10.7 (cont.)
                     More complicated examples of an expression are:
                            (B .INTERSECT. C) .UNION. (X - Y)
                            A + B == C * D
                            .INVERSE. (A + B)
                            A + B .AND. C * D
                            E // G == H (1:10)
                10.1.3      Precedence of operators
            1 There is a precedence among the intrinsic and extension operations corresponding to the form of expressions
                speciﬁed in 10.1.2, which determines the order in which the operands are combined unless the order is changed
                by the use of parentheses. This precedence order is summarized in Table 10.1.
                                         Table 10.1: Categories of operations and relative precedence
                                      Category of operation                      Operators                   Precedence
                                             Extension                       deﬁned-unary-op                    Highest
                                              Numeric                                **                             .
                                              Numeric                               *, /                            .
                                              Numeric                           unary +, –                          .
                                              Numeric                           binary +, –                         .
                                             Character                               //                             .
                                             Relational            .EQ., .NE., .LT., .LE., .GT., .GE.,
                                                                         ==, /=, <, <=, >, >=                       .
                                               Logical                             .NOT.                            .
                                               Logical                             .AND.                            .
                                               Logical                              .OR.                            .
                                               Logical                       .EQV., .NEQV.                          .
                                             Extension                       deﬁned-binary-op                   Lowest
            2 The precedence of a deﬁned operation is that of its operator.
                     NOTE10.8
                     For example, in the expression
                          -A ** 2
                     the exponentiation operator (**) has precedence over the negation operator (–); therefore, the operands of
                     the exponentiation operator are combined to form an expression that is used as the operand of the negation
                     operator. The interpretation of the above expression is the same as the interpretation of the expression
                          - (A ** 2)
            3 The general form of an expression (10.1.2) also establishes a precedence among operators in the same syntactic
                class.  This precedence determines the order in which the operands are to be combined in determining the
                interpretation of the expression unless the order is changed by the use of parentheses.
                     NOTE10.9
                     In interpreting a level-2-expr containing two or more binary operators + or –, each operand (add-operand)
                     is combined from left to right. Similarly, the same left-to-right interpretation for a mult-operand in add-
                     operand, as well as for other kinds of expressions, is a consequence of the general form. However, for
                     interpreting a mult-operand expression when two or more exponentiation operators ** combine level-1-expr
                     operands, each level-1-expr is combined from right to left.
                 c
                ISO/IEC 2017 – All rights reserved                                                                                         151
      ISO/IEC DIS 1539-1:2017 (E)
         NOTE10.9 (cont.)
        For example, the expressions
          2.1 + 3.4 + 4.9
          2.1 * 3.4 * 4.9
          2.1 / 3.4 / 4.9
          2 ** 3 ** 4
          ’AB’ // ’CD’ // ’EF’
        have the same interpretations as the expressions
          (2.1 + 3.4) + 4.9
          (2.1 * 3.4) * 4.9
          (2.1 / 3.4) / 4.9
          2 ** (3 ** 4)
          (’AB’ // ’CD’) // ’EF’
        As a consequence of the general form (10.1.2), only the ﬁrst add-operand of a level-2-expr can be preceded
        by the identity (+) or negation (–) operator. These formation rules do not permit expressions containing
        two consecutive numeric operators, such as A ** –B or A + –B. However, expressions such as A ** (–B)
        and A + (–B) are permitted. The rules do allow a binary operator or an intrinsic unary operator to be
        followed by a deﬁned unary operator, such as:
          A * .INVERSE. B
          - .INVERSE. (B)
        As another example, in the expression
          A .OR. B .AND. C
        the general form implies a higher precedence for the .AND. operator than for the .OR. operator; therefore,
        the interpretation of the above expression is the same as the interpretation of the expression
          A .OR. (B .AND. C)
         NOTE10.10
        An expression can contain more than one category of operator. The logical expression
          L .OR. A + B >= C
        where A, B, and C are of type real, and L is of type logical, contains a numeric operator, a relational
        operator, and a logical operator. This expression would be interpreted the same as the expression
          L .OR. ((A + B) >= C)
         NOTE10.11
        If
          • the operator ** is extended to type logical,
          • the operator .STARSTAR. is deﬁned to duplicate the function of ** on type real,
          • .MINUS. is deﬁned to duplicate the unary operator –, and
          • L1 and L2 are type logical and X and Y are type real,
        then in precedence: L1 ** L2 is higher than X * Y; X * Y is higher than X .STARSTAR. Y; and .MINUS. X
        is higher than –X.
                                   c
      152                          ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            10.1.4   Evaluation of operations
         1 An intrinsic operation requires the values of its operands.
         2 Execution of a function reference in the logical expression in an IF statement (11.1.8.4), the mask expression in a
            WHEREstatement(10.2.3.1),ortheconcurrent-limitsandconcurrent-steps in a FORALL statement (10.2.4) is permitted to
            deﬁne variables in the subsidiary action-stmt, where-assignment-stmt, or forall-assignment-stmt respectively. Except
            in those cases:
              • the evaluation of a function reference shall neither aﬀect nor be aﬀected by the evaluation of any other
                entity within the statement;
              • if a function reference causes deﬁnition or undeﬁnition of an actual argument of the function, that argument
                or any associated entities shall not appear elsewhere in the same statement.
                NOTE10.12
                For example, the statements
                   A (I) = F (I)
                   Y = G (X) + X
                are prohibited if the reference to F deﬁnes or undeﬁnes I or the reference to G deﬁnes or undeﬁnes X.
                However, in the statements
                   IF (F (X)) A = X
                   WHERE (G (X)) B = X
                the reference to F and/or the reference to G can deﬁne X.
         3 Theappearanceofanarrayconstructorrequirestheevaluationofeach scalar-int-expr of the ac-implied-do-control
            in any ac-implied-do it may contain.
         4 When an elemental binary operation is applied to a scalar and an array or to two arrays of the same shape, the
            operation is performed element-by-element on corresponding array elements of the array operands.
                NOTE10.13
                For example, the array expression
                   A + B
                produces an array of the same shape as A and B. The individual array elements of the result have the
                values of the ﬁrst element of A added to the ﬁrst element of B, the second element of A added to the second
                element of B, etc.
         5 Whenanelementalunaryoperator operates on an array operand, the operation is performed element-by-element,
            and the result is the same shape as the operand. If an elemental operation is intrinsically pure or is implemented
            by a pure elemental function (15.8), the element operations may be performed simultaneously or in any order.
            10.1.5   Intrinsic operations
            10.1.5.1 Intrinsic operation classiﬁcation
         1 An intrinsic operation is either a unary or binary operation. An intrinsic unary operation is an operation of
            the form intrinsic-operator x where x is of an intrinsic type (7.4) listed in Table 10.2 for the unary intrinsic
            operator.               2       2
         2 Anintrinsic binary operation is an operation of the form x intrinsic-operator x where x and x are conformable
                                                           1                 2       1     2
            and of the intrinsic types (7.4) listed in Table 10.2 for the binary intrinsic operator.
            c
            ISO/IEC 2017 – All rights reserved                                                      153
              ISO/IEC DIS 1539-1:2017 (E)
           3 Anumeric intrinsic operation is an intrinsic operation for which the intrinsic-operator is a numeric operator (+,
              –, *, /, or **). A numeric intrinsic operator is the operator in a numeric intrinsic operation.
           4 The character intrinsic operation is the intrinsic operation for which the intrinsic-operator is (//) and both
              operands are of type character with the same kind type parameter. The character intrinsic operator is the
              operator in a character intrinsic operation.
           5 A logical intrinsic operation is an intrinsic operation for which the intrinsic-operator is .AND., .OR., .NOT.,
              .EQV., or .NEQV. and both operands are of type logical. A logical intrinsic operator is the operator in a logical
              intrinsic operation.
           6 A relational intrinsic operator is an intrinsic-operator that is .EQ., .NE., .GT., .GE., .LT., .LE., ==, /=, >,
              >=, <, or <=. A relational intrinsic operation is an intrinsic operation for which the intrinsic-operator is a
              relational intrinsic operator. A numeric relational intrinsic operation is a relational intrinsic operation for which
              both operands are of numeric type. A character relational intrinsic operation is a relational intrinsic operation for
              which both operands are of type character. The kind type parameters of the operands of a character relational
              intrinsic operation shall be the same.
           7 The interpretations deﬁned in subclause 10.1.5 apply to both scalars and arrays; the interpretation for arrays is
              obtained by applying the interpretation for scalars element by element.
                                   Table 10.2: Type of operands and results for intrinsic operators
                                      Intrinsic operator         Type of    Type of             Type of
                                              op                    x          x               [x ] op x
                                                                      1         2                1      2
                                         Unary +, –                          I, R, Z            I, R, Z
                                                                     I       I, R, Z            I, R, Z
                                     Binary +, –, *, /, **           R       I, R, Z            R, R, Z
                                                                     Z       I, R, Z            Z, Z, Z
                                              //                     C         C                   C
                                                                     I       I, R, Z            L, L, L
                                         .EQ., .NE.,                 R       I, R, Z            L, L, L
                                           ==, /=                    Z       I, R, Z            L, L, L
                                                                     C         C                   L
                                                                     I        I, R                L, L
                                    .GT., .GE., .LT., .LE.           R        I, R                L, L
                                        >, >=, <, <=                 C         C                   L
                                            .NOT.                               L                  L
                                .AND., .OR., .EQV., .NEQV.           L          L                  L
                                Note: The symbols I, R, Z, C, and L stand for the types integer, real, complex,
                                       character, and logical, respectively. Where more than one type for x2 is
                                       given, the type of the result of the operation is given in the same relative
                                       position in the next column.
                   NOTE10.14
                   For example, if X is of type real and J is of type integer, the expression X + J is of type real.
              10.1.5.2   Numeric intrinsic operations
              10.1.5.2.1   Interpretation of numeric intrinsic operations
           1 The two operands of numeric intrinsic binary operations may be of diﬀerent numeric types or diﬀerent kind
              type parameters. Except for a value of type real or complex raised to an integer power, if the operands have
              diﬀerent types or kind type parameters, the eﬀect is as if each operand that diﬀers in type or kind type parameter
              from those of the result is converted to the type and kind type parameter of the result before the operation is
              performed. When a value of type real or complex is raised to an integer power, the integer operand need not be
              converted.
                                                                                 c
              154                                                                ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           2 A numeric operation is used to express a numeric computation. Evaluation of a numeric operation produces a
              numeric value. The permitted data types for operands of the numeric intrinsic operations are speciﬁed in 10.1.5.1.
           3 The numeric operators and their interpretation in an expression are given in Table 10.3, where x denotes the
              operand to the left of the operator and x denotes the operand to the right of the operator.       1
                                                       2
                                    Table 10.3: Interpretation of the numeric intrinsic operators
                                 Operator    Representing      Use of operator   Interpretation
                                     **      Exponentiation       x ** x         Raise x to the power x
                                                                    1     2              1               2
                                     /       Division              x / x         Divide x by x
                                                                    1    2                1     2
                                     *       Multiplication        x * x         Multiply x by x
                                                                    1    2                  1     2
                                     −       Subtraction           x - x         Subtract x from x
                                                                    1    2                  2       1
                                     −       Negation                - x         Negate x
                                                                        2                 2
                                     +       Addition              x +x          Add x and x
                                                                    1     2            1       2
                                     +       Identity               +x2          Same as x2
           4 The interpretation of a division operation depends on the types of the operands (10.1.5.2.2).
           5 If x and x are of type integer and x has a negative value, the interpretation of x ** x is the same as the
                 1       2                          2                                              1     2
              interpretation of 1/(x1 ** ABS (x2)), which is subject to the rules of integer division (10.1.5.2.2).
                   NOTE10.15
                   For example, 2 ** (−3) has the value of 1/(2 ** 3), which is zero.
              10.1.5.2.2   Integer division
           1 One operand of type integer may be divided by another operand of type integer. Although the mathematical
              quotient of two integers is not necessarily an integer, Table 10.2 speciﬁes that an expression involving the division
              operator with two operands of type integer is interpreted as an expression of type integer. The result of such an
              operation is the integer closest to the mathematical quotient and between zero and the mathematical quotient
              inclusively.
                   NOTE10.16
                   For example, the expression (−8) / 3 has the value (−2).
              10.1.5.2.3   Complex exponentiation
           1 In the case of a complex value raised to a complex power, the value of the operation x ** x is the principal
                                                                                                      1     2
                       x
              value of x12.
              10.1.5.2.4   Evaluation of numeric intrinsic operations
           1 The execution of any numeric operation whose result is not deﬁned by the arithmetic used by the processor is
              prohibited. Raising a negative real value to a real power is prohibited.
           2 Once the interpretation of a numeric intrinsic operation is established, the processor may evaluate any mathem-
              atically equivalent expression, provided that the integrity of parentheses is not violated.
           3 Twoexpressions of a numeric type are mathematically equivalent if, for all possible values of their primaries, their
              mathematical values are equal. However, mathematically equivalent expressions of numeric type may produce
              diﬀerent computational results.
              c
              ISO/IEC 2017 – All rights reserved                                                                        155
        ISO/IEC DIS 1539-1:2017 (E)
           NOTE10.17
           Any diﬀerence between the values of the expressions (1./3.)*3. and 1. is a computational diﬀerence,
           not a mathematical diﬀerence. The diﬀerence between the values of the expressions 5/2 and 5./2. is a
           mathematical diﬀerence, not a computational diﬀerence.
           The mathematical deﬁnition of integer division is given in 10.1.5.2.2.
           NOTE10.18
           Thefollowing are examples of expressions with allowable alternative forms that can be used by the processor
           in the evaluation of those expressions. A, B, and C represent arbitrary real or complex operands; I and J
           represent arbitrary integer operands; and X, Y, and Z represent arbitrary operands of numeric type.
               Expression                  Allowable alternative form
               X+Y                         Y+X
               X*Y                         Y*X
               -X + Y                      Y-X
               X+Y+Z                       X+(Y+Z)
               X-Y+Z                       X-(Y-Z)
               X*A/Z                       X*(A/Z)
               X*Y-X*Z                     X*(Y-Z)
               A/B/C                       A/(B*C)
               A/5.0                       0.2 * A
           The following are examples of expressions with forbidden alternative forms that cannot be used by a
           processor in the evaluation of those expressions.
               Expression                  Forbidden alternative form
               I / 2                       0.5 * I
               X*I/J                       X*(I/J)
               I / J / A                   I / (J * A)
               (X + Y) + Z                 X+(Y+Z)
               (X * Y) - (X * Z)           X*(Y-Z)
               X*(Y-Z)                     X*Y-X*Z
           NOTE10.19
           In addition to the parentheses required to establish the desired interpretation, parentheses can be included to
           restrict the alternative forms that can be used by the processor in the actual evaluation of the expression.
           This is useful for controlling the magnitude and accuracy of intermediate values developed during the
           evaluation of an expression.
           For example, in the expression
             A + (B - C)
           the parenthesized expression (B − C) is evaluated and then added to A.
           The inclusion of parentheses could change the mathematical value of an expression. For example, the two
           expressions
             A * I / J
             A * (I / J)
           could have diﬀerent mathematical values if I and J are of type integer.
                                              c
        156                                   ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                  NOTE10.20
                  Each operand in a numeric intrinsic operation has a type that can depend on the order of evaluation used
                  by the processor.
                  For example, in the evaluation of the expression
                      Z + R + I
                  where Z, R, and I represent data objects of complex, real, and integer type, respectively, the type of the
                  operand that is added to I could be either complex or real, depending on which pair of operands (Z and R,
                  RandI, or Z and I) is added ﬁrst.
             10.1.5.3   Character intrinsic operation
             10.1.5.3.1   Interpretation of the character intrinsic operation
           1 The character intrinsic operator // is used to concatenate two operands of type character with the same kind
             type parameter. Evaluation of the character intrinsic operation produces a result of type character.
           2 The interpretation of the character intrinsic operator // when used to form an expression is given in Table 10.4,
             where x denotes the operand to the left of the operator and x denotes the operand to the right of the operator.
                     1                                                    2
                                 Table 10.4: Interpretation of the character intrinsic operator //
                                 Operator    Representing     Use of operator  Interpretation
                                     //      Concatenation       x // x        Concatenate x with x
                                                                  1     2                     1       2
           3 The result of the character intrinsic operation x  // x is a character string whose value is the value of x
                                                              1      2                                                    1
             concatenated on the right with the value of x2 and whose length is the sum of the lengths of x1 and x2. Parentheses
             used to specify the order of evaluation have no eﬀect on the value of a character expression.
                  NOTE10.21
                  For example, the value of (’AB’      // ’CDE’)    // ’F’ is the string ’ABCDEF’. Also, the value of
                  ’AB’ // (’CDE’ // ’F’) is the string ’ABCDEF’.
             10.1.5.3.2   Evaluation of the character intrinsic operation
           1 Aprocessor is only required to evaluate as much of the character intrinsic operation as is required by the context
             in which the expression appears.
                  NOTE10.22
                  For example, the statements
                      CHARACTER (LEN = 2) C1, C2, C3, CF
                      C1 = C2 // CF (C3)
                  do not require the function CF to be evaluated, because only the value of C2 is needed to determine the
                  value of C1 because C1 and C2 both have a length of 2.
             10.1.5.4   Logical intrinsic operations
             10.1.5.4.1   Interpretation of logical intrinsic operations
           1 A logical operation is used to express a logical computation. Evaluation of a logical operation produces a result
             of type logical. The permitted types for operands of the logical intrinsic operations are speciﬁed in 10.1.5.1.
              c
             ISO/IEC 2017 – All rights reserved                                                                      157
              ISO/IEC DIS 1539-1:2017 (E)
           2 The logical operators and their interpretation when used to form an expression are given in Table 10.5, where x1
              denotes the operand to the left of the operator and x denotes the operand to the right of the operator.
                                                                     2
                                      Table 10.5: Interpretation of the logical intrinsic operators
                      Operator    Representing                       Use of operator    Interpretation
                      .NOT.       Logical negation                   .NOT. x            True if x is false
                                                                              2                  2
                      .AND.       Logical conjunction                x .AND. x          True if x and x are both true
                                                                       1         2               1       2
                      .OR.        Logical inclusive disjunction      x .OR. x           True if x and/or x is true
                                                                       1       2                 1          2
                      .EQV.       Logical equivalence                x .EQV. x          True if both x1 and x2 are true or
                                                                       1         2      both are false
                                                                                        True if either x or x is true, but
                      .NEQV.      Logical nonequivalence             x .NEQV. x                        1     2
                                                                       1           2    not both
           3 The values of the logical intrinsic operations are shown in Table 10.6.
                              Table 10.6: The values of operations involving logical intrinsic operators
                             x       x     .NOT. x      x .AND. x       x .OR. x      x .EQV. x      x .NEQV. x
                               1      2             2    1          2    1        2    1         2     1           2
                            true    true      false         true           true           true            false
                            true    false     true          false          true           false            true
                            false   true      false         false          true           false            true
                            false   false     true          false          false          true            false
              10.1.5.4.2   Evaluation of logical intrinsic operations
           1 Once the interpretation of a logical intrinsic operation is established, the processor may evaluate any other
              expression that is logically equivalent, provided that the integrity of parentheses in any expression is not violated.
                   NOTE10.23
                   For example, for the variables L1, L2, and L3 of type logical, the processor could choose to evaluate the
                   expression
                       L1 .AND. L2 .AND. L3
                   as
                       L1 .AND. (L2 .AND. L3)
           2 Two expressions of type logical are logically equivalent if their values are equal for all possible values of their
              primaries.
              10.1.5.5   Relational intrinsic operations
              10.1.5.5.1   Interpretation of relational intrinsic operations
           1 Arelational intrinsic operation is used to compare values of two operands using the relational intrinsic operators
              .LT., .LE., .GT., .GE., .EQ., .NE., <, <=, >, >=, ==, and /=. The permitted types for operands of the
              relational intrinsic operators are speciﬁed in 10.1.5.1.
           2 The operators <, <=, >, >=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
              .GT., .GE., .EQ., and .NE., respectively.
                   NOTE10.24
                   AsshowninTable10.2, a relational intrinsic operator cannot be used to compare the value of an expression
                   of a numeric type with one of type character or logical. Also, two operands of type logical cannot be
                                                                                 c
              158                                                                ISO/IEC 2017 – All rights reserved
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
                   NOTE10.24 (cont.)
                   compared, a complex operand can be compared with another numeric operand only when the operator is
                   .EQ., .NE., ==, or /=, and two character operands cannot be compared unless they have the same kind
                   type parameter value.
           3 Evaluation of a relational intrinsic operation produces a default logical result.
           4 The interpretation of the relational intrinsic operators is given in Table 10.7, where x denotes the operand to
              the left of the operator and x denotes the operand to the right of the operator.       1
                                           2
                                   Table 10.7: Interpretation of the relational intrinsic operators
                          Operator    Representing                Use of operator   Interpretation
                             .LT.     Less than                     x .LT. x        x less than x
                                                                     1       2       1            2
                              <       Less than                      x1 < x2        x1 less than x2
                             .LE.     Less than or equal to         x1 .LE. x2      x1 less than or equal to x2
                             <=       Less than or equal to         x1 <= x2        x1 less than or equal to x2
                            .GT.      Greater than                  x .GT. x        x greater than x
                                                                     1        2      1               2
                              >       Greater than                   x1 > x2        x1 greater than x2
                            .GE.      Greater than or equal to      x .GE. x        x greater than or equal to x
                                                                     1        2      1                           2
                             >=       Greater than or equal to      x1 >= x2        x1 greater than or equal to x2
                            .EQ.      Equal to                      x .EQ. x        x equal to x
                                                                     1        2      1           2
                             ==       Equal to                      x ==x           x equal to x
                                                                      1      2       1           2
                            .NE.      Not equal to                  x .NE. x        x not equal to x
                                                                     1        2      1               2
                             /=       Not equal to                   x /= x         x not equal to x
                                                                      1      2       1               2
           5 Anumeric relational intrinsic operation is interpreted as having the logical value true if and only if the values of
              the operands satisfy the relation speciﬁed by the operator.
           6 In the numeric relational operation
                    x rel-op x
                     1        2
              if the types or kind type parameters of x1 and x2 diﬀer, their values are converted to the type and kind type
              parameter of the expression x1 + x2 before evaluation.
           7 A character relational intrinsic operation is interpreted as having the logical value true if and only if the values
              of the operands satisfy the relation speciﬁed by the operator.
           8 For a character relational intrinsic operation, the operands are compared one character at a time in order,
              beginning with the ﬁrst character of each character operand. If the operands are of unequal length, the shorter
              operand is treated as if it were extended on the right with blanks to the length of the longer operand. If both
              x and x are of zero length, x is equal to x ; if every character of x is the same as the character in the
               1       2                       1              2                         1
              corresponding position in x , x is equal to x . Otherwise, at the ﬁrst position where the character operands
                                          2   1              2
              diﬀer, the character operand x is considered to be less than x if the character value of x at this position
                                              1                                2                             1
              precedes the value of x in the collating sequence (3.31); x is greater than x if the character value of x at this
                                     2                                  1                  2                          1
              position follows the value of x2 in the collating sequence.
                   NOTE10.25
                   The collating sequence depends partially on the processor; however, the result of the use of the operators
                   .EQ., .NE., ==, and /= does not depend on the collating sequence.
                   For nondefault character kinds, the blank padding character is processor dependent.
              10.1.5.5.2   Evaluation of relational intrinsic operations
           1 Once the interpretation of a relational intrinsic operation is established, the processor may evaluate any other
              expression that is relationally equivalent, provided that the integrity of parentheses in any expression is not
              violated.
               c
              ISO/IEC 2017 – All rights reserved                                                                         159
              ISO/IEC DIS 1539-1:2017 (E)
           2 Tworelational intrinsic operations are relationally equivalent if their logical values are equal for all possible values
              of their primaries.
                   NOTE10.26
                  Whether an operand of a relational intrinsic operation could be an IEEE NaN aﬀects whether expressions
                  are equivalent. For example, if x or y could be a NaN, the expressions
                          .NOT. (x .LT. y) and x .GE. y
                  are not equivalent.
              10.1.6    Deﬁned operations
              10.1.6.1  Deﬁnitions
           1 Adeﬁned operation is either a unary operation or a binary operation. A unary deﬁned operation is an operation
              that has the form deﬁned-unary-op x or intrinsic-operator x and that is deﬁned by a function and a generic
              interface (7.5.5, 15.4.3.4).         2                       2
           2 Afunction deﬁnes the unary operation op x if
                                                         2
                    (1)   the function is speciﬁed with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that speciﬁes one
                          dummy argument d ,
                                             2
                    (2)   either
                          (a)   a generic interface (15.4.3.2) provides the function with a generic-spec of OPERATOR (op),
                                or
                          (b)   there is a generic binding (7.5.5) in the declared type of x  with a generic-spec of OPER-
                                                                                            2
                                ATOR(op) and there is a corresponding binding to the function in the dynamic type of x ,
                                                                                                                         2
                    (3)   the type of d is compatible with the dynamic type of x ,
                                       2                                         2
                    (4)   the type parameters, if any, of d match the corresponding type parameters of x , and
                                                          2                                              2
                    (5)   either
                          (a)   the rank of x2 matches that of d2 or
                          (b)   the function is elemental and there is no other function that deﬁnes the operation.
           3 If d is an array, the shape of x shall match the shape of d .
                 2                           2                           2
           4 Abinary deﬁned operation is an operation that has the form x deﬁned-binary-op x or x intrinsic-operator x
              and that is deﬁned by a function and a generic interface.     1                    2    1                     2
           5 Afunction deﬁnes the binary operation x1 op x2 if
                    (1)   the function is speciﬁed with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that speciﬁes
                          two dummy arguments, d1 and d2,
                    (2)   either
                          (a)   a generic interface (15.4.3.2) provides the function with a generic-spec of OPERATOR (op),
                                or
                          (b)   there is a generic binding (7.5.5) in the declared type of x   or x with a generic-spec of
                                                                                             1      2
                                OPERATOR (op) and there is a corresponding binding to the function in the dynamic type
                                of x1 or x2, respectively,
                    (3)   the types of d and d are compatible with the dynamic types of x and x , respectively,
                                       1       2                                            1      2
                    (4)   the type parameters, if any, of d and d match the corresponding type parameters of x and x ,
                          respectively, and                1      2                                                1       2
                    (5)   either
                          (a)   the ranks of x and x match those of d and d , respectively, or
                                              1      2                  1      2
                                                                              c
              160                                                            ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                         (b)   the function is elemental, x and x are conformable, and there is no other function that deﬁnes
                               the operation.            1      2
          6 If d or d is an array, the shapes of x and x shall match the shapes of d and d , respectively.
                 1    2                           1      2                           1      2
                  NOTE10.27
                  An intrinsic operator can be used as the operator in a deﬁned operation. In such a case, the generic
                  properties of the operator are extended.
             10.1.6.2   Interpretation of a deﬁned operation
          1 The interpretation of a deﬁned operation is provided by the function that deﬁnes the operation.
          2 The operators <, <=, >, >=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
             .GT., .GE., .EQ., and .NE., respectively.
             10.1.6.3   Evaluation of a deﬁned operation
          1 Once the interpretation of a deﬁned operation is established, the processor may evaluate any other expression
             that is equivalent, provided that the integrity of parentheses is not violated.
          2 Two expressions of derived type are equivalent if their values are equal for all possible values of their primaries.
             10.1.7     Evaluation of operands
          1 It is not necessary for a processor to evaluate all of the operands of an expression, or to evaluate entirely each
             operand, if the value of the expression can be determined otherwise.
                  NOTE10.28
                  This principle is most often applicable to logical expressions, zero-sized arrays, and zero-length strings, but
                  it applies to all expressions.
                  For example, in evaluating the expression
                          X > Y .OR. L (Z)
                  where X, Y, and Z are real and L is a function of type logical, the function reference L (Z) need not be
                  evaluated if X is greater than Y. Similarly, in the array expression
                          W (Z) + A
                  where A is of size zero and W is a function, the function reference W (Z) need not be evaluated.
          2 If a statement contains a function reference in a part of an expression that need not be evaluated, all entities that
             would have become deﬁned in the execution of that reference become undeﬁned at the completion of evaluation
             of the expression containing the function reference.
                  NOTE10.29
                  In the examples in NOTE 10.28, if L or W deﬁnes its argument, evaluation of the expressions under the
                  speciﬁed conditions causes Z to become undeﬁned, no matter whether or not L(Z) or W(Z) is evaluated.
          3 If a statement contains a function reference in a part of an expression that need not be evaluated, no invocation
             of that function in that part of the expression shall execute an image control statement other than CRITICAL
             or END CRITICAL.
                  NOTE10.30
                  This restriction is intended to avoid inadvertent deadlock caused by optimization.
              c
             ISO/IEC 2017 – All rights reserved                                                                     161
             ISO/IEC DIS 1539-1:2017 (E)
             10.1.8     Integrity of parentheses
          1 The rules for evaluation speciﬁed in subclause 10.1.5 state certain conditions under which a processor may
             evaluate an expression that is diﬀerent from the one speciﬁed by applying the rules given in 10.1.2 and rules for
             interpretation speciﬁed in subclause 10.1.5. However, any expression in parentheses shall be treated as a data
             entity.
                  NOTE10.31
                  For example, in evaluating the expression A + (B – C) where A, B, and C are of numeric types, the
                  diﬀerence of B and C shall be evaluated before the addition operation is performed; the processor shall not
                  evaluate the mathematically equivalent expression (A + B) – C.
             10.1.9     Type, type parameters, and shape of an expression
             10.1.9.1   General
          1 Thetype,typeparameters,andshapeofanexpressiondependontheoperatorsandonthetypes,typeparameters,
             and shapes of the primaries used in the expression, and are determined recursively from the syntactic form of the
             expression. The type of an expression is one of the intrinsic types (7.4) or a derived type (7.5).
          2 If an expression is a polymorphic primary or deﬁned operation, the type parameters and the declared and dynamic
             types of the expression are the same as those of the primary or deﬁned operation. Otherwise the type parameters
             and dynamic type of the expression are the same as its declared type and type parameters; they are referred to
             simply as the type and type parameters of the expression.
             R1024 logical-expr                  is  expr
             C1006 (R1024) logical-expr shall be of type logical.
             R1025 default-char-expr             is  expr
             C1007 (R1025) default-char-expr shall be default character.
             R1026 int-expr                      is  expr
             C1008 (R1026) int-expr shall be of type integer.
             R1027 numeric-expr                  is  expr
             C1009 (R1027) numeric-expr shall be of type integer, real, or complex.
             10.1.9.2   Type, type parameters, and shape of a primary
          1 The type, type parameters, and shape of a primary are determined according to whether the primary is a literal
             constant, designator, array constructor, structure constructor, function reference, type parameter inquiry, type
             parameter name, or parenthesized expression. If a primary is a literal constant, its type, type parameters, and
             shape are those of the literal constant. If it is a structure constructor, it is scalar and its type and type parameters
             are as described in 7.5.10. If it is an array constructor, its type, type parameters, and shape are as described in
             7.8. If it is a designator or function reference, its type, type parameters, and shape are those of the designator
             (8.2, 8.5) or the function reference (15.5.3), respectively. If the function reference is generic (15.4.3.2, 16.7)
             then its type, type parameters, and shape are those of the speciﬁc function referenced, which is determined by
             the declared types, type parameters, and ranks of its actual arguments as speciﬁed in 15.5.5.2. If it is a type
             parameter inquiry or type parameter name, it is a scalar integer with the kind of the type parameter.
          2 If a primary is a parenthesized expression, its type, type parameters, and shape are those of the expression.
          3 The associated target object is referenced if a pointer appears as
                 • a primary in an intrinsic or deﬁned operation,
                                                                            c
             162                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                 • the expr of a parenthesized primary, or
                 • the only primary on the right-hand side of an intrinsic assignment statement.
          4 Thetype, type parameters, and shape of the primary are those of the target. If the pointer is not associated with
             a target, it may appear as a primary only as an actual argument in a reference to a procedure whose corresponding
             dummy argument is declared to be a pointer, as the target in a pointer assignment statement, or as explicitly
             permitted elsewhere in this document.
          5 A disassociated array pointer or an unallocated allocatable array has no shape but does have rank. The type,
             type parameters, and rank of the result of the intrinsic function NULL (16.9.144) depend on context.
             10.1.9.3   Type, type parameters, and shape of the result of an operation
          1 The type of the result of an intrinsic operation [x ] op x is speciﬁed by Table 10.2. The shape of the result of
                                                             1      2
             an intrinsic operation is the shape of x2 if op is unary or if x1 is scalar, and is the shape of x1 otherwise.
          2 The type, type parameters, and shape of the result of a deﬁned operation [x ] op x are speciﬁed by the function
             deﬁning the operation (10.1.6).                                          1     2
          3 Anexpression of an intrinsic type has a kind type parameter. An expression of type character also has a character
             length parameter.
          4 The type parameters of the result of an intrinsic operation are as follows.
                 • For an expression x // x where // is the character intrinsic operator and x and x are of type character,
                                     1     2                                                1      2
                   the character length parameter is the sum of the lengths of the operands and the kind type parameter is
                   the kind type parameter of x , which shall be the same as the kind type parameter of x .
                                               1                                                       2
                 • For an expression op x where op is an intrinsic unary operator and x is of type integer, real, complex, or
                                        2                                             2
                   logical, the kind type parameter of the expression is that of the operand.
                 • For an expression x op x where op is a numeric intrinsic binary operator with one operand of type integer
                                     1     2
                   and the other of type real or complex, the kind type parameter of the expression is that of the real or
                   complex operand.
                 • For an expression x1 op x2 where op is a numeric intrinsic binary operator with both operands of the same
                   type and kind type parameters, or with one real and one complex with the same kind type parameters, the
                   kind type parameter of the expression is identical to that of each operand. In the case where both operands
                   are integer with diﬀerent kind type parameters, the kind type parameter of the expression is that of the
                   operand with the greater decimal exponent range if the decimal exponent ranges are diﬀerent; if the decimal
                   exponent ranges are the same, the kind type parameter of the expression is processor dependent, but it is
                   the same as that of one of the operands. In the case where both operands are any of type real or complex
                   with diﬀerent kind type parameters, the kind type parameter of the expression is that of the operand with
                   the greater decimal precision if the decimal precisions are diﬀerent; if the decimal precisions are the same,
                   the kind type parameter of the expression is processor dependent, but it is the same as that of one of the
                   operands.
                 • For an expression x op x where op is a logical intrinsic binary operator with both operands of the same
                                      1     2
                   kind type parameter, the kind type parameter of the expression is identical to that of each operand. In the
                   case where both operands are of type logical with diﬀerent kind type parameters, the kind type parameter
                   of the expression is processor dependent, but it is the same as that of one of the operands.
                 • For an expression x op x where op is a relational intrinsic operator, the kind type parameter of the
                                      1      2
                   expression is default logical.
             10.1.10     Conformability rules for elemental operations
          1 Anelemental operation is an intrinsic operation or a deﬁned operation for which the function is elemental (15.8).
          2 For all elemental binary operations, the two operands shall be conformable. In the case where one is a scalar and
             the other an array, the scalar is treated as if it were an array of the same shape as the array operand with every
             element, if any, of the array equal to the value of the scalar.
              c
             ISO/IEC 2017 – All rights reserved                                                                     163
                ISO/IEC DIS 1539-1:2017 (E)
                10.1.11      Speciﬁcation expression
            1 Aspeciﬁcation expression is an expression with limitations that make it suitable for use in speciﬁcations such as
                length type parameters (C704) and array bounds (R817, R818). A speciﬁcation-expr shall be a constant expression
                unless it is in an interface body (15.4.3.2), the speciﬁcation part of a subprogram or BLOCK construct, a derived
                type deﬁnition, or the declaration-type-spec of a FUNCTION statement (15.6.2.2).
                R1028 speciﬁcation-expr                   is  scalar-int-expr
                C1010 (R1028) The scalar-int-expr shall be a restricted expression.
            2 Arestricted expression is an expression in which each operation is intrinsic or deﬁned by a speciﬁcation function
                and each primary is
                       (1)    a constant or subobject of a constant,
                       (2)    an object designator with a base object that is a dummy argument that has neither the OPTIONAL
                              nor the INTENT (OUT) attribute,
                       (3)    an object designator with a base object that is in a common block,
                       (4)    an object designator with a base object that is made accessible by use or host association,
                       (5)    an array constructor where each element and each scalar-int-expr of each ac-implied-do-control is a
                              restricted expression,
                       (6)    a structure constructor where each component is a restricted expression,
                       (7)    a speciﬁcation inquiry where each designator or argument is
                              (a)    a restricted expression or
                              (b)    a variable that is not an optional dummy argument, and whose properties inquired about are
                                     not
                                     (i)    dependent on the upper bound of the last dimension of an assumed-size array,
                                     (ii)   deferred, or
                                     (iii)  deﬁned by an expression that is not a restricted expression,
                       (8)    a speciﬁcation inquiry that is a constant expression,
                       (9)    a reference to the intrinsic function PRESENT,
                       (10)   a reference to any other standard intrinsic function where each argument is a restricted expression,
                       (11)   a reference to a transformational function from the intrinsic module IEEE_ARITHMETIC, IEEE_-
                              EXCEPTIONS, or ISO_C_BINDING, where each argument is a restricted expression,
                       (12)   a reference to a speciﬁcation function where each argument is a restricted expression,
                       (13)   a type parameter of the derived type being deﬁned,
                       (14)   an ac-do-variable within an array constructor where each scalar-int-expr of the corresponding ac-
                              implied-do-control is a restricted expression, or
                       (15)   a restricted expression enclosed in parentheses,
            3 where each subscript, section subscript, substring starting point, substring ending point, and type parameter
                value is a restricted expression, and where any ﬁnal subroutine that is invoked is pure.
            4 Aspeciﬁcation inquiry is a reference to
                       (1)    an intrinsic inquiry function other than PRESENT,
                       (2)    a type parameter inquiry (9.4.5),
                       (3)    an inquiry function from the intrinsic modules IEEE_ARITHMETIC and IEEE_EXCEPTIONS
                              (17.10),
                       (4)    the function C_SIZEOF from the intrinsic module ISO_C_BINDING (18.2.3.7), or
                       (5)    the COMPILER_VERSION or COMPILER_OPTIONS function from the intrinsic module ISO_-
                              FORTRAN_ENV(16.10.2.6, 16.10.2.7).
                                                                                         c
                164                                                                      ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         5 Afunction is a speciﬁcation function if it is a pure function, is not a standard intrinsic function, is not an internal
            function, is not a statement function, and does not have a dummy procedure argument.
         6 Evaluation of a speciﬁcation expression shall not directly or indirectly cause a procedure deﬁned by the subpro-
            gram in which it appears to be invoked.
                NOTE10.32
                Speciﬁcation functions are nonintrinsic functions that can be used in speciﬁcation expressions to determine
                the attributes of data objects. The requirement that they be pure ensures that they cannot have side eﬀects
                that could aﬀect other objects being declared in the same speciﬁcation-part. The requirement that they
                not be internal ensures that they cannot inquire, via host association, about other objects being declared
                in the same speciﬁcation-part. The prohibition against recursion avoids the creation of a new instance of a
                procedure while construction of one is in progress.
         7 A variable in a speciﬁcation expression shall have its type and type parameters, if any, speciﬁed by a previous
            declaration in the same scoping unit, by the implicit typing rules in eﬀect for the scoping unit, or by host or use
            association. If a variable in a speciﬁcation expression is typed by the implicit typing rules, its appearance in any
            subsequent type declaration statement shall conﬁrm the implied type and type parameters.
         8 If a speciﬁcation expression includes a speciﬁcation inquiry that depends on a type parameter, array bound,
            or cobound of an entity speciﬁed in the same speciﬁcation-part, the type parameter, array bound, or cobound
            shall be speciﬁed in a prior speciﬁcation of the speciﬁcation-part. The prior speciﬁcation may be to the left of
            the speciﬁcation inquiry in the same statement, but shall not be within the same entity-decl. If a speciﬁcation
            expression includes a reference to the value of an element of an array speciﬁed in the same speciﬁcation-part, the
            array shall be completely speciﬁed in prior declarations.
         9 A generic entity referenced in a speciﬁcation expression in the speciﬁcation-part of a scoping unit shall have no
            speciﬁc procedures deﬁned in the scoping unit, or its host scoping unit, subsequent to the speciﬁcation expression.
                NOTE10.33
                The following are examples of speciﬁcation expressions:
                       LBOUND (B, 1) + 5  ! B is an assumed-shape dummy array
                       M + LEN (C)        ! M and C are dummy arguments
                       2 * PRECISION (A)  ! A is a real variable made accessible by a USE statement
            10.1.12   Constant expression
         1 A constant expression is an expression with limitations that make it suitable for use as a kind type parameter,
            initializer, or named constant. It is an expression in which each operation is intrinsic, and each primary is
                 (1)  a constant or subobject of a constant,
                 (2)  an array constructor where each element and each scalar-int-expr of each ac-implied-do-control is a
                      constant expression,
                 (3)  a structure constructor where each component-spec corresponding to
                      (a)  an allocatable component is a reference to the intrinsic function NULL,
                      (b)  a pointer component is an initialization target or a reference to the intrinsic function NULL,
                           and
                      (c)  any other component is a constant expression,
                 (4)  a speciﬁcation inquiry where each designator or argument is
                      (a)  a constant expression or
                      (b)  a variable whose properties inquired about are not
                           (i)  assumed,
            c
            ISO/IEC 2017 – All rights reserved                                                      165
                  ISO/IEC DIS 1539-1:2017 (E)
                                          (ii)     deferred, or
                                          (iii)    deﬁned by an expression that is not a constant expression,
                          (5)     a reference to an elemental standard intrinsic function, where each argument is a constant expression,
                          (6)     areference to a standard intrinsic function that is transformational, other than COMMAND_ARGU-
                                  MENT_COUNT, NULL, NUM_IMAGES, THIS_IMAGE, or TRANSFER, where each argument
                                  is a constant expression,
                          (7)     a reference to the intrinsic function NULL that does not have an argument with a type parameter
                                  that is assumed or is deﬁned by an expression that is not a constant expression,
                          (8)     a reference to the intrinsic function TRANSFER where each argument is a constant expression and
                                  each ultimate pointer component of the SOURCE argument is disassociated,
                          (9)     areferencetoatransformationalfunctionfromtheintrinsicmoduleIEEE_ARITHMETICorIEEE_-
                                  EXCEPTIONS, where each argument is a constant expression,
                          (10)    a previously declared kind type parameter of the derived type being deﬁned,
                          (11)    a data-i-do-variable within a data-implied-do,
                          (12)    an ac-do-variable within an array constructor where each scalar-int-expr of the corresponding ac-
                                  implied-do-control is a constant expression, or
                          (13)    a constant expression enclosed in parentheses,
                  and where each subscript, section subscript, substring starting point, substring ending point, and type parameter
                  value is a constant expression.
                  R1029 constant-expr                              is   expr
                  C1011 (R1029) constant-expr shall be a constant expression.
                  R1030 default-char-constant-expr                 is   default-char-expr
                  C1012 (R1030) default-char-constant-expr shall be a constant expression.
                  R1031 int-constant-expr                          is   int-expr
                  C1013 (R1031) int-constant-expr shall be a constant expression.
              2 If a constant expression includes a speciﬁcation inquiry that depends on a type parameter or an array bound of
                  an entity speciﬁed in the same speciﬁcation-part, the type parameter or array bound shall be speciﬁed in a prior
                  speciﬁcation of the speciﬁcation-part. The prior speciﬁcation may be to the left of the speciﬁcation inquiry in the
                  same statement, but shall not be within the same entity-decl unless the speciﬁcation inquiry appears within an
                  initialization.
              3 Agenericentity referenced in a constant expression in the speciﬁcation-part of a scoping unit shall have no speciﬁc
                  procedures deﬁned in that scoping unit, or its host scoping unit, subsequent to the constant expression.
                         NOTE10.34
                        The following are examples of constant expressions:
                                    3
                                    -3 + 4
                                    ’AB’
                                    ’AB’ // ’CD’
                                    (’AB’ // ’CD’) // ’EF’
                                    SIZE (A)
                                    DIGITS (X) + 4
                                    4.0 * ATAN (1.0)
                                    CEILING (number_of_decimal_digits / LOG10 (REAL (RADIX (0.0))))
                        where A is an explicit-shape array with constant bounds, X is default real, and number_of_decimal_digits
                        is an integer named constant.
                                                                                                        c
                  166                                                                                  ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             10.2      Assignment
             10.2.1     Assignment statement
             10.2.1.1   General form
             R1032 assignment-stmt               is  variable = expr
             C1014 (R1032) The variable shall not be a whole assumed-size array.
                  NOTE10.35
                  Examples of an assignment statement are:
                          A = 3.5 + X * Y
                          I = INT (A)
          1 An assignment-stmt shall meet the requirements of either a deﬁned assignment statement or an intrinsic assign-
             ment statement.
             10.2.1.2   Intrinsic assignment statement
          1 An intrinsic assignment statement is an assignment statement that is not a deﬁned assignment statement
             (10.2.1.4). In an intrinsic assignment statement,
                   (1)   if the variable is polymorphic it shall be allocatable and not a coarray,
                   (2)   if expr is an array then the variable shall also be an array,
                   (3)   the variable and expr shall be conformable unless the variable is an allocatable array that has the
                         same rank as expr and is not a coarray,
                   (4)   if the variable is polymorphic it shall be type compatible with expr; otherwise the declared types of
                         the variable and expr shall conform as speciﬁed in Table 10.8,
                   (5)   if the variable is of type character and of ISO 10646, ASCII, or default character kind, expr shall be
                         of ISO 10646, ASCII, or default character kind,
                   (6)   otherwise if the variable is of type character expr shall have the same kind type parameter,
                   (7)   if the variable is of derived type each kind type parameter of the variable shall have the same value
                         as the corresponding kind type parameter of expr, and
                   (8)   if the variable is of derived type each length type parameter of the variable shall have the same value
                         as the corresponding type parameter of expr unless the variable is allocatable, is not a coarray, and
                         its corresponding type parameter is deferred.
                                        Table 10.8: Intrinsic assignment type conformance
                                        Type of the variable            Type of expr
                                              integer               integer, real, complex
                                                real                integer, real, complex
                                              complex               integer, real, complex
                                             character                    character
                                               logical                     logical
                                            derived type      same derived type as the variable
          2 If the variable in an intrinsic assignment statement is a coindexed object,
                 • the variable shall not be polymorphic,
                 • the variable shall not have an allocatable ultimate component,
                 • the variable shall be conformable with expr, and
                 • each deferred length type parameter of the variable shall have the same value as the corresponding type
                   parameter of expr.
              c
             ISO/IEC 2017 – All rights reserved                                                                     167
             ISO/IEC DIS 1539-1:2017 (E)
          3 If the variable is a pointer, it shall be associated with a deﬁnable target such that the type, type parameters,
             and shape of the target and expr conform. If the variable is a coarray or a coindexed object, it shall not be an
             unallocated allocatable variable.
             10.2.1.3   Interpretation of intrinsic assignments
          1 Execution of an intrinsic assignment causes, in eﬀect, the evaluation of the expression expr and all expressions
             within variable (10.1), the possible conversion of expr to the type and type parameters of the variable (Table
             10.9), and the deﬁnition of the variable with the resulting value. The execution of the assignment shall have
             the same eﬀect as if the evaluation of expr and the evaluation of all expressions in variable occurred before any
             portion of the variable is deﬁned by the assignment. The evaluation of expressions within variable shall neither
             aﬀect nor be aﬀected by the evaluation of expr.
          2 If the variable is a pointer, the value of expr is assigned to the target of the variable.
          3 If the variable is an unallocated allocatable array, expr shall have the same rank. If the variable is an allocated
             allocatable variable, it is deallocated if expr is an array of diﬀerent shape, any corresponding length type parameter
             values of the variable and expr diﬀer, or the variable is polymorphic and the dynamic type or any corresponding
             kind type parameter values of the variable and expr diﬀer. If the variable is or becomes an unallocated allocatable
             variable, it is then allocated with
                 • the same dynamic type and kind type parameter values as expr if the variable is polymorphic,
                 • each deferred type parameter equal to the corresponding type parameter of expr,
                 • the same bounds as before if the variable is an array and expr is scalar, and
                 • the shape of expr with each lower bound equal to the corresponding element of LBOUND (expr) if expr is
                   an array.
                  NOTE10.36
                  For example, given the declaration
                          CHARACTER(:),ALLOCATABLE :: NAME
                  then after the assignment statement
                          NAME = ’Dr. ’//FIRST_NAME//’ ’//SURNAME
                  NAME will have the length LEN (FIRST_NAME) + LEN (SURNAME) + 5, even if it had previously
                  been unallocated, or allocated with a diﬀerent length. However, the assignment statement
                          NAME(:) = ’Dr. ’//FIRST_NAME//’ ’//SURNAME
                  is only conforming if NAME is already allocated at the time of the assignment; the assigned value is
                  truncated or blank padded to the previously allocated length of NAME.
          4 Both variable and expr may contain references to any portion of the variable.
                  NOTE10.37
                  For example, in the character intrinsic assignment statement:
                          STRING (2:5) = STRING (1:4)
                  the assignment of the ﬁrst character of STRING to the second character does not aﬀect the evaluation of
                  STRING (1:4). If the value of STRING prior to the assignment was ’ABCDEF’, the value following the
                  assignment is ’AABCDF’.
          5 If expr is a scalar and the variable is an array, the expr is treated as if it were an array of the same shape as the
             variable with every element of the array equal to the scalar value of expr.
                                                                            c
             168                                                           ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
           6 If the variable is an array, the assignment is performed element-by-element on corresponding array elements of
              the variable and expr.
                   NOTE10.38
                  For example, if A and B are arrays of the same shape, the array intrinsic assignment
                      A = B
                  assigns the corresponding elements of B to those of A; that is, the ﬁrst element of B is assigned to the ﬁrst
                  element of A, the second element of B is assigned to the second element of A, etc.
                  If C is an allocatable array of rank 1, then
                      C = PACK (ARRAY, ARRAY>0)
                  will cause C to contain all the positive elements of ARRAY in array element order; if C is not allocated or
                  is allocated with the wrong size, it will be re-allocated to be of the correct size to hold the result of PACK.
           7 The processor may perform the element-by-element assignment in any order.
                   NOTE10.39
                  For example, the following program segment results in the values of the elements of array X being reversed:
                      REAL X (10)
                          ...
                      X (1:10) = X (10:1:-1)
           8 For an intrinsic assignment statement where the variable is of numeric type, the expr can have a diﬀerent numeric
              type or kind type parameter, in which case the value of expr is converted to the type and kind type parameter
              of the variable according to the rules of Table 10.9.
                                  Table 10.9: Numeric conversion and the assignment statement
                                     Type of the variable  Value assigned
                                     integer               INT (expr, KIND = KIND (variable))
                                     real                  REAL(expr, KIND = KIND (variable))
                                     complex               CMPLX(expr, KIND = KIND (variable))
                                     Note: INT, REAL, CMPLX, and KIND are the generic names
                                           of functions deﬁned in 16.9.
           9 For an intrinsic assignment statement where the variable is of type logical, the expr can have a diﬀerent kind
              type parameter, in which case the value of expr is converted to the kind type parameter of the variable.
          10 For an intrinsic assignment statement where the variable is of type character, the expr can have a diﬀerent
              character length parameter in which case the conversion of expr to the length of the variable is as follows.
                    (1)   If the length of the variable is less than that of expr, the value of expr is truncated from the right
                          until it is the same length as the variable.
                    (2)   If the length of the variable is greater than that of expr, the value of expr is extended on the right
                          with blanks until it is the same length as the variable.
          11 Foranintrinsicassignmentstatementwherethevariableisoftypecharacter, if expr has a diﬀerent kind type para-
              meter, each character c in expr is converted to the kind type parameter of the variable by ACHAR (IACHAR(c),
              KIND (variable)).
              c
              ISO/IEC 2017 – All rights reserved                                                                       169
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE10.40
                   For nondefault character kinds, the blank padding character is processor dependent. When assigning a char-
                   acter expression to a variable of a diﬀerent kind, each character of the expression that is not representable
                   in the kind of the variable is replaced by a processor-dependent character.
          12 For an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING,
              or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, the variable becomes undeﬁned
              if the variable and expr are not on the same image.
                   NOTE10.41
                   Anintrinsic assignment statement for a variable of declared type C_PTR, C_FUNPTR, or TEAM_TYPE
                   cannot involve a coindexed object, see C915, which prevents inappropriate copying from one image to
                   another. However, such copying can occur for a component in a derived-type intrinsic assignment.
          13 An intrinsic assignment where the variable is of derived type is performed as if each component of the variable
              were assigned from the corresponding component of expr using pointer assignment (10.2.2) for each pointer
              component, deﬁned assignment for each nonpointer nonallocatable component of a type that has a type-bound
              deﬁned assignment consistent with the component, intrinsic assignment for each other nonpointer nonallocatable
              component, and intrinsic assignment for each allocated coarray component. For unallocated coarray components,
              the corresponding component of the variable shall be unallocated. For a noncoarray allocatable component the
              following sequence of operations is applied.
                     (1)   If the component of the variable is allocated, it is deallocated.
                     (2)   If the component of the value of expr is allocated, the corresponding component of the variable is
                           allocated with the same dynamic type and type parameters as the component of the value of expr.
                           If it is an array, it is allocated with the same bounds. The value of the component of the value of
                           expr is then assigned to the corresponding component of the variable using deﬁned assignment if the
                           declared type of the component has a type-bound deﬁned assignment consistent with the component,
                           and intrinsic assignment for the dynamic type of that component otherwise.
          14 The processor may perform the component-by-component assignment in any order or by any means that has the
              same eﬀect.
                   NOTE10.42
                   For an example of a derived-type intrinsic assignment statement, if C and D are of the same derived type
                   with a pointer component P and nonpointer components S, T, U, and V of type integer, logical, character,
                   and another derived type, respectively, the intrinsic assignment
                            C = D
                   pointer assigns D%P to C%P. It assigns D%S to C%S, D%T to C%T, and D%U to C%U using intrinsic
                   assignment. It assigns D%V to C%V using deﬁned assignment if objects of that type have a compatible
                   type-bound deﬁned assignment, and intrinsic assignment otherwise.
                   NOTE10.43
                   If an allocatable component of expr is unallocated, the corresponding component of the variable has an
                   allocation status of unallocated after execution of the assignment.
              10.2.1.4   Deﬁned assignment statement
           1 Adeﬁnedassignmentstatementis an assignment statement that is deﬁned by a subroutine and a generic interface
              (7.5.5, 15.4.3.4.3) that speciﬁes ASSIGNMENT (=).
           2 Asubroutine deﬁnes the deﬁned assignment x1 = x2 if
                     (1)   the subroutine is speciﬁed with a SUBROUTINE(15.6.2.3) orENTRY(15.6.2.6) statement that speciﬁes
                           two dummy arguments, d1 and d2,
                                                                                 c
              170                                                                ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                   (2)   either
                         (a)    agenericinterface (15.4.3.2) provides the subroutine with a generic-spec of ASSIGNMENT (=),
                                or
                         (b)    there is a generic binding (7.5.5) in the declared type of x  or x with a generic-spec of
                                                                                            1     2
                                ASSIGNMENT (=) and there is a corresponding binding to the subroutine in the dynamic
                                type of x or x , respectively,
                                        1     2
                   (3)   the types of d and d are compatible with the dynamic types of x and x , respectively,
                                       1      2                                            1      2
                   (4)   the type parameters, if any, of d and d match the corresponding type parameters of x and x ,
                         respectively, and                1      2                                               1       2
                   (5)   either
                         (a)    the ranks of x and x match those of d and d or
                                             1       2                 1      2
                         (b)    the subroutine is elemental, x2 is scalar or has the same rank as x1, and there is no other
                                subroutine that deﬁnes the assignment.
           3 If d or d is an array, the shapes of x and x shall match the shapes of d and d , respectively. If the subroutine
                 1    2                           1      2                          1       2
             is elemental, x shall be conformable with x .
                            2                           1
             10.2.1.5   Interpretation of deﬁned assignment statements
           1 The interpretation of a deﬁned assignment is provided by the subroutine that deﬁnes it.
           2 If the deﬁned assignment is an elemental assignment and the variable in the assignment is an array, the deﬁned
             assignment is performed element-by-element, on corresponding elements of the variable and expr. If expr is a
             scalar, it is treated as if it were an array of the same shape as the variable with every element of the array equal
             to the scalar value of expr.
                  NOTE10.44
                  Therules of deﬁned assignment (15.4.3.4.3), procedure references (15.5), subroutine references (15.5.4), and
                  elemental subroutine arguments (15.8.3) ensure that the deﬁned assignment has the same eﬀect as if the
                  evaluation of all operations in x2 and x1 occurs before any portion of x1 is deﬁned. If an elemental assignment
                  is deﬁned by a pure elemental subroutine, the element assignments can be performed simultaneously or in
                  any order.
             10.2.2     Pointer assignment
             10.2.2.1   General
           1 Pointer assignment causes a pointer to become associated with a target or causes its pointer association status
             to become disassociated or undeﬁned. Any previous association between the pointer and a target is broken.
           2 Pointer assignment for a pointer component of a structure may also take place by execution of a derived-type
             intrinsic assignment statement (10.2.1.3).
             10.2.2.2   Syntax of the pointer assignment statement
             R1033 pointer-assignment-stmt        is  data-pointer-object [ (bounds-spec-list) ] => data-target
                                                  or data-pointer-object (bounds-remapping-list ) => data-target
                                                  or proc-pointer-object => proc-target
             R1034 data-pointer-object            is  variable-name
                                                  or scalar-variable % data-pointer-component-name
             C1015 (R1033)Ifdata-target is not unlimited polymorphic, data-pointer-object shall be type compatible (7.3.2.3)
                     with it and the corresponding kind type parameters shall be equal.
              c
             ISO/IEC 2017 – All rights reserved                                                                      171
            ISO/IEC DIS 1539-1:2017 (E)
            C1016 (R1033) If data-target is unlimited polymorphic, data-pointer-object shall be unlimited polymorphic, or
                   of a type with the BIND attribute or the SEQUENCE attribute.
            C1017 (R1033) If bounds-spec-list is speciﬁed, the number of bounds-specs shall equal the rank of data-pointer-
                   object.
            C1018 (R1033) If bounds-remapping-list is speciﬁed, the number of bounds-remappings shall equal the rank of
                   data-pointer-object.
            C1019 (R1033) If bounds-remapping-list is not speciﬁed, the ranks of data-pointer-object and data-target shall
                   be the same.
            C1020 (R1033) A coarray data-target shall have the VOLATILE attribute if and only if the data-pointer-object
                   has the VOLATILE attribute.
            C1021 (R1034) A variable-name shall have the POINTER attribute.
            C1022 (R1034) A scalar-variable shall be a data-ref.
            C1023 (R1034) A data-pointer-component-name shall be the name of a component of scalar-variable that is a
                   data pointer.
            C1024 (R1034) A data-pointer-object shall not be a coindexed object.
            R1035 bounds-spec               is  lower-bound-expr :
            R1036 bounds-remapping          is  lower-bound-expr : upper-bound-expr
            R1037 data-target               is  expr
            C1025 (R1037)Theexpr shall be a designator that designates a variable with either the TARGET or POINTER
                   attribute and is not an array section with a vector subscript, or it shall be a reference to a function that
                   returns a data pointer.
            C1026 (R1037) A data-target shall not be a coindexed object.
                NOTE10.45
                Adatapointer and its target are always on the same image. A coarray can be of a derived type with pointer
                or allocatable subcomponents. For example, if PTR is a pointer component, and Z%PTR on image P has
                been associated with a target by execution of an ALLOCATE statement or a pointer assignment on image
                P, Z[P]%PTR will be a reference to that target.
            R1038 proc-pointer-object       is  proc-pointer-name
                                            or proc-component-ref
            R1039 proc-component-ref        is  scalar-variable % procedure-component-name
            C1027 (R1039) The scalar-variable shall be a data-ref that is not a coindexed object.
            C1028 (R1039) The procedure-component-name shall be the name of a procedure pointer component of the
                   declared type of scalar-variable.
            R1040 proc-target               is  expr
                                            or procedure-name
                                            or proc-component-ref
            C1029 (R1040) An expr shall be a reference to a function whose result is a procedure pointer.
            C1030 (R1040) A procedure-name shall be the name of an internal, module, or dummy procedure, a procedure
                   pointer, a speciﬁc intrinsic function listed in Table 16.2, or an external procedure that is accessed by use or host
                   association, referenced in the scoping unit as a procedure, or that has the EXTERNAL attribute.
                                                                    c
            172                                                    ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             C1031 (R1040) The proc-target shall not be a nonintrinsic elemental procedure.
          1 In a pointer assignment statement, data-pointer-object or proc-pointer-object denotes the pointer object and
             data-target or proc-target denotes the pointer target.
          2 For pointer assignment performed by a derived-type intrinsic assignment statement, the pointer object is the
             pointer component of the variable and the pointer target is the corresponding component of expr.
             10.2.2.3   Data pointer assignment
          1 If the pointer object is not polymorphic (7.3.2.3) and the pointer target is polymorphic with dynamic type that
             diﬀers from its declared type, the assignment target is the ancestor component of the pointer target that has the
             type of the pointer object. Otherwise, the assignment target is the pointer target.
          2 If the pointer target is not a pointer, the pointer object becomes pointer associated with the assignment target;
             if the pointer target is a pointer with a target that is not on the same image, the pointer association status of the
             pointer object becomes undeﬁned. Otherwise, the pointer association status of the pointer object becomes that
             of the pointer target; if the pointer target is associated with an object, the pointer object becomes associated
             with the assignment target. If the pointer target is allocatable, it shall be allocated.
                  NOTE10.46
                  Apointer assignment statement is not permitted to involve a coindexed pointer or target, see C1024 and
                  C1026. This prevents a pointer assignment statement from associating a pointer with a target on another
                  image. If such an association would otherwise be implied, the association status of the pointer becomes
                  undeﬁned. For example, a derived-type intrinsic assignment where the variable and expr are on diﬀerent
                  images and the variable has an ultimate pointer component.
          3 If the pointer object is polymorphic, it assumes the dynamic type of the pointer target. If the pointer object is
             of a type with the BIND attribute or the SEQUENCE attribute, the dynamic type of the pointer target shall be
             that type.
          4 If the pointer target is a disassociated pointer, all nondeferred type parameters of the declared type of the pointer
             object that correspond to nondeferred type parameters of the pointer target shall have the same values as the
             corresponding type parameters of the pointer target.
          5 Otherwise, all nondeferred type parameters of the declared type of the pointer object shall have the same values
             as the corresponding type parameters of the pointer target.
          6 If the pointer object has nondeferred type parameters that correspond to deferred type parameters of the pointer
             target, the pointer target shall not be a pointer with undeﬁned association status.
          7 If the pointer object has the CONTIGUOUS attribute, the pointer target shall be contiguous.
          8 If the target of a pointer is a coarray, the pointer shall have the VOLATILE attribute if and only if the coarray
             has the VOLATILE attribute.
          9 If bounds-remapping-list appears, it speciﬁes the upper and lower bounds of each dimension of the pointer,
             and thus the extents; the pointer target shall be simply contiguous (9.5.4) or of rank one, and shall not be a
             disassociated or undeﬁned pointer. The number of elements of the pointer target shall not be less than the
             number implied by the bounds-remapping-list. The elements of the pointer object are associated with those of
             the pointer target, in array element order; if the pointer target has more elements than speciﬁed for the pointer
             object, the remaining elements are not associated with the pointer object.
         10 If no bounds-remapping-list appears, the extent of a dimension of the pointer object is the extent of the corres-
             ponding dimension of the pointer target. If bounds-spec-list appears, it speciﬁes the lower bounds; otherwise,
             the lower bound of each dimension is the result of the intrinsic function LBOUND (16.9.109) applied to the
             corresponding dimension of the pointer target. The upper bound of each dimension is one less than the sum of
             the lower bound and the extent.
              c
             ISO/IEC 2017 – All rights reserved                                                                     173
             ISO/IEC DIS 1539-1:2017 (E)
             10.2.2.4   Procedure pointer assignment
          1 If the pointer target is not a pointer, the pointer object becomes pointer associated with the pointer target.
             Otherwise, the pointer association status of the pointer object becomes that of the pointer target; if the pointer
             target is associated with a procedure, the pointer object becomes associated with the same procedure.
          2 The host instance (15.6.2.4) of an associated procedure pointer is the host instance of its target.
          3 If the pointer object has an explicit interface, its characteristics shall be the same as the pointer target except
             that the pointer target may be pure even if the pointer object is not pure and the pointer target may be an
             elemental intrinsic procedure even if the pointer object is not elemental.
          4 If the characteristics of the pointer object or the pointer target are such that an explicit interface is required,
             both the pointer object and the pointer target shall have an explicit interface.
          5 If the pointer object has an implicit interface and is explicitly typed or referenced as a function, the pointer target
             shall be a function. If the pointer object has an implicit interface and is referenced as a subroutine, the pointer
             target shall be a subroutine.
          6 If the pointer object is a function with an implicit interface, the pointer target shall be a function with the same
             type; corresponding type parameters shall have the same value.
          7 If procedure-name is a speciﬁc procedure name that is also a generic name, only the speciﬁc procedure is associated
             with the pointer object.
             10.2.2.5   Examples
                  NOTE10.47
                  The following are examples of pointer assignment statements. (See NOTE 15.14 for declarations of P and
                  BESSEL.)
                          NEW_NODE % LEFT => CURRENT_NODE
                          SIMPLE_NAME => TARGET_STRUCTURE % SUBSTRUCT % COMPONENT
                          PTR => NULL ( )
                          ROW => MAT2D (N, :)
                          WINDOW => MAT2D (I-1:I+1, J-1:J+1)
                          POINTER_OBJECT => POINTER_FUNCTION (ARG_1, ARG_2)
                          EVERY_OTHER => VECTOR (1:N:2)
                          WINDOW2 (0:, 0:) => MAT2D (ML:MU, NL:NU)
                          ! P is a procedure pointer and BESSEL is a procedure with a
                          ! compatible interface.
                          P => BESSEL
                          ! Likewise for a structure component.
                          STRUCT % COMPONENT => BESSEL
                  NOTE10.48
                  It is possible to obtain diﬀerent-rank views of parts of an object by specifying upper bounds in pointer
                  assignment statements. This requires that the object be either rank one or contiguous. Consider the
                  following example, in which a matrix is under consideration. The matrix is stored as a rank-one object in
                  MYDATAbecauseits diagonal is needed for some reason – the diagonal cannot be gotten as a single object
                  from a rank-two representation. The matrix is represented as a rank-two view of MYDATA.
                          real, target :: MYDATA ( NR*NC )           ! An automatic array
                          real, pointer :: MATRIX ( :, : )           ! A rank-two view of MYDATA
                          real, pointer :: VIEW_DIAG ( : )
                          MATRIX (1:NR, 1:NC) => MYDATA              ! The MATRIX view of the data
                                                                            c
             174                                                           ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE10.48 (cont.)
                       VIEW_DIAG => MYDATA (1::NR+1)        ! The diagonal of MATRIX
                Rows, columns, or blocks of the matrix can be accessed as sections of MATRIX.
                Rank remapping can be applied to CONTIGUOUS arrays, for example:
                       REAL, CONTIGUOUS, POINTER :: A (:)
                       REAL, CONTIGUOUS, TARGET  :: B (:,:) ! Dummy argument
                       A (1:SIZE(B)) => B                   ! Linear view of a rank-2 array
            10.2.3   Masked array assignment – WHERE
            10.2.3.1 General form of the masked array assignment
         1 A masked array assignment is either a WHERE statement or a WHERE construct. It is used to mask the
            evaluation of expressions and assignment of values in array assignment statements, according to the value of a
            logical array expression.
            R1041 where-stmt               is WHERE(mask-expr ) where-assignment-stmt
            R1042 where-construct          is where-construct-stmt
                                                     [ where-body-construct ] ...
                                                  [ masked-elsewhere-stmt
                                                     [ where-body-construct ] ... ] ...
                                                  [ elsewhere-stmt
                                                     [ where-body-construct ] ... ]
                                                  end-where-stmt
            R1043 where-construct-stmt     is [where-construct-name:] WHERE ( mask-expr )
            R1044 where-body-construct     is where-assignment-stmt
                                           or where-stmt
                                           or where-construct
            R1045 where-assignment-stmt    is assignment-stmt
            R1046 mask-expr                is logical-expr
            R1047 masked-elsewhere-stmt    is ELSEWHERE(mask-expr) [where-construct-name]
            R1048 elsewhere-stmt           is ELSEWHERE[where-construct-name]
            R1049 end-where-stmt           is ENDWHERE[where-construct-name]
            C1032 (R1045) A where-assignment-stmt that is a deﬁned assignment shall be elemental.
            C1033 (R1042) If the where-construct-stmt is identiﬁed by a where-construct-name, the corresponding end-
                  where-stmt shall specify the same where-construct-name. If the where-construct-stmt is not identiﬁed by
                  a where-construct-name, the corresponding end-where-stmt shall not specify a where-construct-name. If
                  an elsewhere-stmt or a masked-elsewhere-stmt is identiﬁed by a where-construct-name, the corresponding
                  where-construct-stmt shall specify the same where-construct-name.
            C1034 (R1044) A statement that is part of a where-body-construct shall not be a branch target statement.
         2 If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or another where-construct then each mask-
            expr within the where-construct shall have the same shape. In each where-assignment-stmt, the mask-expr and
            the variable being deﬁned shall be arrays of the same shape.
            c
            ISO/IEC 2017 – All rights reserved                                                      175
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE10.49
                Examples of a masked array assignment are:
                       WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP
                       WHERE (PRESSURE <= 1.0)
                          PRESSURE = PRESSURE + INC_PRESSURE
                          TEMP = TEMP - 5.0
                       ELSEWHERE
                          RAINING = .TRUE.
                       END WHERE
            10.2.3.2 Interpretation of masked array assignments
         1 When a WHERE statement or a where-construct-stmt is executed, a control mask is established. In addition,
            when a WHERE construct statement is executed, a pending control mask is established. If the statement does
            not appear as part of a where-body-construct, the mask-expr of the statement is evaluated, and the control mask is
            established to be the value of mask-expr. The pending control mask is established to have the value .NOT. mask-
            expr upon execution of a WHERE construct statement that does not appear as part of a where-body-construct.
            The mask-expr is evaluated only once.
         2 Each statement in a WHERE construct is executed in sequence.
         3 Upon execution of a masked-elsewhere-stmt, the following actions take place in sequence.
                 (1)  The control mask mc is established to have the value of the pending control mask.
                 (2)  The pending control mask is established to have the value m .AND. (.NOT. mask-expr).
                                                                         c
                 (3)  The control mask m is established to have the value m .AND. mask-expr.
                                       c                             c
         4 The mask-expr is evaluated at most once.
         5 Upon execution of an ELSEWHERE statement, the control mask is established to have the value of the pending
            control mask. No new pending control mask value is established.
         6 Upon execution of an ENDWHERE statement, the control mask and pending control mask are established to
            have the values they had prior to the execution of the corresponding WHERE construct statement. Following
            the execution of a WHERE statement that appears as a where-body-construct, the control mask is established to
            have the value it had prior to the execution of the WHERE statement.
                NOTE10.50
                The establishment of control masks and the pending control mask is illustrated with the following example:
                       WHERE(cond1)         ! Statement 1
                         ...
                       ELSEWHERE(cond2)     ! Statement 2
                         ...
                       ELSEWHERE            ! Statement 3
                         ...
                       END WHERE
                Following execution of statement 1, the control mask has the value cond1 and the pending
                control mask has the value .NOT. cond1.    Following execution of statement 2, the control
                mask has the value (.NOT. cond1) .AND. cond2 and the pending control mask has the value
                (.NOT. cond1) .AND. (.NOT. cond2). Following execution of statement 3, the control mask has the value
                (.NOT. cond1) .AND. (.NOT. cond2). The false condition values are propagated through the execution of
                the masked ELSEWHERE statement.
         7 Upon execution of a WHERE construct statement that is part of a where-body-construct, the pending control
            mask is established to have the value mc .AND. (.NOT. mask-expr). The control mask is then established to
            have the value m .AND. mask-expr. The mask-expr is evaluated at most once.
                          c
                                                                  c
            176                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         8 Upon execution of a WHERE statement that is part of a where-body-construct, the control mask is established
            to have the value m .AND. mask-expr. The pending control mask is not altered.
                            c
         9 If a nonelemental function reference occurs in the expr or variable of a where-assignment-stmt or in a mask-expr,
            the function is evaluated without any masked control; that is, all of its argument expressions are fully evaluated
            and the function is fully evaluated. If the result is an array and the reference is not within the argument list
            of a nonelemental function, elements corresponding to true values in the control mask are selected for use in
            evaluating the expr, variable or mask-expr.
        10 If an elemental operation or function reference occurs in the expr or variable of a where-assignment-stmt or in a
            mask-expr, and is not within the argument list of a nonelemental function reference, the operation is performed
            or the function is evaluated only for the elements corresponding to true values of the control mask.
        11 If an array constructor appears in a where-assignment-stmt or in a mask-expr, the array constructor is evaluated
            without any masked control and then the where-assignment-stmt is executed or the mask-expr is evaluated.
        12 Whenawhere-assignment-stmt is executed, the values of expr that correspond to true values of the control mask
            are assigned to the corresponding elements of the variable.
        13 The value of the control mask is established by the execution of a WHERE statement, a WHERE construct
            statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or an ENDWHERE statement.
            Subsequent changes to the value of entities in a mask-expr have no eﬀect on the value of the control mask. The
            execution of a function reference in the mask expression of a WHERE statement is permitted to aﬀect entities in
            the assignment statement.
                NOTE10.51
                Examples of function references in masked array assignments are:
                   WHERE (A > 0.0)
                      A = LOG (A)            ! LOG is invoked only for positive elements.
                      A = A / SUM (LOG (A))  ! LOG is invoked for all elements
                                             ! because SUM is transformational
                   END WHERE
            10.2.4   FORALL
            10.2.4.1 Form of the FORALL Construct
         1 The FORALL construct allows multiple assignments, masked array (WHERE) assignments, and nested FORALL constructs and
            statements to be controlled by a single concurrent-control-list and scalar-mask-expr.
            R1050 forall-construct         is forall-construct-stmt
                                                  [forall-body-construct ] ...
                                                  end-forall-stmt
            R1051 forall-construct-stmt    is [forall-construct-name :] FORALL concurrent-header
            R1052 forall-body-construct    is forall-assignment-stmt
                                           or where-stmt
                                           or where-construct
                                           or forall-construct
                                           or forall-stmt
            R1053 forall-assignment-stmt   is assignment-stmt
                                           or pointer-assignment-stmt
            R1054 end-forall-stmt          is ENDFORALL[forall-construct-name ]
            c
            ISO/IEC 2017 – All rights reserved                                                      177
             ISO/IEC DIS 1539-1:2017 (E)
             C1035   (R1054) If the forall-construct-stmt has a forall-construct-name, the end-forall-stmt shall have the same forall-construct-
                     name. If the end-forall-stmt has a forall-construct-name, the forall-construct-stmt shall have the same forall-construct-
                     name.
             C1036   (R1052) A statement in a forall-body-construct shall not deﬁne an index-name of the forall-construct.
             C1037   (R1052) Any procedure referenced in a forall-body-construct, including one referenced by a deﬁned operation, assignment,
                     or ﬁnalization, shall be a pure procedure.
             C1038   (R1052) A forall-body-construct shall not be a branch target.
          2 The scope and attributes of an index-name in a concurrent-header in a FORALL construct or statement are described in 19.4.
             10.2.4.2   Execution of the FORALL construct
             10.2.4.2.1  Execution stages
          1 There are three stages in the execution of a FORALL construct:
                   (1)   determination of the values for index-name variables,
                   (2)   evaluation of the scalar-mask-expr, and
                   (3)   execution of the FORALL body constructs.
             10.2.4.2.2  Determination of the values for index variables
          1 The values of the index variables are determined as they are for the DO CONCURRENT statement (11.1.7.4.2).
             10.2.4.2.3  Evaluation of the mask expression
          1 The mask expression is evaluated as it is for the DO CONCURRENT statement (11.1.7.4.2).
             10.2.4.2.4  Execution of the FORALL body constructs
          1 The forall-body-constructs are executed in the order in which they appear. Each construct is executed for all active combinations of
             the index-name values with the following interpretation:
          2 Execution of a forall-assignment-stmt that is an assignment-stmt causes the evaluation of expr and all expressions within variable
             for all active combinations of index-name values. These evaluations may be done in any order. After all these evaluations have been
             performed, each expr value is assigned to the corresponding variable. The assignments may occur in any order.
          3 Execution of a forall-assignment-stmt that is a pointer-assignment-stmt causes the evaluation of all expressions within data-target
             and data-pointer-object or proc-target and proc-pointer-object, the determination of any pointers within data-pointer-object or proc-
             pointer-object, and the determination of the target for all active combinations of index-name values. These evaluations may be done
             in any order. After all these evaluations have been performed, each data-pointer-object or proc-pointer-object is associated with the
             corresponding target. These associations may occur in any order.
          4 In a forall-assignment-stmt, a deﬁned assignment subroutine shall not reference any variable that becomes deﬁned by the statement.
                  NOTE10.52
                  If a variable deﬁned in an assignment statement within a FORALL construct is referenced in a later statement in that construct,
                  the later statement uses the value(s) computed in the preceding assignment statement, not the value(s) the variable had prior
                  to execution of the FORALL.
          5 Eachstatement in a where-construct (10.2.3) within a forall-construct is executed in sequence. When a where-stmt, where-construct-
             stmt or masked-elsewhere-stmt is executed, the statement’s mask-expr is evaluated for all active combinations of index-name values
             as determined by the outer forall-constructs, masked by any control mask corresponding to outer where-constructs. Any where-
             assignment-stmt is executed for all active combinations of index-name values, masked by the control mask in eﬀect for the where-
             assignment-stmt.
          6 Execution of a forall-stmt or forall-construct causes the evaluation of the concurrent-limit and concurrent-step expressions in the
             concurrent-control-list for all active combinations of the index-name values of the outer FORALL construct. The set of combinations
                                                                           c
             178                                                          ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             of index-name values for the inner FORALL is the union of the sets deﬁned by these limits and steps for each active combination of the
             outer index-name values; it also includes the outer index-name values. The scalar-mask-expr is then evaluated for all combinations
             of the index-name values of the inner construct to produce a set of active combinations for the inner construct. If there is no
             scalar-mask-expr, it is as if it appeared with the value true. Each statement in the inner FORALL is then executed for each active
             combination of the index-name values.
             10.2.4.3   The FORALL statement
          1 The FORALL statement allows a single assignment statement or pointer assignment statement to be controlled by a set of index
             values and an optional mask expression.
             R1055   forall-stmt                 is  FORALLconcurrent-header forall-assignment-stmt
          2 AFORALLstatementisequivalenttoaFORALLconstructcontainingasingleforall-body-construct that is a forall-assignment-stmt.
          3 The scope of an index-name in a forall-stmt is the statement itself (19.4).
             10.2.4.4   Restrictions on FORALL constructs and statements
          1 A many-to-one assignment is more than one assignment to the same object, or association of more than one target with the same
             pointer, whether the object is referenced directly or indirectly through a pointer. A many-to-one assignment shall not occur within
             a single statement in a FORALL construct or statement. It is possible to assign or pointer-assign to the same object in diﬀerent
             assignment or pointer assignment statements in a FORALL construct.
                  NOTE10.53
                  Theappearanceofeachindex-nameintheidentiﬁcationoftheleft-handsideofanassignmentstatementishelpfulineliminating
                  many-to-one assignments, but it is not suﬃcient to guarantee there will be none. For example, the following is allowed
                     FORALL (I = 1:10)
                         A (INDEX (I)) = B(I)
                     END FORALL
                  if and only if INDEX(1:10) contains no repeated values.
          2 Within the scope of a FORALL construct, a nested FORALL statement or FORALL construct shall not have the same index-name.
             The concurrent-header expressions within a nested FORALL may depend on the values of outer index-name variables.
              c
             ISO/IEC 2017 – All rights reserved                                                                     179
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      180                          ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             11 Execution control
             11.1      Executable constructs containing blocks
             11.1.1     Blocks
          1 The following are executable constructs that contain blocks:
                 • ASSOCIATE construct;
                 • BLOCK construct;
                 • CHANGETEAMconstruct;
                 • CRITICAL construct;
                 • DO construct;
                 • IF construct;
                 • SELECT CASE construct;
                 • SELECT RANK construct;
                 • SELECT TYPE construct.
             R1101 block                         is  [ execution-part-construct ] ...
          2 Executable constructs may be used to control which blocks of a program are executed or how many times a block
             is executed. Blocks are always bounded by statements that are particular to the construct in which they are
             embedded.
                  NOTE11.1
                  An example of a construct containing a block is:
                  IF (A > 0.0) THEN
                     B = SQRT (A)     ! These two statements
                     C = LOG (A)      ! form a block.
                  END IF
             11.1.2     Rules governing blocks
             11.1.2.1   Control ﬂow in blocks
          1 Transfer of control to the interior of a block from outside the block is prohibited, except for the return from a
             procedure invoked within the block. Transfers within a block and transfers from the interior of a block to outside
             the block may occur.
          2 Subroutine and function references (15.5.3, 15.5.4) may appear in a block.
             11.1.2.2   Execution of a block
          1 Execution of a block begins with the execution of the ﬁrst executable construct in the block.
          2 Execution of the block is completed when
                 • execution of the last executable construct in the block completes without branching to a statement within
                   the block,
                 • a branch (11.2) within the block that has a branch target outside the block occurs,
              c
             ISO/IEC 2017 – All rights reserved                                                                     181
             ISO/IEC DIS 1539-1:2017 (E)
                 • a RETURN statement within the block is executed, or
                 • an EXIT statement or CYCLE statement statement that belongs to a construct that contains the block is
                   executed.
                  NOTE11.2
                  The action that takes place at the terminal boundary depends on the particular construct and on the block
                  within that construct.
             11.1.3     ASSOCIATE construct
             11.1.3.1   Purpose and form of the ASSOCIATE construct
          1 The ASSOCIATE construct associates named entities with expressions or variables during the execution of its
             block. These named construct entities (19.4) are associating entities (19.5.1.6). The names are associate names.
             R1102 associate-construct           is  associate-stmt
                                                         block
                                                         end-associate-stmt
             R1103 associate-stmt                is  [ associate-construct-name : ] ASSOCIATE
                                                        (association-list )
             R1104 association                   is  associate-name => selector
             R1105 selector                      is  expr
                                                 or variable
             C1101 (R1104) If selector is not a variable or is a variable that has a vector subscript, neither associate-name
                     nor any subobject thereof shall appear in a variable deﬁnition context (19.6.7).
             C1102 (R1104) An associate-name shall not be the same as another associate-name in the same associate-stmt.
             C1103 (R1105) variable shall not be a coindexed object.
             C1104 (R1105) expr shall not be a variable.
             C1105 (R1105) expr shall not be a designator of a procedure pointer or a function reference that returns a
                     procedure pointer.
             R1106 end-associate-stmt            is  ENDASSOCIATE[associate-construct-name ]
             C1106 (R1106) If the associate-stmt of an associate-construct speciﬁes an associate-construct-name, the corres-
                     ponding end-associate-stmt shall specify the same associate-construct-name. If the associate-stmt of an
                     associate-construct does not specify an associate-construct-name, the corresponding end-associate-stmt
                     shall not specify an associate-construct-name.
             11.1.3.2   Execution of the ASSOCIATE construct
          1 Execution of an ASSOCIATE construct causes evaluation of every expression within every selector that is a
             variable designator and evaluation of every other selector, followed by execution of its block. During execution of
             that block each associate name identiﬁes an entity which is associated (19.5.1.6) with the corresponding selector.
             The associating entity assumes the declared type and type parameters of the selector. If and only if the selector
             is polymorphic, the associating entity is polymorphic.
          2 The other attributes of the associating entity are described in 11.1.3.3.
          3 It is permissible to branch to an end-associate-stmt only from within its ASSOCIATE construct.
                                                                            c
             182                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             11.1.3.3   Other attributes of associate names
          1 Within an ASSOCIATE, CHANGE TEAM, or SELECT TYPE construct, each associating entity has the same
             rank as its associated selector. The lower bound of each dimension is the result of the intrinsic function LBOUND
             (16.9.109) applied to the corresponding dimension of selector. The upper bound of each dimension is one less
             than the sum of the lower bound and the extent. The associating entity does not have the ALLOCATABLE or
             POINTER attributes; it has the TARGET attribute if and only if the selector is a variable and has either the
             TARGETorPOINTERattribute.
          2 Within an ASSOCIATE, SELECT RANK, or SELECT TYPE construct, each associating entity has the same
             corank as its associated selector. If the selector is a coarray, the cobounds of each codimension of the associating
             entity are the same as those of the selector.
          3 WithinaCHANGETEAMconstruct,theassociatingentityisacoarray. Itscorankandcoboundsareasspeciﬁed
             in its codimension-decl.
          4 Within an ASSOCIATE, CHANGE TEAM, SELECT RANK, or SELECT TYPE construct, the associating
             entity has the ASYNCHRONOUS or VOLATILE attribute if and only if the selector is a variable and has the
             attribute. If the associating entity is polymorphic, it assumes the dynamic type and type parameter values of the
             selector. If the selector has the OPTIONAL attribute, it shall be present. The associating entity is contiguous if
             and only if the selector is contiguous.
          5 The associating entity itself is a variable, but if the selector is not a deﬁnable variable, the associating entity
             is not deﬁnable and shall not be deﬁned or become undeﬁned. If a selector is not permitted to appear in
             a variable deﬁnition context (19.6.7), neither the associate name nor any subobject thereof shall appear in a
             variable deﬁnition context.
             11.1.3.4   Examples of the ASSOCIATE construct
                  NOTE11.3
                  The following example illustrates an association with an expression.
                  ASSOCIATE ( Z => EXP (-(X**2+Y**2)) * COS (THETA) )
                    PRINT *, A+Z, A-Z
                  END ASSOCIATE
                  The following example illustrates an association with a derived-type variable.
                  ASSOCIATE ( XC => AX%B(I,J)%C )
                    XC%DV = XC%DV + PRODUCT (XC%EV(1:N))
                  END ASSOCIATE
                  The following example illustrates association with an array section.
                  ASSOCIATE ( ARRAY => AX%B(I,:)%C )
                    ARRAY(N)%EV = ARRAY(N-1)%EV
                  END ASSOCIATE
                  The following example illustrates multiple associations.
                  ASSOCIATE ( W => RESULT(I,J)%W, ZX => AX%B(I,J)%D, ZY => AY%B(I,J)%D )
                    W = ZX*X + ZY*Y
                  END ASSOCIATE
             11.1.4     BLOCK construct
          1 The BLOCK construct is an executable construct that may contain declarations.
              c
             ISO/IEC 2017 – All rights reserved                                                                     183
                ISO/IEC DIS 1539-1:2017 (E)
                R1107 block-construct                     is  block-stmt
                                                                    [ block-speciﬁcation-part ]
                                                                    block
                                                                    end-block-stmt
                R1108 block-stmt                          is  [ block-construct-name : ] BLOCK
                R1109 block-speciﬁcation-part             is  [ use-stmt ]...
                                                              [ import-stmt ] ...
                                                              [ [ declaration-construct ] ...
                                                                speciﬁcation-construct ]
                R1110 end-block-stmt                      is  ENDBLOCK[block-construct-name ]
                C1107 (R1107) A block-speciﬁcation-part shall not contain a COMMON, EQUIVALENCE, INTENT, NAMELIST,
                         OPTIONAL, statement function, or VALUE statement.
                C1108 (R1107) A SAVE statement in a BLOCK construct shall contain a saved-entity-list that does not specify a
                         common-block-name.
                C1109 (R1107) If the block-stmt of a block-construct speciﬁes a block-construct-name, the corresponding end-
                         block-stmt shall specify the same block-construct-name.             If the block-stmt does not specify a block-
                         construct-name, the corresponding end-block-stmt shall not specify a block-construct-name.
            2 Except for the ASYNCHRONOUS and VOLATILE statements, speciﬁcations in a BLOCK construct declare
                construct entities whose scope is that of the BLOCK construct (19.4). The appearance of the name of an object
                that is not a construct entity in an ASYNCHRONOUS or VOLATILE statement in a BLOCK construct speciﬁes
                that the object has the attribute within the construct even if it does not have the attribute outside the construct.
            3 Execution of a BLOCK construct causes evaluation of the speciﬁcation expressions within its speciﬁcation part
                in a processor-dependent order, followed by execution of its block.
            4 It is permissible to branch to an end-block-stmt only from within its BLOCK construct.
                     NOTE11.4
                     The following is an example of a BLOCK construct.
                             IF (swapxy) THEN
                                BLOCK
                                   REAL (KIND (x)) tmp
                                   tmp = x
                                   x = y
                                   y = tmp
                                END BLOCK
                             END IF
                     Actions on a variable local to a BLOCK construct do not aﬀect any variable of the same name outside the
                     construct. For example,
                             F = 254E-2
                             BLOCK
                                REAL F
                                F = 39.37
                             END BLOCK
                             ! F is still equal to 254E-2.
                     A SAVE statement outside a BLOCK construct does not aﬀect variables local to the BLOCK construct,
                     because a SAVE statement aﬀects variables in its scoping unit rather than in its inclusive scope. For
                                                                                         c
                184                                                                      ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE11.4 (cont.)
                  example,
                         SUBROUTINE S
                           ...
                           SAVE
                           ...
                           BLOCK
                             REAL X                 ! Not saved.
                             REAL,SAVE :: Y(100) ! SAVE attribute is allowed.
                             Z = 3                  ! Implicitly declared in S, thus saved.
                             ...
                           END BLOCK
                           ...
                         END SUBROUTINE
             11.1.5     CHANGE TEAM construct
             11.1.5.1   Purpose and form of the CHANGE TEAM construct
          1 The CHANGE TEAM construct changes the current team. Named construct entities (19.4) can be associated
             (19.5.1.6) with coarrays in the containing scoping unit, in the same way as for the ASSOCIATE construct.
             R1111 change-team-construct         is  change-team-stmt
                                                         block
                                                         end-change-team-stmt
             R1112 change-team-stmt              is  [ team-construct-name : ] CHANGE TEAM ( team-value
                                                        [ , coarray-association-list ] [ , sync-stat-list ] )
             R1113 coarray-association           is  codimension-decl => selector
             R1114 end-change-team-stmt          is  ENDTEAM[([sync-stat-list ] ) ] [ team-construct-name ]
             R1115 team-value                    is  scalar-expr
             C1110 A branch (11.2) within a CHANGE TEAM construct shall not have a branch target that is outside the
                     construct.
             C1111 A RETURN statement shall not appear within a CHANGE TEAM construct.
             C1112 If the change-team-stmt of a change-team-construct speciﬁes a team-construct-name, the corresponding
                     end-change-team-stmt shall specify the same team-construct-name. If the change-team-stmt of a change-
                     team-construct does not specify a team-construct-name, the corresponding end-change-team-stmt shall
                     not specify a team-construct-name.
             C1113 In a change-team-stmt, a coarray-name in a codimension-decl shall not be the same as a selector, or
                     another coarray-name, in that statement.
             C1114 A team-value shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
             C1115 No selector shall appear more than once in a given change-team-stmt.
             C1116 A selector in a coarray-association shall be a named coarray.
          2 Each coarray-name in a codimension-decl in the CHANGE TEAM statement is an associate name which is
             associated with the corresponding selector. Each associating entity assumes the type and type parameters of
             its selector; it is polymorphic if and only if the selector is polymorphic. The other attributes of the associating
             entities are described in 11.1.3.3.
              c
             ISO/IEC 2017 – All rights reserved                                                                     185
             ISO/IEC DIS 1539-1:2017 (E)
             11.1.5.2   Execution of a CHANGE TEAM construct
          1 Theteam-valuesontheactiveimagesthatexecutetheCHANGETEAMstatementshallbethoseofteamvariables
             deﬁned by corresponding executions of the same FORM TEAM statement (11.6.9). When the CHANGE TEAM
             statementisexecuted, the current team shall be the team that was current when those team variables were deﬁned.
             The current team for the statements of the CHANGE TEAM block is the team identiﬁed by the team-value. If
             team-value is a variable, the variable shall not be deﬁned or become undeﬁned during execution of the CHANGE
             TEAMconstruct. A CHANGE TEAM construct completes execution by executing its END TEAM statement,
             which restores the current team to the original team that was current for the CHANGE TEAM statement.
          2 Execution of a CHANGE TEAM construct causes evaluation of the expressions within each codimension-decl in
             the CHANGETEAMstatement, followed by execution of its block. Each selector shall be an established coarray
             when the CHANGE TEAM statement begins execution.
          3 It is permissible to branch to an end-change-team-stmt only from within its CHANGE TEAM construct.
          4 An allocatable coarray that was allocated immediately before executing a CHANGE TEAM statement shall not
             be deallocated during execution of the construct. An allocatable coarray that was unallocated immediately before
             executing a CHANGE TEAM statement, and which is allocated immediately before executing the corresponding
             ENDTEAMstatement, is deallocated by the execution of the END TEAM statement.
          5 Successful execution of a CHANGE TEAM statement performs an implicit synchronization of all images of the
             new team that is identiﬁed by team-value. All active images of the new team shall execute the same CHANGE
             TEAM statement. On each image of the new team, execution of the segment following the CHANGE TEAM
             statement is delayed until all other images of that team have executed the same statement the same number of
             times in the original team.
          6 If the new team contains a failed image and no other error condition occurs, there is an implicit synchronization
             of all active images of the new team. On each active image of the new team, execution of the segment following
             the CHANGE TEAM statement is delayed until all other active images of that team have executed the same
             statement the same number of times in the original team.
          7 If no error condition other than the new team containing a failed image occurs, the segments that executed before
             the CHANGETEAMstatementonanactive image of the new team precede the segments that execute after the
             CHANGETEAMstatement on another active image of that team.
          8 WhenaCHANGETEAMconstructcompletesexecution,thereisanimplicit synchronization of all active images
             in the new team. On each active image of the new team, execution of the segment following the END TEAM
             statement is delayed until all other active images of this team have executed the same construct the same number
             of times in this team. The segments that executed before the END TEAM statement on an active image of the
             new team precede the segments that execute after the END TEAM statement on another active image of that
             team.
                  NOTE11.5
                  Deallocation of an allocatable coarray that was not allocated at the beginning of a CHANGE TEAM
                  construct, but is allocated at the end of execution of the construct, occurs even for allocatable coarrays
                  with the SAVE attribute.
                  NOTE11.6
                  Execution of a CHANGETEAMstatementincludesasynchronizationoftheexecutingimagewiththeother
                  images that will be in the same team after execution of the CHANGE TEAM statement. Synchronization
                  of these images occurs again when the corresponding END TEAM statement is executed.
                  If it is desired to synchronize all of the images in the team that was current when the CHANGE TEAM
                  statement was executed, a SYNC TEAM statement that speciﬁes the parent team can be executed imme-
                  diately after the CHANGE TEAM statement. If similar semantics are desired following the END TEAM
                  statement, a SYNC ALL statement could immediately follow the END TEAM statement.
                                                                            c
             186                                                           ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
               NOTE11.7
               AcoarraythatisestablishedwhenaCHANGETEAMstatementisexecutedretainsitscorankandcobounds
               inside the block. If it is desired to perform remote accesses based on corank or cobounds diﬀerent from
               those of the original coarray, an associating coarray can be used. An example of this is in C.6.7.
           11.1.6  CRITICAL construct
         1 ACRITICAL construct limits execution of a block to one image at a time.
           R1116 critical-construct     is critical-stmt
                                               block
                                               end-critical-stmt
           R1117 critical-stmt          is [ critical-construct-name : ] CRITICAL [ ( [ sync-stat-list ] ) ]
           R1118 end-critical-stmt      is ENDCRITICAL[critical-construct-name ]
           C1117 (R1116) If the critical-stmt of a critical-construct speciﬁes a critical-construct-name, the corresponding
                 end-critical-stmt shall specify the same critical-construct-name. If the critical-stmt of a critical-construct
                 does not specify a critical-construct-name, the corresponding end-critical-stmt shall not specify a critical-
                 construct-name.
           C1118 (R1116) The block of a critical-construct shall not contain a RETURN statement or an image control
                 statement.
           C1119 Abranch(11.2)withinaCRITICALconstructshallnothaveabranchtargetthatisoutsidetheconstruct.
         2 Execution of the CRITICAL construct is completed when execution of its block is completed, or the executing
           image fails (5.3.6). A procedure invoked, directly or indirectly, from a CRITICAL construct shall not execute an
           image control statement.
         3 The processor shall ensure that once an image has commenced executing block, no other image shall commence
           executing block until this image has completed execution of the construct. The image shall not execute an image
           control statement during the execution of block. The sequence of executed statements is therefore a segment
           (11.6.2). If image M completes execution of the construct without failing and image T is the next to execute the
           construct, the segment on image M precedes the segment on image T. Otherwise, if image M completes execution
           of the construct by failing, and image T is the next to execute the construct, the previous segment on image M
           precedes the segment on image T.
         4 The eﬀect of a STAT= or ERRMSG= speciﬁer in a CRITICAL statement is speciﬁed in subclause 11.6.11.
         5 It is permissible to branch to an end-critical-stmt only from within its CRITICAL construct.
               NOTE11.8
               If more than one image executes the block of a CRITICAL construct without failing, its execution by one
               image always either precedes or succeeds its execution by another nonfailed image. Typically no other
               statement ordering is needed. Consider the following example:
               CRITICAL
                   GLOBAL_COUNTER[1] = GLOBAL_COUNTER[1] + 1
               END CRITICAL
               The deﬁnition of GLOBAL_COUNTER [1] by a particular image will always precede the reference to the
               same variable by the next image to execute the block.
           c
           ISO/IEC 2017 – All rights reserved                                                 187
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE11.9
                  The following example permits a large number of jobs to be shared among the images:
                  INTEGER :: NUM_JOBS[*], JOB
                  IF (THIS_IMAGE() == 1) READ(*,*) NUM_JOBS
                  SYNC ALL
                  DO
                     CRITICAL
                         JOB = NUM_JOBS[1]
                         NUM_JOBS[1] = JOB - 1
                     END CRITICAL
                     IF (JOB > 0) THEN
                         ! Work on JOB
                     ELSE
                         EXIT
                     END IF
                  END DO
                  SYNC ALL
             11.1.7     DOconstruct
             11.1.7.1   Purpose and form of the DO construct
          1 The DO construct speciﬁes the repeated execution of a sequence of executable constructs. Such a repeated
             sequence is called a loop.
          2 The number of iterations of a loop can be determined at the beginning of execution of the DO construct, or can
             be left indeﬁnite (“DO forever” or DO WHILE). The execution order of the iterations can be left indeterminate
             (DOCONCURRENT);exceptin this case, the loop can be terminated immediately (11.1.7.4.5). An iteration of
             the loop can be curtailed by executing a CYCLE statement (11.1.7.4.4).
          3 There are three phases in the execution of a DO construct: initiation of the loop, execution of each iteration of
             the loop, and termination of the loop.
          4 The scope and attributes of an index-name in a concurrent-header (DO CONCURRENT) are described in 19.4.
             11.1.7.2   Form of the DO construct
             R1119 do-construct                  is  do-stmt
                                                         block
                                                         end-do
             R1120 do-stmt                       is  nonlabel-do-stmt
                                                 or  label-do-stmt
             R1121   label-do-stmt               is  [ do-construct-name : ] DO label [ loop-control ]
             R1122 nonlabel-do-stmt              is  [ do-construct-name : ] DO [ loop-control ]
             R1123 loop-control                  is  [ , ] do-variable = scalar-int-expr, scalar-int-expr
                                                       [ , scalar-int-expr ]
                                                 or [ , ] WHILE ( scalar-logical-expr )
                                                 or [ , ] CONCURRENT concurrent-header concurrent-locality
             R1124 do-variable                   is  scalar-int-variable-name
                                                                            c
             188                                                           ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                C1120 (R1124) The do-variable shall be a variable of type integer.
                R1125 concurrent-header                   is  ( [ integer-type-spec :: ] concurrent-control-list [ , scalar-mask-expr ] )
                R1126 concurrent-control                  is  index-name = concurrent-limit : concurrent-limit [ : concurrent-step ]
                R1127 concurrent-limit                    is  scalar-int-expr
                R1128 concurrent-step                     is  scalar-int-expr
                R1129 concurrent-locality                 is  [ locality-spec ]...
                R1130 locality-spec                       is  LOCAL(variable-name-list )
                                                          or LOCAL_INIT ( variable-name-list )
                                                          or SHARED(variable-name-list )
                                                          or DEFAULT ( NONE )
                C1121 (R1125) Any procedure referenced in the scalar-mask-expr, including one referenced by a deﬁned opera-
                         tion, shall be a pure procedure (15.7).
                C1122 (R1126) The index-name shall be a named scalar variable of type integer.
                C1123 (R1126) A concurrent-limit or concurrent-step in a concurrent-control shall not contain a reference to
                         any index-name in the concurrent-control-list in which it appears.
                C1124 A variable-name in a locality-spec shall be the name of a variable in the innermost executable construct
                         or scoping unit that includes the DO CONCURRENT statement.
                C1125 A variable-name in a locality-spec shall not be the same as an index-name in the concurrent-header of
                         the same DO CONCURRENT statement.
                C1126 The name of a variable shall not appear in more than one variable-name-list, or more than once in a
                         variable-name-list, in a given concurrent-locality.
                C1127 The DEFAULT ( NONE ) locality-spec shall not appear more than once in a given concurrent-locality.
                C1128 Avariable-name that appears in a LOCAL or LOCAL_INIT locality-spec shall not have the ALLOCAT-
                         ABLE,INTENT(IN),orOPTIONALattribute,shallnotbeofﬁnalizabletype, shallnotbeanonpointer
                         polymorphicdummyargument,andshallnotbeacoarrayoranassumed-sizearray. Avariable-name that
                         is not permitted to appear in a variable deﬁnition context shall not appear in a LOCAL or LOCAL_INIT
                         locality-spec.
                C1129 A variable that is referenced by the scalar-mask-expr of a concurrent-header or by any concurrent-limit
                         or concurrent-step in that concurrent-header shall not appear in a LOCAL locality-spec in the same DO
                         CONCURRENTstatement.
                C1130 If the locality-spec DEFAULT ( NONE ) appears in a DO CONCURRENT statement, a variable that is
                         a local or construct entity of a scope containing the DO CONCURRENT construct, and that appears in
                         the block of the construct, shall have its locality explicitly speciﬁed by that statement.
                R1131 end-do                              is  end-do-stmt
                                                          or  continue-stmt
                R1132 end-do-stmt                         is  ENDDO[do-construct-name ]
                c
                ISO/IEC 2017 – All rights reserved                                                                                       189
              ISO/IEC DIS 1539-1:2017 (E)
              C1131 (R1119) If the do-stmt of a do-construct speciﬁes a do-construct-name, the corresponding end-do shall be
                       an end-do-stmt specifying the same do-construct-name. If the do-stmt of a do-construct does not specify
                       a do-construct-name, the corresponding end-do shall not specify a do-construct-name.
              C1132 (R1119) If the do-stmt is a nonlabel-do-stmt, the corresponding end-do shall be an end-do-stmt.
              C1133    (R1119) If the do-stmt is a label-do-stmt, the corresponding end-do shall be identiﬁed with the same label.
           1 It is permissible to branch to an end-do only from within its DO construct.
              11.1.7.3   Active and inactive DO constructs
           1 A DO construct is either active or inactive. Initially inactive, a DO construct becomes active only when its DO
              statement is executed.
           2 Once active, the DO construct becomes inactive only when it terminates (11.1.7.4.5).
              11.1.7.4   Execution of a DO construct
              11.1.7.4.1   Loop initiation
           1 When the DO statement is executed, the DO construct becomes active. If loop-control is
                  [ , ] do-variable = scalar-int-expr1 , scalar-int-expr2 [ , scalar-int-expr3 ]
              the following steps are performed in sequence.
                    (1)    The initial parameter m , the terminal parameter m , and the incrementation parameter m are
                                                    1                             2                                         3
                           of type integer with the same kind type parameter as the do-variable. Their values are established
                           by evaluating scalar-int-expr1, scalar-int-expr2, and scalar-int-expr3, respectively, including, if ne-
                           cessary, conversion to the kind type parameter of the do-variable according to the rules for numeric
                           conversion (Table 10.9). If scalar-int-expr  does not appear, m has the value 1. The value of m
                           shall not be zero.                         3                     3                                   3
                    (2)    The DO variable becomes deﬁned with the value of the initial parameter m1.
                    (3)    The iteration count is established and is the value of the expression (m −m +m )/m , unless that
                           value is negative, in which case the iteration count is 0.              2     1    3     3
                   NOTE11.10
                   The iteration count is zero whenever:
                       m >m andm >0,or
                         1      2       3
                       m <m andm <0.
                         1      2       3
           2 If loop-control is omitted, no iteration count is calculated. The eﬀect is as if a large positive iteration count,
              impossible to decrement to zero, were established. If loop-control is [ , ] WHILE (scalar-logical-expr), the eﬀect
              is as if loop-control were omitted and the following statement inserted as the ﬁrst statement of the block:
                 IF (.NOT. (scalar-logical-expr)) EXIT
           3 For a DO CONCURRENT construct, the values of the index variables for the iterations of the construct are
              determined by the rules in 11.1.7.4.2.
           4 At the completion of the execution of the DO statement, the execution cycle begins.
              11.1.7.4.2   DOCONCURRENTloop control
           1 The concurrent-limit and concurrent-step expressions in the concurrent-control-list are evaluated. These ex-
              pressions may be evaluated in any order. The set of values that a particular index-name variable assumes is
              determined as follows.
                                                                                 c
              190                                                               ISO/IEC 2017 – All rights reserved
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
                   (1)   The lower bound m , the upper bound m , and the step m are of type integer with the same kind
                                            1                     2                3
                         type parameter as the index-name. Their values are established by evaluating the ﬁrst concurrent-
                         limit, the second concurrent-limit, and the concurrent-step expressions, respectively, including, if
                         necessary, conversion to the kind type parameter of the index-name according to the rules for numeric
                         conversion (Table 10.9). If concurrent-step does not appear, m has the value 1. The value m shall
                         not be zero.                                                 3                             3
                   (2)   Let the value of max be (m −m +m )/m . If max≤ 0 for some index-name, the execution of the
                                                    2     1    3    3
                         construct is complete. Otherwise, the set of values for the index-name is
                              m +(k−1)×m              where k = 1, 2, ..., max.
                                1              3
           2 Theset of combinations of index-name values is the Cartesian product of the sets deﬁned by each triplet speciﬁc-
             ation. An index-name becomes deﬁned when this set is evaluated.
           3 The scalar-mask-expr, if any, is evaluated for each combination of index-name values. If there is no scalar-
             mask-expr, it is as if it appeared with the value true.  The index-name variables may be primaries in the
             scalar-mask-expr.
           4 The set of active combinations of index-name values is the subset of all possible combinations for which the
             scalar-mask-expr has the value true.
                  NOTE11.11
                  The index-name variables can appear in the mask, for example
                      DO CONCURRENT (I=1:10, J=1:10, A(I) > 0.0 .AND. B(J) < 1.0)
                      . . .
             11.1.7.4.3   The execution cycle
           1 Theexecution cycle of a DO construct that is not a DO CONCURRENT construct consists of the following steps
             performed in sequence repeatedly until termination.
                   (1)   The iteration count, if any, is tested. If it is zero, the loop terminates and the DO construct becomes
                         inactive. If loop-control is [ , ] WHILE (scalar-logical-expr), the scalar-logical-expr is evaluated; if
                         the value of this expression is false, the loop terminates and the DO construct becomes inactive.
                   (2)   The block of the loop is executed.
                   (3)   The iteration count, if any, is decremented by one. The DO variable, if any, is incremented by the
                         value of the incrementation parameter m .
                                                                 3
           2 ExceptfortheincrementationoftheDOvariablethatoccursinstep(3), theDOvariableshallneitherberedeﬁned
             nor become undeﬁned while the DO construct is active.
           3 The block of a DO CONCURRENT construct is executed for every active combination of the index-name values.
             Each execution of the block is an iteration. The executions may occur in any order.
             11.1.7.4.4   CYCLE statement
           1 Execution of a loop iteration can be curtailed by executing a CYCLE statement that belongs to the construct.
             R1133 cycle-stmt                    is  CYCLE[do-construct-name ]
             C1134 If a do-construct-name appears on a CYCLE statement, the CYCLE statement shall be within that
                     do-construct; otherwise, it shall be within at least one do-construct.
             C1135 Acycle-stmt shall not appear within a CHANGE TEAM, CRITICAL, or DO CONCURRENT construct
                     if it belongs to an outer construct.
           2 A CYCLE statement belongs to a particular DO construct. If the CYCLE statement contains a DO construct
             name, it belongs to that DO construct; otherwise, it belongs to the innermost DO construct in which it appears.
              c
             ISO/IEC 2017 – All rights reserved                                                                     191
             ISO/IEC DIS 1539-1:2017 (E)
           3 Execution of a CYCLE statement that belongs to a DO construct that is not a DO CONCURRENT construct
             causes immediate progression to step (3) of the execution cycle of the DO construct to which it belongs.
           4 Execution of a CYCLE statement that belongs to a DO CONCURRENT construct completes execution of that
             iteration of the construct.
           5 In a DO construct, a transfer of control to the end-do has the same eﬀect as execution of a CYCLE statement
             belonging to that construct.
             11.1.7.4.5   Loop termination
           1 For a DO construct that is not a DO CONCURRENT construct, the loop terminates, and the DO construct
             becomes inactive, when any of the following occurs.
                 • The iteration count is determined to be zero or the scalar-logical-expr is false, when tested during step (1)
                   of the above execution cycle.
                 • An EXIT statement that belongs to the DO construct is executed.
                 • An EXIT or CYCLE statement that belongs to an outer construct and is within the DO construct is
                   executed.
                 • A branch occurs within the DO construct and the branch target statement is outside the construct.
                 • A RETURN statement within the DO construct is executed.
           2 For a DO CONCURRENT construct, the loop terminates, and the DO construct becomes inactive when all of
             the iterations have completed execution.
           3 When a DO construct becomes inactive, the DO variable, if any, of the DO construct retains its last deﬁned
             value.
             11.1.7.5   Additional semantics for DO CONCURRENT constructs
             C1136 A RETURN statement shall not appear within a DO CONCURRENT construct.
             C1137 An image control statement shall not appear within a DO CONCURRENT construct.
             C1138 A branch (11.2) within a DO CONCURRENT construct shall not have a branch target that is outside
                     the construct.
             C1139 A reference to an impure procedure shall not appear within a DO CONCURRENT construct.
             C1140 A statement that might result in the deallocation of a polymorphic entity shall not appear within a DO
                     CONCURRENTconstruct.
             C1141 A reference to the procedure IEEE_GET_FLAG, IEEE_SET_HALTING_MODE, or IEEE_GET_-
                     HALTING_MODE from the intrinsic module IEEE_EXCEPTIONS, shall not appear within a DO
                     CONCURRENTconstruct.
           1 Thelocality of a variable that appears in a DO CONCURRENT construct is LOCAL, LOCAL_INIT, SHARED,
             or unspeciﬁed. A construct or statement entity of a construct or statement within the DO CONCURRENT
             construct has SHARED locality if it has the SAVE attribute. If it does not have the SAVE attribute, it is a
             diﬀerent entity in each iteration, similar to LOCAL locality.
           2 Avariable that has LOCAL or LOCAL_INIT locality is a construct entity with the same type, type parameters,
             and rank as the variable with the same name in the innermost executable construct or scoping unit that includes
             theDOCONCURRENTconstruct,andtheoutsidevariableisinaccessiblebythatnamewithintheconstruct. The
             construct entity has the ASYNCHRONOUS, CONTIGUOUS, POINTER, TARGET, or VOLATILE attribute if
             and only if the outside variable has that attribute; it does not have the BIND, INTENT, PROTECTED, SAVE
             or VALUE attribute, even if the outside variable has that attribute. If it is not a pointer, it has the same bounds
             as the outside variable. At the beginning of execution of each iteration,
                                                                             c
             192                                                            ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
           • if a variable with LOCAL locality is a pointer it has undeﬁned pointer association status, and otherwise it
            is undeﬁned except for any subobjects that are default-initialized;
           • a variable with LOCAL_INIT locality has the pointer association status and deﬁnition status of the out-
            side variable with that name; the outside variable shall not be an undeﬁned pointer or a nonallocatable
            nonpointer variable that is undeﬁned.
         If a variable with LOCAL or LOCAL_INIT locality becomes an aﬀector of a pending input/output operation,
         the operation shall have completed before the end of the iteration. If a variable with LOCAL or LOCAL_INIT
         locality has the TARGET attribute, a pointer associated with it during an iteration becomes undeﬁned when
         execution of that iteration completes.
       3 If a variable has SHARED locality, appearances of the variable within the DO CONCURRENT construct refer
         to the variable in the innermost executable construct or scoping unit that includes the DO CONCURRENT
         construct. If it is deﬁned or becomes undeﬁned during any iteration, it shall not be referenced, deﬁned, or
         become undeﬁned during any other iteration. If it is allocated, deallocated, nulliﬁed, or pointer-assigned during
         an iteration it shall not have its allocation or association status, dynamic type, array bounds, shape, or a deferred
         type parameter value inquired about in any other iteration. A noncontiguous array with SHARED locality shall
         not be supplied as an actual argument corresponding to a contiguous INTENT (INOUT) dummy argument.
       4 If a variable has unspeciﬁed locality,
           • if it is referenced in an iteration it shall either be previously deﬁned during that iteration, or shall not be
            deﬁned or become undeﬁned during any other iteration; if it is deﬁned or becomes undeﬁned by more than
            one iteration it becomes undeﬁned when the loop terminates;
           • if it is noncontiguous and is supplied as an actual argument corresponding to a contiguous INTENT (IN-
            OUT) dummy argument in an iteration, it shall either be previously deﬁned in that iteration or shall not
            be deﬁned in any other iteration;
           • if it is a pointer and is used in an iteration other than as the pointer in pointer assignment, allocation,
            or nulliﬁcation, it shall either be previously pointer associated during that iteration or shall not have its
            pointer association changed during any iteration;
           • if it is a pointer whose pointer association is changed in more than one iteration, it has an association status
            of undeﬁned when the construct terminates;
           • if it is allocatable and is allocated in more than one iteration, it shall have an allocation status of unallocated
            at the end of every iteration;
           • if it is allocatable and is referenced, deﬁned, deallocated, or has its allocation status, dynamic type, or a
            deferred type parameter value inquired about, in any iteration, it shall either be previously allocated in
            that iteration or shall not be allocated or deallocated in any other iteration.
       5 ADOCONCURRENTconstructshallnotcontainaninput/outputstatementthathasanADVANCE=speciﬁer.
       6 If data are written to a ﬁle record or position in one iteration, that record or position in that ﬁle shall not be
         read from or written to in a diﬀerent iteration. If records are written to a ﬁle connected for sequential access by
         more than one iteration, the ordering of records written by diﬀerent iterations is processor dependent.
            NOTE11.12
            The restrictions on referencing variables deﬁned in an iteration of a DO CONCURRENT construct apply
            to any procedure invoked within the loop.
            NOTE11.13
            The restrictions on the statements in a DO CONCURRENT construct are designed to ensure there are no
            data dependencies between iterations of the loop. This permits code optimizations that might otherwise be
            diﬃcult or impossible because they would depend on properties of the program not visible to the compiler.
         c
         ISO/IEC 2017 – All rights reserved                                 193
             ISO/IEC DIS 1539-1:2017 (E)
             11.1.7.6   Examples of DO constructs
                  NOTE11.14
                  The following program fragment computes a tensor product of two arrays:
                  DO I = 1, M
                     DO J = 1, N
                         C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))
                     END DO
                  END DO
                  NOTE11.15
                  The following program fragment contains a DO construct that uses the WHILE form of loop-control. The
                  loop will continue to execute until an end-of-ﬁle or input/output error is encountered, at which point the
                  DOstatement terminates the loop. When a negative value of X is read, the program skips immediately to
                  the next READ statement, bypassing most of the block of the loop.
                  READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
                  DO WHILE (IOS == 0)
                     IF (X >= 0.) THEN
                         CALL SUBA (X)
                         CALL SUBB (X)
                               ...
                         CALL SUBZ (X)
                     ENDIF
                     READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
                  END DO
                  NOTE11.16
                  Thefollowing example behaves exactly the same as the one in NOTE 11.15. However, the READ statement
                  has been moved to the interior of the loop, so that only one READ statement is needed. Also, a CYCLE
                  statement has been used to avoid an extra level of IF nesting.
                  DO      ! A "DO WHILE + 1/2" loop
                     READ (IUN, ’(1X, G14.7)’, IOSTAT = IOS) X
                     IF (IOS /= 0) EXIT
                     IF (X < 0.) CYCLE
                     CALL SUBA (X)
                     CALL SUBB (X)
                         . . .
                     CALL SUBZ (X)
                  END DO
                  NOTE11.17
                  The following example illustrates a case in which the user knows that there are no repeated values in the
                  index array IND. The DO CONCURRENT construct makes it easier for the processor to generate vector
                  gather/scatter code, unroll the loop, or parallelize the code for this loop, potentially improving performance.
                  INTEGER :: A(N),IND(N)
                  DO CONCURRENT (I=1:M)
                     A(IND(I)) = I
                  END DO
                                                                            c
             194                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE11.18
                  Thefollowing code demonstrates the use of the LOCAL clause so that the X inside the DO CONCURRENT
                  construct is a temporary variable, and will not aﬀect the X outside the construct.
                           X = 1.0
                           DO CONCURRENT (I=1:10) LOCAL (X)
                             IF (A (I) > 0) THEN
                                X = SQRT (A (I))
                                A (I) = A (I) - X**2
                             END IF
                             B (I) = B (I) - A (I)
                           END DO
                           PRINT *, X                             ! Always prints 1.0.
                  NOTE11.19
                  Additional examples of DO constructs are in C.6.3.
             11.1.8     IF construct and statement
             11.1.8.1   Purpose and form of the IF construct
          1 The IF construct selects for execution at most one of its constituent blocks. The selection is based on a sequence
             of logical expressions.
             R1134 if-construct                  is  if-then-stmt
                                                             block
                                                         [ else-if-stmt
                                                             block ] ...
                                                         [ else-stmt
                                                             block ]
                                                         end-if-stmt
             R1135 if-then-stmt                  is  [ if-construct-name : ] IF ( scalar-logical-expr ) THEN
             R1136 else-if-stmt                  is  ELSE IF ( scalar-logical-expr ) THEN [ if-construct-name ]
             R1137 else-stmt                     is  ELSE [ if-construct-name ]
             R1138 end-if-stmt                   is  ENDIF[if-construct-name ]
             C1142 (R1134) If the if-then-stmt of an if-construct speciﬁes an if-construct-name, the corresponding end-if-
                     stmt shall specify the same if-construct-name. If the if-then-stmt of an if-construct does not specify an
                     if-construct-name, the corresponding end-if-stmt shall not specify an if-construct-name. If an else-if-
                     stmt or else-stmt speciﬁes an if-construct-name, the corresponding if-then-stmt shall specify the same
                     if-construct-name.
             11.1.8.2   Execution of an IF construct
          1 At most one of the blocks in the IF construct is executed. If there is an ELSE statement in the construct,
             exactly one of the blocks in the construct is executed. The scalar logical expressions are evaluated in the order
             of their appearance in the construct until a true value is found or an ELSE statement or END IF statement is
             encountered. If a true value or an ELSE statement is found, the block immediately following is executed and this
             completes the execution of the construct. The scalar logical expressions in any remaining ELSE IF statements of
             the IF construct are not evaluated. If none of the evaluated expressions is true and there is no ELSE statement,
             the execution of the construct is completed without the execution of any block within the construct.
              c
             ISO/IEC 2017 – All rights reserved                                                                     195
             ISO/IEC DIS 1539-1:2017 (E)
          2 It is permissible to branch to an END IF statement only from within its IF construct. Execution of an END IF
             statement has no eﬀect.
             11.1.8.3   Examples of IF constructs
                  NOTE11.20
                          IF (CVAR == ’RESET’) THEN
                             I = 0; J = 0; K = 0
                          END IF
                          PROOF_DONE: IF (PROP) THEN
                             WRITE (3, ’(’’QED’’)’)
                             STOP
                          ELSE
                             PROP = NEXTPROP
                          END IF PROOF_DONE
                          IF (A > 0) THEN
                             B = C/A
                             IF (B > 0) THEN
                                 D = 1.0
                             END IF
                          ELSE IF (C > 0) THEN
                             B = A/C
                             D = -1.0
                          ELSE
                             B = ABS (MAX (A, C))
                             D = 0
                          END IF
             11.1.8.4   IF statement
          1 The IF statement controls the execution of a single action statement based on a single logical expression.
             R1139 if-stmt                       is  IF ( scalar-logical-expr ) action-stmt
             C1143 (R1139) The action-stmt in the if-stmt shall not be an if-stmt.
          2 Execution of an IF statement causes evaluation of the scalar logical expression. If the value of the expression is
             true, the action statement is executed. If the value is false, the action statement is not executed.
          3 The execution of a function reference in the scalar logical expression may aﬀect entities in the action statement.
                  NOTE11.21
                  An example of an IF statement is:
                          IF (A > 0.0) A = LOG (A)
             11.1.9     SELECT CASE construct
             11.1.9.1   Purpose and form of the SELECT CASE construct
          1 The SELECT CASE construct selects for execution at most one of its constituent blocks. The selection is based
             on the value of an expression.
             R1140 case-construct                is  select-case-stmt
                                                         [ case-stmt
                                                             block ] ...
                                                         end-select-stmt
                                                                            c
             196                                                           ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
             R1141 select-case-stmt             is  [ case-construct-name : ] SELECT CASE ( case-expr )
             R1142 case-stmt                    is  CASEcase-selector [case-construct-name]
             R1143 end-select-stmt              is  ENDSELECT[case-construct-name ]
             C1144 (R1140)Iftheselect-case-stmt of a case-construct speciﬁes a case-construct-name, the corresponding end-
                     select-stmt shall specify the same case-construct-name. If the select-case-stmt of a case-construct does
                     not specify a case-construct-name, the corresponding end-select-stmt shall not specify a case-construct-
                     name. If a case-stmt speciﬁes a case-construct-name, the corresponding select-case-stmt shall specify the
                     same case-construct-name.
             R1144 case-expr                    is  scalar-expr
             C1145 case-expr shall be of type character, integer, or logical.
             R1145 case-selector                is  ( case-value-range-list )
                                                or DEFAULT
             C1146 (R1140) No more than one of the selectors of one of the CASE statements shall be DEFAULT.
             R1146 case-value-range             is  case-value
                                                or case-value :
                                                or : case-value
                                                or case-value : case-value
             R1147 case-value                   is  scalar-constant-expr
             C1147 (R1140) For a given case-construct, each case-value shall be of the same type as case-expr. For character
                     type, the kind type parameters shall be the same; character length diﬀerences are allowed.
             C1148 (R1140) A case-value-range using a colon shall not be used if case-expr is of type logical.
             C1149 (R1140) For a given case-construct, there shall be no possible value of the case-expr that matches more
                     than one case-value-range.
             11.1.9.2  Execution of a SELECT CASE construct
          1 The execution of the SELECT CASE statement causes the case expression to be evaluated. For a case value
             range list, a match occurs if the case expression value matches any of the case value ranges in the list. For a case
             expression with a value of c, a match is determined as follows.
                   (1)   If the case value range contains a single value v without a colon, a match occurs for type logical if
                         the expression c .EQV. v is true, and a match occurs for type integer or character if the expression
                         c == v is true.
                   (2)   If the case value range is of the form low : high, a match occurs if the expression low <= c .AND.
                         c <= high is true.
                   (3)   If the case value range is of the form low :, a match occurs if the expression low <= c is true.
                   (4)   If the case value range is of the form : high, a match occurs if the expression c <= high is true.
                   (5)   If no other selector matches and a DEFAULT selector appears, it matches the case index.
                   (6)   If no other selector matches and the DEFAULT selector does not appear, there is no match.
          2 The block following the CASE statement containing the matching selector, if any, is executed. This completes
             execution of the construct.
          3 It is permissible to branch to an end-select-stmt only from within its SELECT CASE construct.
              c
             ISO/IEC 2017 – All rights reserved                                                                  197
             ISO/IEC DIS 1539-1:2017 (E)
             11.1.9.3   Examples of SELECT CASE constructs
                  NOTE11.22
                  An integer signum function:
                          INTEGER FUNCTION SIGNUM (N)
                          SELECT CASE (N)
                          CASE (:-1)
                             SIGNUM = -1
                          CASE (0)
                             SIGNUM = 0
                          CASE (1:)
                             SIGNUM = 1
                          END SELECT
                          END
                  NOTE11.23
                  Acode fragment to check for balanced parentheses:
                          CHARACTER (80) :: LINE
                             ...
                          LEVEL = 0
                          SCAN_LINE: DO I = 1, 80
                             CHECK_PARENS: SELECT CASE (LINE (I:I))
                             CASE (’(’)
                                 LEVEL = LEVEL + 1
                             CASE (’)’)
                                 LEVEL = LEVEL - 1
                                 IF (LEVEL < 0) THEN
                                    PRINT *, ’UNEXPECTED RIGHT PARENTHESIS’
                                    EXIT SCAN_LINE
                                 END IF
                             CASE DEFAULT
                                 ! Ignore all other characters
                             END SELECT CHECK_PARENS
                          END DO SCAN_LINE
                          IF (LEVEL > 0) THEN
                             PRINT *, ’MISSING RIGHT PARENTHESIS’
                          END IF
                  NOTE11.24
                  The following three fragments are equivalent:
                          IF (SILLY == 1) THEN
                             CALL THIS
                          ELSE
                             CALL THAT
                          END IF
                          SELECT CASE (SILLY == 1)
                          CASE (.TRUE.)
                             CALL THIS
                          CASE (.FALSE.)
                             CALL THAT
                          END SELECT
                          SELECT CASE (SILLY)
                                                                            c
             198                                                           ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE11.24 (cont.)
                       CASE DEFAULT
                          CALL THAT
                       CASE (1)
                          CALL THIS
                       END SELECT
                NOTE11.25
                Acode fragment showing several selections of one block:
                       SELECT CASE (N)
                       CASE (1, 3:5, 8)  ! Selects 1, 3, 4, 5, 8
                          CALL SUB
                       CASE DEFAULT
                          CALL OTHER
                       END SELECT
            11.1.10   SELECT RANK construct
            11.1.10.1 Purpose and form of the SELECT RANK construct
         1 The SELECT RANKconstruct selects for execution at most one of its constituent blocks. The selection is based
            on the rank of an assumed-rank variable. A name is associated with the variable (19.4, 19.5.1.6), in the same
            way as for the ASSOCIATE construct.
            R1148 select-rank-construct    is select-rank-stmt
                                                  [ select-rank-case-stmt
                                                  block ]...
                                                  end-select-rank-stmt
            R1149 select-rank-stmt         is [ select-construct-name : ] SELECT RANK
                                                 ( [ associate-name => ] selector )
            C1150 The selector in a select-rank-stmt shall be the name of an assumed-rank array.
            R1150 select-rank-case-stmt    is RANK(scalar-int-constant-expr ) [ select-construct-name ]
                                           or RANK(*)[select-construct-name ]
                                           or RANKDEFAULT[select-construct-name ]
            C1151 A scalar-int-constant-expr in a select-rank-case-stmt shall be nonnegative and less than or equal to the
                  maximum possible rank of selector.
            C1152 For a given select-rank-construct, the same rank value shall not be speciﬁed in more than one select-rank-
                  case-stmt.
            C1153 For a given select-rank-construct, there shall be at most one RANK ( * ) select-rank-case-stmt and at
                  most one RANK DEFAULT select-rank-case-stmt.
            C1154 If select-construct-name appears on a select-rank-case-stmt the corresponding select-rank-stmt shall spe-
                  cify the same select-construct-name.
            C1155 A SELECT RANK construct shall not have a select-rank-case-stmt that is RANK ( * ) if the selector
                  has the ALLOCATABLE or POINTER attribute.
            R1151 end-select-rank-stmt     is ENDSELECT[select-construct-name ]
            c
            ISO/IEC 2017 – All rights reserved                                                      199
             ISO/IEC DIS 1539-1:2017 (E)
             C1156 If the select-rank-stmt of a select-rank-construct speciﬁes a select-construct-name, the corresponding
                     end-select-rank-stmt shall specify the same select-construct-name. If the select-rank-stmt of a select-
                     rank-construct does not specify a select-construct-name, the corresponding end-select-rank-stmt shall not
                     specify a select-construct-name.
          2 The associate name of a SELECT RANK construct is the associate-name if speciﬁed; otherwise it is the name
             that constitutes the selector.
             11.1.10.2  Execution of the SELECT RANK construct
          1 A SELECT RANK construct selects at most one block to be executed. During execution of that block, the
             associate name identiﬁes an entity which is associated (19.5.1.6) with the selector. A RANK ( * ) statement
             matches the selector if the selector is argument associated with an assumed-size array. A RANK ( scalar-int-
             constant-expr ) statement matches the selector if the selector has that rank and is not argument associated with
             an assumed-size array. A RANK DEFAULT statement matches the selector if no other select-rank-case-stmt
             of the construct matches the selector. If a select-rank-case-stmt matches the selector, the block following that
             statement is executed; otherwise, control is transferred to the end-select-rank-stmt.
          2 It is permissible to branch to an end-select-rank-stmt only from within its SELECT RANK construct.
             11.1.10.3  Attributes of a SELECT RANK associate name
          1 Withintheblockfollowing a RANKDEFAULTstatement, theassociatingentity(19.5.5) is assumed-rank and has
             exactly the same attributes as the selector. Within the block following a RANK ( * ) statement, the associating
             entity has rank 1 and is assumed-size, as if it were declared with DIMENSION(1:*). Within the block following
             a RANK ( scalar-int-constant-expr ) statement, the associating entity has the speciﬁed rank; the lower bound of
             each dimension is the result of the intrinsic function LBOUND (16.9.109) applied to the corresponding dimension
             of the selector, and the upper bound of each dimension is the result of the intrinsic function UBOUND (16.9.196)
             applied to the corresponding dimension of the selector.
          2 The associating entity has the ALLOCATABLE, POINTER, or TARGET attribute if the selector has that
             attribute. The other attributes of the associating entity are described in 11.1.3.3.
             11.1.10.4  Examples of the SELECT RANK construct
                  NOTE11.26
                  This example shows how to use a SELECT RANK construct to process scalars and rank-2 arrays; anything
                  else will be rejected as an error.
                         SUBROUTINE process(x)
                            REAL x(..)
                            !
                            SELECT RANK(x)
                            RANK (0)
                              x = 0
                            RANK (2)
                              IF (SIZE(x,2)>=2) x(:,2) = 2
                            RANK DEFAULT
                              Print *, ’I did not expect rank’, RANK(x), ’shape’, SHAPE(x)
                              ERROR STOP ’process bad arg’
                            END SELECT
                  NOTE11.27
                  Thefollowing example shows how to process assumed-size arrays, including how to use sequence association
                  if you want to do multi-dimensional processing of an assumed-size array.
                                                                          c
             200                                                         ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                  NOTE11.27 (cont.)
                         SELECT RANK (y => x)
                         RANK (*)
                            IF (RANK(x)==2) THEN
                              ! Special code for the rank two case.
                              CALL sequence_assoc_2(y, LBOUND(x,1), UBOUND(x,1), LBOUND(x,2))
                            ELSE
                              ! We just do all the other ranks in array element order.
                              i = 1
                              DO
                                IF (y(i)==0) Exit
                                y(i) = -y(i)
                                i = i + 1
                              END DO
                            END IF
                         END SELECT
                         ...
                      CONTAINS
                         ...
                         SUBROUTINE sequence_assoc_2(a, lb1, ub1, lb2)
                            INTEGER, INTENT (IN) :: lb1, ub1, lb2
                            REAL a(lb1:ub1,lb2:*)
                            j = lb2
                    outer: DO
                              DO i=lb1,ub1
                                IF (a(i,j)==0) EXIT outer
                                a(i,j) = a(i,j)**2
                              END DO
                              j = j + 1
                              IF (ANY(a(:,j)==0)) EXIT
                              j = j + 1
                            END DO outer
                         END SUBROUTINE
             11.1.11    SELECT TYPE construct
             11.1.11.1  Purpose and form of the SELECT TYPE construct
          1 The SELECT TYPE construct selects for execution at most one of its constituent blocks. The selection is based
             on the dynamic type of an expression. A name is associated with the expression or variable (19.4, 19.5.1.6), in
             the same way as for the ASSOCIATE construct.
             R1152 select-type-construct        is  select-type-stmt
                                                        [ type-guard-stmt
                                                           block ] ...
                                                        end-select-type-stmt
             R1153 select-type-stmt             is  [ select-construct-name : ] SELECT TYPE
                                                      ( [ associate-name => ] selector )
             C1157 (R1153) If selector is not a named variable, associate-name => shall appear.
             C1158 (R1153) If selector is not a variable or is a variable that has a vector subscript, neither associate-name
                     nor any subobject thereof shall appear in a variable deﬁnition context (19.6.7).
             C1159 (R1153) The selector in a select-type-stmt shall be polymorphic.
              c
             ISO/IEC 2017 – All rights reserved                                                                  201
            ISO/IEC DIS 1539-1:2017 (E)
            R1154 type-guard-stmt             is TYPEIS(type-spec ) [ select-construct-name ]
                                              or CLASS IS ( derived-type-spec ) [ select-construct-name ]
                                              or CLASS DEFAULT [ select-construct-name ]
            C1160 (R1154) The type-spec or derived-type-spec shall specify that each length type parameter is assumed.
            C1161 (R1154) The type-spec or derived-type-spec shall not specify a type with the BIND attribute or the
                    SEQUENCEattribute.
            C1162 (R1152) If selector is not unlimited polymorphic, each TYPE IS or CLASS IS type-guard-stmt shall
                    specify an extension of the declared type of selector.
            C1163 (R1152) For a given select-type-construct, the same type and kind type parameter values shall not be
                    speciﬁed in more than one TYPE IS type-guard-stmt and shall not be speciﬁed in more than one CLASS
                    IS type-guard-stmt.
            C1164 (R1152) For a given select-type-construct, there shall be at most one CLASS DEFAULT type-guard-stmt.
            R1155 end-select-type-stmt        is ENDSELECT[select-construct-name ]
            C1165 (R1152)Iftheselect-type-stmt of a select-type-construct speciﬁes a select-construct-name, the correspond-
                    ing end-select-type-stmt shall specify the same select-construct-name. If the select-type-stmt of a select-
                    type-construct does not specify a select-construct-name, the corresponding end-select-type-stmt shall not
                    specify a select-construct-name. If a type-guard-stmt speciﬁes a select-construct-name, the corresponding
                    select-type-stmt shall specify the same select-construct-name.
          2 The associate name of a SELECT TYPE construct is the associate-name if speciﬁed; otherwise it is the name
            that constitutes the selector.
            11.1.11.2  Execution of the SELECT TYPE construct
          1 Execution of a SELECT TYPE construct causes evaluation of every expression within a selector that is a variable
            designator, or evaluation of a selector that is not a variable designator.
          2 A SELECT TYPE construct selects at most one block to be executed. During execution of that block, the
            associate name identiﬁes an entity which is associated (19.5.1.6) with the selector.
          3 A TYPE IS type guard statement matches the selector if the dynamic type and kind type parameter values of
            the selector are the same as those speciﬁed by the statement. A CLASS IS type guard statement matches the
            selector if the dynamic type of the selector is an extension of the type speciﬁed by the statement and the kind
            type parameter values speciﬁed by the statement are the same as the corresponding type parameter values of the
            dynamic type of the selector.
          4 The block to be executed is selected as follows.
                  (1)  If a TYPE IS type guard statement matches the selector, the block following that statement is
                       executed.
                  (2)  Otherwise, if exactly one CLASS IS type guard statement matches the selector, the block following
                       that statement is executed.
                  (3)  Otherwise, if several CLASS IS type guard statements match the selector, one of these statements
                       will inevitably specify a type that is an extension of all the types speciﬁed in the others; the block
                       following that statement is executed.
                  (4)  Otherwise, if there is a CLASS DEFAULT type guard statement, the block following that statement
                       is executed.
                  (5)  Otherwise, no block is executed.
                                                                      c
            202                                                       ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                  NOTE11.28
                  This algorithm does not examine the type guard statements in source text order when it looks for a match;
                  it selects the most particular type guard when there are several potential matches.
          5 Within the block following a TYPE IS type guard statement, the associating entity (19.5.5) is not polymorphic
             (7.3.2.3), has the type named in the type guard statement, and has the type parameter values of the selector.
          6 Within the block following a CLASS IS type guard statement, the associating entity is polymorphic and has the
             declared type named in the type guard statement. The type parameter values of the associating entity are the
             corresponding type parameter values of the selector.
          7 Within the block following a CLASS DEFAULT type guard statement, the associating entity is polymorphic and
             has the same declared type as the selector. The type parameter values of the associating entity are those of the
             declared type of the selector.
                  NOTE11.29
                  If the declared type of the selector is T, specifying CLASS DEFAULT has the same eﬀect as specifying
                  CLASS IS (T).
          8 The other attributes of the associating entity are described in 11.1.3.3.
          9 It is permissible to branch to an end-select-type-stmt only from within its SELECT TYPE construct.
             11.1.11.3  Examples of the SELECT TYPE construct
                  NOTE11.30
                  TYPE POINT
                    REAL :: X, Y
                  END TYPE POINT
                  TYPE, EXTENDS(POINT) :: POINT_3D
                    REAL :: Z
                  END TYPE POINT_3D
                  TYPE, EXTENDS(POINT) :: COLOR_POINT
                    INTEGER :: COLOR
                  END TYPE COLOR_POINT
                  TYPE(POINT), TARGET :: P
                  TYPE(POINT_3D), TARGET :: P3
                  TYPE(COLOR_POINT), TARGET :: C
                  CLASS(POINT), POINTER :: P_OR_C
                  P_OR_C => C
                  SELECT TYPE ( A => P_OR_C )
                  CLASS IS ( POINT )
                    ! "CLASS ( POINT ) :: A" implied here
                    PRINT *, A%X, A%Y ! This block gets executed
                  TYPE IS ( POINT_3D )
                    ! "TYPE ( POINT_3D ) :: A" implied here
                    PRINT *, A%X, A%Y, A%Z
                  END SELECT
                  NOTE11.31
                  The following example illustrates the omission of associate-name. It uses the declarations from NOTE
                  11.30.
              c
             ISO/IEC 2017 – All rights reserved                                                                  203
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE11.31 (cont.)
                P_OR_C => P3
                SELECT TYPE ( P_OR_C )
                CLASS IS ( POINT )
                  ! "CLASS ( POINT ) :: P_OR_C" implied here
                  PRINT *, P_OR_C%X, P_OR_C%Y
                TYPE IS ( POINT_3D )
                  ! "TYPE ( POINT_3D ) :: P_OR_C" implied here
                  PRINT *, P_OR_C%X, P_OR_C%Y, P_OR_C%Z  ! This block gets executed
                END SELECT
            11.1.12   EXIT statement
         1 The EXIT statement provides one way of terminating a loop, or completing execution of another construct.
            R1156 exit-stmt                is EXIT [ construct-name ]
            C1166 If a construct-name appears on an EXIT statement, the EXIT statement shall be within that construct;
                  otherwise, it shall be within at least one do-construct.
         2 AnEXITstatement belongs to a particular construct. If a construct name appears, the EXIT statement belongs
            to that construct; otherwise, it belongs to the innermost DO construct in which it appears.
            C1167 Anexit-stmt shall not appear within a CHANGE TEAM, CRITICAL, or DO CONCURRENT construct
                  if it belongs to that construct or an outer construct.
         3 When an EXIT statement that belongs to a DO construct is executed, it terminates the loop (11.1.7.4.5) and
            any active loops contained within the terminated loop. When an EXIT statement that belongs to a non-DO
            construct is executed, it terminates any active loops contained within that construct, and completes execution of
            that construct.
            11.2    Branching
            11.2.1   Branch concepts
         1 Branchingisusedtoalterthenormalexecutionsequence. Abranchcausesatransferofcontrolfromonestatement
            to a labeled branch target statement in the same inclusive scope. Branching may be caused by a GO TO state-
            ment, a computed GO TO statement, a CALL statement that has an alt-return-spec, or an input/output statement that has
            an END=, EOR=, or ERR= speciﬁer. Although procedure references and control constructs can cause transfer
            of control, they are not branches. A branch target statement is an action-stmt, associate-stmt, end-associate-
            stmt, if-then-stmt, end-if-stmt, select-case-stmt, end-select-stmt, select-rank-stmt, end-select-rank-stmt, select-
            type-stmt, end-select-type-stmt, do-stmt, end-do-stmt, block-stmt, end-block-stmt, critical-stmt, end-critical-stmt,
            forall-construct-stmt, forall-stmt, where-construct-stmt, end-function-stmt, end-mp-subprogram-stmt, end-program-
            stmt, or end-subroutine-stmt.
            11.2.2   GOTOstatement
            R1157 goto-stmt                is GOTOlabel
            C1168 (R1157) The label shall be the statement label of a branch target statement that appears in the same
                  inclusive scope as the goto-stmt.
         1 Execution of a GO TO statement causes a branch to the branch target statement identiﬁed by the label.
                                                                  c
            204                                                  ISO/IEC 2017 – All rights reserved
                                                                                                        ISO/IEC DIS 1539-1:2017 (E)
                11.2.3       Computed GO TO statement
                R1158     computed-goto-stmt                is   GOTO(label-list ) [ , ] scalar-int-expr
                C1169     (R1158) Each label in label-list shall be the statement label of a branch target statement that appears in the same inclusive
                          scope as the computed-goto-stmt.
             1 Execution of a computed GO TO statement causes evaluation of the scalar integer expression. If this value is i such that 1 ≤ i ≤ n
                                                                                                                                th
                where n is the number of labels in label-list, a branch occurs to the branch target statement identiﬁed by the i   label in the list of
                labels. If i is less than 1 or greater than n, the execution sequence continues as though a CONTINUE statement were executed.
                11.3        CONTINUE statement
             1 Execution of a CONTINUE statement has no eﬀect.
                R1159 continue-stmt                         is   CONTINUE
                11.4        STOP and ERROR STOP statements
                R1160 stop-stmt                             is   STOP[stop-code ] [ , QUIET = scalar-logical-expr]
                R1161 error-stop-stmt                       is   ERRORSTOP[stop-code ] [ , QUIET = scalar-logical-expr]
                R1162 stop-code                             is   scalar-default-char-expr
                                                            or scalar-int-expr
                C1170 (R1162) The scalar-int-expr shall be of default kind.
             1 Execution of a STOP statement initiates normal termination of execution. Execution of an ERROR STOP
                statement initiates error termination of execution.
             2 When an image is terminated by a STOP or ERROR STOP statement, its stop code, if any, is made available
                in a processor-dependent manner. If the stop-code is an integer, it is recommended that the value be used as
                the process exit status, if the processor supports that concept. If the stop-code in a STOP statement is of type
                character or does not appear, or if an end-program-stmt is executed, it is recommended that the value zero be
                supplied as the process exit status, if the processor supports that concept. If the stop-code in an ERROR STOP
                statement is of type character or does not appear, it is recommended that a processor-dependent nonzero value
                be supplied as the process exit status, if the processor supports that concept.
             3 If QUIET= is omitted or the scalar-logical-expr has the value false:
                    • if any exception (17) is signaling on that image, the processor shall issue a warning indicating which
                       exceptions are signaling, and this warning shall be on the unit identiﬁed by the named constant ERROR_-
                       UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2.9);
                    • if a stop code is speciﬁed, it is recommended that it be made available by formatted output to the same
                       unit.
             4 If QUIET= appears and the scalar-logical-expr has the value true, no output of signaling exceptions or stop code
                shall be produced.
                      NOTE11.32
                      When normal termination occurs on more than one image, it is expected that a processor-dependent sum-
                      mary of any stop codes and signaling exceptions will be made available.
                 c
                ISO/IEC 2017 – All rights reserved                                                                                             205
                ISO/IEC DIS 1539-1:2017 (E)
                     NOTE11.33
                     If the integer stop-code is used as the process exit status, the processor might be able to interpret only values
                     within a limited range, or only a limited portion of the integer value (for example, only the least-signiﬁcant
                     8 bits).
                11.5       FAIL IMAGE statement
                R1163 fail-image-stmt                     is  FAIL IMAGE
            1 Execution of a FAIL IMAGE statement causes the executing image to cease participating in program execution
                without initiating termination. No further statements are executed by that image.
                     NOTE11.34
                     The FAIL IMAGE statement allows a program to test a recovery algorithm without needing an actual
                     failure.
                     On a processor that does not have the ability to detect that an image has failed, execution of a FAIL
                     IMAGEstatement might provide a simulated failure environment that provides debug information.
                     In a piece of code that executes about once a second, invoking this subroutine on an image
                               SUBROUTINE FAIL
                                 REAL :: X
                                 CALL RANDOM_NUMBER (X)
                                 IF (X<0.001) FAIL IMAGE
                               END SUBROUTINE FAIL
                     will cause that image to have an independent 1/1000 chance of failure every second if the random number
                     generators on diﬀerent images are independent.
                     Note that FAIL IMAGE is not an image control statement.
                11.6       Image execution control
                11.6.1      Image control statements
            1 The execution sequence on each image is speciﬁed in 5.3.5.
            2 Execution of an image control statement divides the execution sequence on an image into segments. Each of the
                following is an image control statement:
                   • SYNC ALL statement;
                   • SYNC IMAGES statement;
                   • SYNC MEMORYstatement;
                   • SYNC TEAM statement;
                   • ALLOCATE or DEALLOCATE statement that has a coarray allocate-object;
                   • CHANGETEAMorENDTEAMstatement(11.1.5);
                   • CRITICAL or END CRITICAL statement (11.1.6);
                   • EVENT POST or EVENT WAIT statement;
                   • FORMTEAMstatement;
                   • LOCK or UNLOCK statement;
                   • anystatementthatcompletesexecutionofablockorprocedureandwhichresultsintheimplicitdeallocation
                      of a coarray;
                                                                                         c
                206                                                                      ISO/IEC 2017 – All rights reserved
                                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                      • a CALL statement that references the intrinsic subroutine MOVE_ALLOC with coarray arguments;
                      • STOP statement;
                      • END statement of a main program.
              3 All image control statements except CRITICAL, END CRITICAL, EVENT POST, EVENT WAIT, FORM
                  TEAM,LOCK,andUNLOCKinclude the eﬀect of executing a SYNC MEMORY statement (11.6.5).
              4 During an execution of a statement that invokes more than one procedure, at most one invocation shall cause
                  execution of an image control statement other than CRITICAL or END CRITICAL.
                  11.6.2        Segments
              1 On each image, the sequence of statements executed before the ﬁrst execution of an image control statement,
                  between the execution of two image control statements, or after the last execution of an image control statement
                  is a segment. The segment executed immediately before the execution of an image control statement includes the
                  evaluation of all expressions within the statement.
              2 By execution of image control statements or user-deﬁned ordering (11.6.5), the program can ensure that the
                                         th                                                                                                      th
                  execution of the i         segment on image P, P , either precedes or succeeds the execution of the j                              segment on
                                                                            i
                  another image Q, Q . If the program does not ensure this, segments P and Q are unordered; depending on the
                                            j                                                                i          j
                  relative execution speeds of the images, some or all of the execution of the segment Pi may take place at the same
                  time as some or all of the execution of the segment Q .
                                                                                        j
              3 Acoarray may be referenced or deﬁned by execution of an atomic subroutine during the execution of a segment
                  that is unordered relative to the execution of a segment in which the coarray is referenced or deﬁned by execution
                  of an atomic subroutine. An event variable may be referenced or deﬁned during the execution of a segment that
                  is unordered relative to the execution of another segment in which that event variable is deﬁned. Otherwise,
                      • if a variable is deﬁned or becomes undeﬁned on an image in a segment, it shall not be referenced, deﬁned,
                         or become undeﬁned in a segment on another image unless the segments are ordered,
                      • if the allocation of an allocatable subobject of a coarray or the pointer association of a pointer subobject
                         of a coarray is changed on an image in a segment, that subobject shall not be referenced, deﬁned, or have
                         its allocation or association status, dynamic type, array bounds, shape, or a deferred type parameter value
                         inquired about in a segment on another image unless the segments are ordered, and
                      • if a procedure invocation on image P is in execution in segments P , P                           , ..., P   and deﬁnes a noncoarray
                                                                                                                i    i+1         k
                         dummyargument, the eﬀective argument shall not be referenced, deﬁned, or become undeﬁned on another
                         image Q in a segment Q unless Q precedes P or succeeds P .
                                                         j            j                i                  k
                        NOTE11.35
                        The set of all segments on all images is partially ordered: the segment P precedes segment Q if and
                                                                                                                            i                           j
                        only if there is a sequence of segments starting with Pi and ending with Qj such that each segment of the
                        sequence precedes the next either because they are consecutive segments on the same image or because of
                        the execution of image control statements.
                        NOTE11.36
                        If the segments S , S , ..., S          on the distinct images P , P , ..., P are all unordered with respect to each
                                               1    2        k                                  1    2         k
                        other, it is expected that the processor will ensure that each of these images is provided with an equitable
                        share of resources for executing its segment.
                        NOTE11.37
                        Because of the restrictions on references and deﬁnitions in unordered segments, the processor can apply
                        code motion optimizations within a segment as if it were the only image in execution, provided calls to
                        atomic subroutines are not involved.
                   c
                  ISO/IEC 2017 – All rights reserved                                                                                                         207
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE11.38
               The model upon which the interpretation of a program is based is that there is a permanent memory
               location for each coarray and that all images on which it is established can access it.
               In practice, apart from executions of atomic subroutines, the processor could make a copy of a nonvolatile
               coarray on an image (in cache or a register, for example) and, as an optimization, defer copying a changed
               value back to the permanent memory location while it is still being used. Since the variable is not volatile,
               it is safe to defer this transfer until the end of the segment and thereafter to reload from permanent memory
               any coarray that was not deﬁned within the segment. It might not be safe to defer these actions beyond
               the end of the segment since another image might reference the variable then.
               The value of the ATOM argument of an atomic subroutine might be accessed or modiﬁed by another
               concurrently executing image. Therefore, execution of an atomic subroutine that references the ATOM
               argument cannot rely on a local copy, but instead always gets its value from its permanent memory location.
               Execution of an atomic subroutine that deﬁnes the ATOM argument does not complete until the value of
               its ATOM argument has been sent to its permanent memory location.
               NOTE11.39
               The incorrect sequencing of image control statements can suspend execution indeﬁnitely. For example, one
               image might be executing a SYNC ALL statement while another is executing an ALLOCATE statement
               for a coarray.
           11.6.3  SYNC ALL statement
           R1164 sync-all-stmt          is SYNCALL[([sync-stat-list ] ) ]
           R1165 sync-stat              is STAT = stat-variable
                                        or ERRMSG=errmsg-variable
           C1171 No speciﬁer shall appear more than once in a given sync-stat-list.
           C1172 A stat-variable or errmsg-variable in a sync-stat shall not be a coindexed object.
         1 The STAT= and ERRMSG= speciﬁers for image control statements are described in 11.6.11.
         2 Successful execution of a SYNC ALL statement performs a synchronization of all images in the current team.
           Execution on an image, M, of the segment following the SYNC ALL statement is delayed until each other image
           in the current team has executed a SYNC ALL statement as many times as has image M in this team. The
           segments that executed before the SYNC ALL statement on an image precede the segments that execute after
           the SYNC ALL statement on another image.
               NOTE11.40
               The processor might have special hardware or employ an optimized algorithm to make the SYNC ALL
               statement execute eﬃciently.
               Here is a simple example of its use. Image 1 reads data and broadcasts it to other images:
                     REAL :: P[*]
                     ...
                     SYNC ALL
                     IF (THIS_IMAGE()==1) THEN
                        READ (*,*) P
                        DO I = 2, NUM_IMAGES()
                           P[I] = P
                        END DO
                     END IF
                     SYNC ALL
                                                              c
           208                                               ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           11.6.4  SYNC IMAGES statement
           R1166 sync-images-stmt       is SYNCIMAGES(image-set [ , sync-stat-list ] )
           R1167 image-set              is int-expr
                                        or *
           C1173 An image-set that is an int-expr shall be scalar or of rank one.
           C1174 The value of image-set shall not depend on the value of stat-variable or errmsg-variable.
         1 If image-set is an array expression, the value of each element shall be positive and not greater than the number
           of images in the current team, and there shall be no repeated values.
         2 If image-set is a scalar expression, its value shall be positive and not greater than the number of images in the
           current team.
         3 An image-set that is an asterisk speciﬁes all images in the current team.
         4 Execution of a SYNC IMAGES statement performs a synchronization of the image with each of the other images
           in the image-set. Executions of SYNC IMAGES statements on images M and T correspond if the number of
           times image M has executed a SYNC IMAGES statement in the current team with T in its image set is the same
           as the number of times image T has executed a SYNC IMAGES statement with M in its image set in this team.
           The segments that executed before the SYNC IMAGES statement on either image precede the segments that
           execute after the corresponding SYNC IMAGES statement on the other image.
               NOTE11.41
               ASYNCIMAGESstatementthatspeciﬁes the single image index value THIS_IMAGE ( ) in its image set
               is allowed. This simpliﬁes writing programs for an arbitrary number of images by allowing correct execution
               in the limiting case of the number of images being equal to one.
               NOTE11.42
               In a program that uses SYNC ALL as its only synchronization mechanism, every SYNC ALL statement
               could be replaced by a SYNC IMAGES (*) statement, but SYNC ALL might give better performance.
               SYNC IMAGES statements are not required to specify the entire image set, or even the same image set,
               on all images participating in the synchronization. In the following example, image 1 will wait for each of
               the other images to execute the statement SYNC IMAGES (1). The other images wait for image 1 to set
               up the data, but do not wait on any other image.
                     IF (THIS_IMAGE() == 1) then
                        ! Set up coarray data needed by all other images.
                        SYNC IMAGES(*)
                     ELSE
                        SYNC IMAGES(1)
                        ! Use the data set up by image 1.
                     END IF
               Whenthefollowingexamplerunsonﬁveormoreimages,eachimagesynchronizeswithbothofitsneighbors,
               in a circular fashion.
                     INTEGER :: up, down
                     ...
                     IF (NUM_IMAGES () > 1) THEN
                        up   = THIS_IMAGE () + 1; IF (up>NUM_IMAGES ()) up = 1
                        down = THIS_IMAGE () - 1; IF (down==0) down = NUM_IMAGES ()
                        SYNC IMAGES ( (/ up, down /) )
                     END IF
           c
           ISO/IEC 2017 – All rights reserved                                                 209
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE11.42 (cont.)
                This might appear to have the same eﬀect as SYNC ALL but there is no ordering between the preceding
                and succeeding segments on non-adjacent images. For example, the segment preceding the SYNC IMAGES
                statement on image 3 will be ordered before those succeeding it on images 2 and 4, but not those on images
                1 and 5.
                NOTE11.43
                In the following example, each image synchronizes with its neighbor.
                       INTEGER :: ME, NE, STEP, NSTEPS
                       NE = NUM_IMAGES()
                       ME = THIS_IMAGE()
                       ... ! Initial calculation
                       SYNC ALL
                       DO STEP = 1, NSTEPS
                          IF (ME > 1) SYNC IMAGES(ME-1)
                             ... ! Perform calculation
                          IF (ME < NE) SYNC IMAGES(ME+1)
                       END DO
                       SYNC ALL
                The calculation starts on image 1 since all the others will be waiting on SYNC IMAGES (ME−1). When
                this is done, image 2 can start and image 1 can perform its second calculation. This continues until they
                are all executing diﬀerent steps at the same time. Eventually, image 1 will ﬁnish and then the others will
                ﬁnish one by one.
            11.6.5   SYNC MEMORY statement
         1 Execution of a SYNC MEMORY statement ends one segment and begins another; those two segments can be
            ordered by a user-deﬁned way with respect to segments on other images.
            R1168 sync-memory-stmt         is SYNCMEMORY[([sync-stat-list ] ) ]
         2 If, by execution of statements on image P,
              • a variable X on image Q is deﬁned, referenced, becomes undeﬁned, or has its allocation status, pointer
                association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
                of a statement,
              • that statement precedes a successful execution of a SYNC MEMORY statement, and
              • a variable Y on image Q is deﬁned, referenced, becomes undeﬁned, or has its allocation status, pointer
                association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
                of a statement that succeeds execution of that SYNC MEMORY statement,
            then the action regarding X on image Q precedes the action regarding Y on image Q.
         3 User-deﬁned ordering of segment P on image P to precede segment Q on image Q occurs when
                                         i                            j
              • image P executes an image control statement that ends segment P , and then executes statements that
                initiate a cooperative synchronization between images P and Q, andi
              • image Q executes statements that complete the cooperative synchronization between images P and Q and
                then executes an image control statement that begins segment Q .
                                                                       j
         4 Execution of the cooperative synchronization between images P and Q shall include a dependency that forces
            execution on image P of the statements that initiate the synchronization to precede the execution on image Q of
            the statements that complete the synchronization. The mechanisms available for creating such a dependency are
            processor dependent.
                                                                  c
            210                                                  ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
               NOTE11.44
               SYNCMEMORYusually suppresses compiler optimizations that might reorder memory operations across
               the segment boundary deﬁned by the SYNC MEMORY statement and ensures that all memory operations
               initiated in the preceding segments in its image complete before any memory operations in the subsequent
               segment in its image are initiated. It needs to do this unless it can establish that failure to do so could not
               alter processing on another image.
               NOTE11.45
               SYNCMEMORYcanbeusedtoimplementspecializedschemesforsegmentordering. Forexample,theuser
               might have access to an external procedure that performs synchronization between images. That library
               procedure might not be aware of the mechanisms used by the processor to manage remote data references
               and deﬁnitions, and therefore not, by itself, be able to ensure the correct memory state before and after its
               reference. The SYNC MEMORY statement provides the needed memory ordering that enables the safe use
               of the external synchronization routine. For example:
                     INTEGER :: IAM
                     REAL    :: X[*]
                     IAM = THIS_IMAGE ()
                     IF (IAM == 1) X = 1.0
                     SYNC MEMORY
                     CALL EXTERNAL_SYNC ()
                     SYNC MEMORY
                     IF (IAM == 2) WRITE (*,*) X[1]
               where executing the subroutine EXTERNAL_SYNC has an image synchronization eﬀect similar to execut-
               ing a SYNC ALL statement.
           11.6.6  SYNC TEAM statement
           R1169 sync-team-stmt         is SYNCTEAM(team-value [ , sync-stat-list ] )
         1 The team-value shall identify an ancestor team, the current team, or a team whose parent is the current team.
           The executing image shall be a member of the speciﬁed team.
         2 Successful execution of a SYNC TEAM statement performs a synchronization of the team identiﬁed by team-
           value. Execution on an image, M, of the segment following the SYNC TEAM statement is delayed until each
           other image of the speciﬁed team has executed a SYNC TEAM statement specifying the same team as many
           times as has image M in this team. The segments that executed before the SYNC TEAM statement on an image
           precede the segments that execute after the corresponding SYNC TEAM statement on another image.
               NOTE11.46
               ASYNCTEAMstatement synchronizes a particular team whereas a SYNC ALL statement synchronizes
               the current team.
           11.6.7  EVENT POST statement
         1 The EVENT POST statement posts an event.
           R1170 event-post-stmt        is EVENTPOST(event-variable [ , sync-stat-list ] )
           R1171 event-variable         is scalar-variable
           C1175 (R1171)Anevent-variable shall be of type EVENT_TYPEfromtheintrinsicmoduleISO_FORTRAN_-
                 ENV(16.10.2).
           c
           ISO/IEC 2017 – All rights reserved                                                 211
           ISO/IEC DIS 1539-1:2017 (E)
         2 The event-variable shall not depend on the value of stat-variable or errmsg-variable.
         3 Successful execution of an EVENT POST statement atomically increments the count of the event variable by
           one. If an error condition occurs during execution of an EVENT POST statement, the value of the count of the
           event variable is processor dependent. The completion of an EVENT POST statement does not depend on the
           execution of a corresponding EVENT WAIT statement.
           11.6.8  EVENT WAIT statement
         1 The EVENT WAIT statement waits until an event is posted.
           R1172 event-wait-stmt        is EVENTWAIT(event-variable [ , event-wait-spec-list ] )
           R1173 event-wait-spec        is until-spec
                                        or sync-stat
           R1174 until-spec             is UNTIL_COUNT=scalar-int-expr
           C1176 (R1172) The event-variable in an event-wait-stmt shall not be coindexed.
           C1177 No speciﬁer shall appear more than once in a given event-wait-spec-list.
         2 The event-variable shall not depend on the value of stat-variable or errmsg-variable.
         3 Execution of an EVENT WAIT statement consists of the following sequence of actions:
             1. if the UNTIL_COUNT=speciﬁerdoesnotappear,thethresholdvalueissettoone; otherwise, thethreshold
               value is set to the maximum of the value of the scalar-int-expr and one;
             2. the executing image waits until the count of the event variable is greater than or equal to the threshold
               value or an error condition occurs;
             3. if no error condition occurs, the count of the event variable is atomically decremented by the threshold
               value.
         4 If an error condition occurs during execution of an EVENT WAIT statement, the value of the count of its event
           variable is processor dependent.
         5 An EVENT POST statement execution is initially unsatisﬁed. Successful execution of an EVENT WAIT state-
           ment with a threshold of k satisﬁes the ﬁrst k unsatisﬁed EVENT POST statement executions for that event
           variable. This EVENT WAIT statement execution causes the segment following the EVENT WAIT statement
           execution to succeed the segments preceding those k EVENT POST statement executions.
           11.6.9  FORMTEAMstatement
         1 The FORM TEAM statement creates new teams whose parent team is the current team.
           R1175 form-team-stmt         is FORMTEAM(team-number, team-variable
                                              [ , form-team-spec-list ] )
           R1176 team-number            is scalar-int-expr
           R1177 team-variable          is scalar-variable
           C1178 A team-variable shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
           R1178 form-team-spec         is NEW_INDEX=scalar-int-expr
                                        or sync-stat
           C1179 No speciﬁer shall appear more than once in a given form-team-spec-list.
                                                              c
           212                                               ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        2 SuccessfulexecutionofaFORMTEAMstatementcreatesanewteamforeachuniqueteam-number valuespeciﬁed
           by the active images of the current team. The value of team-number shall be positive. Each executing image will
           belong to the team whose team number is equal to the value of team-number on that image, and the team-variable
           becomes deﬁned with a value that identiﬁes that team.
        3 Thevalue of the scalar-int-expr in a NEW_INDEX= speciﬁer speciﬁes the image index that the executing image
           will have in its new team. It shall be positive, less than or equal to the number of images in the team, and
           diﬀerent from the value speciﬁed by every other image that belongs to that team.
        4 If the NEW_INDEX= speciﬁer does not appear, the image index of the executing image in the new team is
           processor dependent. This image index will be positive, less than or equal to the number of images in the team,
           and diﬀerent from that of every other image in the team.
        5 If the FORM TEAM statement is executed on one image, the same statement shall be executed on all active
           images of the current team. When a FORM TEAM statement is executed, there is an implicit synchronization
           of all active images in the current team. On those images, execution of the segment following the statement is
           delayed until all other active images in the current team have executed the same statement the same number of
           times in this team. The segments that executed before the FORM TEAM statement on an active image of this
           team precede the segments that execute after the FORM TEAM statement on another active image of this team.
           If an error condition other than detection of a failed image occurs, the team variable becomes undeﬁned.
        6 If execution of a FORM TEAM statement assigns the value STAT_FAILED_IMAGE to the stat-variable, the
           eﬀect is the same as for the successful execution of FORM TEAM except for the value assigned to stat-variable.
              NOTE11.47
              Executing the statement
                     FORM TEAM ( 2 - MOD (THIS_IMAGE (), 2), ODD_EVEN )
              will create two subteams of the current team, with images whose image index is odd being in the team with
              number 1, and those with an even image index being in the team with number 2.
              NOTE11.48
              If the current team consists of P2 images, with corresponding coarrays on each image representing parts of
              a larger array spread over a P × P square, the following code will establish teams for the rows with image
              indices equal to the column indices.
                     USE, INTRINSIC :: ISO_FORTRAN_ENV
                     TYPE(TEAM_TYPE) :: ROW
                     REAL :: A [P, *]
                     INTEGER :: ME (2)
                     ME (:) = THIS_IMAGE (A)
                     FORM TEAM (ME(1), ROW, NEW_INDEX=ME(2))
           11.6.10  LOCK and UNLOCK statements
           R1179 lock-stmt             is LOCK(lock-variable [ , lock-stat-list ] )
           R1180 lock-stat             is ACQUIRED_LOCK=scalar-logical-variable
                                       or sync-stat
           C1180 No speciﬁer shall appear more than once in a given lock-stat-list.
           R1181 unlock-stmt           is UNLOCK(lock-variable [ , sync-stat-list ] )
           R1182 lock-variable         is scalar-variable
           c
           ISO/IEC 2017 – All rights reserved                                               213
         ISO/IEC DIS 1539-1:2017 (E)
         C1181 (R1182)Alock-variable shall be of type LOCK_TYPEfromtheintrinsic module ISO_FORTRAN_ENV
              (16.10.2.19).
       1 The lock-variable shall not depend on the value of stat-variable, errmsg-variable, or the scalar-logical-variable in
         the ACQUIRED_LOCK=speciﬁer. Thescalar-logical-variable shall not depend on the value of the lock-variable,
         stat-variable, or errmsg-variable.
       2 Alockvariable is unlocked if and only if the value of each component is the same as its default value. If it has any
         other value, it is locked. A lock variable is locked by an image if it was locked by execution of a LOCK statement
         on that image, has not been subsequently unlocked by execution of an UNLOCK statement on the same image,
         and that image has not failed.
       3 Successful execution of a LOCK statement without an ACQUIRED_LOCK= speciﬁer causes the lock variable
         to become locked by that image. If the lock variable is already locked by another image, that LOCK statement
         causes the lock variable to become locked after the other image causes the lock variable to become unlocked.
       4 If the lock variable is unlocked, successful execution of a LOCK statement with an ACQUIRED_LOCK= speciﬁer
         causes the lock variable to become locked by that image and the scalar logical variable to become deﬁned with the
         value true. If the lock variable is already locked by a diﬀerent image, successful execution of a LOCK statement
         with an ACQUIRED_LOCK= speciﬁer leaves the lock variable unchanged and causes the scalar logical variable
         to become deﬁned with the value false.
       5 Successful execution of an UNLOCK statement causes the lock variable to become unlocked. Failure of an image
         causes all lock variables that are locked by that image to become unlocked.
       6 During execution of the program, the value of a lock variable changes through a sequence of locked and unlocked
         states due to the execution of LOCK and UNLOCK statements, and by failure of an image while it is locked by
         that image. If a lock variable becomes unlocked by execution of an UNLOCK statement on image M and next
         becomes locked by execution of a LOCK statement on image T, the segments preceding the UNLOCK statement
         on image M precede the segments following the LOCK statement on image T. Execution of a LOCK statement
         that does not cause the lock variable to become locked does not aﬀect segment ordering.
       7 An error condition occurs if the lock variable in a LOCK statement is already locked by the executing image.
         An error condition occurs if the lock variable in an UNLOCK statement is not already locked by the executing
         image. If an error condition occurs during execution of a LOCK or UNLOCK statement, the value of the lock
         variable is not changed and the value of the ACQUIRED_LOCK variable, if any, is not changed.
            NOTE11.49
            Alockvariable is eﬀectively deﬁned atomically by a LOCK or UNLOCK statement. If LOCK statements on
            twoimagesbothattempttoacquirealock, onewillsucceedandtheotherwilleitherfailifanACQUIRED_-
            LOCK=speciﬁer appears, or will wait until the lock is later released if an ACQUIRED_LOCK= speciﬁer
            does not appear.
            NOTE11.50
            An image might wait for a LOCK statement to successfully complete for a long period of time if other
            images frequently lock and unlock the same lock variable. This situation might result from executing
            LOCKstatements with ACQUIRED_LOCK= speciﬁers inside a spin loop.
            NOTE11.51
            The following example illustrates the use of LOCK and UNLOCK statements to manage a work queue:
            USE, INTRINSIC :: ISO_FORTRAN_ENV
            TYPE(LOCK_TYPE) :: queue_lock[*] ! Lock on each image to manage its work queue
            INTEGER :: work_queue_size[*]
            TYPE(Task) :: work_queue(100)[*] ! List of tasks to perform
                                                  c
         214                                     ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
              NOTE11.51 (cont.)
              TYPE(Task) :: job ! Current task working on
              INTEGER :: me
              me = THIS_IMAGE()
              DO
                 ! Process the next item in your work queue
                 LOCK (queue_lock) ! New segment A starts
                 ! This segment A is ordered with respect to
                 ! segment B executed by image me-1 below because of lock exclusion
                 IF (work_queue_size>0) THEN
                    ! Fetch the next job from the queue
                    job = work_queue(work_queue_size)
                    work_queue_size = work_queue_size-1
                 END IF
                 UNLOCK (queue_lock) ! Segment ends
                 ... ! Actually process the task
                 ! Add a new task on neighbors queue:
                 LOCK(queue_lock[me+1]) ! Starts segment B
                 ! This segment B is ordered with respect to
                 ! segment A executed by image me+1 above because of lock exclusion
                 IF (work_queue_size[me+1]<SIZE (work_queue)) THEN
                    work_queue_size[me+1] = work_queue_size[me+1]+1
                    work_queue(work_queue_size[me+1])[me+1] = job
                 END IF
                 UNLOCK (queue_lock[me+1]) ! Ends segment B
              END DO
           11.6.11  STAT= and ERRMSG= speciﬁers in image control statements
        1 In an image control statement, the stat-variable in a sync-stat shall not depend on the value of an errmsg-variable
           in a sync-stat, event-variable, lock-variable, team-variable, or the scalar-logical-variable in the ACQUIRED_-
           LOCK= speciﬁer. The errmsg-variable in a sync-stat shall not depend on the value of a stat-variable in a
           sync-stat, event-variable, lock-variable, team-variable, or the scalar-logical-variable in the ACQUIRED_LOCK=
           speciﬁer.
        2 If a STAT= speciﬁer appears in a sync-stat in an image control statement, the stat-variable is assigned the value
           zero if execution of the statement is successful.
        3 If the STAT= speciﬁer appears in a sync-stat in an EVENT WAIT or SYNC MEMORY statement and an error
           condition occurs, stat-variable is assigned a processor-dependent positive value that is diﬀerent from the value
           of STAT_FAILED_IMAGE(16.10.2.26) and STAT_STOPPED_IMAGE(16.10.2.29) from the intrinsic module
           ISO_FORTRAN_ENV(16.10.2).
        4 The images involved in execution of an END TEAM, FORM TEAM, or SYNC ALL statement are those in the
           current team. The images involved in execution of a CHANGE TEAM or SYNC TEAM statement are those of
           the speciﬁed team. The images involved in execution of a SYNC IMAGES statement are the images speciﬁed
           and the executing image. The images involved in execution of an EVENT POST statement are the image on
           which the event variable is located and the executing image.
        5 If the STAT= speciﬁer appears in a sync-stat in a CHANGE TEAM, END TEAM, EVENT POST, FORM
           TEAM,SYNCALL,SYNCIMAGES,orSYNCTEAMstatement,
           c
           ISO/IEC 2017 – All rights reserved                                               215
         ISO/IEC DIS 1539-1:2017 (E)
           • if one of the images involved has stopped, stat-variable is assigned the value STAT_STOPPED_IMAGE
            (16.10.2.29) from the intrinsic module ISO_FORTRAN_ENV;
           • otherwise, if one of the images involved has failed and no other error condition occurs, the intended action
            is performed on the active images involved and stat-variable is assigned the value STAT_FAILED_IMAGE
            (16.10.2.26) from the intrinsic module ISO_FORTRAN_ENV;
           • otherwise, if any other error condition occurs, stat-variable is assigned a processor-dependent positive value
            that is diﬀerent from the values of STAT_STOPPED_IMAGE and STAT_FAILED_IMAGE.
       6 If the STAT= speciﬁer appears in a sync-stat in a SYNC ALL, SYNC IMAGES, or SYNC TEAM statement
         and the error condition STAT_STOPPED_IMAGE occurs, the eﬀect is the same as that of executing the SYNC
         MEMORYstatement, except for deﬁning the stat-variable.
       7 If the STAT= speciﬁer appears in a sync-stat in a LOCK statement,
           • if the image on which the lock variable is located has failed, the stat-variable becomes deﬁned with the
            value STAT_FAILED_IMAGE;
           • otherwise, if the lock variable is locked by the executing image, the stat-variable becomes deﬁned with the
            value of STAT_LOCKED (16.10.2.27) from the intrinsic module ISO_FORTRAN_ENV;
           • otherwise, if the lock variable is unlocked because of the failure of the image that locked it, stat-variable
            becomes deﬁned with the value STAT_UNLOCKED_FAILED_IMAGE (16.10.2.31) from the intrinsic
            module ISO_FORTRAN_ENV.
       8 If the STAT= speciﬁer appears in a sync-stat in an UNLOCK statement,
           • if the image on which the lock variable is located has failed, the stat-variable becomes deﬁned with the
            value STAT_FAILED_IMAGE;
           • otherwise, if the lock variable has the value unlocked, the stat-variable becomes deﬁned with the value of
            STAT_UNLOCKED(16.10.2.30) from the intrinsic module ISO_FORTRAN_ENV;
           • otherwise, if the lock variable is locked by a diﬀerent image, the stat-variable becomes deﬁned with the
            value STAT_LOCKED_OTHER_IMAGE(16.10.2.28) from the intrinsic module ISO_FORTRAN_ENV.
       9 If the STAT= speciﬁer appears in a sync-stat in a LOCK or UNLOCK statement and any other error condi-
         tion occurs during execution of that statement, the stat-variable becomes deﬁned with a processor-dependent
         positive integer value that is diﬀerent from STAT_LOCKED, STAT_LOCKED_OTHER_IMAGE, STAT_UN-
         LOCKED, and STAT_UNLOCKED_FAILED_IMAGE.
      10 If an image completes execution of a CRITICAL statement that has a sync-stat that is a STAT= speciﬁer and the
         previous image to have entered the construct failed while executing it, the stat-variable becomes deﬁned with the
         value STAT_FAILED_IMAGE and execution of the construct continues normally. If any other error condition
         occurs during execution of a CRITICAL statement that has a STAT= speciﬁer, the stat-variable becomes deﬁned
         with a processor-dependent value other than STAT_FAILED_IMAGE.
      11 If an error condition occurs during execution of an image control statement that does not contain the STAT=
         speciﬁer in a sync-stat, error termination is initiated.
      12 If an ERRMSG= speciﬁer appears in an image control statement and an error condition occurs, errmsg-variable
         is assigned an explanatory message, truncated or padded according to the rules of intrinsic assignment. If no
         such condition occurs, the deﬁnition status and value of errmsg-variable are unchanged.
      13 The set of error conditions that can occur in an image control statement is processor dependent.
            NOTE11.52
            A processor might detect communication failure between images and treat it as an error condition. A
            processor might also treat an invalid set of images in a SYNC IMAGES statement as an error condition.
                                                  c
         216                                     ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           12 Input/output statements
           12.1    Input/output concepts
         1 Inputstatementsprovidethemeansoftransferringdatafromexternalmediatointernalstorageorfromaninternal
           ﬁle to internal storage. This process is called reading. Output statements provide the means of transferring data
           from internal storage to external media or from internal storage to an internal ﬁle. This process is called writing.
           Some input/output statements specify that editing of the data is to be performed.
         2 In addition to the statements that transfer data, there are auxiliary input/output statements to manipulate the
           external medium, or to describe or inquire about the properties of the connection to the external medium.
         3 The input/output statements are the BACKSPACE, CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN, PRINT,
           READ, REWIND, WAIT, and WRITE statements.
         4 A ﬁle is composed of either a sequence of ﬁle storage units (12.3.5) or a sequence of records, which provide an
           extra level of organization to the ﬁle. A ﬁle composed of records is called a record ﬁle. A ﬁle composed of ﬁle
           storage units is called a stream ﬁle. A processor may allow a ﬁle to be viewed both as a record ﬁle and as a stream
           ﬁle; in this case the relationship between the ﬁle storage units when viewed as a stream ﬁle and the records when
           viewed as a record ﬁle is processor dependent.
         5 Aﬁle is either an external ﬁle (12.3) or an internal ﬁle (12.4).
           12.2    Records
           12.2.1  Deﬁnition of a record
         1 Arecordisasequenceofvaluesorasequenceofcharacters. Forexample, a line on a terminal is usually considered
           to be a record. However, a record does not necessarily correspond to a physical entity. There are three kinds of
           records:
                (1)  formatted;
                (2)  unformatted;
                (3)  endﬁle.
               NOTE12.1
               What is called a “record” in Fortran is commonly called a “logical record”. There is no concept in Fortran
               of a “physical record.”
           12.2.2  Formatted record
         1 A formatted record consists of a sequence of characters that are representable in the processor; however, a
           processor may prohibit some control characters (6.1.1) from appearing in a formatted record. The length of a
           formatted record is measured in characters and depends primarily on the number of characters put into the record
           when it is written; however, it may depend on the processor and the external medium. The length may be zero.
           Formatted records shall be read or written only by formatted input/output statements.
           12.2.3  Unformatted record
         1 An unformatted record consists of a sequence of values in a processor-dependent form and may contain data
           of any type or may contain no data. The length of an unformatted record is measured in ﬁle storage units
           c
           ISO/IEC 2017 – All rights reserved                                                 217
           ISO/IEC DIS 1539-1:2017 (E)
           (12.3.5) and depends on the output list (12.6.3) used when it is written, as well as on the processor and the
           external medium. The length may be zero. Unformatted records may be read or written only by unformatted
           input/output statements.
           12.2.4  Endﬁle record
         1 An endﬁle record is written explicitly by the ENDFILE statement; the ﬁle shall be connected for sequential
           access. An endﬁle record is written implicitly to a ﬁle connected for sequential access when the most recent data
           transfer statement referring to the ﬁle is an output statement, no intervening ﬁle positioning statement referring
           to the ﬁle has been executed, and
              • a REWIND or BACKSPACE statement references the unit to which the ﬁle is connected, or
              • the unit is closed, either explicitly by a CLOSE statement, implicitly by normal termination, or implicitly
               by another OPEN statement for the same unit.
         2 An endﬁle record may occur only as the last record of a ﬁle. An endﬁle record does not have a length property.
               NOTE12.2
               Anendﬁle record does not necessarily have any physical embodiment. The processor can use a record count
               or any other means to register the position of the ﬁle at the time an ENDFILE statement is executed, so
               that it can take appropriate action when that position is reached again during a read operation. The endﬁle
               record, however it is implemented, is considered to exist for the BACKSPACE statement (12.8.2).
           12.3    External ﬁles
           12.3.1  External ﬁle concepts
         1 An external ﬁle is any ﬁle that exists in a medium external to the program.
         2 At any given time, there is a processor-dependent set of allowed access methods, a processor-dependent set of
           allowed forms, a processor-dependent set of allowed actions, and a processor-dependent set of allowed record
           lengths for a ﬁle.
               NOTE12.3
               For example, the processor-dependent set of allowed actions for a printer would likely include the write
               action, but not the read action.
         3 Aﬁle may have a name; a ﬁle that has a name is called a named ﬁle. The name of a named ﬁle is represented by
           a character string value. The set of allowable names for a ﬁle is processor dependent. Whether a named ﬁle on
           one image is the same as a ﬁle with the same name on another image is processor dependent.
               NOTE12.4
               If diﬀerent ﬁles are needed on each image, using a diﬀerent ﬁle name on each image will improve portability
               of the code. One technique is to incorporate the image index as part of the name.
         4 An external ﬁle that is connected to a unit has a position property (12.3.4).
               NOTE12.5
               For more explanatory information on external ﬁles, see C.7.1.
           12.3.2  File existence
         1 At any given time, there is a processor-dependent set of external ﬁles that exist for a program. A ﬁle may be
           known to the processor, yet not exist for a program at a particular time.
                                                              c
           218                                               ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          2 To create a ﬁle means to cause a ﬁle to exist that did not exist previously. To delete a ﬁle means to terminate
             the existence of the ﬁle.
          3 All input/output statements may refer to ﬁles that exist. A CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN,
             PRINT,REWIND,orWRITEstatementispermittedtorefertoaﬁlethatdoesnotexist. Nootherinput/output
             statement shall refer to a ﬁle that does not exist. Execution of a WRITE, PRINT, or ENDFILE statement
             referring to a preconnected ﬁle that does not exist creates the ﬁle. This ﬁle is a diﬀerent ﬁle from one preconnected
             on any other image.
             12.3.3     File access
             12.3.3.1   File access methods
          1 There are three methods of accessing the data of an external ﬁle: sequential, direct, and stream. Some ﬁles may
             have more than one allowed access method; other ﬁles may be restricted to one access method.
                  NOTE12.6
                  For example, a processor might provide only sequential access to a ﬁle on magnetic tape. Thus, the set of
                  allowed access methods depends on the ﬁle and the processor.
          2 The method of accessing a ﬁle is determined when the ﬁle is connected to a unit (12.5.4) or when the ﬁle is
             created if the ﬁle is preconnected (12.5.5).
             12.3.3.2   Sequential access
          1 Sequential access is a method of accessing the records of an external record ﬁle in order.
          2 While connected for sequential access, an external ﬁle has the following properties.
                 • The order of the records is the order in which they were written if the direct access method is not a member
                   of the set of allowed access methods for the ﬁle. If the direct access method is also a member of the set of
                   allowed access methods for the ﬁle, the order of the records is the same as that speciﬁed for direct access.
                   In this case, the ﬁrst record accessible by sequential access is the record whose record number is 1 for direct
                   access. The second record accessible by sequential access is the record whose record number is 2 for direct
                   access, etc. A record that has not been written since the ﬁle was created shall not be read.
                 • The records of the ﬁle are either all formatted or all unformatted, except that the last record of the ﬁle may
                   be an endﬁle record. Unless the previous reference to the ﬁle was an output statement, the last record, if
                   any, of the ﬁle shall be an endﬁle record.
                 • The records of the ﬁle shall be read or written only by sequential access data transfer statements.
             12.3.3.3   Direct access
          1 Direct access is a method of accessing the records of an external record ﬁle in arbitrary order.
          2 While connected for direct access, an external ﬁle has the following properties.
                 • Each record of the ﬁle is uniquely identiﬁed by a positive integer called the record number. The record
                   number of a record is speciﬁed when the record is written. Once established, the record number of a record
                   can never be changed. The order of the records is the order of their record numbers.
                 • The records of the ﬁle are either all formatted or all unformatted. If the sequential access method is also a
                   member of the set of allowed access methods for the ﬁle, its endﬁle record, if any, is not considered to be
                   part of the ﬁle while it is connected for direct access. If the sequential access method is not a member of
                   the set of allowed access methods for the ﬁle, the ﬁle shall not contain an endﬁle record.
                 • The records of the ﬁle shall be read or written only by direct access data transfer statements.
                 • All records of the ﬁle have the same length.
              c
             ISO/IEC 2017 – All rights reserved                                                                     219
             ISO/IEC DIS 1539-1:2017 (E)
                 • Records need not be read or written in the order of their record numbers. Any record may be written
                   into the ﬁle while it is connected to a unit. For example, it is permissible to write record 3, even though
                   records 1 and 2 have not been written. Any record may be read from the ﬁle while it is connected to a
                   unit, provided that the record has been written since the ﬁle was created, and if a READ statement for this
                   connection is permitted.
                 • Therecords of the ﬁle shall not be read or written using list-directed formatting (13.10), namelist formatting
                   (13.11), or a nonadvancing data transfer statement (12.3.4.2).
                  NOTE12.7
                  Arecord cannot be deleted; however, a record can be rewritten.
             12.3.3.4   Stream access
          1 Stream access is a method of accessing the ﬁle storage units (12.3.5) of an external stream ﬁle.
          2 Thepropertiesofanexternalﬁleconnectedforstreamaccessdependonwhethertheconnectionisforunformatted
             or formatted access. While connected for stream access, the ﬁle storage units of the ﬁle shall be read or written
             only by stream access data transfer statements.
          3 While connected for unformatted stream access, an external ﬁle has the following properties.
                 • Each ﬁle storage unit in the ﬁle is uniquely identiﬁed by a positive integer called the position. The ﬁrst ﬁle
                   storage unit in the ﬁle is at position 1. The position of each subsequent ﬁle storage unit is one greater than
                   that of its preceding ﬁle storage unit.
                 • If it is possible to position the ﬁle, the ﬁle storage units need not be read or written in order of their position.
                   For example, it might be permissible to write the ﬁle storage unit at position 3, even though the ﬁle storage
                   units at positions 1 and 2 have not been written. Any ﬁle storage unit may be read from the ﬁle while it is
                   connected to a unit, provided that the ﬁle storage unit has been written since the ﬁle was created, and if a
                   READstatement for this connection is permitted.
          4 While connected for formatted stream access, an external ﬁle has the following properties.
                 • Some ﬁle storage units of the ﬁle may contain record markers; this imposes a record structure on the ﬁle
                   in addition to its stream structure. There might or might not be a record marker at the end of the ﬁle. If
                   there is no record marker at the end of the ﬁle, the ﬁnal record is incomplete.
                 • No maximum length (12.5.6.15) is applicable to these records.
                 • Writing an empty record with no record marker has no eﬀect.
                 • Each ﬁle storage unit in the ﬁle is uniquely identiﬁed by a positive integer called the position. The ﬁrst ﬁle
                   storage unit in the ﬁle is at position 1. The relationship between positions of successive ﬁle storage units is
                   processor dependent; not all positive integers need correspond to valid positions.
                 • If it is possible to position the ﬁle, the ﬁle position can be set to a position that was previously identiﬁed
                   by the POS= speciﬁer in an INQUIRE statement.
                 • A processor may prohibit some control characters (6.1.1) from appearing in a formatted stream ﬁle.
                  NOTE12.8
                  Because the record structure is determined from the record markers that are stored in the ﬁle itself, an
                  incomplete record at the end of the ﬁle is necessarily not empty.
                  NOTE12.9
                  There might be some character positions in the ﬁle that do not correspond to characters written; this is
                  because on some processors a record marker could be written to the ﬁle as a carriage-return/line-feed or
                  other sequence. The means of determining the position in a ﬁle connected for stream access is via the POS=
                  speciﬁer in an INQUIRE statement (12.10.2.22).
                                                                            c
             220                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             12.3.4     File position
             12.3.4.1   General
          1 Execution of certain input/output statements aﬀects the position of an external ﬁle. Certain circumstances can
             cause the position of a ﬁle to become indeterminate.
          2 The initial point of a ﬁle is the position just before the ﬁrst record or ﬁle storage unit. The terminal point is the
             position just after the last record or ﬁle storage unit. If there are no records or ﬁle storage units in the ﬁle, the
             initial point and the terminal point are the same position.
          3 If a record ﬁle is positioned within a record, that record is the current record; otherwise, there is no current
             record.
          4 Let n be the number of records in the ﬁle. If 1 < i ≤ n and a ﬁle is positioned within the ith record or between
             the (i − 1)th record and the ith record, the (i − 1)th record is the preceding record. If n ≥ 1 and the ﬁle is
             positioned at its terminal point, the preceding record is the nth and last record. If n = 0 or if a ﬁle is positioned
             at its initial point or within the ﬁrst record, there is no preceding record.
          5 If 1 ≤ i < n and a ﬁle is positioned within the ith record or between the ith and (i + 1)th record, the (i + 1)th
             record is the next record. If n ≥ 1 and the ﬁle is positioned at its initial point, the ﬁrst record is the next record.
             If n = 0 or if a ﬁle is positioned at its terminal point or within the nth (last) record, there is no next record.
          6 For a ﬁle connected for stream access, the ﬁle position is either between two ﬁle storage units, at the initial point
             of the ﬁle, at the terminal point of the ﬁle, or undeﬁned.
             12.3.4.2   Advancing and nonadvancing input/output
          1 An advancing input/output statement always positions a record ﬁle after the last record read or written, unless
             there is an error condition.
          2 A nonadvancing input/output statement may position a record ﬁle at a character position within the current
             record, or a subsequent record (13.8.2). Using nonadvancing input/output, it is possible to read or write a record
             of the ﬁle by a sequence of data transfer statements, each accessing a portion of the record. If a nonadvancing
             output statement leaves a ﬁle positioned within a current record and no further output statement is executed for
             the ﬁle before it is closed or a BACKSPACE, ENDFILE, or REWIND statement is executed for it, the eﬀect is
             as if the output statement were the corresponding advancing output statement.
             12.3.4.3   File position prior to data transfer
          1 The positioning of the ﬁle prior to data transfer depends on the method of access: sequential, direct, or stream.
          2 For sequential access on input, if there is a current record, the ﬁle position is not changed. Otherwise, the ﬁle is
             positioned at the beginning of the next record and this record becomes the current record. Input shall not occur
             if there is no next record or if there is a current record and the last data transfer statement accessing the ﬁle
             performed output.
          3 If the ﬁle contains an endﬁle record, the ﬁle shall not be positioned after the endﬁle record prior to data transfer.
             However, a REWIND or BACKSPACE statement may be used to reposition the ﬁle.
          4 For sequential access on output, if there is a current record, the ﬁle position is not changed and the current record
             becomes the last record of the ﬁle. Otherwise, a new record is created as the next record of the ﬁle; this new
             record becomes the last and current record of the ﬁle and the ﬁle is positioned at the beginning of this record.
          5 For direct access, the ﬁle is positioned at the beginning of the record speciﬁed by the REC= speciﬁer. This record
             becomes the current record.
          6 For stream access, the ﬁle is positioned immediately before the ﬁle storage unit speciﬁed by the POS= speciﬁer;
             if there is no POS= speciﬁer, the ﬁle position is not changed.
              c
             ISO/IEC 2017 – All rights reserved                                                                     221
             ISO/IEC DIS 1539-1:2017 (E)
          7 File positioning for child data transfer statements is described in 12.6.4.8.
             12.3.4.4   File position after data transfer
          1 If an error condition (12.11) occurred, the position of the ﬁle is indeterminate. If no error condition occurred,
             but an end-of-ﬁle condition (12.11) occurred as a result of reading an endﬁle record, the ﬁle is positioned after
             the endﬁle record.
          2 For unformatted stream input/output, if no error condition occurred, the ﬁle position is not changed. For
             unformatted stream output, if the ﬁle position exceeds the previous terminal point of the ﬁle, the terminal point
             is set to the ﬁle position.
                  NOTE12.10
                  An unformatted stream output statement with a POS= speciﬁer and an empty output list can have the
                  eﬀect of extending the terminal point of a ﬁle without actually writing any data.
          3 For formatted stream input, if an end-of-ﬁle condition occurred, the ﬁle position is not changed.
          4 For nonadvancing input, if no error condition or end-of-ﬁle condition occurred, but an end-of-record condition
             (12.11) occurred, the ﬁle is positioned after the record just read. If no error condition, end-of-ﬁle condition, or
             end-of-record condition occurred in a nonadvancing input statement, the ﬁle position is not changed. If no error
             condition occurred in a nonadvancing output statement, the ﬁle position is not changed.
          5 Inall other cases, the ﬁle is positioned after the record just read or written and that record becomes the preceding
             record.
          6 For a formatted stream output statement, if no error condition occurred, the terminal point of the ﬁle is set to
             the next position after the highest-numbered position to which a datum was transferred by the statement.
                  NOTE12.11
                  The highest-numbered position might not be the current one if the output involved a T, TL, TR, or X edit
                  descriptor (13.8.1) and the statement is a nonadvancing output statement.
             12.3.5     File storage units
          1 A ﬁle storage unit is the basic unit of storage in a stream ﬁle or an unformatted record ﬁle. It is the unit of ﬁle
             position for stream access, the unit of record length for unformatted ﬁles, and the unit of ﬁle size for all external
             ﬁles.
          2 Every value in a stream ﬁle or an unformatted record ﬁle shall occupy an integer number of ﬁle storage units; if
             the stream or record ﬁle is unformatted, this number shall be the same for all scalar values of the same type and
             type parameters. The number of ﬁle storage units required for an item of a given type and type parameters may
             be determined using the IOLENGTH= speciﬁer of the INQUIRE statement (12.10.3).
          3 Foraﬁleconnectedforunformattedstreamaccess, theprocessorshallnothavealignmentrestrictionsthatprevent
             a value of any type from being stored at any positive integer ﬁle position.
          4 The number of bits in a ﬁle storage unit is given by the constant FILE_STORAGE_SIZE (16.10.2.11) deﬁned
             in the intrinsic module ISO_FORTRAN_ENV. It is recommended that the ﬁle storage unit be an 8-bit octet
             where this choice is practical.
                  NOTE12.12
                  The requirement that every data value occupy an integer number of ﬁle storage units implies that data
                  items inherently smaller than a ﬁle storage unit will require padding. This suggests that the ﬁle storage
                  unit be small to avoid wasted space. Ideally, the ﬁle storage unit would be chosen such that padding is
                  never required. A ﬁle storage unit of one bit would always meet this goal, but would likely be impractical
                  because of the alignment requirements.
                                                                            c
             222                                                           ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
               NOTE12.12 (cont.)
               Theprohibition on alignment restrictions prohibits the processor from requiring data alignments larger than
               the ﬁle storage unit.
               The 8-bit octet is recommended as a good compromise that is small enough to accommodate the require-
               ments of many applications, yet not so small that the data alignment requirements are likely to cause
               signiﬁcant performance problems.
           12.4    Internal ﬁles
         1 Internal ﬁles provide a means of transferring and converting data from internal storage to internal storage.
         2 An internal ﬁle is a record ﬁle with the following properties.
              • The ﬁle is a variable of default, ASCII, or ISO 10646 character kind that is not an array section with a
               vector subscript.
              • A record of an internal ﬁle is a scalar character variable.
              • If the ﬁle is a scalar character variable, it consists of a single record whose length is the same as the length
               of the scalar character variable. If the ﬁle is a character array, it is treated as a sequence of character array
               elements. Each array element, if any, is a record of the ﬁle. The ordering of the records of the ﬁle is the
               same as the ordering of the array elements in the array (9.5.3.2) or the array section (9.5.3.3). Every record
               of the ﬁle has the same length, which is the length of an array element in the array.
              • A record of the internal ﬁle becomes deﬁned by writing the record. If the number of characters written in
               a record is less than the length of the record, the remaining portion of the record is ﬁlled with blanks. The
               number of characters to be written shall not exceed the length of the record.
              • A record may be read only if the record is deﬁned.
              • A record of an internal ﬁle may become deﬁned (or undeﬁned) by means other than an output statement.
               For example, the character variable may become deﬁned by a character assignment statement.
              • An internal ﬁle is always positioned at the beginning of the ﬁrst record prior to data transfer, except for
               child data transfer statements (12.6.4.8). This record becomes the current record.
              • The initial value of a connection mode (12.5.2) is the value that would be implied by an initial OPEN
               statement without the corresponding keyword.
              • Reading and writing records shall be accomplished only by sequential access formatted data transfer state-
               ments.
              • An internal ﬁle shall not be speciﬁed as the unit in a CLOSE, INQUIRE, or OPEN statement.
           12.5    File connection
           12.5.1  Referring to a ﬁle
         1 Aunit, speciﬁed by an io-unit, provides a means for referring to a ﬁle.
           R1201 io-unit                is ﬁle-unit-number
                                        or *
                                        or internal-ﬁle-variable
           R1202 ﬁle-unit-number        is scalar-int-expr
           R1203 internal-ﬁle-variable  is char-variable
           C1201 (R1203) The char-variable shall not be an array section with a vector subscript.
           C1202 (R1203) The char-variable shall be default character, ASCII character, or ISO 10646 character.
           c
           ISO/IEC 2017 – All rights reserved                                                 223
           ISO/IEC DIS 1539-1:2017 (E)
         2 A unit is either an external unit or an internal unit. An external unit is used to refer to an external ﬁle and
           is speciﬁed by an asterisk or a ﬁle-unit-number. The value of ﬁle-unit-number shall be nonnegative, equal to
           one of the named constants INPUT_UNIT, OUTPUT_UNIT, or ERROR_UNIT of the intrinsic module ISO_-
           FORTRAN_ENV (16.10.2), the unit argument of an active deﬁned input/output procedure (12.6.4.8), or a
           NEWUNITvalue (12.5.6.12). An internal unit is used to refer to an internal ﬁle and is speciﬁed by an internal-
           ﬁle-variable or a ﬁle-unit-number whose value is equal to the unit argument of an active deﬁned input/output
           procedure. The value of a ﬁle-unit-number shall identify a valid unit.
         3 On an image, the external unit identiﬁed by a particular value of a scalar-int-expr is the same external unit in
           all program units.
               NOTE12.13
               In the example:
               SUBROUTINE A
                  READ (6) X
                    ...
               SUBROUTINE B
                  N = 6
                  REWIND N
               the value 6 used in both program units identiﬁes the same external unit.
         4 In a READ statement, an io-unit that is an asterisk identiﬁes an external unit that is preconnected for sequential
           formatted input on image 1 in the initial team only (12.6.4.3). This unit is also identiﬁed by the value of
           the named constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). In a WRITE
           statement, an io-unit that is an asterisk identiﬁes an external unit that is preconnected for sequential formatted
           output. This unit is also identiﬁed by the value of the named constant OUTPUT_UNIT of the intrinsic module
           ISO_FORTRAN_ENV(16.10.2.22).
         5 This document identiﬁes a processor-dependent external unit for the purpose of error reporting. This unit shall
           be preconnected for sequential formatted output. The processor may deﬁne this to be the same as the output
           unit identiﬁed by an asterisk. This unit is also identiﬁed by a unit number deﬁned by the named constant
           ERROR_UNITofthe intrinsic module ISO_FORTRAN_ENV.
               NOTE12.14
               EventhoughOUTPUT_UNITisconnectedtoaseparateﬁleoneachimage,itisexpectedthattheprocessor
               could merge the sequences of records from these ﬁles into a single sequence of records that is sent to the
               physical device associated with this unit, such as the user’s terminal. If ERROR_UNIT is associated with
               the same physical device, the sequences of records from ﬁles connected to ERROR_UNIT on each of the
               images could be merged into the same sequence generated from the OUTPUT_UNIT ﬁles. Otherwise, it
               is expected that the sequence of records in the ﬁles connected to ERROR_UNIT on each image could be
               merged into a single sequence of records that is sent to the physical device associated with ERROR_UNIT.
           12.5.2  Connection modes
         1 Aconnection for formatted input/output has several changeable modes: these are the blank interpretation mode
           (13.8.6), delimiter mode (13.10.4, 13.11.4.2), sign mode (13.8.4), decimal edit mode (13.8.8), input/output round-
           ing mode(13.7.2.3.8), pad mode (12.6.4.5.3), and scale factor (13.8.5). A connection for unformatted input/output
           has no changeable modes.
         2 Values for the modes of a connection are established when the connection is initiated. If the connection is initiated
           by an OPEN statement, the values are as speciﬁed, either explicitly or implicitly, by the OPEN statement. If the
           connection is initiated other than by an OPEN statement (that is, if the ﬁle is an internal ﬁle or preconnected ﬁle)
           the values established are those that would be implied by an initial OPEN statement without the corresponding
           keywords.
                                                              c
           224                                               ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
         3 The scale factor cannot be explicitly speciﬁed in an OPEN statement; it is implicitly 0.
         4 The modes of a connection to an external ﬁle may be changed by a subsequent OPEN statement that modiﬁes
           the connection.
         5 The modes of a connection may be temporarily changed by a corresponding keyword speciﬁer in a data transfer
           statement or by an edit descriptor. Keyword speciﬁers take eﬀect at the beginning of execution of the data
           transfer statement. Edit descriptors take eﬀect when they are encountered in format processing. When a data
           transfer statement terminates, the values for the modes are reset to the values in eﬀect immediately before the
           data transfer statement was executed.
           12.5.3  Unit existence
         1 At any given time, there is a processor-dependent set of external units that exist for an image.
         2 All input/output statements are permitted to refer to units that exist. The CLOSE, INQUIRE, and WAIT
           statements are also permitted to refer to units that do not exist. No other input/output statement shall refer to
           a unit that does not exist.
           12.5.4  Connection of a ﬁle to a unit
         1 Anexternal unit has a property of being connected or not connected. If connected, it refers to an external ﬁle. An
           external unit may become connected by preconnection or by the execution of an OPEN statement. The property
           of connection is symmetric; the unit is connected to a ﬁle if and only if the ﬁle is connected to the unit.
         2 Every input/output statement except an OPEN, CLOSE, INQUIRE, or WAIT statement shall refer to a unit
           that is connected to a ﬁle and thereby make use of or aﬀect that ﬁle.
         3 Aﬁle may be connected and not exist (12.3.2).
               NOTE12.15
               An example is a preconnected external ﬁle that has not yet been written.
         4 A unit shall not be connected to more than one ﬁle at the same time. However, means are provided to change
           the status of an external unit and to connect a unit to a diﬀerent ﬁle. It is processor dependent whether a ﬁle
           can be connected to more than one unit at the same time.
         5 This document deﬁnes means of portable interoperation with C. C streams are described in 7.21.2 of ISO/IEC
           9899:2011. Whether a unit can be connected to a ﬁle that is also connected to a C stream is processor dependent.
           If a unit is connected to a ﬁle that is also connected to a C stream, the results of performing input/output
           operations on such a ﬁle are processor dependent. It is processor dependent whether the ﬁles connected to
           the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond to the predeﬁned C text streams
           standard input, standard output, and standard error. If a main program or procedure deﬁned by means of Fortran
           and a main program or procedure deﬁned by means other than Fortran perform input/output operations on the
           sameexternal ﬁle, the results are processor dependent. A main program or procedure deﬁned by means of Fortran
           and a main program or procedure deﬁned by means other than Fortran can perform input/output operations on
           diﬀerent external ﬁles without interference.
         6 If input/output operations are performed on more than one unit while they are connected to the same external
           ﬁle, the results are processor dependent.
         7 After an external unit has been disconnected by the execution of a CLOSE statement, it may be connected again
           within the same program to the same ﬁle or to a diﬀerent ﬁle. After an external ﬁle has been disconnected by
           the execution of a CLOSE statement, it may be connected again within the same program to the same unit or
           to a diﬀerent unit.
           c
           ISO/IEC 2017 – All rights reserved                                                 225
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE12.16
                  TheonlymeansofreferencingaﬁlethathasbeendisconnectedisbytheappearanceofitsnameinanOPEN
                  or INQUIRE statement. There might be no means of reconnecting an unnamed ﬁle once it is disconnected.
          8 An internal unit is always connected to the internal ﬁle designated by the variable that identiﬁes the unit.
                  NOTE12.17
                  For more explanatory information on ﬁle connection properties, see C.7.4.
             12.5.5     Preconnection
          1 Preconnectionmeansthattheunitisconnectedtoaﬁleatthebeginningofexecutionoftheprogramandtherefore
             it may be speciﬁed in input/output statements without the prior execution of an OPEN statement.
             12.5.6     OPEN statement
             12.5.6.1   General
          1 AnOPENstatementinitiatesormodiﬁestheconnectionbetweenanexternalﬁleandaspeciﬁedunit. TheOPEN
             statement may be used to connect an existing ﬁle to a unit, create a ﬁle that is preconnected, create a ﬁle and
             connect it to a unit, or change certain modes of a connection between a ﬁle and a unit.
          2 An external unit may be connected by an OPEN statement in the main program or any subprogram.
          3 If the ﬁle to be connected to the unit does not exist but is the same as the ﬁle to which the unit is preconnected,
             the modes speciﬁed by an OPEN statement become a part of the connection.
          4 If the ﬁle to be connected to the unit is not the same as the ﬁle to which the unit is connected, the eﬀect is as
             if a CLOSE statement without a STATUS= speciﬁer had been executed for the unit immediately prior to the
             execution of an OPEN statement.
          5 If a unit is connected to a ﬁle that exists, execution of an OPEN statement for that unit is permitted. If the
             FILE= speciﬁer is not included in such an OPEN statement, the ﬁle to be connected to the unit is the same as
             the ﬁle to which the unit is already connected.
          6 If the ﬁle to be connected to the unit is the same as the ﬁle to which the unit is connected, a new connection is not
             established and values for any changeable modes (12.5.2) speciﬁed come into eﬀect for the established connection;
             the current ﬁle position is unaﬀected. Before any eﬀect on changeable modes, a wait operation is performed for
             any pending asynchronous data transfer operations for the speciﬁed unit. If the POSITION= speciﬁer appears
             in such an OPEN statement, the value speciﬁed shall not disagree with the current position of the ﬁle. If the
             STATUS=speciﬁer is included in such an OPEN statement, it shall be speciﬁed with the value OLD. Other than
             ERR=, IOSTAT=, and IOMSG=, and the changeable modes, the values of all other speciﬁers in such an OPEN
             statement shall not diﬀer from those in eﬀect for the established connection.
          7 ASTATUS=speciﬁerwithavalueofOLDisalwaysallowedwhentheﬁletobeconnectedtotheunitis the same
             as the ﬁle to which the unit is connected. In this case, if the status of the ﬁle was SCRATCH before execution of
             the OPEN statement, the ﬁle will still be deleted when the unit is closed, and the ﬁle is still considered to have
             a status of SCRATCH.
             12.5.6.2   Syntax of the OPEN statement
             R1204 open-stmt                     is  OPEN(connect-spec-list )
             R1205 connect-spec                  is  [ UNIT = ] ﬁle-unit-number
                                                 or ACCESS = scalar-default-char-expr
                                                 or ACTION = scalar-default-char-expr
                                                                            c
             226                                                           ISO/IEC 2017 – All rights reserved
                                                                           ISO/IEC DIS 1539-1:2017 (E)
                                           or ASYNCHRONOUS=scalar-default-char-expr
                                           or BLANK=scalar-default-char-expr
                                           or DECIMAL = scalar-default-char-expr
                                           or DELIM = scalar-default-char-expr
                                           or ENCODING=scalar-default-char-expr
                                           or ERR = label
                                           or FILE = ﬁle-name-expr
                                           or FORM=scalar-default-char-expr
                                           or IOMSG = iomsg-variable
                                           or IOSTAT = stat-variable
                                           or NEWUNIT=scalar-int-variable
                                           or PAD = scalar-default-char-expr
                                           or POSITION = scalar-default-char-expr
                                           or RECL = scalar-int-expr
                                           or ROUND=scalar-default-char-expr
                                           or SIGN = scalar-default-char-expr
                                           or STATUS = scalar-default-char-expr
            R1206 ﬁle-name-expr            is  scalar-default-char-expr
            R1207 iomsg-variable           is  scalar-default-char-variable
            C1203 No speciﬁer shall appear more than once in a given connect-spec-list.
            C1204 (R1204)IftheNEWUNIT=speciﬁerdoesnotappear,aﬁle-unit-number shallbespeciﬁed; iftheoptional
                   characters UNIT= are omitted, the ﬁle-unit-number shall be the ﬁrst item in the connect-spec-list.
            C1205 (R1204) If a NEWUNIT= speciﬁer appears, a ﬁle-unit-number shall not appear.
            C1206 (R1204) The label used in the ERR= speciﬁer shall be the statement label of a branch target statement
                   that appears in the same inclusive scope as the OPEN statement.
         1 A speciﬁer that requires a scalar-default-char-expr may have a limited list of character values. These values are
            listed for each such speciﬁer. Any trailing blanks are ignored. The value speciﬁed is without regard to case. Some
            speciﬁers have a default value if the speciﬁer is omitted.
         2 The IOSTAT=, ERR=, and IOMSG= speciﬁers are described in 12.11.
                NOTE12.18
                An example of an OPEN statement is:
                OPEN (10, FILE = ’employee.names’, ACTION = ’READ’, PAD = ’YES’)
                NOTE12.19
                For more explanatory information on the OPEN statement, see C.7.3.
            12.5.6.3 ACCESS= speciﬁer in the OPEN statement
         1 The scalar-default-char-expr shall evaluate to SEQUENTIAL, DIRECT, or STREAM. The ACCESS= speciﬁer
            speciﬁes the access method for the connection of the ﬁle as being sequential, direct, or stream. If this speciﬁer is
            omitted, the default value is SEQUENTIAL. For an existing ﬁle, the speciﬁed access method shall be included in
            the set of allowed access methods for the ﬁle. For a new ﬁle, the processor creates the ﬁle with a set of allowed
            access methods that includes the speciﬁed method.
            c
            ISO/IEC 2017 – All rights reserved                                                        227
             ISO/IEC DIS 1539-1:2017 (E)
             12.5.6.4   ACTION= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to READ, WRITE, or READWRITE. READ speciﬁes that the
             WRITE, PRINT, and ENDFILE statements shall not refer to this connection. WRITE speciﬁes that READ
             statements shall not refer to this connection. READWRITE permits any input/output statements to refer to this
             connection. If this speciﬁer is omitted, the default value is processor dependent. If READWRITE is included in
             the set of allowable actions for a ﬁle, both READ and WRITE also shall be included in the set of allowed actions
             for that ﬁle. For an existing ﬁle, the speciﬁed action shall be included in the set of allowed actions for the ﬁle.
             For a new ﬁle, the processor creates the ﬁle with a set of allowed actions that includes the speciﬁed action.
             12.5.6.5   ASYNCHRONOUS=speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to YES or NO. If YES is speciﬁed, asynchronous input/output on
             the unit is allowed. If NO is speciﬁed, asynchronous input/output on the unit is not allowed. If this speciﬁer is
             omitted, the default value is NO.
             12.5.6.6   BLANK=speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= speciﬁer is permitted only for a
             connection for formatted input/output. It speciﬁes the blank interpretation mode (13.8.6, 12.6.2.6) for input for
             this connection. This mode has no eﬀect on output. It is a changeable mode (12.5.2). If this speciﬁer is omitted
             in an OPEN statement that initiates a connection, the default value is NULL.
             12.5.6.7   DECIMAL= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to COMMA or POINT. The DECIMAL= speciﬁer is permitted only
             for a connection for formatted input/output. It speciﬁes the decimal edit mode (13.6, 13.8.8, 12.6.2.7) for this
             connection. It is a changeable mode (12.5.2). If this speciﬁer is omitted in an OPEN statement that initiates a
             connection, the default value is POINT.
             12.5.6.8   DELIM= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= speciﬁer is
             permitted only for a connection for formatted input/output. It speciﬁes the delimiter mode (12.6.2.8) for list-
             directed (13.10.4) and namelist (13.11.4.2) output for the connection. This mode has no eﬀect on input. It is
             a changeable mode (12.5.2). If this speciﬁer is omitted in an OPEN statement that initiates a connection, the
             default value is NONE.
             12.5.6.9   ENCODING= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to UTF-8 or DEFAULT. The ENCODING= speciﬁer is permitted
             only for a connection for formatted input/output. The value UTF-8 speciﬁes that the encoding form of the ﬁle
             is UTF-8 as speciﬁed in ISO/IEC 10646. Such a ﬁle is called a Unicode ﬁle, and all characters therein are of ISO
             10646 character kind. The value UTF-8 shall not be speciﬁed if the processor does not support the ISO 10646
             character kind. The value DEFAULT speciﬁes that the encoding form of the ﬁle is processor dependent. If this
             speciﬁer is omitted in an OPEN statement that initiates a connection, the default value is DEFAULT.
             12.5.6.10   FILE= speciﬁer in the OPEN statement
          1 Thevalue of the FILE= speciﬁer is the name of the ﬁle to be connected to the speciﬁed unit. Any trailing blanks
             are ignored. The ﬁle-name-expr shall be a name that is allowed by the processor. The interpretation of case is
             processor dependent.
          2 This speciﬁer shall appear if the STATUS= speciﬁer has the value NEW or REPLACE. This speciﬁer shall not
             appear if the STATUS= speciﬁer has the value SCRATCH. If the STATUS= speciﬁer has the value OLD, this
             speciﬁer shall appear unless the unit is connected and the ﬁle connected to the unit exists. If this speciﬁer
                                                                            c
             228                                                           ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
             is omitted and the unit is not connected to a ﬁle, the STATUS= speciﬁer shall be speciﬁed with a value of
             SCRATCH; in this case, the connection is made to a processor-dependent ﬁle.
             12.5.6.11  FORM=speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to FORMATTED or UNFORMATTED. The FORM= speciﬁer de-
             termines whether the ﬁle is being connected for formatted or unformatted input/output. If this speciﬁer is
             omitted, the default value is UNFORMATTED if the ﬁle is being connected for direct access or stream access,
             and the default value is FORMATTED if the ﬁle is being connected for sequential access. For an existing ﬁle,
             the speciﬁed form shall be included in the set of allowed forms for the ﬁle. For a new ﬁle, the processor creates
             the ﬁle with a set of allowed forms that includes the speciﬁed form.
             12.5.6.12  NEWUNIT=speciﬁer in the OPEN statement
          1 If this speciﬁer appears in an OPEN statement, either the FILE= speciﬁer shall appear, or the STATUS= speciﬁer
             shall appear with a value of SCRATCH.
          2 The variable is deﬁned with a processor determined NEWUNIT value if no error condition occurs during the
             execution of the OPEN statement. If an error condition occurs, the processor shall not change the value of the
             variable.
          3 A NEWUNIT value is a negative number, and shall not be equal to −1, any of the named constants ER-
             ROR_UNIT, INPUT_UNIT, or OUTPUT_UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2),
             any value used by the processor for the unit argument to a deﬁned input/output procedure, nor any previous
             NEWUNITvalue that identiﬁes a ﬁle that is connected. The unit identiﬁed by a NEWUNIT value shall not be
             preconnected.
             12.5.6.13  PAD=speciﬁer in the OPEN statement
          1 Thescalar-default-char-expr shall evaluate to YES or NO. The PAD= speciﬁer is permitted only for a connection
             for formatted input/output. It speciﬁes the pad mode (12.6.4.5.3, 12.6.2.10) for input for this connection. This
             modehasnoeﬀect on output. It is a changeable mode (12.5.2). If this speciﬁer is omitted in an OPEN statement
             that initiates a connection, the default value is YES.
             12.5.6.14  POSITION= speciﬁer in the OPEN statement
          1 Thescalar-default-char-expr shall evaluate to ASIS, REWIND, or APPEND. The connection shall be for sequen-
             tial or stream access. A new ﬁle is positioned at its initial point. REWIND positions an existing ﬁle at its initial
             point. APPEND positions an existing ﬁle such that the endﬁle record is the next record, if it has one. If an
             existing ﬁle does not have an endﬁle record, APPEND positions the ﬁle at its terminal point. ASIS leaves the
             position unchanged if the ﬁle exists and already is connected. If the ﬁle exists but is not connected, the position
             resulting from ASIS is processor dependent. If this speciﬁer is omitted, the default value is ASIS.
             12.5.6.15  RECL= speciﬁer in the OPEN statement
          1 Thevalue of the RECL= speciﬁer shall be positive. It speciﬁes the length of each record in a ﬁle being connected
             for direct access, or speciﬁes the maximum length of a record in a ﬁle being connected for sequential access. This
             speciﬁer shall not appear when a ﬁle is being connected for stream access. This speciﬁer shall appear when a
             ﬁle is being connected for direct access. If this speciﬁer is omitted when a ﬁle is being connected for sequential
             access, the default value is processor dependent. If the ﬁle is being connected for formatted input/output, the
             length is the number of characters for all records that contain only characters of default kind. When a record
             contains any nondefault characters, the eﬀect of the RECL= speciﬁer is processor dependent. If the ﬁle is being
             connected for unformatted input/output, the length is measured in ﬁle storage units. For an existing ﬁle, the
             value of the RECL= speciﬁer shall be included in the set of allowed record lengths for the ﬁle. For a new ﬁle, the
             processor creates the ﬁle with a set of allowed record lengths that includes the speciﬁed value.
              c
             ISO/IEC 2017 – All rights reserved                                                                  229
             ISO/IEC DIS 1539-1:2017 (E)
             12.5.6.16  ROUND=speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PRO-
             CESSOR_DEFINED. The ROUND= speciﬁer is permitted only for a connection for formatted input/output.
             It speciﬁes the input/output rounding mode (13.7.2.3.8, 12.6.2.13) for this connection. It is a changeable mode
             (12.5.2). If this speciﬁer is omitted in an OPEN statement that initiates a connection, the input/output rounding
             mode is processor dependent; it shall be one of the above modes.
                  NOTE12.20
                  A processor is free to select any input/output rounding mode for the default mode. The mode might
                  correspond to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it might be a completely diﬀerent
                  input/output rounding mode.
             12.5.6.17  SIGN= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to one of PLUS, SUPPRESS, or PROCESSOR_DEFINED. The
             SIGN= speciﬁer is permitted only for a connection for formatted input/output. It speciﬁes the sign mode
             (13.8.4, 12.6.2.14) for this connection. It is a changeable mode (12.5.2). If this speciﬁer is omitted in an OPEN
             statement that initiates a connection, the default value is PROCESSOR_DEFINED.
             12.5.6.18  STATUS= speciﬁer in the OPEN statement
          1 The scalar-default-char-expr shall evaluate to OLD, NEW, SCRATCH, REPLACE, or UNKNOWN. If OLD is
             speciﬁed, the ﬁle shall exist. If NEW is speciﬁed, the ﬁle shall not exist.
          2 Successful execution of an OPEN statement with NEW speciﬁed creates the ﬁle and changes the status to OLD.
             If REPLACE is speciﬁed and the ﬁle does not already exist, the ﬁle is created and the status is changed to OLD.
             If REPLACE is speciﬁed and the ﬁle does exist, the ﬁle is deleted, a new ﬁle is created with the same name, and
             the status is changed to OLD. If SCRATCH is speciﬁed, the ﬁle is created and connected to the speciﬁed unit
             for use by the program but is deleted at the execution of a CLOSE statement referring to the same unit or at
             the normal termination of the program.
          3 If UNKNOWN is speciﬁed, the status is processor dependent. If this speciﬁer is omitted, the default value is
             UNKNOWN.
                  NOTE12.21
                  SCRATCHcannot be speciﬁed if the FILE= speciﬁer appears (12.5.6.10).
             12.5.7    CLOSE statement
             12.5.7.1  General
          1 The CLOSE statement is used to terminate the connection of a speciﬁed unit to an external ﬁle.
          2 Execution of a CLOSE statement for a unit may occur in any program unit of a program and need not occur in
             the same program unit as the execution of an OPEN statement referring to that unit.
          3 ExecutionofaCLOSEstatementperformsawaitoperationforanypendingasynchronousdatatransferoperations
             for the speciﬁed unit.
          4 Execution of a CLOSE statement specifying a unit that does not exist, exists but is connected to a ﬁle that does
             not exist, or has no ﬁle connected to it, is permitted and aﬀects no ﬁle or unit.
          5 After a unit has been disconnected by execution of a CLOSE statement, it may be connected again within the
             same program, either to the same ﬁle or to a diﬀerent ﬁle. After a named ﬁle has been disconnected by execution
             of a CLOSE statement, it may be connected again within the same program, either to the same unit or to a
             diﬀerent unit, provided that the ﬁle still exists.
                                                                          c
             230                                                         ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          6 During the completion step (5.3.7) of normal termination, all units that are connected are closed. Each unit is
             closed with status KEEP unless the ﬁle status prior to termination of execution was SCRATCH, in which case
             the unit is closed with status DELETE.
                  NOTE12.22
                  Theeﬀect is as though a CLOSE statement without a STATUS= speciﬁer were executed on each connected
                  unit.
             12.5.7.2   Syntax
             R1208 close-stmt                    is  CLOSE(close-spec-list )
             R1209 close-spec                    is  [ UNIT = ] ﬁle-unit-number
                                                 or IOSTAT = stat-variable
                                                 or IOMSG = iomsg-variable
                                                 or ERR = label
                                                 or STATUS = scalar-default-char-expr
             C1207 No speciﬁer shall appear more than once in a given close-spec-list.
             C1208 A ﬁle-unit-number shall be speciﬁed in a close-spec-list; if the optional characters UNIT= are omitted,
                     the ﬁle-unit-number shall be the ﬁrst item in the close-spec-list.
             C1209 (R1209) The label used in the ERR= speciﬁer shall be the statement label of a branch target statement
                     that appears in the same inclusive scope as the CLOSE statement.
          1 The scalar-default-char-expr has a limited list of character values. Any trailing blanks are ignored. The value
             speciﬁed is without regard to case.
          2 The IOSTAT=, ERR=, and IOMSG= speciﬁers are described in 12.11.
                  NOTE12.23
                  An example of a CLOSE statement is:
                  CLOSE (10, STATUS = ’KEEP’)
             12.5.7.3   STATUS= speciﬁer in the CLOSE statement
          1 The scalar-default-char-expr shall evaluate to KEEP or DELETE. The STATUS= speciﬁer determines the dis-
             position of the ﬁle that is connected to the speciﬁed unit. KEEP shall not be speciﬁed for a ﬁle whose status prior
             to execution of a CLOSE statement is SCRATCH. If KEEP is speciﬁed for a ﬁle that exists, the ﬁle continues
             to exist after the execution of a CLOSE statement. If KEEP is speciﬁed for a ﬁle that does not exist, the ﬁle
             will not exist after the execution of a CLOSE statement. If DELETE is speciﬁed, the ﬁle will not exist after the
             execution of a CLOSE statement. If this speciﬁer is omitted, the default value is KEEP, unless the ﬁle status
             prior to execution of the CLOSE statement is SCRATCH, in which case the default value is DELETE.
             12.6      Data transfer statements
             12.6.1     Form of input and output statements
          1 The READ statement is the data transfer input statement. The WRITE statement and the PRINT statement
             are the data transfer output statements.
             R1210 read-stmt                     is  READ(io-control-spec-list ) [ input-item-list ]
                                                 or READformat [ , input-item-list ]
             R1211 write-stmt                    is  WRITE(io-control-spec-list ) [ output-item-list ]
              c
             ISO/IEC 2017 – All rights reserved                                                                     231
                ISO/IEC DIS 1539-1:2017 (E)
                R1212 print-stmt                          is  PRINT format [ , output-item-list ]
                     NOTE12.24
                     Examples of data transfer statements are:
                         READ (6, *) SIZE
                         READ 10, A, B
                         WRITE (6, 10) A, S, J
                         PRINT 10, A, S, J
                     10 FORMAT (2E16.3, I5)
                12.6.2      Control information list
                12.6.2.1    Syntax
            1 Acontrol information list is an io-control-spec-list. It governs data transfer.
                R1213 io-control-spec                     is  [ UNIT = ] io-unit
                                                          or [ FMT = ] format
                                                          or [ NML = ] namelist-group-name
                                                          or ADVANCE=scalar-default-char-expr
                                                          or ASYNCHRONOUS=scalar-default-char-constant-expr
                                                          or BLANK=scalar-default-char-expr
                                                          or DECIMAL = scalar-default-char-expr
                                                          or DELIM = scalar-default-char-expr
                                                          or END=label
                                                          or EOR=label
                                                          or ERR = label
                                                          or ID = id-variable
                                                          or IOMSG = iomsg-variable
                                                          or IOSTAT = stat-variable
                                                          or PAD = scalar-default-char-expr
                                                          or POS = scalar-int-expr
                                                          or REC = scalar-int-expr
                                                          or ROUND=scalar-default-char-expr
                                                          or SIGN = scalar-default-char-expr
                                                          or SIZE = scalar-int-variable
                R1214 id-variable                         is  scalar-int-variable
                C1210 No speciﬁer shall appear more than once in a given io-control-spec-list.
                C1211 Anio-unit shall be speciﬁed in an io-control-spec-list; if the optional characters UNIT= are omitted, the
                         io-unit shall be the ﬁrst item in the io-control-spec-list.
                C1212 (R1213) A DELIM= or SIGN= speciﬁer shall not appear in a read-stmt.
                C1213 (R1213) A BLANK=, PAD=, END=, EOR=, or SIZE= speciﬁer shall not appear in a write-stmt.
                C1214 (R1213) The label in the ERR=, EOR=, or END= speciﬁer shall be the statement label of a branch
                         target statement that appears in the same inclusive scope as the data transfer statement.
                C1215 (R1213) A namelist-group-name shall be the name of a namelist group.
                C1216 (R1213) A namelist-group-name shall not appear if a REC= speciﬁer, format, input-item-list, or an
                         output-item-list appears in the data transfer statement.
                C1217 (R1213) If format appears without a preceding FMT=, it shall be the second item in the io-control-spec-
                                                                                         c
                232                                                                      ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                     list and the ﬁrst item shall be io-unit.
             C1218 (R1213) If namelist-group-name appears without a preceding NML=, it shall be the second item in the
                     io-control-spec-list and the ﬁrst item shall be io-unit.
             C1219 (R1213) If io-unit is not a ﬁle-unit-number, the io-control-spec-list shall not contain a REC= speciﬁer or
                     a POS= speciﬁer.
             C1220 (R1213) If the REC= speciﬁer appears, an END= speciﬁer shall not appear, and the format, if any, shall
                     not be an asterisk.
             C1221 (R1213) An ADVANCE= speciﬁer may appear only in a formatted sequential or stream data transfer
                     statement with explicit format speciﬁcation (13.2) whose io-control-spec-list does not contain an internal-
                     ﬁle-variable as the io-unit.
             C1222 (R1213) If an EOR= speciﬁer appears, an ADVANCE= speciﬁer also shall appear.
             C1223 (R1213) The scalar-default-char-constant-expr in an ASYNCHRONOUS= speciﬁer shall have the value
                     YES or NO.
             C1224 (R1213) An ASYNCHRONOUS= speciﬁer with a value YES shall not appear unless io-unit is a ﬁle-
                     unit-number.
             C1225 (R1213) If an ID= speciﬁer appears, an ASYNCHRONOUS= speciﬁer with the value YES shall also
                     appear.
             C1226 (R1213) If a POS= speciﬁer appears, the io-control-spec-list shall not contain a REC= speciﬁer.
             C1227 (R1213) If a DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= speciﬁer appears, a format or
                     namelist-group-name shall also appear.
             C1228 (R1213) If a DELIM= speciﬁer appears, either format shall be an asterisk or namelist-group-name shall
                     appear.
             C1229 (R1214) The scalar-int-variable shall have a decimal exponent range no smaller than that of default
                     integer.
          2 If an EOR= speciﬁer appears, an ADVANCE= speciﬁer with the value NO shall also appear.
          3 If the data transfer statement contains a format or namelist-group-name, the statement is a formatted in-
             put/output statement; otherwise, it is an unformatted input/output statement.
          4 The ADVANCE=, ASYNCHRONOUS=, DECIMAL=, BLANK=, DELIM=, PAD=, SIGN=, and ROUND=
             speciﬁers have a limited list of character values. Any trailing blanks are ignored. The values speciﬁed are without
             regard to case.
          5 The IOSTAT=, ERR=, EOR=, END=, and IOMSG= speciﬁers are described in 12.11.
                  NOTE12.25
                  An example of a READ statement is:
                  READ (IOSTAT = IOS, UNIT = 6, FMT = ’(10F8.2)’) A, B
             12.6.2.2   Format speciﬁcation in a data transfer statement
          1 The format speciﬁer supplies a format speciﬁcation or speciﬁes list-directed formatting for a formatted in-
             put/output statement.
              c
             ISO/IEC 2017 – All rights reserved                                                                     233
                ISO/IEC DIS 1539-1:2017 (E)
                R1215 format                              is  default-char-expr
                                                          or label
                                                          or *
                C1230 (R1215) The label shall be the label of a FORMAT statement that appears in the same inclusive scope
                         as the statement containing the FMT= speciﬁer.
            2 The default-char-expr shall evaluate to a valid format speciﬁcation (13.2.1 and 13.2.2).
            3 If default-char-expr is an array, it is treated as if all of the elements of the array were speciﬁed in array element
                order and were concatenated.
            4 If format is *, the statement is a list-directed input/output statement.
                     NOTE12.26
                     An example in which the format is a character expression is:
                     READ (6, FMT = "(" // CHAR_FMT // ")" )                 X, Y, Z
                     where CHAR_FMT is a default character variable.
                12.6.2.3    NML=speciﬁer in a data transfer statement
            1 The NML= speciﬁer supplies the namelist-group-name (8.9). This name identiﬁes a particular collection of data
                objects on which transfer is to be performed.
            2 If a namelist-group-name appears, the statement is a namelist input/output statement.
                12.6.2.4    ADVANCE=speciﬁer in a data transfer statement
            1 Thescalar-default-char-expr shall evaluate to YES or NO. The ADVANCE= speciﬁer determines whether advan-
                cing input/output occurs for a nonchild data transfer statement. If YES is speciﬁed for a nonchild data transfer
                statement, advancing input/output occurs. If NO is speciﬁed, nonadvancing input/output occurs (12.3.4.2). If
                this speciﬁer is omitted from a nonchild data transfer statement that allows the speciﬁer, the default value is
                YES.Aformattedchilddatatransferstatementisanonadvancinginput/outputstatement, andanyADVANCE=
                speciﬁer is ignored.
                12.6.2.5    ASYNCHRONOUS=speciﬁer in a data transfer statement
            1 TheASYNCHRONOUS=speciﬁerdetermineswhetherthisdatatransferstatement is synchronous or asynchron-
                ous. If YES is speciﬁed, the statement and the input/output operation are asynchronous. If NO is speciﬁed or if
                the speciﬁer is omitted, the statement and the input/output operation are synchronous.
            2 Asynchronous input/output is permitted only for external ﬁles opened with an ASYNCHRONOUS= speciﬁer
                with the value YES in the OPEN statement.
                     NOTE12.27
                     Bothsynchronousandasynchronousinput/outputareallowedforﬁlesopenedwithanASYNCHRONOUS=
                     speciﬁer of YES. For other ﬁles, only synchronous input/output is allowed; this includes ﬁles opened with an
                     ASYNCHRONOUS=speciﬁerofNO,ﬁlesopenedwithoutanASYNCHRONOUS=speciﬁer,preconnected
                     ﬁles accessed without an OPEN statement, and internal ﬁles.
                     The ASYNCHRONOUS= speciﬁer value in a data transfer statement is a constant expression because it
                     eﬀects compiler optimizations and, therefore, needs to be known at compile time.
            3 The processor may perform an asynchronous data transfer operation asynchronously, but it is not required to do
                so. For each external ﬁle, records and ﬁle storage units read or written by asynchronous data transfer statements
                                                                                         c
                234                                                                      ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             are read, written, and processed in the same order as they would have been if the data transfer statements were
             synchronous. The documentation of the Fortran processor should describe when input/output will be performed
             asynchronously.
          4 If a variable is used in an asynchronous data transfer statement as
                 • an item in an input/output list,
                 • a group object in a namelist, or
                 • a SIZE= speciﬁer,
             the base object of the data-ref is implicitly given the ASYNCHRONOUS attribute in the scoping unit of the data
             transfer statement. This attribute may be conﬁrmed by explicit declaration.
          5 When an asynchronous input/output statement is executed, the set of storage units speciﬁed by the item list or
             NML=speciﬁer, plus the storage units speciﬁed by the SIZE= speciﬁer, is deﬁned to be the pending input/output
             storage sequence for the data transfer operation.
                  NOTE12.28
                  Apending input/output storage sequence is not necessarily a contiguous set of storage units.
          6 Apendinginput/output storage sequence aﬀector is a variable of which any part is associated with a storage unit
             in a pending input/output storage sequence.
             12.6.2.6   BLANK=speciﬁer in a data transfer statement
          1 The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= speciﬁer temporarily changes
             (12.5.2) the blank interpretation mode (13.8.6, 12.5.6.6) for the connection. If the speciﬁer is omitted, the mode
             is not changed.
             12.6.2.7   DECIMAL= speciﬁer in a data transfer statement
          1 Thescalar-default-char-expr shallevaluatetoCOMMAorPOINT.TheDECIMAL=speciﬁertemporarilychanges
             (12.5.2) the decimal edit mode (13.6, 13.8.8, 12.5.6.7) for the connection. If the speciﬁer is omitted, the mode is
             not changed.
             12.6.2.8   DELIM= speciﬁer in a data transfer statement
          1 The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= speciﬁer tem-
             porarily changes (12.5.2) the delimiter mode (13.10.4, 13.11.4.2, 12.5.6.8) for the connection. If the speciﬁer is
             omitted, the mode is not changed.
             12.6.2.9   ID= speciﬁer in a data transfer statement
          1 Successful execution of an asynchronous data transfer statement containing an ID= speciﬁer causes the variable
             speciﬁed in the ID= speciﬁer to become deﬁned with a processor determined value. If this value is zero, the
             data transfer operation has been completed. A nonzero value is referred to as the identiﬁer of the data transfer
             operation. This identiﬁer is diﬀerent from the identiﬁer of any other pending data transfer operation for this unit.
             It can be used in a subsequent WAIT or INQUIRE statement to identify the particular data transfer operation.
          2 If an error condition occurs during the execution of a data transfer statement containing an ID= speciﬁer, the
             variable speciﬁed in the ID= speciﬁer becomes undeﬁned.
          3 Achild data transfer statement shall not specify the ID= speciﬁer.
              c
             ISO/IEC 2017 – All rights reserved                                                                     235
             ISO/IEC DIS 1539-1:2017 (E)
             12.6.2.10  PAD=speciﬁer in a data transfer statement
          1 The scalar-default-char-expr shall evaluate to YES or NO. The PAD= speciﬁer temporarily changes (12.5.2) the
             pad mode (12.6.4.5.3, 12.5.6.13) for the connection. If the speciﬁer is omitted, the mode is not changed.
             12.6.2.11  POS=speciﬁer in a data transfer statement
          1 The POS= speciﬁer speciﬁes the ﬁle position in ﬁle storage units. This speciﬁer may appear in a data transfer
             statement only if the statement speciﬁes a unit connected for stream access. A child data transfer statement shall
             not specify this speciﬁer.
          2 A processor may prohibit the use of POS= with particular ﬁles that do not have the properties necessary to
             support random positioning. A processor may also prohibit positioning a particular ﬁle to any position prior to
             its current ﬁle position if the ﬁle does not have the properties necessary to support such positioning.
                  NOTE12.29
                  Aunit that is connected to a device or data stream might not be positionable.
          3 If the ﬁle is connected for formatted stream access, the ﬁle position speciﬁed by POS= shall be equal to either 1
             (the beginning of the ﬁle) or a value previously returned by a POS= speciﬁer in an INQUIRE statement for the
             ﬁle.
             12.6.2.12  REC= speciﬁer in a data transfer statement
          1 The REC= speciﬁer speciﬁes the number of the record that is to be read or written. This speciﬁer may appear
             only in a data transfer statement that speciﬁes a unit connected for direct access; it shall not appear in a child
             data transfer statement. If the io-control-spec-list contains a REC= speciﬁer, the statement is a direct access
             data transfer statement. A child data transfer statement is a direct access data transfer statement if the parent
             is a direct access data transfer statement. Any other data transfer statement is a sequential access data transfer
             statement or a stream access data transfer statement, depending on whether the ﬁle connection is for sequential
             access or stream access.
             12.6.2.13  ROUND=speciﬁer in a data transfer statement
          1 The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE or PRO-
             CESSOR_DEFINED. The ROUND= speciﬁer temporarily changes (12.5.2) the input/output rounding mode
             (13.7.2.3.8, 12.5.6.16) for the connection. If the speciﬁer is omitted, the mode is not changed.
             12.6.2.14  SIGN= speciﬁer in a data transfer statement
          1 The scalar-default-char-expr shall evaluate to PLUS, SUPPRESS, or PROCESSOR_DEFINED. The SIGN=
             speciﬁer temporarily changes (12.5.2) the sign mode (13.8.4, 12.5.6.17) for the connection. If the speciﬁer is
             omitted, the mode is not changed.
             12.6.2.15  SIZE= speciﬁer in a data transfer statement
          1 The SIZE= speciﬁer in an input statement causes the variable speciﬁed to become deﬁned with the count of
             the characters transferred from the ﬁle by data edit descriptors during the input operation. Blanks inserted as
             padding are not counted.
          2 For a synchronous input statement, this deﬁnition occurs when execution of the statement completes. For an
             asynchronous input statement, this deﬁnition occurs when the corresponding wait operation is performed.
             12.6.3    Data transfer input/output list
          1 An input/output list speciﬁes the entities whose values are transferred by a data transfer statement.
                                                                          c
             236                                                         ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                R1216 input-item                          is  variable
                                                          or io-implied-do
                R1217 output-item                         is  expr
                                                          or io-implied-do
                R1218 io-implied-do                       is  ( io-implied-do-object-list , io-implied-do-control )
                R1219 io-implied-do-object                is  input-item
                                                          or output-item
                R1220 io-implied-do-control               is  do-variable = scalar-int-expr ,
                                                                  scalar-int-expr [ , scalar-int-expr ]
                C1231 (R1216) A variable that is an input-item shall not be a whole assumed-size array.
                C1232 (R1219) In an input-item-list, an io-implied-do-object shall be an input-item. In an output-item-list, an
                         io-implied-do-object shall be an output-item.
                C1233 (R1217) An expression that is an output-item shall not have a value that is a procedure pointer.
            2 Aninput-item shall not appear as, nor be associated with, the do-variable of any io-implied-do that contains the
                input-item.
                     NOTE12.30
                     Aconstant, an expression involving operators or function references that does not have a pointer result, or
                     an expression enclosed in parentheses shall not appear as an input list item.
            3 If an input item is a pointer, it shall be associated with a deﬁnable target and data are transferred from the ﬁle to
                the associated target. If an output item is a pointer, it shall be associated with a target and data are transferred
                from the target to the ﬁle.
                     NOTE12.31
                     Data transfers always involve the movement of values between a ﬁle and internal storage. A pointer as such
                     cannot be read or written. Therefore, a pointer shall not appear as an item in an input/output list unless
                     it is associated with a target that can receive a value (input) or can deliver a value (output).
            4 If an input item or an output item is allocatable, it shall be allocated.
            5 Alist item shall not be polymorphic unless it is processed by a deﬁned input/output procedure (12.6.4.8).
            6 The do-variable of an io-implied-do that is in another io-implied-do shall not appear as, nor be associated with,
                the do-variable of the containing io-implied-do.
            7 The following rules describing whether to expand an input/output list item are re-applied to each expanded list
                item until none of the rules apply.
                   • If an array appears as an input/output list item, it is treated as if the elements, if any, were speciﬁed in
                      array element order (9.5.3.2). However, no element of that array may aﬀect the value of any expression in
                      the input-item, nor may any element appear more than once in a given input-item.
                     NOTE12.32
                     For example:
                     INTEGER A (100), J (100)
                         ...
                     READ *, A (A)                                              ! Not allowed
                     READ *, A (LBOUND (A, 1) : UBOUND (A, 1))                  ! Allowed
                c
                ISO/IEC 2017 – All rights reserved                                                                                       237
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE12.32 (cont.)
                READ *, A (J)                              ! Allowed if no two elements
                                                           !    of J have the same value
                A(1) = 1; A(10) = 10
                READ *, A (A (1) : A (10))                 ! Not allowed
              • If a list item of derived type in an unformatted input/output statement is not processed by a deﬁned
                input/output procedure (12.6.4.8), and if any subobject of that list item would be processed by a deﬁned
                input/output procedure, the list item is treated as if all of the components of the object were speciﬁed in
                the list in component order (7.5.4.7); those components shall be accessible in the scoping unit containing
                the data transfer statement and shall not be pointers or allocatable.
              • An eﬀective item of derived type in an unformatted input/output statement is treated as a single value in a
                processor-dependent form unless the list item or a subobject thereof is processed by a deﬁned input/output
                procedure (12.6.4.8).
                NOTE12.33
                The appearance of a derived-type object as an input/output list item in an unformatted input/output
                statement is not equivalent to the list of its components.
                Unformatted input/output involving derived-type list items forms the single exception to the rule that the
                appearance of an aggregate list item (such as an array) is equivalent to the appearance of its expanded
                list of component parts. This exception permits the processor greater latitude in improving eﬃciency or
                in matching the processor-dependent sequence of values for a derived-type object to similar sequences for
                aggregate objects used by means other than Fortran. However, formatted input/output of all list items and
                unformatted input/output of list items other than those of derived types adhere to the above rule.
              • If a list item of derived type in a formatted input/output statement is not processed by a deﬁned in-
                put/output procedure, that list item is treated as if all of the components of the list item were speciﬁed
                in the list in component order; those components shall be accessible in the scoping unit containing the
                input/output statement and shall not be pointers or allocatable.
              • If a derived-type list item is not processed by a deﬁned input/output procedure and is not treated as a list
                of its individual components, all the subcomponents of that list item shall be accessible in the scoping unit
                containing the data transfer statement and shall not be pointers or allocatable.
              • For an io-implied-do, the loop initialization and execution are the same as for a DO construct (11.1.7.4).
                NOTE12.34
                An example of an output list with an implied DO is:
                WRITE (LP, FMT = ’(10F8.2)’) (LOG (A (I)), I = 1, N + 9, K), G
         8 The scalar objects resulting when a data transfer statement’s list items are expanded according to the rules in
            this subclause for handling array and derived-type list items are called eﬀective items. Zero-sized arrays and
            io-implied-dos with an iteration count of zero do not contribute to the list of eﬀective items. A scalar character
            item of zero length is an eﬀective item.
                NOTE12.35
                In a formatted input/output statement, edit descriptors are associated with eﬀective items, which are always
                scalar. The rules in 12.6.3 determine the set of eﬀective items corresponding to each actual list item in the
                statement. These rules might have to be applied repetitively until all of the eﬀective items are scalar items.
         9 Aninput/outputlist shall not contain an eﬀective item of nondefault character kind if the data transfer statement
            speciﬁes an internal ﬁle of default character kind. An input/output list shall not contain an eﬀective item that is
            nondefault character except for ISO 10646 or ASCII character if the data transfer statement speciﬁes an internal
            ﬁle of ISO 10646 character kind. An input/output list shall not contain an eﬀective item of type character of any
            kind other than ASCII if the data transfer statement speciﬁes an ASCII character internal ﬁle.
                                                                  c
            238                                                  ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             12.6.4     Execution of a data transfer input/output statement
             12.6.4.1   Data transfer sequence of operations
          1 Execution of a WRITE or PRINT statement for a unit connected to a ﬁle that does not exist creates the ﬁle
             unless an error condition occurs.
          2 Theeﬀectofexecutingasynchronousdatatransferstatementshallbeasifthefollowingoperationswereperformed
             in the order speciﬁed.
                   (1)   Determine the direction of data transfer (12.6.4.2).
                   (2)   Identify the unit (12.6.4.3).
                   (3)   Perform a wait operation for all pending input/output operations for the unit. If an error, end-of-ﬁle,
                         or end-of-record condition occurs during any of the wait operations, steps 4 through 8 are skipped.
                   (4)   Establish the format if one is speciﬁed.
                   (5)   If the statement is not a child data transfer statement (12.6.4.8),
                         (a)   position the ﬁle prior to data transfer (12.3.4.3), and
                         (b)   for formatted data transfer, set the left tab limit (13.8.1.2).
                   (6)   Transfer data between the ﬁle and the entities speciﬁed by the input/output list (if any) or namelist,
                         possibly mediated by deﬁned input/output procedures (12.6.4.8).
                   (7)   Determine whether an error, end-of-ﬁle, or end-of-record condition has occurred.
                   (8)   Position the ﬁle after data transfer (12.3.4.4) unless the statement is a child data transfer statement
                         (12.6.4.8).
                   (9)   Cause any variable speciﬁed in a SIZE= speciﬁer to become deﬁned.
                   (10)  If an error, end-of-ﬁle, or end-of-record condition occurred, processing continues as speciﬁed in 12.11;
                         otherwise, any variable speciﬁed in an IOSTAT= speciﬁer is assigned the value zero.
          3 The eﬀect of executing an asynchronous data transfer statement shall be as if the following operations were
             performed in the order speciﬁed.
                   (1)   Determine the direction of data transfer (12.6.4.2).
                   (2)   Identify the unit (12.6.4.3).
                   (3)   Optionally, perform wait operations for one or more pending input/output operations for the unit.
                         If an error, end-of-ﬁle, or end-of-record condition occurs during any of the wait operations, steps 4
                         through 9 are skipped.
                   (4)   Establish the format if one is speciﬁed.
                   (5)   Position the ﬁle prior to data transfer (12.3.4.3) and, for formatted data transfer, set the left tab
                         limit (13.8.1.2).
                   (6)   Establish the set of storage units identiﬁed by the input/output list. For an input statement, this
                         might require some or all of the data in the ﬁle to be read if an input variable is used as a scalar-
                         int-expr in an io-implied-do-control in the input/output list, as a subscript, substring-range, stride,
                         or is otherwise referenced.
                   (7)   Initiate an asynchronous data transfer between the ﬁle and the entities speciﬁed by the input/output
                         list (if any) or namelist. The asynchronous data transfer may complete (and an error, end-of-ﬁle, or
                         end-of-record condition may occur) during the execution of this data transfer statement or during a
                         later wait operation.
                   (8)   Determine whether an error, end-of-ﬁle, or end-of-record condition has occurred. The conditions
                         may occur during the execution of this data transfer statement or during the corresponding wait
                         operation, but not both.
                   (9)   Position the ﬁle as if the data transfer had ﬁnished (12.3.4.4).
                   (10)  Cause any variable speciﬁed in a SIZE= speciﬁer to become undeﬁned.
                   (11)  If an error, end-of-ﬁle, or end-of-record condition occurred, processing continues as speciﬁed in 12.11;
                         otherwise, any variable speciﬁed in an IOSTAT= speciﬁer is assigned the value zero.
              c
             ISO/IEC 2017 – All rights reserved                                                                     239
             ISO/IEC DIS 1539-1:2017 (E)
          4 For an asynchronous data transfer statement, the data transfers may occur during execution of the statement,
             during execution of the corresponding wait operation, or anywhere between. The data transfer operation is
             considered to be pending until a corresponding wait operation is performed.
          5 For asynchronous output, a pending input/output storage sequence aﬀector (12.6.2.5) shall not be redeﬁned,
             become undeﬁned, or have its pointer association status changed.
          6 Forasynchronousinput, apendinginput/outputstoragesequenceaﬀectorshallnotbereferenced, becomedeﬁned,
             become undeﬁned, become associated with a dummy argument that has the VALUE attribute, or have its pointer
             association status changed.
          7 Error, end-of-ﬁle, and end-of-record conditions in an asynchronous data transfer operation may occur during
             execution of either the data transfer statement or the corresponding wait operation. If an ID= speciﬁer does not
             appear in the initiating data transfer statement, the conditions may occur during the execution of any subsequent
             data transfer or wait operation for the same unit. When a condition occurs for a previously executed asynchronous
             data transfer statement, a wait operation is performed for all pending data transfer operations on that unit. When
             a condition occurs during a subsequent statement, any actions speciﬁed by IOSTAT=, IOMSG=, ERR=, END=,
             and EOR= speciﬁers for that statement are taken.
          8 If execution of the program is terminated during execution of an output statement, the contents of the ﬁle become
             undeﬁned.
                  NOTE12.36
                  Because end-of-ﬁle and error conditions for asynchronous data transfer statements without an ID= speciﬁer
                  can be reported by the processor during the execution of a subsequent data transfer statement, it might be
                  impossible for the user to determine which data transfer statement caused the condition. Reliably detecting
                  which input statement caused an end-of-ﬁle condition requires that all asynchronous input statements for
                  the unit include an ID= speciﬁer.
             12.6.4.2   Direction of data transfer
          1 Execution of a READ statement causes values to be transferred from a ﬁle to the entities speciﬁed by the input
             list, if any, or speciﬁed within the ﬁle itself for namelist input. Execution of a WRITE or PRINT statement
             causes values to be transferred to a ﬁle from the entities speciﬁed by the output list and format speciﬁcation, if
             any, or by the namelist-group-name for namelist output.
             12.6.4.3   Identifying a unit
          1 A data transfer statement that contains an input/output control list includes a UNIT= speciﬁer that identiﬁes
             an external or internal unit. A READ statement that does not contain an input/output control list speciﬁes a
             particular processor-dependent unit, which is the same as the unit identiﬁed by * in a READ statement that
             contains an input/output control list (12.5.1) and is the same as the unit identiﬁed by the value of the named
             constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). The PRINT statement
             speciﬁes some other processor-dependent unit, which is the same as the unit identiﬁed by * in a WRITE statement
             andis the same as the unit identiﬁed by the value of the named constant OUTPUT_UNIT of the intrinsic module
             ISO_FORTRAN_ENV(16.10.2.22). Thus, each data transfer statement identiﬁes an external or internal unit.
          2 The unit identiﬁed by an unformatted data transfer statement shall be an external unit.
          3 The unit identiﬁed by a data transfer statement shall be connected to a ﬁle when execution of the statement
             begins.
                  NOTE12.37
                  The unit could be preconnected.
                                                                            c
             240                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             12.6.4.4   Establishing a format
          1 If the input/output control list contains * as a format, list-directed formatting is established. If namelist-group-
             name appears, namelist formatting is established. If no format or namelist-group-name is speciﬁed, unformatted
             data transfer is established. Otherwise, the format speciﬁed by format is established.
          2 For output to an internal ﬁle, a format speciﬁcation that is in the ﬁle or is associated with the ﬁle shall not be
             speciﬁed.
          3 An input list item, or an entity associated with it, shall not contain any portion of an established format spe-
             ciﬁcation.
             12.6.4.5   Data transfer
             12.6.4.5.1   General
          1 Dataaretransferred between the ﬁle and the entities speciﬁed by the input/output list or namelist. The list items
             are processed in the order of the input/output list for all data transfer statements except namelist data transfer
             statements. The list items for a namelist input statement are processed in the order of the entities speciﬁed
             within the input records. The list items for a namelist output statement are processed in the order in which the
             variables are speciﬁed in the namelist-group-object-list. Eﬀective items are derived from the input/output list
             items as described in 12.6.3.
          2 All values needed to determine which entities are speciﬁed by an input/output list item are determined at the
             beginning of the processing of that item.
          3 All values are transmitted to or from the entities speciﬁed by a list item prior to the processing of any succeeding
             list item for all data transfer statements.
                  NOTE12.38
                  In the example
                  READ (N) N, X (N)
                  the old value of N identiﬁes the unit, but the new value of N is the subscript of X.
          4 All values following the name= part of the namelist entity (13.11) within the input records are transmitted to
             the matching entity speciﬁed in the namelist-group-object-list prior to processing any succeeding entity within
             the input record for namelist input statements. If an entity is speciﬁed more than once within the input record
             during a namelist input statement, the last occurrence of the entity speciﬁes the value or values to be used for
             that entity.
          5 If the input/output item is a pointer, data are transferred between the ﬁle and the associated target.
          6 If an internal ﬁle has been speciﬁed, an input/output list item shall not be in the ﬁle or associated with the ﬁle.
          7 During the execution of an output statement that speciﬁes an internal ﬁle, no part of that internal ﬁle shall be
             referenced, deﬁned, or become undeﬁned as the result of evaluating any output list item.
          8 During the execution of an input statement that speciﬁes an internal ﬁle, no part of that internal ﬁle shall be
             deﬁned or become undeﬁned as the result of transferring a value to any input list item.
          9 ADOvariablebecomesdeﬁnedanditsiterationcountestablishedatthebeginningofprocessingofthe io-implied-
             do-object-list an io-implied-do.
         10 On output, every entity whose value is to be transferred shall be deﬁned.
              c
             ISO/IEC 2017 – All rights reserved                                                                     241
             ISO/IEC DIS 1539-1:2017 (E)
             12.6.4.5.2   Unformatted data transfer
           1 If the ﬁle is not connected for unformatted input/output, unformatted data transfer is prohibited.
           2 During unformatted data transfer, data are transferred without editing between the ﬁle and the entities speciﬁed
             by the input/output list. If the ﬁle is connected for sequential or direct access, exactly one record is read or
             written.
           3 A value in the ﬁle is stored in a contiguous sequence of ﬁle storage units, beginning with the ﬁle storage unit
             immediately following the current ﬁle position.
           4 After each value is transferred, the current ﬁle position is moved to a point immediately after the last ﬁle storage
             unit of the value.
           5 On input from a ﬁle connected for sequential or direct access, the number of ﬁle storage units required by the
             input list shall be less than or equal to the number of ﬁle storage units in the record.
           6 On input, if the ﬁle storage units transferred do not contain a value with the same type and type parameters as
             the input list entity, then the resulting value of the entity is processor dependent except in the following cases.
                 • A complex entity may correspond to two real values with the same kind type parameter as the complex
                   entity.
                 • Adefaultcharacter list entity of length n may correspond to n default characters stored in the ﬁle, regardless
                   of the length parameters of the entities that were written to these storage units of the ﬁle. If the ﬁle is
                   connected for stream input, the characters may have been written by formatted stream output.
           7 On output to a ﬁle connected for unformatted direct access, the output list shall not specify more values than
             can ﬁt into the record. If the ﬁle is connected for direct access and the values speciﬁed by the output list do not
             ﬁll the record, the remainder of the record is undeﬁned.
           8 If the ﬁle is connected for unformatted sequential access, the record is created with a length suﬃcient to hold
             the values from the output list. This length shall be one of the set of allowed record lengths for the ﬁle and
             shall not exceed the value speciﬁed in the RECL= speciﬁer, if any, of the OPEN statement that established the
             connection.
             12.6.4.5.3   Formatted data transfer
           1 If the ﬁle is not connected for formatted input/output, formatted data transfer is prohibited.
           2 During formatted data transfer, data are transferred with editing between the ﬁle and the entities speciﬁed by
             the input/output list or by the namelist-group-name. Format control is initiated and editing is performed as
             described in Clause 13.
           3 The current record and possibly additional records are read or written.
           4 During advancing input when the pad mode has the value NO, the input list and format speciﬁcation shall not
             require more characters from the record than the record contains.
           5 During advancing input when the pad mode has the value YES, blank characters are supplied by the processor
             if the input list and format speciﬁcation require more characters from the record than the record contains.
           6 During nonadvancing input when the pad mode has the value NO, an end-of-record condition (12.11) occurs if
             the input list and format speciﬁcation require more characters from the record than the record contains, and the
             record is complete (12.3.3.4). If the record is incomplete, an end-of-ﬁle condition occurs instead of an end-of-record
             condition.
           7 DuringnonadvancinginputwhenthepadmodehasthevalueYES,blankcharactersaresuppliedbytheprocessor
             if an eﬀective item and its corresponding data edit descriptors require more characters from the record than the
             record contains. If the record is incomplete, an end-of-ﬁle condition occurs; otherwise, an end-of-record condition
             occurs.
                                                                             c
             242                                                            ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          8 If the ﬁle is connected for direct access, the record number is increased by one as each succeeding record is read
             or written.
          9 Onoutput, if the ﬁle is connected for direct access or is an internal ﬁle and the characters speciﬁed by the output
             list and format do not ﬁll a record, blank characters are added to ﬁll the record.
         10 On output, the output list and format speciﬁcation shall not specify more characters for a record than have been
             speciﬁed by a RECL= speciﬁer in the OPEN statement or the record length of an internal ﬁle.
             12.6.4.6   List-directed formatting
          1 If list-directed formatting has been established, editing is performed as described in 13.10.
             12.6.4.7   Namelist formatting
          1 If namelist formatting has been established, editing is performed as described in 13.11.
          2 Every allocatable namelist-group-object in the namelist group shall be allocated and every namelist-group-object
             that is a pointer shall be associated with a target. If a namelist-group-object is polymorphic or has an ultimate
             component that is allocatable or a pointer, that object shall be processed by a deﬁned input/output procedure
             (12.6.4.8).
             12.6.4.8   Deﬁned input/output
             12.6.4.8.1   General
          1 Deﬁned input/output allows a program to override the default handling of derived-type objects and values in
             data transfer statements described in 12.6.3.
          2 A deﬁned input/output procedure is a procedure accessible by a deﬁned-io-generic-spec (15.4.3.2). A particular
             deﬁned input/output procedure is selected as described in 12.6.4.8.4.
             12.6.4.8.2   Deﬁned input/output procedures
          1 For a particular derived type and a particular set of kind type parameter values, there are four possible sets of
             characteristics for deﬁned input/output procedures; one each for formatted input, formatted output, unformatted
             input, and unformatted output. The program need not supply all four procedures. The procedures are speciﬁed
             to be used for derived-type input/output by interface blocks (15.4.3.2) or by generic bindings (7.5.5), with a
             deﬁned-io-generic-spec (R1509). The deﬁned-io-generic-specs for these procedures are READ (FORMATTED),
             READ (UNFORMATTED), WRITE (FORMATTED), and WRITE (UNFORMATTED), for formatted input,
             unformatted input, formatted output, and unformatted output respectively.
          2 In the four interfaces, which specify the characteristics of deﬁned input/output procedures, the following syntax
             term is used:
             R1221 dtv-type-spec                 is  TYPE( derived-type-spec )
                                                 or CLASS( derived-type-spec )
             C1234 (R1221) If derived-type-spec speciﬁes an extensible type, the CLASS keyword shall be used; otherwise,
                     the TYPE keyword shall be used.
             C1235 (R1221) All length type parameters of derived-type-spec shall be assumed.
          3 If the deﬁned-io-generic-spec is READ (FORMATTED), the characteristics shall be the same as those speciﬁed
             by the following interface:
                     SUBROUTINE my_read_routine_formatted (dtv,                      &
                                                                 unit,               &
                                                                 iotype, v_list,     &
              c
             ISO/IEC 2017 – All rights reserved                                                                     243
            ISO/IEC DIS 1539-1:2017 (E)
                                                         iostat, iomsg)
                     ! the derived-type variable
                     dtv-type-spec, INTENT(INOUT) :: dtv
                     INTEGER, INTENT(IN) :: unit ! unit number
                     ! the edit descriptor string
                     CHARACTER (LEN=*), INTENT(IN) :: iotype
                     INTEGER, INTENT(IN) :: v_list(:)
                     INTEGER, INTENT(OUT) :: iostat
                     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                   END
         4 Ifthedeﬁned-io-generic-spec is READ (UNFORMATTED),thecharacteristicsshallbethesameasthosespeciﬁed
            by the following interface:
                   SUBROUTINE my_read_routine_unformatted (dtv,           &
                                                           unit,          &
                                                           iostat, iomsg)
                     ! the derived-type variable
                     dtv-type-spec, INTENT(INOUT) :: dtv
                     INTEGER, INTENT(IN) :: unit
                     INTEGER, INTENT(OUT) :: iostat
                     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                   END
         5 If the deﬁned-io-generic-spec is WRITE (FORMATTED), the characteristics shall be the same as those speciﬁed
            by the following interface:
                   SUBROUTINE my_write_routine_formatted (dtv,            &
                                                          unit,           &
                                                          iotype, v_list, &
                                                          iostat, iomsg)
                     ! the derived-type value/variable
                     dtv-type-spec, INTENT(IN) :: dtv
                     INTEGER, INTENT(IN) :: unit
                     ! the edit descriptor string
                     CHARACTER (LEN=*), INTENT(IN) :: iotype
                     INTEGER, INTENT(IN) :: v_list(:)
                     INTEGER, INTENT(OUT) :: iostat
                     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                   END
         6 If the deﬁned-io-generic-spec is WRITE (UNFORMATTED), the characteristics shall be the same as those
            speciﬁed by the following interface:
                   SUBROUTINE my_write_routine_unformatted (dtv,          &
                                                            unit,         &
                                                            iostat, iomsg)
                     ! the derived-type value/variable
                     dtv-type-spec, INTENT(IN) :: dtv
                     INTEGER, INTENT(IN) :: unit
                     INTEGER, INTENT(OUT) :: iostat
                     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                   END
                                                                  c
            244                                                  ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
           7 The actual speciﬁc procedure names (the my_..._routine_... procedure names above) are not signiﬁcant. In
             the discussion here and elsewhere, the dummy arguments in these interfaces are referred to by the names given
             above; the names are, however, arbitrary.
             12.6.4.8.3   Executing deﬁned input/output data transfers
           1 If a deﬁned input/output procedure is selected for an eﬀective item as speciﬁed in 12.6.4.8.4, the processor shall
             call the selected deﬁned input/output procedure for that item. The deﬁned input/output procedure controls the
             actual data transfer operations for the derived-type list item.
           2 Adatatransfer statement that includes a derived-type list item and that causes a deﬁned input/output procedure
             to be invoked is called a parent data transfer statement. A data transfer statement that is executed while a parent
             datatransfer statement is being processed and that speciﬁes the unit passed into a deﬁned input/output procedure
             is called a child data transfer statement.
                  NOTE12.39
                  A deﬁned input/output procedure will usually contain child data transfer statements that read values
                  from or write values to the current record or at the current ﬁle position. The eﬀect of executing the
                  deﬁned input/output procedure is similar to that of substituting the list items from any child data transfer
                  statements into the parent data transfer statement’s list items, along with similar substitutions in the format
                  speciﬁcation.
                  NOTE12.40
                  A particular execution of a READ, WRITE or PRINT statement can be both a parent and a child data
                  transfer statement.  A deﬁned input/output procedure can indirectly call itself or another deﬁned in-
                  put/output procedure by executing a child data transfer statement containing a list item of derived type,
                  where a matching interface is accessible for that derived type. If a deﬁned input/output procedure calls
                  itself indirectly in this manner, it cannot be declared NON_RECURSIVE.
           3 A child data transfer statement is processed diﬀerently from a nonchild data transfer statement in the following
             ways.
                 • Executing a child data transfer statement does not position the ﬁle prior to data transfer.
                 • An unformatted child data transfer statement does not position the ﬁle after data transfer is complete.
                 • Any ADVANCE= speciﬁer in a child input/output statement is ignored.
           4 Whenadeﬁnedinput/output procedure is invoked, the processor shall pass a unit argument that has a value as
             follows.
                 • If the parent data transfer statement uses a ﬁle-unit-number, the value of the unit argument shall be that
                   of the ﬁle-unit-number.
                 • If the parent data transfer statement is a WRITE statement with an asterisk unit or a PRINT statement,
                   the unit argument shall have the same value as the named constant OUTPUT_UNIT of the intrinsic
                   module ISO_FORTRAN_ENV (16.10.2).
                 • If the parent data transfer statement is a READ statement with an asterisk unit or a READ statement
                   without an io-control-spec-list, the unit argument shall have the same value as the INPUT_UNIT named
                   constant of the intrinsic module ISO_FORTRAN_ENV (16.10.2).
                 • Otherwise the parent data transfer statement accesses an internal ﬁle, in which case the unit argument
                   shall have a processor-dependent negative value.
                  NOTE12.41
                  The unit argument passed to a deﬁned input/output procedure will be negative when the parent data
                  transfer statement speciﬁed an internal unit, or speciﬁed an external unit that is a NEWUNIT value.
              c
             ISO/IEC 2017 – All rights reserved                                                                      245
         ISO/IEC DIS 1539-1:2017 (E)
            NOTE12.41 (cont.)
            Whenaninternal unit is used with the INQUIRE statement, an error condition will occur, and any variable
            speciﬁed in an IOSTAT=speciﬁer will be assigned the value IOSTAT_INQUIRE_INTERNAL_UNITfrom
            the intrinsic module ISO_FORTRAN_ENV (16.10.2).
       5 For formatted data transfer, the processor shall pass an iotype argument that has the value
           • “LISTDIRECTED” if the parent data transfer statement speciﬁed list directed formatting,
           • “NAMELIST” if the parent data transfer statement speciﬁed namelist formatting, or
           • “DT”concatenatedwiththechar-literal-constant, ifany, oftheDTeditdescriptorintheformatspeciﬁcation
            of the parent data transfer statement.
       6 If the parent data transfer statement is an input statement, the dtv dummy argument is argument associated
         with the eﬀective item that caused the deﬁned input procedure to be invoked, as if the eﬀective item were an
         actual argument in this procedure reference (5.4.5).
       7 If the parent data transfer statement is an output statement, the processor shall provide the value of the eﬀective
         item in the dtv dummy argument.
       8 If the v-list of the edit descriptor appears in the parent data transfer statement, the processor shall provide the
         values from it in the v_list dummy argument, with the same number of elements in the same order as v-list.
         If there is no v-list in the edit descriptor or if the data transfer statement speciﬁes list-directed or namelist
         formatting, the processor shall provide v_list as a zero-sized array.
            NOTE12.42
            The user’s procedure might choose to interpret an element of the v_list argument as a ﬁeld width, but
            this is not required. If it does, it would be appropriate to ﬁll an output ﬁeld with “*”s if the width is too
            small.
       9 The iostat argument is used to report whether an error, end-of-record, or end-of-ﬁle condition (12.11) occurs.
         If an error condition occurs, the deﬁned input/output procedure shall assign a positive value to the iostat
         argument. Otherwise, if an end-of-ﬁle condition occurs, the deﬁned input procedure shall assign the value of the
         named constant IOSTAT_END (16.10.2.16) to the iostat argument. Otherwise, if an end-of-record condition
         occurs, the deﬁned input procedure shall assign the value of the named constant IOSTAT_EOR (16.10.2.17) to
         iostat. Otherwise, the deﬁned input/output procedure shall assign the value zero to the iostat argument.
      10 If the deﬁned input/output procedure returns a nonzero value for the iostat argument, the procedure shall also
         return an explanatory message in the iomsg argument. Otherwise, the procedure shall not change the value of
         the iomsg argument.
            NOTE12.43
            The values of the iostat and iomsg arguments set in a deﬁned input/output procedure need not be passed
            to all of the parent data transfer statements.
      11 If the iostat argument of the deﬁned input/output procedure has a nonzero value when that procedure returns,
         and the processor therefore terminates execution of the program as described in 12.11, the processor shall make
         the value of the iomsg argument available in a processor-dependent manner.
      12 While a parent READ statement is active, an input/output statement shall not read from any external unit other
         than the one speciﬁed by the unit dummy argument and shall not perform output to any external unit.
      13 While a parent WRITE or PRINT statement is active, an input/output statement shall not perform output to
         any external unit other than the one speciﬁed by the unit dummy argument and shall not read from any external
         unit.
                                                  c
         246                                     ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
      14 While a parent data transfer statement is active, a data transfer statement that speciﬁes an internal ﬁle is
         permitted.
      15 OPEN, CLOSE, BACKSPACE, ENDFILE, and REWIND statements shall not be executed while a parent data
         transfer statement is active.
      16 A deﬁned input/output procedure may use a format speciﬁcation with a DT edit descriptor for handling a
         component of the derived type that is itself of a derived type. A child data transfer statement that is a list
         directed or namelist input/output statement may contain a list item of derived type.
      17 Because a child data transfer statement does not position the ﬁle prior to data transfer, the child data transfer
         statement starts transferring data from where the ﬁle was positioned by the parent data transfer statement’s
         most recently processed eﬀective item or edit descriptor. This is not necessarily at the beginning of a record.
      18 The edit descriptors T and TL used on unit by a child data transfer statement shall not cause the ﬁle to be
         positioned before the ﬁle position at the time the deﬁned input/output procedure was invoked.
            NOTE12.44
            A deﬁned input/output procedure could use INQUIRE to determine the settings of BLANK=, PAD=,
            ROUND=, DECIMAL=, and DELIM= for an external unit. The INQUIRE statement provides values as
            speciﬁed in 12.10.
      19 Neither a parent nor child data transfer statement shall be asynchronous.
      20 A deﬁned input/output procedure, and any procedures invoked therefrom, shall not deﬁne, nor cause to become
         undeﬁned, any storage unit referenced by any input/output list item, the corresponding format, or any speciﬁer
         in any active parent data transfer statement, except through the dtv argument.
            NOTE12.45
            Adatatransfer statement with an ID=, POS=, or REC= speciﬁer cannot be a child data transfer statement
            in a standard-conforming program.
            NOTE12.46
            Asimple example of derived type formatted output follows. The derived type variable chairman has two
            components. The type and an associated write formatted procedure are deﬁned in a module so as to be
            accessible from wherever they might be needed. It would also be possible to check that iotype indeed has
            the value ’DT’ and to set iostat and iomsg accordingly.
            MODULE p
             TYPE :: person
               CHARACTER (LEN=20) :: name
               INTEGER :: age
             CONTAINS
               PROCEDURE,PRIVATE :: pwf
               GENERIC       :: WRITE(FORMATTED) => pwf
             END TYPE person
            CONTAINS
             SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
            ! argument definitions
               CLASS(person), INTENT(IN) :: dtv
               INTEGER, INTENT(IN) :: unit
               CHARACTER (LEN=*), INTENT(IN) :: iotype
         c
         ISO/IEC 2017 – All rights reserved                                 247
            ISO/IEC DIS 1539-1:2017 (E)
                NOTE12.46 (cont.)
                    INTEGER, INTENT(IN) :: vlist(:)
                    INTEGER, INTENT(OUT) :: iostat
                    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                ! local variable
                    CHARACTER (LEN=9) :: pfmt
                !   vlist(1) and (2) are to be used as the field widths of the two
                !   components of the derived type variable.  First set up the format to
                !   be used for output.
                    WRITE(pfmt,’(A,I2,A,I2,A)’ ) ’(A’,  vlist(1), ’,I’,  vlist(2),  ’)’
                !   now the basic output statement
                    WRITE(unit, FMT=pfmt, IOSTAT=iostat) dtv%name, dtv%age
                  END SUBROUTINE pwf
                END MODULE p
                PROGRAM committee
                  USE p
                  INTEGER id, members
                  TYPE (person) :: chairman
                  ...
                  WRITE(6, FMT="(I2, DT (15,6), I5)" ) id, chairman, members
                ! this writes a record with four fields, with lengths 2, 15, 6, 5
                ! respectively
                END PROGRAM
                NOTE12.47
                In the following example, the variables of the derived type node form a linked list, with a single value at
                each node. The subroutine pwf is used to write the values in the list, one per line.
                MODULE p
                  TYPE node
                    INTEGER :: value = 0
                    TYPE (NODE), POINTER :: next_node => NULL ( )
                  CONTAINS
                    PROCEDURE,PRIVATE :: pwf
                    GENERIC           :: WRITE(FORMATTED) => pwf
                  END TYPE node
                CONTAINS
                  SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
                ! Write the chain of values, each on a separate line in I9 format.
                    CLASS(node), INTENT(IN) :: dtv
                    INTEGER, INTENT(IN) :: unit
                    CHARACTER (LEN=*), INTENT(IN) :: iotype
                    INTEGER, INTENT(IN) :: vlist(:)
                    INTEGER, INTENT(OUT) :: iostat
                    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
                                                                  c
            248                                                  ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                  NOTE12.47 (cont.)
                       WRITE(unit,’(i9 /)’, IOSTAT = iostat) dtv%value
                       IF(iostat/=0) RETURN
                       IF(ASSOCIATED(dtv%next_node)) WRITE(unit,’(dt)’, IOSTAT=iostat) dtv%next_node
                     END SUBROUTINE pwf
                  END MODULE p
             12.6.4.8.4   Resolving deﬁned input/output procedure references
           1 Asuitable generic interface for deﬁned input/output of an eﬀective item is one that has a deﬁned-io-generic-spec
             that is appropriate to the direction (read or write) and form (formatted or unformatted) of the data transfer
             as speciﬁed in 12.6.4.8.2, and has a speciﬁc interface whose dtv argument is compatible with the eﬀective item
             according to the rules for argument association in 15.5.2.4.
           2 Whenaneﬀectiveitem(12.6.3) that is of derived type is encountered during a data transfer, deﬁned input/output
             occurs if both of the following conditions are true.
                   (1)   The circumstances of the input/output are such that deﬁned input/output is permitted; that is,
                         either
                         (a)    the transfer was initiated by a list-directed, namelist, or unformatted input/output statement,
                                or
                         (b)    a format speciﬁcation is supplied for the data transfer statement, and the edit descriptor
                                corresponding to the eﬀective item is a DT edit descriptor.
                   (2)   Asuitable deﬁned input/output procedure is available; that is, either
                         (a)    the declared type of the eﬀective item has a suitable generic type-bound procedure, or
                         (b)    a suitable generic interface is accessible.
           3 If (2a) is true, the procedure referenced is determined as for explicit type-bound procedure references (15.5); that
             is, the binding with the appropriate speciﬁc interface is located in the declared type of the eﬀective item, and the
             corresponding binding in the dynamic type of the eﬀective item is selected.
           4 If (2a) is false and (2b) is true, the reference is to the procedure identiﬁed by the appropriate speciﬁc interface
             in the interface block.
             12.6.5     Termination of data transfer statements
           1 Termination of a data transfer statement occurs when
                 • format processing encounters a colon or data edit descriptor and there are no remaining elements in the
                   input-item-list or output-item-list,
                 • unformatted or list-directed data transfer exhausts the input-item-list or output-item-list,
                 • namelist output exhausts the namelist-group-object-list,
                 • an error condition occurs,
                 • an end-of-ﬁle condition occurs,
                 • a slash (/) is encountered as a value separator (13.10, 13.11) in the record being read during list-directed
                   or namelist input, or
                 • an end-of-record condition occurs during execution of a nonadvancing input statement (12.11).
              c
             ISO/IEC 2017 – All rights reserved                                                                      249
             ISO/IEC DIS 1539-1:2017 (E)
             12.7      Waiting on pending data transfer
             12.7.1     Wait operation
           1 Execution of an asynchronous data transfer statement in which neither an error, end-of-record, nor end-of-ﬁle
             condition occurs initiates a pending data transfer operation.   There may be multiple pending data transfer
             operations for the same or multiple units simultaneously. A pending data transfer operation remains pending
             until a corresponding wait operation is performed. A wait operation may be performed by a BACKSPACE,
             CLOSE, ENDFILE, FLUSH, INQUIRE, PRINT, READ, REWIND, WAIT, or WRITE statement.
           2 A wait operation completes the processing of a pending data transfer operation. Each wait operation completes
             only a single data transfer operation, although a single statement may perform multiple wait operations.
           3 If the actual data transfer is not yet complete, the wait operation ﬁrst waits for its completion. If the data
             transfer operation is an input operation that completed without error, the storage units of the input/output
             storage sequence then become deﬁned with the values as described in 12.6.2.15 and 12.6.4.5.
           4 If any error, end-of-ﬁle, or end-of-record conditions occur, the applicable actions speciﬁed by the IOSTAT=,
             IOMSG=, ERR=, END=, and EOR= speciﬁers of the statement that performs the wait operation are taken.
           5 If an error or end-of-ﬁle condition occurs during a wait operation for a unit, the processor performs a wait
             operation for all pending data transfer operations for that unit.
                  NOTE12.48
                  Error, end-of-ﬁle, and end-of-record conditions can be raised either during the data transfer statement that
                  initiates asynchronous input/output, a subsequent asynchronous data transfer statement for the same unit,
                  or during the wait operation. If such conditions are raised during a data transfer statement, they trigger
                  actions according to the IOSTAT=, ERR=, END=, and EOR= speciﬁers of that statement; if they are
                  raised during the wait operation, the actions are in accordance with the speciﬁers of the statement that
                  performs the wait operation.
           6 After completion of the wait operation, the data transfer operation and its input/output storage sequence are no
             longer considered to be pending.
             12.7.2     WAIT statement
           1 AWAITstatement performs a wait operation for speciﬁed pending asynchronous data transfer operations.
             R1222 wait-stmt                      is  WAIT(wait-spec-list)
             R1223 wait-spec                      is  [ UNIT = ] ﬁle-unit-number
                                                  or END=label
                                                  or EOR=label
                                                  or ERR = label
                                                  or ID = scalar-int-expr
                                                  or IOMSG = iomsg-variable
                                                  or IOSTAT = stat-variable
             C1236 No speciﬁer shall appear more than once in a given wait-spec-list.
             C1237 A ﬁle-unit-number shall be speciﬁed in a wait-spec-list; if the optional characters UNIT= are omitted,
                     the ﬁle-unit-number shall be the ﬁrst item in the wait-spec-list.
             C1238 (R1223) The label in the ERR=, EOR=, or END= speciﬁer shall be the statement label of a branch
                     target statement that appears in the same inclusive scope as the WAIT statement.
           2 The IOSTAT=, ERR=, EOR=, END=, and IOMSG= speciﬁers are described in 12.11.
                                                                             c
             250                                                            ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
         3 The value of the expression speciﬁed in the ID= speciﬁer shall be zero or the identiﬁer of a pending data transfer
           operation for the speciﬁed unit. If the ID= speciﬁer appears, a wait operation for the speciﬁed data transfer
           operation, if any, is performed. If the ID= speciﬁer is omitted, wait operations for all pending data transfers for
           the speciﬁed unit are performed.
         4 Execution of a WAIT statement specifying a unit that does not exist, has no ﬁle connected to it, or is not open
           for asynchronous input/output is permitted, provided that the WAIT statement has no ID= speciﬁer; such a
           WAITstatement does not cause an error or end-of-ﬁle condition to occur.
               NOTE12.49
               An EOR= speciﬁer has no eﬀect if the pending data transfer operation is not a nonadvancing read. An
               END=speciﬁer has no eﬀect if the pending data transfer operation is not a READ.
           12.8    File positioning statements
           12.8.1  Syntax
           R1224 backspace-stmt         is BACKSPACEﬁle-unit-number
                                        or BACKSPACE(position-spec-list )
           R1225 endﬁle-stmt            is ENDFILE ﬁle-unit-number
                                        or ENDFILE ( position-spec-list )
           R1226 rewind-stmt            is REWINDﬁle-unit-number
                                        or REWIND(position-spec-list )
         1 A unit that is connected for direct access shall not be referred to by a BACKSPACE, ENDFILE, or REWIND
           statement. A unit that is connected for unformatted stream access shall not be referred to by a BACKSPACE
           statement. A unit that is connected with an ACTION= speciﬁer having the value READ shall not be referred
           to by an ENDFILE statement.
           R1227 position-spec          is [ UNIT = ] ﬁle-unit-number
                                        or IOMSG = iomsg-variable
                                        or IOSTAT = stat-variable
                                        or ERR = label
           C1239 No speciﬁer shall appear more than once in a given position-spec-list.
           C1240 Aﬁle-unit-number shall be speciﬁed in a position-spec-list; if the optional characters UNIT= are omitted,
                 the ﬁle-unit-number shall be the ﬁrst item in the position-spec-list.
           C1241 (R1227) The label in the ERR= speciﬁer shall be the statement label of a branch target statement that
                 appears in the same inclusive scope as the ﬁle positioning statement.
         2 The IOSTAT=, ERR=, and IOMSG= speciﬁers are described in 12.11.
         3 Execution of a ﬁle positioning statement performs a wait operation for all pending asynchronous data transfer
           operations for the speciﬁed unit.
           12.8.2  BACKSPACE statement
         1 Execution of a BACKSPACE statement causes the ﬁle connected to the speciﬁed unit to be positioned before
           the current record if there is a current record, or before the preceding record if there is no current record. If the
           ﬁle is at its initial point, the position of the ﬁle is not changed.
           c
           ISO/IEC 2017 – All rights reserved                                                 251
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE12.50
               If the preceding record is an endﬁle record, the ﬁle is positioned before the endﬁle record.
         2 If a BACKSPACE statement causes the implicit writing of an endﬁle record, the ﬁle is positioned before the
           record that precedes the endﬁle record.
         3 Backspacing a ﬁle that is connected but does not exist is prohibited.
         4 Backspacing over records written using list-directed or namelist formatting is prohibited.
               NOTE12.51
               An example of a BACKSPACE statement is:
               BACKSPACE (10, IOSTAT = N)
           12.8.3  ENDFILE statement
         1 Execution of an ENDFILE statement for a ﬁle connected for sequential access writes an endﬁle record as the next
           record of the ﬁle. The ﬁle is then positioned after the endﬁle record, which becomes the last record of the ﬁle.
           If the ﬁle also may be connected for direct access, only those records before the endﬁle record are considered to
           have been written. Thus, only those records may be read during subsequent direct access connections to the ﬁle.
         2 After execution of an ENDFILE statement for a ﬁle connected for sequential access, a BACKSPACE or REWIND
           statement shall be used to reposition the ﬁle prior to execution of any data transfer input/output statement or
           ENDFILE statement.
         3 Execution of an ENDFILE statement for a ﬁle connected for stream access causes the terminal point of the ﬁle
           to become equal to the current ﬁle position. Only ﬁle storage units before the current position are considered
           to have been written; thus only those ﬁle storage units may be subsequently read. Subsequent stream output
           statements may be used to write further data to the ﬁle.
         4 Execution of an ENDFILE statement for a ﬁle that is connected but does not exist creates the ﬁle; if the ﬁle is
           connected for sequential access, it is created prior to writing the endﬁle record.
               NOTE12.52
               An example of an ENDFILE statement is:
               ENDFILE K
           12.8.4  REWIND statement
         1 Execution of a REWIND statement causes the speciﬁed ﬁle to be positioned at its initial point.
               NOTE12.53
               If the ﬁle is already positioned at its initial point, execution of this statement has no eﬀect on the position
               of the ﬁle.
         2 Execution of a REWIND statement for a ﬁle that is connected but does not exist is permitted and has no eﬀect
           on any ﬁle.
               NOTE12.54
               An example of a REWIND statement is:
               REWIND 10
                                                              c
           252                                               ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                12.9       FLUSH statement
                R1228 ﬂush-stmt                           is  FLUSH ﬁle-unit-number
                                                          or FLUSH ( ﬂush-spec-list )
                R1229 ﬂush-spec                           is  [UNIT =] ﬁle-unit-number
                                                          or IOSTAT = stat-variable
                                                          or IOMSG = iomsg-variable
                                                          or ERR = label
                C1242 No speciﬁer shall appear more than once in a given ﬂush-spec-list.
                C1243 A ﬁle-unit-number shall be speciﬁed in a ﬂush-spec-list; if the optional characters UNIT= are omitted
                         from the unit speciﬁer, the ﬁle-unit-number shall be the ﬁrst item in the ﬂush-spec-list.
                C1244 (R1229) The label in the ERR= speciﬁer shall be the statement label of a branch target statement that
                         appears in the same inclusive scope as the FLUSH statement.
            1 The IOSTAT=, IOMSG= and ERR= speciﬁers are described in 12.11.
            2 Execution of a FLUSH statement causes data written to an external ﬁle to be available to other processes, or
                causes data placed in an external ﬁle by means other than Fortran to be available to a READ statement. These
                actions are processor dependent.
            3 Execution of a FLUSH statement for a ﬁle that is connected but does not exist is permitted and has no eﬀect on
                any ﬁle. A FLUSH statement has no eﬀect on ﬁle position.
            4 Execution of a FLUSH statement performs a wait operation for all pending asynchronous data transfer operations
                for the speciﬁed unit.
                     NOTE12.55
                     Because this document does not specify the mechanism of ﬁle storage, the exact meaning of the ﬂush
                     operation is not precisely deﬁned. It is expected that the ﬂush operation will make all data written to a ﬁle
                     available to other processes or devices, or make data recently added to a ﬁle by other processes or devices
                     available to the program via a subsequent read operation. This is commonly called “ﬂushing input/output
                     buﬀers”.
                     NOTE12.56
                     An example of a FLUSH statement is:
                     FLUSH (10, IOSTAT = N)
                12.10        File inquiry statement
                12.10.1      Forms of the INQUIRE statement
            1 The INQUIRE statement can be used to inquire about properties of a particular named ﬁle, of the connection
                to a particular unit, or the number of ﬁle storage units required for an output list. There are three forms of the
                INQUIRE statement: inquire by ﬁle, which uses the FILE= speciﬁer, inquire by unit, which uses the UNIT=
                speciﬁer, and inquire by output list, which uses only the IOLENGTH= speciﬁer. Assignments to speciﬁer variables
                are converted, truncated, or padded according to the rules of intrinsic assignment.
            2 For inquiry by unit, the unit speciﬁed need not exist or be connected to a ﬁle. If it is connected to a ﬁle, the
                inquiry is being made about the connection and about the ﬁle connected.
            3 For inquiry by ﬁle, the ﬁle speciﬁed need not exist or be connected to a unit. If it is connected to a unit, the
                inquiry is being made about the connection as well as about the ﬁle.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       253
            ISO/IEC DIS 1539-1:2017 (E)
          4 AnINQUIREstatement may be executed before, while, or after a ﬁle is connected to a unit. All values assigned
            by an INQUIRE statement are those that are current at the time the statement is executed.
            R1230 inquire-stmt                is INQUIRE ( inquire-spec-list )
                                              or INQUIRE ( IOLENGTH = scalar-int-variable )
                                                    output-item-list
                 NOTE12.57
                 Examples of INQUIRE statements are:
                        INQUIRE (IOLENGTH = IOL) A (1:N)
                        INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
                                  FORM = CHAR_VAR, IOSTAT = IOS)
            12.10.2    Inquiry speciﬁers
            12.10.2.1  Syntax
          1 Unless constrained, the following inquiry speciﬁers may be used in either of the inquire by ﬁle or inquire by unit
            forms of the INQUIRE statement.
            R1231 inquire-spec                is [ UNIT = ] ﬁle-unit-number
                                              or FILE = ﬁle-name-expr
                                              or ACCESS = scalar-default-char-variable
                                              or ACTION = scalar-default-char-variable
                                              or ASYNCHRONOUS=scalar-default-char-variable
                                              or BLANK=scalar-default-char-variable
                                              or DECIMAL = scalar-default-char-variable
                                              or DELIM = scalar-default-char-variable
                                              or DIRECT = scalar-default-char-variable
                                              or ENCODING=scalar-default-char-variable
                                              or ERR = label
                                              or EXIST = scalar-logical-variable
                                              or FORM=scalar-default-char-variable
                                              or FORMATTED=scalar-default-char-variable
                                              or ID = scalar-int-expr
                                              or IOMSG = iomsg-variable
                                              or IOSTAT = stat-variable
                                              or NAME=scalar-default-char-variable
                                              or NAMED=scalar-logical-variable
                                              or NEXTREC=scalar-int-variable
                                              or NUMBER=scalar-int-variable
                                              or OPENED=scalar-logical-variable
                                              or PAD = scalar-default-char-variable
                                              or PENDING = scalar-logical-variable
                                              or POS = scalar-int-variable
                                              or POSITION = scalar-default-char-variable
                                              or READ=scalar-default-char-variable
                                              or READWRITE=scalar-default-char-variable
                                              or RECL = scalar-int-variable
                                              or ROUND=scalar-default-char-variable
                                              or SEQUENTIAL = scalar-default-char-variable
                                              or SIGN = scalar-default-char-variable
                                              or SIZE = scalar-int-variable
                                              or STREAM=scalar-default-char-variable
                                              or UNFORMATTED=scalar-default-char-variable
                                              or WRITE=scalar-default-char-variable
                                                                      c
            254                                                       ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
             C1245 No speciﬁer shall appear more than once in a given inquire-spec-list.
             C1246 An inquire-spec-list shall contain one FILE= speciﬁer or one ﬁle-unit-number, but not both.
             C1247 In the inquire by unit form of the INQUIRE statement, if the optional characters UNIT= are omitted,
                     the ﬁle-unit-number shall be the ﬁrst item in the inquire-spec-list.
             C1248 If an ID= speciﬁer appears in an inquire-spec-list, a PENDING= speciﬁer shall also appear.
             C1249 (R1229) The label in the ERR= speciﬁer shall be the statement label of a branch target statement that
                     appears in the same inclusive scope as the INQUIRE statement.
          2 If ﬁle-unit-number identiﬁes an internal unit (12.6.4.8.2), an error condition occurs.
          3 When a returned value of a speciﬁer other than the NAME= speciﬁer is of type character, the value returned is
             in upper case.
          4 If an error condition occurs during execution of an INQUIRE statement, all of the inquiry speciﬁer variables
             become undeﬁned, except for variables in the IOSTAT= and IOMSG= speciﬁers (if any).
          5 The IOSTAT=, ERR=, and IOMSG= speciﬁers are described in 12.11.
             12.10.2.2  FILE= speciﬁer in the INQUIRE statement
          1 The value of the ﬁle-name-expr in the FILE= speciﬁer speciﬁes the name of the ﬁle being inquired about. The
             named ﬁle need not exist or be connected to a unit. The value of the ﬁle-name-expr shall be of a form acceptable
             to the processor as a ﬁle name. Any trailing blanks are ignored. The interpretation of case is processor dependent.
             12.10.2.3  ACCESS= speciﬁer in the INQUIRE statement
          1 Thescalar-default-char-variable in the ACCESS= speciﬁer is assigned the value SEQUENTIAL if the connection
             is for sequential access, DIRECT if the connection is for direct access, or STREAM if the connection is for stream
             access. If there is no connection, it is assigned the value UNDEFINED.
             12.10.2.4  ACTION= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the ACTION= speciﬁer is assigned the value READ if the connection is for
             input only, WRITE if the connection is for output only, and READWRITE if the connection is for both input
             and output. If there is no connection, the scalar-default-char-variable is assigned the value UNDEFINED.
             12.10.2.5  ASYNCHRONOUS=speciﬁer in the INQUIRE statement
          1 Thescalar-default-char-variable in the ASYNCHRONOUS= speciﬁer is assigned the value YES if the connection
             allows asynchronous input/output; it is assigned the value NO if the connection does not allow asynchronous
             input/output. If there is no connection, the scalar-default-char-variable is assigned the value UNDEFINED.
             12.10.2.6  BLANK=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the BLANK= speciﬁer is assigned the value ZERO or NULL, corresponding
             to the blank interpretation mode in eﬀect for a connection for formatted input/output. If there is no connection,
             or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the value
             UNDEFINED.
             12.10.2.7  DECIMAL= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the DECIMAL= speciﬁer is assigned the value COMMA or POINT, corres-
             ponding to the decimal edit mode in eﬀect for a connection for formatted input/output. If there is no connection,
             or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the value
             UNDEFINED.
              c
             ISO/IEC 2017 – All rights reserved                                                                  255
             ISO/IEC DIS 1539-1:2017 (E)
             12.10.2.8  DELIM= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the DELIM= speciﬁer is assigned the value APOSTROPHE, QUOTE, or
             NONE,corresponding to the delimiter mode in eﬀect for a connection for formatted input/output. If there is no
             connection or if the connection is not for formatted input/output, the scalar-default-char-variable is assigned the
             value UNDEFINED.
             12.10.2.9  DIRECT= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the DIRECT= speciﬁer is assigned the value YES if DIRECT is included in
             the set of allowed access methods for the ﬁle, NO if DIRECT is not included in the set of allowed access methods
             for the ﬁle, and UNKNOWN if the processor is unable to determine whether DIRECT is included in the set of
             allowed access methods for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.2.10   ENCODING= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the ENCODING= speciﬁer is assigned the value UTF-8 if the connection is
             for formatted input/output with an encoding form of UTF-8, and is assigned the value UNDEFINED if the
             connection is for unformatted input/output. If there is no connection, it is assigned the value UTF-8 if the
             processor is able to determine that the encoding form of the ﬁle is UTF-8; if the processor is unable to determine
             the encoding form of the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle, the variable is
             assigned the value UNKNOWN.
                  NOTE12.58
                  The value assigned could be something other than UTF-8, UNDEFINED, or UNKNOWN if the processor
                  supports other speciﬁc encoding forms (e.g. UTF-16BE).
             12.10.2.11   EXIST= speciﬁer in the INQUIRE statement
          1 Execution of an INQUIRE by ﬁle statement causes the scalar-logical-variable in the EXIST= speciﬁer to be
             assigned the value true if there exists a ﬁle with the speciﬁed name; otherwise, false is assigned. Execution of an
             INQUIRE by unit statement causes true to be assigned if the speciﬁed unit exists; otherwise, false is assigned.
             12.10.2.12   FORM=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the FORM= speciﬁer is assigned the value FORMATTED if the connection
             is for formatted input/output, and is assigned the value UNFORMATTED if the connection is for unformatted
             input/output. If there is no connection, it is assigned the value UNDEFINED.
             12.10.2.13   FORMATTED=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the FORMATTED= speciﬁer is assigned the value YES if FORMATTED is
             included in the set of allowed forms for the ﬁle, NO if FORMATTED is not included in the set of allowed forms
             for the ﬁle, and UNKNOWN if the processor is unable to determine whether FORMATTED is included in the
             set of allowed forms for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.2.14   ID= speciﬁer in the INQUIRE statement
          1 ThevalueoftheexpressionspeciﬁedintheID=speciﬁershallbetheidentiﬁerofapendingdatatransferoperation
             for the speciﬁed unit. This speciﬁer interacts with the PENDING= speciﬁer (12.10.2.21).
             12.10.2.15   NAME=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the NAME= speciﬁer is assigned the value of the name of the ﬁle if the ﬁle
             has a name; otherwise, it becomes undeﬁned. The value assigned shall be suitable for use as the value of the
             ﬁle-name-expr in the FILE= speciﬁer in an OPEN statement.
                                                                          c
             256                                                         ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
                 NOTE12.59
                 If this speciﬁer appears in an INQUIRE by ﬁle statement, its value is not necessarily the same as the name
                 given in the FILE= speciﬁer.
                 The processor could assign a ﬁle name qualiﬁed by a user identiﬁcation, device, directory, or other relevant
                 information.
          2 The case of the characters assigned to scalar-default-char-variable is processor dependent.
             12.10.2.16  NAMED=speciﬁer in the INQUIRE statement
          1 The scalar-logical-variable in the NAMED= speciﬁer is assigned the value true if the ﬁle has a name; otherwise,
             it is assigned the value false.
             12.10.2.17  NEXTREC= speciﬁer in the INQUIRE statement
          1 The scalar-int-variable in the NEXTREC= speciﬁer is assigned the value n+1, where n is the record number of
             the last record read from or written to the connection for direct access. If there is a connection but no records have
             been read or written since the connection, the scalar-int-variable is assigned the value 1. If there is no connection,
             the connection is not for direct access, or the position is indeterminate because of a previous error condition, the
             scalar-int-variable becomes undeﬁned. If there are pending data transfer operations for the speciﬁed unit, the
             value assigned is computed as if all the pending data transfers had already completed.
             12.10.2.18  NUMBER=speciﬁer in the INQUIRE statement
          1 Execution of an INQUIRE by ﬁle statement causes the scalar-int-variable in the NUMBER= speciﬁer to be
             assigned the value of the external unit number of the unit that is connected to the ﬁle. If more than one unit
             on an image is connected to the ﬁle, which of the connected external unit numbers is assigned to the scalar-int-
             variable is processor dependent. If there is no unit connected to the ﬁle, the value −1 is assigned. Execution of
             an INQUIRE by unit statement causes the scalar-int-variable to be assigned the value of ﬁle-unit-number.
             12.10.2.19  OPENED=speciﬁer in the INQUIRE statement
          1 Execution of an INQUIRE by ﬁle statement causes the scalar-logical-variable in the OPENED= speciﬁer to be
             assigned the value true if the ﬁle speciﬁed is connected to a unit; otherwise, false is assigned. Execution of an
             INQUIRE by unit statement causes the scalar-logical-variable to be assigned the value true if the speciﬁed unit
             is connected to a ﬁle; otherwise, false is assigned.
             12.10.2.20  PAD=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the PAD= speciﬁer is assigned the value YES or NO, corresponding to the
             pad mode in eﬀect for a connection for formatted input/output. If there is no connection or if the connection is
             not for formatted input/output, the scalar-default-char-variable is assigned the value UNDEFINED.
             12.10.2.21  PENDING= speciﬁer in the INQUIRE statement
          1 The PENDING= speciﬁer is used to determine whether previously pending asynchronous data transfers are
             complete. A data transfer operation is previously pending if it is pending at the beginning of execution of the
             INQUIRE statement.
          2 If an ID= speciﬁer appears and the speciﬁed data transfer operation is complete, then the variable speciﬁed in
             the PENDING= speciﬁer is assigned the value false and the INQUIRE statement performs the wait operation
             for the speciﬁed data transfer.
          3 If the ID= speciﬁer is omitted and all previously pending data transfer operations for the speciﬁed unit are
             complete, then the variable speciﬁed in the PENDING= speciﬁer is assigned the value false and the INQUIRE
             statement performs wait operations for all previously pending data transfers for the speciﬁed unit.
             c
             ISO/IEC 2017 – All rights reserved                                                                257
             ISO/IEC DIS 1539-1:2017 (E)
          4 In all other cases, the variable speciﬁed in the PENDING= speciﬁer is assigned the value true, no wait operations
             are performed, and the previously pending data transfers remain pending after the execution of the INQUIRE
             statement.
                 NOTE12.60
                 The processor has considerable ﬂexibility in deﬁning when it considers a transfer to be complete. Any of
                 the following approaches could be used:
                    • The INQUIRE statement could consider an asynchronous data transfer to be incomplete until after
                       the corresponding wait operation. In this case PENDING= would always return true unless there
                       were no previously pending data transfers for the unit.
                    • TheINQUIREstatementcouldwaitforallspeciﬁeddatatransferstocompleteandthenalwaysreturn
                       false for PENDING=.
                    • The INQUIRE statement could actually test the state of the speciﬁed data transfer operations.
             12.10.2.22  POS=speciﬁer in the INQUIRE statement
          1 Thescalar-int-variable in the POS= speciﬁer is assigned the number of the ﬁle storage unit immediately following
             the current position of a ﬁle connected for stream access. If the ﬁle is positioned at its terminal position, the
             variable is assigned a value one greater than the number of the highest-numbered ﬁle storage unit in the ﬁle.
             If there are pending data transfer operations for the speciﬁed unit, the value assigned is computed as if all the
             pending data transfers had already completed. If there is no connection, the ﬁle is not connected for stream
             access, or if the position of the ﬁle is indeterminate because of previous error conditions, the variable becomes
             undeﬁned.
             12.10.2.23  POSITION= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the POSITION= speciﬁer is assigned the value REWIND if the connection
             was opened for positioning at its initial point, APPEND if the connection was opened for positioning before its
             endﬁle record or at its terminal point, and ASIS if the connection was opened without changing its position.
             If there is no connection or if the ﬁle is connected for direct access, the scalar-default-char-variable is assigned
             the value UNDEFINED. If the ﬁle has been repositioned since the connection, the scalar-default-char-variable
             is assigned a processor-dependent value, which shall not be REWIND unless the ﬁle is positioned at its initial
             point and shall not be APPEND unless the ﬁle is positioned so that its endﬁle record is the next record or at its
             terminal point if it has no endﬁle record.
             12.10.2.24  READ=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the READ= speciﬁer is assigned the value YES if READ is included in the
             set of allowed actions for the ﬁle, NO if READ is not included in the set of allowed actions for the ﬁle, and
             UNKNOWNifthe processor is unable to determine whether READ is included in the set of allowed actions for
             the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.2.25  READWRITE= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the READWRITE= speciﬁer is assigned the value YES if READWRITE is
             included in the set of allowed actions for the ﬁle, NO if READWRITE is not included in the set of allowed actions
             for the ﬁle, and UNKNOWN if the processor is unable to determine whether READWRITE is included in the
             set of allowed actions for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.2.26  RECL= speciﬁer in the INQUIRE statement
          1 Thescalar-int-variable in the RECL= speciﬁer is assigned the value of the record length of a connection for direct
             access, or the value of the maximum record length of a connection for sequential access. If the connection is for
             formatted input/output, the length is the number of characters for all records that contain only characters of
                                                                         c
             258                                                        ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
             default kind. If the connection is for unformatted input/output, the length is measured in ﬁle storage units. If
             there is no connection, the scalar-int-variable is assigned the value −1, and if the connection is for stream access,
             the scalar-int-variable is assigned the value −2.
             12.10.2.27  ROUND=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the ROUND= speciﬁer is assigned the value UP, DOWN, ZERO, NEAREST,
             COMPATIBLE, or PROCESSOR_DEFINED, corresponding to the input/output rounding mode in eﬀect for
             a connection for formatted input/output. If there is no connection or if the connection is not for formatted
             input/output, the scalar-default-char-variable is assigned the value UNDEFINED. The processor shall return the
             value PROCESSOR_DEFINED only if the behavior of the input/output rounding mode is diﬀerent from that
             of the UP, DOWN, ZERO, NEAREST, and COMPATIBLE modes.
             12.10.2.28  SEQUENTIAL= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the SEQUENTIAL= speciﬁer is assigned the value YES if SEQUENTIAL is
             included in the set of allowed access methods for the ﬁle, NO if SEQUENTIAL is not included in the set of allowed
             access methods for the ﬁle, and UNKNOWN if the processor is unable to determine whether SEQUENTIAL is
             included in the set of allowed access methods for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not
             connected to a ﬁle.
             12.10.2.29  SIGN= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the SIGN= speciﬁer is assigned the value PLUS, SUPPRESS, or PRO-
             CESSOR_DEFINED, corresponding to the sign mode in eﬀect for a connection for formatted input/output.
             If there is no connection, or if the connection is not for formatted input/output, the scalar-default-char-variable
             is assigned the value UNDEFINED.
             12.10.2.30  SIZE= speciﬁer in the INQUIRE statement
          1 The scalar-int-variable in the SIZE= speciﬁer is assigned the size of the ﬁle in ﬁle storage units. If the ﬁle size
             cannot be determined or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle, the variable is assigned
             the value −1.
          2 For a ﬁle that may be connected for stream access, the ﬁle size is the number of the highest-numbered ﬁle storage
             unit in the ﬁle.
          3 For a ﬁle that may be connected for sequential or direct access, the ﬁle size may be diﬀerent from the number of
             storage units implied by the data in the records; the exact relationship is processor dependent.
          4 If there are pending data transfer operations for the speciﬁed unit, the value assigned is computed as if all the
             pending data transfers had already completed.
             12.10.2.31  STREAM=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the STREAM= speciﬁer is assigned the value YES if STREAM is included in
             the set of allowed access methods for the ﬁle, NO if STREAM is not included in the set of allowed access methods
             for the ﬁle, and UNKNOWN if the processor is unable to determine whether STREAM is included in the set of
             allowed access methods for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.2.32  UNFORMATTED=speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the UNFORMATTED= speciﬁer is assigned the value YES if UNFORMAT-
             TED is included in the set of allowed forms for the ﬁle, NO if UNFORMATTED is not included in the set of
             allowed forms for the ﬁle, and UNKNOWN if the processor is unable to determine whether UNFORMATTED is
             included in the set of allowed forms for the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a
             ﬁle.
             c
             ISO/IEC 2017 – All rights reserved                                                                259
             ISO/IEC DIS 1539-1:2017 (E)
             12.10.2.33  WRITE= speciﬁer in the INQUIRE statement
          1 The scalar-default-char-variable in the WRITE= speciﬁer is assigned the value YES if WRITE is included in the
             set of allowed actions for the ﬁle, NO if WRITE is not included in the set of allowed actions for the ﬁle, and
             UNKNOWNiftheprocessor is unable to determine whether WRITE is included in the set of allowed actions for
             the ﬁle or if the unit identiﬁed by ﬁle-unit-number is not connected to a ﬁle.
             12.10.3    Inquire by output list
          1 The scalar-int-variable in the IOLENGTH= speciﬁer is assigned the processor-dependent number of ﬁle storage
             units that would be required to store the data of the output list in an unformatted ﬁle. The value shall be suitable
             as a RECL= speciﬁer in an OPEN statement that connects a ﬁle for unformatted direct access if data will be
             read from or written to the ﬁle using data transfer statements with an input/output list that speciﬁes transfer of
             a sequence of objects having the same types, type parameters, and extents, in the same order as the output list
             in the INQUIRE statement.
          2 The output list in an INQUIRE statement shall not contain any derived-type list items that require a deﬁned
             input/output procedure as described in subclause 12.6.3. If a derived-type list item appears in the output list, the
             value returned for the IOLENGTH= speciﬁer assumes that no deﬁned input/output procedure will be invoked.
             12.11      Error, end-of-record, and end-of-ﬁle conditions
             12.11.1    Occurrence of input/output conditions
          1 The set of input/output error conditions is processor dependent. Except as otherwise speciﬁed, when an error
             condition occurs or is detected is processor dependent.
          2 Anend-of-recordconditionoccurswhenanonadvancinginputstatementattemptstotransferdatafromaposition
             beyond the end of the current record, unless the ﬁle is a stream ﬁle and the current record is at the end of the
             ﬁle (an end-of-ﬁle condition occurs instead).
          3 An end-of-ﬁle condition occurs when
                • an endﬁle record is encountered during the reading of a ﬁle connected for sequential access,
                • an attempt is made to read a record beyond the end of an internal ﬁle, or
                • an attempt is made to read beyond the end of a stream ﬁle.
          4 An end-of-ﬁle condition may occur at the beginning of execution of an input statement. An end-of-ﬁle condition
             also may occur during execution of a formatted input statement when more than one record is required by the
             interaction of the input list and the format. An end-of-ﬁle condition also may occur during execution of a stream
             input statement.
             12.11.2    Error conditions and the ERR= speciﬁer
          1 If an error condition occurs during execution of an input/output statement, the position of the ﬁle becomes
             indeterminate.
          2 If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor
             IOSTAT=speciﬁer,errorterminationisinitiated. Ifanerrorconditionoccursduringexecutionofaninput/output
             statement that contains either an ERR= speciﬁer or an IOSTAT= speciﬁer then:
                  (1)   processing of the input/output list, if any, terminates;
                  (2)   if the statement is a data transfer statement or the error condition occurs during a wait operation,
                        all do-variables in the statement that initiated the transfer become undeﬁned;
                  (3)   if an IOSTAT= speciﬁer appears, the stat-variable in the IOSTAT= speciﬁer becomes deﬁned as
                        speciﬁed in 12.11.5;
                                                                         c
             260                                                        ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                     (4)   if an IOMSG= speciﬁer appears, the iomsg-variable becomes deﬁned as speciﬁed in 12.11.6;
                     (5)   if the statement is a READ statement and it contains a SIZE= speciﬁer, the scalar-int-variable in
                           the SIZE= speciﬁer becomes deﬁned as speciﬁed in 12.6.2.15;
                     (6)   if the statement is a READ statement or the error condition occurs in a wait operation for a transfer
                           initiated by a READ statement, all input items or namelist group objects in the statement that
                           initiated the transfer become undeﬁned;
                     (7)   if an ERR= speciﬁer appears, a branch to the statement labeled by the label in the ERR= speciﬁer
                           occurs.
              12.11.3      End-of-ﬁle condition and the END= speciﬁer
           1 If an end-of-ﬁle condition occurs during execution of an input/output statement that contains neither an END=
              speciﬁer nor an IOSTAT= speciﬁer, error termination is initiated. If an end-of-ﬁle condition occurs during
              execution of an input/output statement that contains either an END= speciﬁer or an IOSTAT= speciﬁer, and
              an error condition does not occur then:
                     (1)   processing of the input list, if any, terminates;
                     (2)   if the statement is a data transfer statement or the end-of-ﬁle condition occurs during a wait operation,
                           all do-variables in the statement that initiated the transfer become undeﬁned;
                     (3)   if the statement is an input statement or the end-of-ﬁle condition occurs during a wait operation
                           for a transfer initiated by an input statement, all input list items or namelist group objects in the
                           statement that initiated the transfer become undeﬁned;
                     (4)   if the ﬁle speciﬁed in the input statement is an external record ﬁle, it is positioned after the endﬁle
                           record;
                     (5)   if an IOSTAT= speciﬁer appears, the stat-variable in the IOSTAT= speciﬁer becomes deﬁned as
                           speciﬁed in 12.11.5;
                     (6)   if an IOMSG= speciﬁer appears, the iomsg-variable becomes deﬁned as speciﬁed in 12.11.6;
                     (7)   if an END= speciﬁer appears, a branch to the statement labeled by the label in the END= speciﬁer
                           occurs.
              12.11.4      End-of-record condition and the EOR= speciﬁer
           1 If an end-of-record condition occurs during execution of an input/output statement that contains neither an
              EOR= speciﬁer nor an IOSTAT= speciﬁer, error termination is initiated. If an end-of-record condition occurs
              during execution of an input/output statement that contains either an EOR= speciﬁer or an IOSTAT= speciﬁer,
              and an error condition does not occur then:
                     (1)   if the pad mode has the value
                           (a)   YES,therecord is padded with blanks to satisfy the eﬀective item (12.6.4.5.3) and correspond-
                                 ing data edit descriptors that require more characters than the record contains,
                           (b)   NO, the input list item becomes undeﬁned;
                     (2)   processing of the input list, if any, terminates;
                     (3)   if the statement is a data transfer statement or the end-of-record condition occurs during a wait
                           operation, all do-variables in the statement that initiated the transfer become undeﬁned;
                     (4)   the ﬁle speciﬁed in the input statement is positioned after the current record;
                     (5)   if an IOSTAT= speciﬁer appears, the stat-variable in the IOSTAT= speciﬁer becomes deﬁned as
                           speciﬁed in 12.11.5;
                     (6)   if an IOMSG= speciﬁer appears, the iomsg-variable becomes deﬁned as speciﬁed in 12.11.6;
                     (7)   if a SIZE= speciﬁer appears, the scalar-int-variable in the SIZE= speciﬁer becomes deﬁned as spe-
                           ciﬁed in (12.6.2.15);
                     (8)   if an EOR= speciﬁer appears, a branch to the statement labeled by the label in the EOR= speciﬁer
                           occurs.
               c
              ISO/IEC 2017 – All rights reserved                                                                            261
           ISO/IEC DIS 1539-1:2017 (E)
           12.11.5  IOSTAT= speciﬁer
        1 Execution of an input/output statement containing the IOSTAT= speciﬁer causes the stat-variable in the IO-
           STAT=speciﬁer to become deﬁned with
             • a zero value if neither an error condition, an end-of-ﬁle condition, nor an end-of-record condition occurs,
             • the processor-dependent positive integer value of the constant IOSTAT_INQUIRE_INTERNAL_UNIT
               from the intrinsic module ISO_FORTRAN_ENV (16.10.2) if a unit number in an INQUIRE statement
               identiﬁes an internal ﬁle,
             • a processor-dependent positive integer value diﬀerent from IOSTAT_INQUIRE_INTERNAL_UNIT if any
               other error condition occurs,
             • theprocessor-dependentnegativeintegervalueoftheconstantIOSTAT_END(16.10.2.16)fromtheintrinsic
               module ISO_FORTRAN_ENV if an end-of-ﬁle condition occurs and no error condition occurs,
             • theprocessor-dependentnegativeintegervalueoftheconstantIOSTAT_EOR(16.10.2.17)fromtheintrinsic
               module ISO_FORTRAN_ENV if an end-of-record condition occurs and no error condition or end-of-ﬁle
               condition occurs, or
             • a processor-dependent negative integer value diﬀerent from IOSTAT_EOR and IOSTAT_END, if the IO-
               STAT=speciﬁer appears in a FLUSH statement and the processor does not support the ﬂush operation for
               the speciﬁed unit.
              NOTE12.61
              An end-of-ﬁle condition can occur only for sequential or stream input and an end-of-record condition can
              occur only for nonadvancing input.
              For example,
              READ (FMT = "(E8.3)", UNIT = 3, IOSTAT = IOSS) X
              IF (IOSS < 0) THEN
                 ! Perform end-of-file processing on the file connected to unit 3.
                 CALL END_PROCESSING
              ELSE IF (IOSS > 0) THEN
                 ! Perform error processing
                 CALL ERROR_PROCESSING
              END IF
           12.11.6  IOMSG= speciﬁer
        1 If an error, end-of-ﬁle, or end-of-record condition occurs during execution of an input/output statement, iomsg-
           variable is assigned an explanatory message, truncated or padded according to the rules of intrinsic assignment.
           If no such condition occurs, the deﬁnition status and value of iomsg-variable are unchanged.
           12.12    Restrictions on input/output statements
        1 If a unit, or a ﬁle connected to a unit, does not have all of the properties required for the execution of certain
           input/output statements, those statements shall not refer to the unit.
        2 Aninput/outputstatementthatisexecutedwhileanotherinput/outputstatementisbeingexecutedisarecursive
           input/output statement. A recursive input/output statement shall not identify an external unit that is identiﬁed
           by another input/output statement being executed except that a child data transfer statement may identify its
           parent data transfer statement external unit.
        3 An input/output statement shall not cause the value of any established format speciﬁcation to be modiﬁed.
        4 Arecursiveinput/outputstatementshall not modify the value of any internal unit except that a recursive WRITE
           statement may modify the internal unit identiﬁed by that recursive WRITE statement.
                                                            c
           262                                              ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
       5 Thevalueofaspeciﬁer in an input/output statement shall not depend on the deﬁnition or evaluation of any other
         speciﬁer in the io-control-spec-list or inquire-spec-list in that statement. The value of an internal-ﬁle-variable or
         of a FMT=, ID=, IOMSG=, IOSTAT=, or SIZE= speciﬁer shall not depend on the value of any input-item or
         io-implied-do do-variable in the same statement.
       6 The value of any subscript or substring bound of a variable that appears in a speciﬁer in an input/output
         statement shall not depend on any input-item, io-implied-do do-variable, or on the deﬁnition or evaluation of any
         other speciﬁer in the io-control-spec-list or inquire-spec-list in that statement.
       7 In a data transfer statement, the variable speciﬁed in an IOSTAT=, IOMSG=, or SIZE= speciﬁer, if any, shall
         not be associated with any entity in the data transfer input/output list (12.6.3) or namelist-group-object-list, nor
         with a do-variable of an io-implied-do in the data transfer input/output list.
       8 In a data transfer statement, if a variable speciﬁed in an IOSTAT=, IOMSG=, or SIZE= speciﬁer is an array
         element reference, its subscript values shall not be aﬀected by the data transfer, the io-implied-do processing, or
         the deﬁnition or evaluation of any other speciﬁer in the io-control-spec-list.
       9 A variable that may become deﬁned or undeﬁned as a result of its use in a speciﬁer in an INQUIRE statement,
         or any associated entity, shall not appear in another speciﬁer in the same INQUIRE statement.
            NOTE12.62
            Restrictions on the evaluation of expressions (10.1.4) prohibit certain side eﬀects.
         c
         ISO/IEC 2017 – All rights reserved                                 263
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      264                          ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           13 Input/output editing
           13.1    Format speciﬁcations
         1 Aformatusedinconjunctionwithadatatransferstatementprovidesinformation that directs the editing between
           the internal representation of data and the characters of a sequence of formatted records.
         2 Aformat (12.6.2.2) in a data transfer statement may refer to a FORMAT statement or to a character expression
           that contains a format speciﬁcation. A format speciﬁcation provides explicit editing information. The format
           alternatively may be an asterisk (*), which indicates list-directed formatting (13.10). Namelist formatting (13.11)
           may be indicated by specifying a namelist-group-name instead of a format.
           13.2    Explicit format speciﬁcation methods
           13.2.1  FORMATstatement
           R1301 format-stmt            is FORMATformat-speciﬁcation
           R1302 format-speciﬁcation    is ( [ format-items ] )
                                        or ( [ format-items, ] unlimited-format-item )
           C1301 (R1301) The format-stmt shall be labeled.
         1 Blank characters may precede the initial left parenthesis of the format speciﬁcation. Additional blank characters
           may appear at any point within the format speciﬁcation, with no eﬀect on the interpretation of the format
           speciﬁcation, except within a character string edit descriptor (13.9).
               NOTE13.1
               Examples of FORMAT statements are:
               5    FORMAT (1PE12.4, I10)
               9    FORMAT (I12, /, ’ Dates: ’, 2 (2I3, I5))
           13.2.2  Character format speciﬁcation
         1 A character expression used as a format in a formatted input/output statement shall evaluate to a character
           string whose leading part is a valid format speciﬁcation.
               NOTE13.2
               The format speciﬁcation begins with a left parenthesis and ends with a right parenthesis.
         2 All character positions up to and including the ﬁnal right parenthesis of the format speciﬁcation shall be deﬁned
           at the time the data transfer statement is executed, and shall not become redeﬁned or undeﬁned during the
           execution of the statement. Character positions, if any, following the right parenthesis that ends the format
           speciﬁcation need not be deﬁned and may contain any character data with no eﬀect on the interpretation of the
           format speciﬁcation.
         3 If the format is a character array, it is treated as if all of the elements of the array were speciﬁed in array element
           order and were concatenated. However, if a format is a character array element, the format speciﬁcation shall be
           entirely within that array element.
           c
           ISO/IEC 2017 – All rights reserved                                                 265
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE13.3
               If a character constant is used as a format in data transfer statement, care shall be taken that the value
               of the character constant is a valid format speciﬁcation. In particular, if a format speciﬁcation delimited
               by apostrophes contains a character constant edit descriptor delimited with apostrophes, two apostrophes
               shall be written to delimit the edit descriptor and four apostrophes shall be written for each apostrophe
               that occurs within the edit descriptor. For example, the text:
                2 ISN’T 3
               can be written by various combinations of output statements and format speciﬁcations:
                   WRITE (6, 100) 2, 3
               100 FORMAT (1X, I1, 1X, ’ISN’’T’, 1X, I1)
                   WRITE (6, ’(1X, I1, 1X, ’’ISN’’’’T’’, 1X, I1)’) 2, 3
                   WRITE (6, ’(A)’) ’ 2 ISN’’T 3’
               Doubling of internal apostrophes usually can be avoided by using quotation marks to delimit the format
               speciﬁcation and doubling of internal quotation marks usually can be avoided by using apostrophes as
               delimiters.
           13.3    Form of a format item list
           13.3.1  Syntax
           R1303 format-items           is format-item [ [ , ] format-item ] ...
           R1304 format-item            is [ r ] data-edit-desc
                                        or control-edit-desc
                                        or char-string-edit-desc
                                        or [ r ] ( format-items )
           R1305 unlimited-format-item  is * ( format-items )
           R1306 r                      is int-literal-constant
           C1302 (R1303) The optional comma shall not be omitted except
                   • between a P edit descriptor and an immediately following F, E, EN, ES, D, or G edit descriptor
                     (13.8.5), possibly preceded by a repeat speciﬁcation,
                   • before a slash edit descriptor when the optional repeat speciﬁcation does not appear (13.8.2),
                   • after a slash edit descriptor, or
                   • before or after a colon edit descriptor (13.8.3)
           C1303 (R1305) An unlimited-format-item shall contain at least one data edit descriptor.
           C1304 (R1306) r shall be positive.
           C1305 (R1306) A kind parameter shall not be speciﬁed for r.
         1 The integer literal constant r is called a repeat speciﬁcation.
           13.3.2  Edit descriptors
         1 Aneditdescriptorisadataeditdescriptor(data-edit-desc), control edit descriptor (control-edit-desc), or character
           string edit descriptor (char-string-edit-desc).
                                                              c
           266                                               ISO/IEC 2017 – All rights reserved
                                                                                ISO/IEC DIS 1539-1:2017 (E)
             R1307 data-edit-desc              is I w [ . m ]
                                               or B w [ . m ]
                                               or O w [ . m ]
                                               or Z w [ . m ]
                                               or F w . d
                                               or E w . d [ E e ]
                                               or EN w . d [ E e ]
                                               or ES w . d [ E e ]
                                               or EX w . d [ E e ]
                                               or G w [ . d [ E e ] ]
                                               or L w
                                               or A [ w ]
                                               or D w . d
                                               or DT [ char-literal-constant ] [ ( v-list ) ]
             R1308 w                           is int-literal-constant
             R1309 m                           is int-literal-constant
             R1310 d                           is int-literal-constant
             R1311 e                           is int-literal-constant
             R1312 v                           is signed-int-literal-constant
             C1306 (R1308) w shall be zero or positive for the I, B, O, Z, D, E, EN, ES, EX, F, and G edit descriptors. w
                    shall be positive for all other edit descriptors.
             C1307 (R1307) For the G edit descriptor, d shall be speciﬁed if w is not zero.
             C1308 (R1307) For the G edit descriptor, e shall not be speciﬁed if w is zero.
             C1309 (R1307) A kind parameter shall not be speciﬁed for the char-literal-constant in the DT edit descriptor,
                    or for w, m, d, e, and v.
          2 An I, B, O, Z, F, E, EN, ES, EX, G, L, A, D, or DT edit descriptor indicates the manner of editing.
             R1313 control-edit-desc           is position-edit-desc
                                               or [ r ] /
                                               or :
                                               or sign-edit-desc
                                               or k P
                                               or blank-interp-edit-desc
                                               or round-edit-desc
                                               or decimal-edit-desc
             R1314 k                           is signed-int-literal-constant
             C1310 (R1314) A kind parameter shall not be speciﬁed for k.
          3 In k P, k is called the scale factor.
             R1315 position-edit-desc          is Tn
                                               or TL n
                                               or TR n
                                               or n X
             R1316 n                           is int-literal-constant
             C1311 (R1316) n shall be positive.
             c
             ISO/IEC 2017 – All rights reserved                                                               267
             ISO/IEC DIS 1539-1:2017 (E)
             C1312 (R1316) A kind parameter shall not be speciﬁed for n.
             R1317 sign-edit-desc              is  SS
                                               or SP
                                               or S
             R1318 blank-interp-edit-desc      is  BN
                                               or BZ
             R1319 round-edit-desc             is  RU
                                               or RD
                                               or RZ
                                               or RN
                                               or RC
                                               or RP
             R1320 decimal-edit-desc           is  DC
                                               or DP
          4 A T, TL, TR, X, slash, colon, SS, SP, S, P, BN, BZ, RU, RD, RZ, RN, RC, RP, DC, or DP edit descriptor
             indicates the manner of editing.
             R1321 char-string-edit-desc       is  char-literal-constant
             C1313 (R1321) A kind parameter shall not be speciﬁed for the char-literal-constant.
          5 Each rep-char in a character string edit descriptor shall be capable of representation by the processor.
          6 Acharacter string edit descriptor provides constant data to be output, and is not valid for input.
          7 The edit descriptors are without regard to case except within a character string edit descriptor.
             13.3.3    Fields
          1 A ﬁeld is a part of a record that is read on input or written on output when format control encounters a data
             edit descriptor or a character string edit descriptor. The ﬁeld width is the size in characters of the ﬁeld.
             13.4     Interaction between input/output list and format
          1 Thestart of formatted data transfer using a format speciﬁcation initiates format control (12.6.4.5.3). Each action
             of format control depends on information jointly provided by the next edit descriptor in the format speciﬁcation
             and the next eﬀective item in the input/output list, if one exists.
          2 If an input/output list speciﬁes at least one eﬀective item, at least one data edit descriptor shall exist in the
             format speciﬁcation.
                 NOTE13.4
                 Anemptyformat speciﬁcation of the form ( ) can be used only if the input/output list has no eﬀective item
                 (12.6.4.5). A zero length character item is an eﬀective item, but a zero sized array and an implied DO list
                 with an iteration count of zero is not.
          3 A format speciﬁcation is interpreted from left to right. The exceptions are format items preceded by a repeat
             speciﬁcation r, and format reversion (described below).
          4 A format item preceded by a repeat speciﬁcation is processed as a list of r items, each identical to the format
             item but without the repeat speciﬁcation and separated by commas.
                                                                         c
             268                                                         ISO/IEC 2017 – All rights reserved
                                                      ISO/IEC DIS 1539-1:2017 (E)
            NOTE13.5
            An omitted repeat speciﬁcation is treated in the same way as a repeat speciﬁcation whose value is one.
       5 Toeachdataeditdescriptor interpreted in a format speciﬁcation, there corresponds one eﬀective item speciﬁed by
         the input/output list (12.6.3), except that an input/output list item of type complex requires the interpretation
         of two F, E, EN, ES, D, or G edit descriptors. For each control edit descriptor or character edit descriptor,
         there is no corresponding item speciﬁed by the input/output list, and format control communicates information
         directly with the record.
       6 Whenever format control encounters a data edit descriptor in a format speciﬁcation, it determines whether
         there is a corresponding eﬀective item speciﬁed by the input/output list. If there is such an item, it transmits
         appropriately edited information between the item and the record, and then format control proceeds. If there is
         no such item, format control terminates.
       7 If format control encounters a colon edit descriptor in a format speciﬁcation and another eﬀective item is not
         speciﬁed, format control terminates.
       8 If format control encounters the rightmost parenthesis of an unlimited format item, control reverts to the leftmost
         parenthesis of that unlimited format item. This reversion of format control has no eﬀect on the changeable modes
         (12.5.2).
       9 If format control encounters the rightmost parenthesis of a complete format speciﬁcation and another eﬀective
         item is not speciﬁed, format control terminates. However, if another eﬀective item is speciﬁed, format control
         then reverts to the beginning of the format item terminated by the last preceding right parenthesis that is not
         part of a DT edit descriptor. If there is no such preceding right parenthesis, format control reverts to the ﬁrst
         left parenthesis of the format speciﬁcation. If any reversion occurs, the reused portion of the format speciﬁcation
         shall contain at least one data edit descriptor. If format control reverts to a parenthesis that is preceded by a
         repeat speciﬁcation, the repeat speciﬁcation is reused. Reversion of format control, of itself, has no eﬀect on
         the changeable modes. The ﬁle is positioned in a manner identical to the way it is positioned when a slash edit
         descriptor is processed (13.8.2).
            NOTE13.6
            Example: The format speciﬁcation:
            10 FORMAT (1X, 2(F10.3, I5))
            with an output list of
            WRITE (10,10) 10.1, 3, 4.7, 1, 12.4, 5, 5.2, 6
            produces the same output as the format speciﬁcation:
            10 FORMAT (1X, F10.3, I5, F10.3, I5/F10.3, I5, F10.3, I5)
            NOTE13.7
            The eﬀect of an unlimited-format-item is as if its enclosed list were preceded by a very large repeat count.
            There is no ﬁle positioning implied by unlimited-format-item reversion. This can be used to write what is
            commonly called a comma separated value record.
            For example,
            WRITE( 10, ’( "IARRAY =", *( I0, :, ","))’) IARRAY
            produces a single record with a header and a comma separated list of integer values.
         c
         ISO/IEC 2017 – All rights reserved                               269
           ISO/IEC DIS 1539-1:2017 (E)
           13.5    Positioning by format control
         1 After each data edit descriptor or character string edit descriptor is processed, the ﬁle is positioned after the last
           character read or written in the current record.
         2 After each T, TL, TR, or X edit descriptor is processed, the ﬁle is positioned as described in 13.8.1.1. After each
           slash edit descriptor is processed, the ﬁle is positioned as described in 13.8.2.
         3 During formatted stream output, processing of an A edit descriptor can cause ﬁle positioning to occur (13.7.4).
         4 If format control reverts as described in 13.4, the ﬁle is positioned in a manner identical to the way it is positioned
           when a slash edit descriptor is processed (13.8.2).
         5 During a read operation, any unprocessed characters of the current record are skipped whenever the next record
           is read.
           13.6    Decimal symbol
         1 The decimal symbol is the character that separates the whole and fractional parts in the decimal representation
           of a real number in an internal or external ﬁle. When the decimal edit mode is POINT, the decimal symbol is a
           decimal point. When the decimal edit mode is COMMA, the decimal symbol is a comma.
         2 If the decimal edit mode is COMMA during list-directed input/output, the character used as a value separator
           is a semicolon in place of a comma.
           13.7    Data edit descriptors
           13.7.1  Purpose of data edit descriptors
         1 Data edit descriptors cause the conversion of data to or from its internal representation; during formatted stream
           output, the A data edit descriptor may also cause ﬁle positioning. On input, the speciﬁed variable becomes
           deﬁned unless an error condition, an end-of-ﬁle condition, or an end-of-record condition occurs. On output, the
           speciﬁed expression is evaluated.
         2 During input from a Unicode ﬁle,
              • characters in the record that correspond to an ASCII character variable shall have a position in the ISO
               10646 character collating sequence of 127 or less, and
              • characters in the record that correspond to a default character variable shall be representable as default
               characters.
         3 During input from a non-Unicode ﬁle,
              • characters in the record that correspond to a character variable shall have the kind of the character variable,
               and
              • characters in the record that correspond to a numeric or logical variable shall be default characters.
         4 During output to a Unicode ﬁle, all characters transmitted to the record are of ISO 10646 character kind. If a
           character input/output list item or character string edit descriptor contains a character that is not representable
           as an ISO 10646 character, the result is processor dependent.
         5 During output to a non-Unicode ﬁle, characters transmitted to the record as a result of processing a character
           string edit descriptor or as a result of evaluating a numeric, logical, or default character data entity, are of default
           kind.
                                                              c
           270                                               ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             13.7.2     Numeric editing
             13.7.2.1   General rules
          1 The I, B, O, Z, F, E, EN, ES, EX, D, and G edit descriptors may be used to specify the input/output of integer,
             real, and complex data. The following general rules apply.
                   (1)   On input, leading blanks are not signiﬁcant. When the input ﬁeld is not an IEEE exceptional
                         speciﬁcation or hexadecimal-signiﬁcand number (13.7.2.3.2), the interpretation of blanks, other than
                         leading blanks, is determined by the blank interpretation mode (13.8.6). Plus signs may be omitted.
                         Aﬁeld containing only blanks is considered to be zero.
                   (2)   On input, with F, E, EN, ES, EX, D, and G editing, a decimal symbol appearing in the input ﬁeld
                         overrides the portion of an edit descriptor that speciﬁes the decimal symbol location. The input ﬁeld
                         may have more digits than the processor uses to approximate the value of the datum.
                   (3)   On output with I, F, E, EN, ES, EX, D, and G editing, the representation of a positive or zero
                         internal value in the ﬁeld may be preﬁxed with a plus sign, as controlled by the S, SP, and SS edit
                         descriptors or the processor. The representation of a negative internal value in the ﬁeld shall be
                         preﬁxed with a minus sign.
                   (4)   Onoutput, the representation is right justiﬁed in the ﬁeld. If the number of characters produced by
                         the editing is smaller than the ﬁeld width, leading blanks are inserted in the ﬁeld.
                   (5)   On output, if an exponent exceeds its speciﬁed or implied width using the E, EN, ES, EX, D, or G
                         edit descriptor, or the number of characters produced exceeds the ﬁeld width, the processor shall ﬁll
                         the entire ﬁeld of width w with asterisks. However, the processor shall not produce asterisks if the
                         ﬁeld width is not exceeded when optional characters are omitted.
                  NOTE13.8
                  When the sign mode is PLUS, a plus sign is not optional.
                   (6)   Onoutput, with I, B, O, Z, D, E, EN, ES, EX, F, and G editing, the speciﬁed value of the ﬁeld width
                         w may be zero. In such cases, the processor selects the smallest positive actual ﬁeld width that does
                         not result in a ﬁeld ﬁlled with asterisks. The speciﬁed value of w shall not be zero on input.
                   (7)   On output of a real zero value, the digits in the exponent ﬁeld shall all be zero.
             13.7.2.2   Integer editing
          1 TheIw and Iw.m edit descriptors indicate that the ﬁeld to be edited occupies w positions, except when w is zero.
             When w is zero, the processor selects the ﬁeld width. On input, w shall not be zero. The speciﬁed input/output
             list item shall be of type integer. The G, B, O, and Z edit descriptor also may be used to edit integer data
             (13.7.5.2.1, 13.7.2.4).
          2 On input, m has no eﬀect.
          3 Inthestandard form of the input ﬁeld for the I edit descriptor, the character string is a signed-digit-string (R710),
             except for the interpretation of blanks. If the input ﬁeld does not have the standard form and is not acceptable
             to the processor, an error condition occurs.
          4 The output ﬁeld for the Iw edit descriptor consists of zero or more leading blanks followed by a minus sign if the
             internal value is negative, or an optional plus sign otherwise, followed by the magnitude of the internal value as
             a digit-string without leading zeros.
                  NOTE13.9
                  Adigit-string always consists of at least one digit.
          5 Theoutput ﬁeld for the Iw.m edit descriptor is the same as for the Iw edit descriptor, except that the digit-string
             consists of at least m digits. If necessary, suﬃcient leading zeros are included to achieve the minimum of m digits.
             The value of m shall not exceed the value of w, except when w is zero. If m is zero and the internal value is zero,
              c
             ISO/IEC 2017 – All rights reserved                                                                     271
             ISO/IEC DIS 1539-1:2017 (E)
             the output ﬁeld consists of only blank characters, regardless of the sign control in eﬀect. When m and w are both
             zero, and the internal value is zero, one blank character is produced.
             13.7.2.3   Real and complex editing
             13.7.2.3.1   General
          1 The F, E, EN, ES, and D edit descriptors specify the editing of real and complex data. An input/output list
             item corresponding to an F, E, EN, ES, or D edit descriptor shall be real or complex. The G, B, O, and Z edit
             descriptors also may be used to edit real and complex data (13.7.5.2.2, 13.7.2.4).
             13.7.2.3.2   F editing
          1 The Fw.d edit descriptor indicates that the ﬁeld occupies w positions, except when w is zero in which case the
             processor selects the ﬁeld width. The fractional part of the ﬁeld consists of d digits. On input, w shall not be
             zero.
          2 A lower-case letter is equivalent to the corresponding upper-case letter in an IEEE exceptional speciﬁcation or
             the exponent in a numeric input ﬁeld.
          3 The standard form of the input ﬁeld is an IEEE exceptional speciﬁcation, a hexadecimal-signiﬁcand number, or
             consists of a mantissa optionally followed by an exponent. The form of the mantissa is an optional sign, followed
             by a string of one or more digits optionally containing a decimal symbol, including any blanks interpreted as
             zeros. The d has no eﬀect on input if the input ﬁeld contains a decimal symbol. If the decimal symbol is omitted,
             the rightmost d digits of the string, with leading zeros assumed if necessary, are interpreted as the fractional part
             of the value represented. The string of digits may contain more digits than a processor uses to approximate the
             value. The form of the exponent is one of the following:
                 • a sign followed by a digit-string;
                 • the letter E followed by zero or more blanks, followed by a signed-digit-string;
                 • the letter D followed by zero or more blanks, followed by a signed-digit-string.
          4 An exponent containing a D is processed identically to an exponent containing an E.
                  NOTE13.10
                  If the input ﬁeld does not contain an exponent, the eﬀect is as if the basic form were followed by an exponent
                  with a value of −k, where k is the established scale factor (13.8.5).
          5 An input ﬁeld that is an IEEE exceptional speciﬁcation consists of optional blanks, followed by either
                 • an optional sign, followed by the string ’INF’ or the string ’INFINITY’, or
                 • an optional sign, followed by the string ’NAN’, optionally followed by zero or more alphanumeric characters
                   enclosed in parentheses,
             optionally followed by blanks.
          6 The value speciﬁed by ’INF’ or ’INFINITY’ is an IEEE inﬁnity; this form shall not be used if the processor does
             not support IEEE inﬁnities for the input variable. The value speciﬁed by ’NAN’ is an IEEE NaN; this form shall
             not be used if the processor does not support IEEE NaNs for the input variable. The NaN value is a quiet NaN if
             the only nonblank characters in the ﬁeld are ’NAN’ or ’NAN()’; otherwise, the NaN value is processor dependent.
             The interpretation of a sign in a NaN input ﬁeld is processor dependent.
          7 Aninput ﬁeld that is a hexadecimal-signiﬁcand number consists of an optional sign, followed by the hexadecimal
             indicator which is the digit 0 immediately followed by the letter X, followed by a hexadecimal signiﬁcand followed
             byahexadecimalexponent. Ahexadecimalsigniﬁcandisastringofoneormorehexadecimalcharactersoptionally
             containing a decimal symbol. The decimal symbol indicates the position of the hexadecimal point; if no decimal
             symbol appears, the hexadecimal point implicitly follows the last hexadecimal symbol. A hexadecimal exponent
                                                                            c
             272                                                           ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
             is the letter P followed by a (decimal) signed-digit-string. Embedded blanks are not permitted in a hexadecimal-
             signiﬁcand number. The value is equal to the signiﬁcand multiplied by two raised to the power of the exponent,
             negated if the optional sign is minus.
           8 If the input ﬁeld does not have one of the standard forms, and is not acceptable to the processor, an error
             condition occurs.
           9 For an internal value that is an IEEE inﬁnity, the output ﬁeld consists of blanks, if necessary, followed by a minus
             sign for negative inﬁnity or an optional plus sign otherwise, followed by the letters ’Inf’ or ’Inﬁnity’, right justiﬁed
             within the ﬁeld. The minimum ﬁeld width required for output of the form ’Inf’ is 3 if no sign is produced, and
             4 otherwise. The minimum ﬁeld width required for output of the form ’Inﬁnity’ is 8 if no sign is produced, and
             9 otherwise. If w is greater than or equal to the minimum required for the form ’Inﬁnity’, the form ’Inﬁnity’ is
             output. If w is zero or w is less than the minimum required for the form ’Inﬁnity’ and greater than or equal to
             the minimum required for the form ’Inf’, the form ’Inf’ is output. Otherwise (w is greater than zero but less than
             the minimum required for any form), the ﬁeld is ﬁlled with asterisks.
          10 For an internal value that is an IEEE NaN, the output ﬁeld consists of blanks, if necessary, followed by the
             letters ’NaN’ and optionally followed by one to w−5 alphanumeric processor-dependent characters enclosed in
             parentheses, right justiﬁed within the ﬁeld. If w is greater than zero and less than 3, the ﬁeld is ﬁlled with
             asterisks. If w is zero, the output ﬁeld is ’NaN’.
                  NOTE13.11
                  The processor-dependent characters following ’NaN’ might convey additional information about that par-
                  ticular NaN.
          11 For an internal value that is neither an IEEE inﬁnity nor a NaN, the output ﬁeld consists of blanks, if necessary,
             followed by a minus sign if the internal value is negative, or an optional plus sign otherwise, followed by a string
             of digits that contains a decimal symbol and represents the magnitude of the internal value, as modiﬁed by the
             established scale factor and rounded (13.7.2.3.8) to d fractional digits. Leading zeros are not permitted except
             for an optional zero immediately to the left of the decimal symbol if the magnitude of the value in the output
             ﬁeld is less than one. The optional zero shall appear if there would otherwise be no digits in the output ﬁeld.
             13.7.2.3.3   E and D editing
           1 TheEw.d, Dw.d, and Ew.d Ee edit descriptors indicate that the external ﬁeld occupies w positions, except when
             w is zero in which case the processor selects the ﬁeld width. The fractional part of the ﬁeld contains d digits,
             unless a scale factor greater than one is in eﬀect. If e is positive the exponent part contains e digits, otherwise it
             contains the minimum number of digits required to represent the exponent value. The e has no eﬀect on input.
           2 The form and interpretation of the input ﬁeld is the same as for Fw.d editing (13.7.2.3.2).
           3 For an internal value that is an IEEE inﬁnity or NaN, the form of the output ﬁeld is the same as for Fw.d.
           4 For an internal value that is neither an IEEE inﬁnity nor a NaN, the form of the output ﬁeld for a scale factor
             of zero is
                 [ ± ] [0].x x ...x exp
             where:        1 2     d
                 • ± signiﬁes a plus sign or a minus sign;
                 • . signiﬁes a decimal symbol (13.6);
                 • x x ...x are the d most signiﬁcant digits of the internal value after rounding (13.7.2.3.8);
                    1 2     d
                 • exp is a decimal exponent having one of the forms speciﬁed in table 13.1.
              c
             ISO/IEC 2017 – All rights reserved                                                                      273
             ISO/IEC DIS 1539-1:2017 (E)
                                                Table 13.1: E and D exponent forms
                                            Edit           Absolute Value            Form of
                                         Descriptor          of Exponent           Exponent1
                                            Ew.d              |exp| ≤ 99        E±z z or ±0z z
                                                                                    1 2       1 2
                                                          99 < |exp| ≤ 999           ±z z z
                                                                                       1 2 3
                                                                     e
                                    Ew.d Ee with e > 0     |exp| ≤ 10 −1          E±z z ...z
                                                                                       1 2    e
                                          Ew.d E0                any              E±z z ...z
                                                                                       1 2    s
                                           Dw.d               |exp| ≤ 99       D±z z or E±z z
                                                                                    1 2        1 2
                                                                                    or ±0z z
                                                                                          1 2
                                                          99 < |exp| ≤ 999           ±z z z
                                                                                       1 2 3
                                    (1) where each z is a digit, and s is the minimum number of digits
                                    required to represent the exponent.
           5 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
           6 The scale factor k controls the decimal normalization (13.3.2, 13.8.5). If −d < k ≤ 0, the output ﬁeld contains
             exactly |k| leading zeros and d−|k| signiﬁcant digits after the decimal symbol. If 0 < k < d+2, the output ﬁeld
             contains exactly k signiﬁcant digits to the left of the decimal symbol and d−k +1 signiﬁcant digits to the right
             of the decimal symbol. Other values of k are not permitted.
             13.7.2.3.4   EN editing
           1 The EN edit descriptor produces an output ﬁeld in the form of a real number in engineering notation such that
             the decimal exponent is divisible by three and the absolute value of the signiﬁcand (R715) is greater than or
             equal to 1 and less than 1000, except when the output value is zero. The scale factor has no eﬀect on output.
           2 Theformsof the edit descriptor are ENw.d and ENw.d Ee indicating that the external ﬁeld occupies w positions,
             except when w is zero in which case the processor selects the ﬁeld width. The fractional part of the ﬁeld contains
             d digits. If e is positive the exponent part contains e digits, otherwise it contains the minimum number of digits
             required to represent the exponent value.
           3 The form and interpretation of the input ﬁeld is the same as for Fw.d editing (13.7.2.3.2).
           4 For an internal value that is an IEEE inﬁnity or NaN, the form of the output ﬁeld is the same as for Fw.d.
           5 For an internal value that is neither an IEEE inﬁnity nor a NaN, the form of the output ﬁeld is
                 [ ± ] yyy . x1x2 ...xdexp
             where:
                 • ± signiﬁes a plus sign or a minus sign;
                 • yyy are the 1 to 3 decimal digits representative of the most signiﬁcant digits of the internal value after
                   rounding (13.7.2.3.8);
                 • yyy is an integer such that 1 ≤ yyy < 1000 or, if the output value is zero, yyy = 0;
                 • . signiﬁes a decimal symbol (13.6);
                 • x x ...x are the d next most signiﬁcant digits of the internal value after rounding;
                    1 2     d
                 • exp is a decimal exponent, divisible by three, having one of the forms speciﬁed in table 13.2.
                                                                             c
             274                                                            ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                                                   Table 13.2: EN exponent forms
                                             Edit            Absolute Value           Form of
                                          Descriptor          of Exponent           Exponent1
                                            ENw.d              |exp| ≤ 99        E±z z or ±0z z
                                                                                     1 2       1 2
                                                            99 < |exp| ≤ 999          ±z z z
                                                                                        1 2 3
                                                                       e
                                    ENw.d Ee with e > 0      |exp| ≤ 10 −1         E±z z ...z
                                                                                       1 2     e
                                          ENw.d E0                 any             E±z z ...z
                                                                                       1 2     s
                                    (1) where each z is a digit, and s is the minimum number of digits
                                    required to represent the exponent.
           6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
                  NOTE13.12
                  Examples:
                          Internal Value                 Output ﬁeld using SS, EN12.3
                               6.421                         6.421E+00
                               -.5                       -500.000E-03
                               .00217                        2.170E-03
                          4721.3                             4.721E+03
             13.7.2.3.5   ES editing
           1 The ES edit descriptor produces an output ﬁeld in the form of a real number in scientiﬁc notation such that the
             absolute value of the signiﬁcand (R715) is greater than or equal to 1 and less than 10, except when the output
             value is zero. The scale factor has no eﬀect on output.
           2 The forms of the edit descriptor are ESw.d and ESw.d Ee indicating that the external ﬁeld occupies w positions,
             except when w is zero in which case the processor selects the ﬁeld width. The fractional part of the ﬁeld contains
             d digits. If e is positive the exponent part contains e digits, otherwise it contains the minimum number of digits
             required to represent the exponent value.
           3 The form and interpretation of the input ﬁeld is the same as for Fw.d editing (13.7.2.3.2).
           4 For an internal value that is an IEEE inﬁnity or NaN, the form of the output ﬁeld is the same as for Fw.d.
           5 For an internal value that is neither an IEEE inﬁnity nor a NaN, the form of the output ﬁeld is
                 [ ± ] y . x1x2 ...xdexp
             where:
                 • ± signiﬁes a plus sign or a minus sign;
                 • y is a decimal digit representative of the most signiﬁcant digit of the internal value after rounding (13.7.2.3.8);
                 • . signiﬁes a decimal symbol (13.6);
                 • x x ...x are the d next most signiﬁcant digits of the internal value after rounding;
                    1 2     d
                 • exp is a decimal exponent having one of the forms speciﬁed in table 13.3.
                                                    Table 13.3: ES exponent forms
                                             Edit           Absolute Value           Form of
                                          Descriptor          of Exponent           Exponent1
                                            ESw.d              |exp| ≤ 99       E±z z or ±0z z
                                                                                     1 2       1 2
                                                            99 < |exp| ≤ 999         ±z z z
                                                                                        1 2 3
                                                                      e
                                    ESw.d Ee with e > 0     |exp| ≤ 10 −1          E±z z ...z
                                                                                       1 2     e
                                          ESw.d E0                any              E±z z ...z
                                                                                       1 2     s
                                    (1) where each z is a digit, and s is the minimum number of digits
                                    required to represent the exponent.
              c
             ISO/IEC 2017 – All rights reserved                                                                      275
             ISO/IEC DIS 1539-1:2017 (E)
           6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
                  NOTE13.13
                  Examples:
                          Internal Value                 Output ﬁeld Using SS, ES12.3
                             6.421                           6.421E+00
                              -.5                          -5.000E-01
                               .00217                        2.170E-03
                          4721.3                             4.721E+03
             13.7.2.3.6   EX editing
           1 The EX edit descriptor produces an output ﬁeld in the form of a hexadecimal-signiﬁcand number.
           2 The EXw.d and EXw.dEe edit descriptors indicate that the external ﬁeld occupies w positions, except when w
             is zero in which case the processor selects the ﬁeld width. The fractional part of the ﬁeld contains d hexadecimal
             digits, except when d is zero in which case the processor selects the number of hexadecimal digits to be the
             minimum required so that the output ﬁeld is equal to the internal value; d shall not be zero if the radix of the
             internal value is not a power of two. The hexadecimal point, represented by a decimal symbol, appears after
             the ﬁrst hexadecimal digit. For the form EXw.d, and for EXw.dE0, the exponent part contains the minimum
             number of digits needed to represent the exponent; otherwise the exponent contains e digits. The e has no eﬀect
             on input. The scale factor has no eﬀect on output.
           3 The form and interpretation of the input ﬁeld is the same as for Fw.d editing (13.7.2.3.2).
           4 For an internal value that is an IEEE inﬁnity or NaN, the form of the output ﬁeld is the same as for Fw.d.
           5 For an internal value that is neither an IEEE inﬁnity nor a NaN, the form of the output ﬁeld is
                 [ ± ] 0X x . x x ... exp
             where:        0    1 2
                 • ± signiﬁes a plus sign or a minus sign;
                 • . signiﬁes a decimal symbol (13.6);
                 • x x x ... are the most signiﬁcant hexadecimal digits of the internal value, after rounding if d is not zero
                    0 1 2
                   (13.7.2.3.8);
                 • exp is a binary exponent expressed as a decimal integer; for EXw.d and EXw.dE0, the form is P ±z ...z ,
                                                                                                                    1    n
                   where n is the minimum number of digits needed to represent exp, and for EXw.dEe with e greater than
                   zero the form is P ±z1...ze. The choice of binary exponent is processor dependent. If the most signiﬁcant
                   binary digits of the internal value are b b b ..., the binary exponent might make the value of x be that of
                   b , b b , b b b , or b b b b .        0 1 2                                                 0
                    0  0 1   0 1 2    0 1 2 3
           6 The sign in the exponent is produced. A plus sign is produced if the exponent value is zero.
                  NOTE13.14
                  Examples:
                    Internal value  Edit descriptor  Possible output with SS in eﬀect
                        1.375         EX0.1                0X1.6P+0
                      −15.625         EX14.4E3             -0X1.F400P+003
                     1048580.0        EX0.0                0X1.00004P+20
                        2.375         EX0.1                      0X2.6P+0
             13.7.2.3.7   Complex editing
           1 A complex datum consists of a pair of separate real data. The editing of a scalar datum of complex type is
             speciﬁed by two edit descriptors each of which speciﬁes the editing of real data. The ﬁrst edit descriptor speciﬁes
                                                                             c
             276                                                            ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
             the editing for the real part; the second speciﬁes it for the imaginary part. The two edit descriptors may be
             diﬀerent. Control and character string edit descriptors may be processed between the edit descriptor for the real
             part and the edit descriptor for the imaginary part.
             13.7.2.3.8   Input/output rounding mode
           1 The input/output rounding mode can be speciﬁed by an OPEN statement (12.5.2), a data transfer statement
             (12.6.2.13), or an edit descriptor (13.8.7).
           2 In what follows, the term “decimal value” means the exact decimal number as given by the character string, while
             the term “internal value” means the number actually stored in the processor. For example, in dealing with the
             decimal constant 0.1, the decimal value is the mathematical quantity 1/10, which has no exact representation
             in binary form. Formatted output of real data involves conversion from an internal value to a decimal value;
             formatted input involves conversion from a decimal value to an internal value.
           3 Whentheinput/output rounding mode is UP, the value resulting from conversion shall be the smallest represent-
             able value that is greater than or equal to the original value. When the input/output rounding mode is DOWN,
             the value resulting from conversion shall be the largest representable value that is less than or equal to the original
             value. When the input/output rounding mode is ZERO, the value resulting from conversion shall be the value
             closest to the original value and no greater in magnitude than the original value. When the input/output rounding
             modeis NEAREST,thevalueresulting from conversion shall be the closer of the two nearest representable values
             if one is closer than the other. If the two nearest representable values are equidistant from the original value, it is
             processor dependent which one of them is chosen. When the input/output rounding mode is COMPATIBLE, the
             value resulting from conversion shall be the closer of the two nearest representable values or the value away from
             zero if halfway between them. When the input/output rounding mode is PROCESSOR_DEFINED, rounding
             during conversion shall be a processor-dependent default mode, which may correspond to one of the other modes.
           4 OnprocessorsthatsupportIEEEroundingonconversions(17.4), NEARESTshallcorrespondtoroundtonearest,
             as speciﬁed in ISO/IEC/IEEE 60559:2011.
                  NOTE13.15
                  On processors that support IEEE rounding on conversions, the input/output rounding modes COMPAT-
                  IBLE and NEAREST will produce the same results except when the datum is halfway between the two
                  representable values. In that case, NEAREST will pick the even value, but COMPATIBLE will pick the
                  value away from zero. The input/output rounding modes UP, DOWN, and ZERO have the same eﬀect as
                  those speciﬁed in ISO/IEC/IEEE 60559:2011 for round toward +∞, round toward −∞, and round toward
                  0, respectively.
             13.7.2.4   B, O, and Z editing
           1 The Bw, Bw.m, Ow, Ow.m, Zw, and Zw.m edit descriptors indicate that the ﬁeld to be edited occupies w
             positions, except when w is zero. When w is zero, the processor selects the ﬁeld width. On input, w shall not be
             zero. The corresponding input/output list item shall be of type integer, real, or complex.
           2 On input, m has no eﬀect.
           3 In the standard form of the input ﬁeld for the B, O, and Z edit descriptors the character string consists of binary,
             octal, or hexadecimal digits (as in R765, R766, R767) in the respective input ﬁeld. The lower-case hexadecimal
             digits a through f in a hexadecimal input ﬁeld are equivalent to the corresponding upper-case hexadecimal digits.
             If the input ﬁeld does not have the standard form, and is not acceptable to the processor, an error condition
             occurs.
           4 The value is INT (X) if the input list item is of type integer and REAL (X) if the input list item is of type real
             or complex, where X is a boz-literal-constant that speciﬁes the same bit sequence as the digits of the input ﬁeld.
           5 The output ﬁeld for the Bw, Ow, and Zw descriptors consists of zero or more leading blanks followed by the
             internal value in a form identical to the digits of a binary, octal, or hexadecimal constant, respectively, that
             speciﬁes the same bit sequence but without leading zero bits.
              c
             ISO/IEC 2017 – All rights reserved                                                                      277
                ISO/IEC DIS 1539-1:2017 (E)
                     NOTE13.16
                     Abinary, octal, or hexadecimal constant always consists of at least one digit or hexadecimal digit.
                R1322 hex-digit-string                    is  hex-digit [ hex-digit ] ...
            6 The output ﬁeld for the Bw.m, Ow.m, and Zw.m edit descriptor is the same as for the Bw, Ow, and Zw edit
                descriptor, except that the digit-string or hex-digit-string consists of at least m digits. If necessary, suﬃcient
                leading zeros are included to achieve the minimum of m digits. The value of m shall not exceed the value of w,
                except when w is zero. If m is zero and the internal value consists of all zero bits, the output ﬁeld consists of
                only blank characters. When m and w are both zero, and the internal value consists of all zero bits, one blank
                character is produced.
                13.7.3      Logical editing
            1 The Lw edit descriptor indicates that the ﬁeld occupies w positions. The speciﬁed input/output list item shall
                be of type logical. The G edit descriptor also may be used to edit logical data (13.7.5.3).
            2 The standard form of the input ﬁeld consists of optional blanks, optionally followed by a period, followed by a T
                for true or F for false. The T or F may be followed by additional characters in the ﬁeld, which are ignored. If the
                input ﬁeld does not have the standard form, and is not acceptable to the processor, an error condition occurs.
            3 Alower-case letter is equivalent to the corresponding upper-case letter in a logical input ﬁeld.
                     NOTE13.17
                     The logical constants .TRUE. and .FALSE. are acceptable input forms.
            4 The output ﬁeld consists of w−1 blanks followed by a T or F, depending on whether the internal value is true or
                false, respectively.
                13.7.4      Character editing
            1 TheA[w]edit descriptor is used with an input/output list item of type character. The G edit descriptor also may
                be used to edit character data (13.7.5.4). The kind type parameter of all characters transferred and converted
                under control of one A or G edit descriptor is implied by the kind of the corresponding list item.
            2 If a ﬁeld width w is speciﬁed with the A edit descriptor, the ﬁeld consists of w characters. If a ﬁeld width w is
                not speciﬁed with the A edit descriptor, the number of characters in the ﬁeld is the length of the corresponding
                list item, regardless of the value of the kind type parameter.
            3 Let len be the length of the input/output list item. If the speciﬁed ﬁeld width w for an A edit descriptor
                corresponding to an input item is greater than or equal to len, the rightmost len characters will be taken from the
                input ﬁeld. If the speciﬁed ﬁeld width w is less than len, the w characters will appear left justiﬁed with len−w
                trailing blanks in the internal value.
            4 If the speciﬁed ﬁeld width w for an A edit descriptor corresponding to an output item is greater than len, the
                output ﬁeld will consist of w−len blanks followed by the len characters from the internal value. If the speciﬁed
                ﬁeld width w is less than or equal to len, the output ﬁeld will consist of the leftmost w characters from the internal
                value.
                     NOTE13.18
                     For nondefault character kinds, the blank padding character is processor dependent.
            5 If the ﬁle is connected for stream access, the output may be split across more than one record if it contains
                newline characters. A newline character is a nonblank character returned by the intrinsic function NEW_LINE.
                Beginning with the ﬁrst character of the output ﬁeld, each character that is not a newline is written to the current
                record in successive positions; each newline character causes ﬁle positioning at that point as if by slash editing
                                                                                         c
                278                                                                      ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             (the current record is terminated at that point, a new empty record is created following the current record, this
             new record becomes the last and current record of the ﬁle, and the ﬁle is positioned at the beginning of this new
             record).
                  NOTE13.19
                  If the intrinsic function NEW_LINE returns a blank character for a particular character kind, then the
                  processor does not support using a character of that kind to cause record termination in a formatted stream
                  ﬁle.
             13.7.5     Generalized editing
             13.7.5.1   Overview
          1 TheGw,Gw.d andGw.d Ee edit descriptors are used with an input/output list item of any intrinsic type. When
             w is nonzero, these edit descriptors indicate that the external ﬁeld occupies w positions. For real or complex
             data the fractional part consists of a maximum of d digits and the exponent part consists of e digits. When these
             edit descriptors are used to specify the input/output of integer, logical, or character data, d and e have no eﬀect.
             When w is zero the processor selects the ﬁeld width. On input, w shall not be zero.
             13.7.5.2   Generalized numeric editing
          1 When used to specify the input/output of integer, real, and complex data, the Gw, Gw.d and Gw.d Ee edit
             descriptors follow the general rules for numeric editing (13.7.2).
                  NOTE13.20
                  The Gw.d Ee edit descriptor follows any additional rules for the Ew.d Ee edit descriptor.
             13.7.5.2.1   Generalized integer editing
          1 When used to specify the input/output of integer data, the Gw, Gw.d, and Gw.d Ee edit descriptors follow the
             rules for the Iw edit descriptor (13.7.2.2). Note that w cannot be zero for input editing (13.7.5.1).
             13.7.5.2.2   Generalized real and complex editing
          1 The form and interpretation of the input ﬁeld for Gw.d and Gw.d Ee editing is the same as for Fw.d editing
             (13.7.2.3.2). The rest of this subclause applies only to output editing.
          2 If w is nonzero and d is zero, kPEw.0 or kPEw.0Ee editing is used for Gw.0 editing or Gw.0Ee editing respectively.
          3 When used to specify the output of real or complex data that is not an IEEE inﬁnity or NaN, the G0 and G0.d
             edit descriptors follow the rules for the Gw.dEe edit descriptor, except that any leading or trailing blanks are
             removed. Reasonable processor-dependent values of w, d (if not speciﬁed), and e are used with each output value.
          4 For an internal value that is an IEEE inﬁnity or NaN, the form of the output ﬁeld for the Gw.d and Gw.d Ee
             edit descriptors is the same as for Fw.d, and the form of the output ﬁeld for the G0 and G0.d edit descriptors is
             the same as for F0.0.
          5 Otherwise, the method of representation in the output ﬁeld depends on the magnitude of the internal value
             being edited. If the internal value is zero, let s be one. If the internal value is a number other than zero, let N
             be the decimal value that is the result of converting the internal value to d signiﬁcant digits according to the
                                                                             s−1           s
             input/output rounding mode and let s be the integer such that 10   ≤|N|<10 . If s < 0 or s > d, kPEw.d or
             kPEw.dEe editing is used for Gw.d editing or Gw.dEe editing respectively, where k is the scale factor (13.8.5).
             If 0 ≤ s ≤ d, the scale factor has no eﬀect and F(w−n).(d−s),n(’b’) editing is used where b is a blank and n is
             4 for Gw.d editing, e + 2 for Gw.dEe editing if e > 0, and 4 for Gw.dE0 editing.
          6 The value of w−n shall be positive.
              c
             ISO/IEC 2017 – All rights reserved                                                                     279
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE13.21
                  Thescale factor has no eﬀect on output unless the magnitude of the datum to be edited is outside the range
                  that permits eﬀective use of F editing.
             13.7.5.3   Generalized logical editing
          1 When used to specify the input/output of logical data, the Gw.d and Gw.d Ee edit descriptors with nonzero w
             follow the rules for the Lw edit descriptor (13.7.3). When used to specify the output of logical data, the G0 and
             G0.d edit descriptors follow the rules for the L1 edit descriptor.
             13.7.5.4   Generalized character editing
          1 When used to specify the input/output of character data, the Gw.d and Gw.d Ee edit descriptors with nonzero
             w follow the rules for the Aw edit descriptor (13.7.4). When used to specify the output of character data, the G0
             and G0.d edit descriptors follow the rules for the A edit descriptor with no ﬁeld width.
             13.7.6     User-deﬁned derived-type editing
          1 The DT edit descriptor speciﬁes that a user-provided procedure shall be used instead of the processor’s default
             input/output formatting for processing a list item of derived type.
          2 TheDTeditdescriptormayincludeacharacterliteral constant. The character value “DT” concatenated with the
             character literal constant is passed to the deﬁned input/output procedure as the iotype argument (12.6.4.8). The
             v values of the edit descriptor are passed to the deﬁned input/output procedure as the v_list array argument.
                  NOTE13.22
                  For the edit descriptor DT’Link List’(10, 4, 2), iotype is "DTLink List" and v_list is [10, 4, 2].
          3 If a derived-type variable or value corresponds to a DT edit descriptor, there shall be an accessible interface to
             a corresponding deﬁned input/output procedure for that derived type (12.6.4.8). A DT edit descriptor shall not
             correspond to a list item that is not of a derived type.
             13.8      Control edit descriptors
             13.8.1     Position edit descriptors
             13.8.1.1   Position editing
          1 Theposition edit descriptors T, TL, TR, and X, specify the position at which the next character will be transmit-
             ted to or from the record. If any character skipped by a position edit descriptor is of type nondefault character,
             and the unit is a default character internal ﬁle or an external non-Unicode ﬁle, the result of that position editing
             is processor dependent.
          2 Oninput, if the position speciﬁed by a position edit descriptor is before the current position, portions of a record
             can be processed more than once, possibly with diﬀerent editing.
          3 On input, a position beyond the last character of the record may be speciﬁed if no characters are transmitted
             from such positions.
          4 Onoutput, a position edit descriptor does not by itself cause characters to be transmitted and therefore does not
             by itself aﬀect the length of the record. If characters are transmitted to positions at or after the position speciﬁed
             by a position edit descriptor, positions skipped and not previously ﬁlled are ﬁlled with blanks. The result is as if
             the entire record were initially ﬁlled with blanks.
          5 Onoutput, a character in the record can be replaced. A position edit descriptor never directly causes a character
                                                                            c
             280                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             already placed in the record to be replaced, but it might result in positioning such that subsequent editing causes
             a replacement.
             13.8.1.2   T, TL, and TR editing
          1 The left tab limit aﬀects ﬁle positioning by the T and TL edit descriptors. Immediately prior to nonchild data
             transfer (12.6.4.8.3), the left tab limit becomes deﬁned as the character position of the current record or the
             current position of the stream ﬁle. If, during data transfer, the ﬁle is positioned to another record, the left tab
             limit becomes deﬁned as character position one of that record.
          2 The Tn edit descriptor indicates that the transmission of the next character to or from a record is to occur at
             the nth character position of the record, relative to the left tab limit. This position can be in either direction
             from the current position.
          3 The TLn edit descriptor indicates that the transmission of the next character to or from the record is to occur at
             the character position n characters backward from the current position. However, if n is greater than the diﬀerence
             between the current position and the left tab limit, the TLn edit descriptor indicates that the transmission of
             the next character to or from the record is to occur at the left tab limit.
          4 The TRn edit descriptor indicates that the transmission of the next character to or from the record is to occur
             at the character position n characters forward from the current position.
             13.8.1.3   X editing
          1 The nX edit descriptor indicates that the transmission of the next character to or from a record is to occur at
             the character position n characters forward from the current position.
                  NOTE13.23
                  An nX edit descriptor has the same eﬀect as a TRn edit descriptor.
             13.8.2     Slash editing
          1 The slash edit descriptor indicates the end of data transfer to or from the current record.
          2 On input from a ﬁle connected for sequential or stream access, the remaining portion of the current record is
             skipped and the ﬁle is positioned at the beginning of the next record. This record becomes the current record.
             Onoutput to a ﬁle connected for sequential or stream access, a new empty record is created following the current
             record; this new record then becomes the last and current record of the ﬁle and the ﬁle is positioned at the
             beginning of this new record.
          3 For a ﬁle connected for direct access, the record number is increased by one and the ﬁle is positioned at the
             beginning of the record that has that record number, if there is such a record, and this record becomes the
             current record.
                  NOTE13.24
                  Arecordthatcontainsnocharacters can be written on output. If the ﬁle is an internal ﬁle or a ﬁle connected
                  for direct access, the record is ﬁlled with blank characters.
                  An entire record can be skipped on input.
          4 The repeat speciﬁcation is optional in the slash edit descriptor. If it is not speciﬁed, the default value is one.
             13.8.3     Colon editing
          1 The colon edit descriptor terminates format control if there are no more eﬀective items in the input/output list
             (12.6.3). The colon edit descriptor has no eﬀect if there are more eﬀective items in the input/output list.
              c
             ISO/IEC 2017 – All rights reserved                                                                     281
           ISO/IEC DIS 1539-1:2017 (E)
           13.8.4   SS, SP, and S editing
         1 The SS, SP, and S edit descriptors temporarily change (12.5.2) the sign mode (12.5.6.17, 12.6.2.14) for the
           connection. The edit descriptors SS, SP, and S set the sign mode corresponding to the SIGN= speciﬁer values
           SUPPRESS, PLUS, and PROCESSOR_DEFINED, respectively.
         2 The sign mode controls optional plus characters in numeric output ﬁelds. When the sign mode is PLUS, the
           processor shall produce a plus sign in any position that normally contains an optional plus sign. When the
           sign mode is SUPPRESS, the processor shall not produce a plus sign in such positions. When the sign mode is
           PROCESSOR_DEFINED,theprocessorhastheoptionofproducing a plus sign or not in such positions, subject
           to 13.7.2(5).
         3 TheSS,SP,andSeditdescriptors aﬀect only I, F, E, EN, ES, D, and G editing during the execution of an output
           statement. The SS, SP, and S edit descriptors have no eﬀect during the execution of an input statement.
           13.8.5   P editing
         1 The kP edit descriptor temporarily changes (12.5.2) the scale factor for the connection to k. The scale factor
           aﬀects the editing done by the F, E, EN, ES, EX, D, and G edit descriptors for real and complex quantities.
         2 The scale factor k aﬀects the appropriate editing in the following manner.
              • On input, with F, E, EN, ES, EX, D, and G editing (provided that no exponent exists in the ﬁeld), the
                                                                                                   k
                eﬀect is that the externally represented number equals the internally represented number multiplied by 10 ;
                the scale factor is applied to the external decimal value and then this is converted using the input/output
                rounding mode.
              • On input, with F, E, EN, ES, EX, D, and G editing, the scale factor has no eﬀect if there is an exponent
                in the ﬁeld.
              • On output, with F output editing, the eﬀect is that the externally represented number equals the internally
                                              k
                represented number multiplied by 10 ; the internal value is converted using the input/output rounding
                mode and then the scale factor is applied to the converted decimal value.
              • On output, with E and D editing, the eﬀect is that the signiﬁcand (R715) part of the quantity to be
                                      k
                produced is multiplied by 10 and the exponent is reduced by k.
              • Onoutput, with G editing, the eﬀect is suspended unless the magnitude of the datum to be edited is outside
                the range that permits the use of F editing. If the use of E editing is required, the scale factor has the same
                eﬀect as with E output editing.
              • On output, with EN, ES, and EX editing, the scale factor has no eﬀect.
           13.8.6   BNand BZ editing
         1 The BN and BZ edit descriptors temporarily change (12.5.2) the blank interpretation mode (12.5.6.6, 12.6.2.6)
           for the connection. The edit descriptors BN and BZ set the blank interpretation mode corresponding to the
           BLANK=speciﬁer values NULL and ZERO, respectively.
         2 The blank interpretation mode controls the interpretation of nonleading blanks in numeric input ﬁelds. Such
           blank characters are interpreted as zeros when the blank interpretation mode has the value ZERO; they are
           ignored when the blank interpretation mode has the value NULL. The eﬀect of ignoring blanks is to treat the
           input ﬁeld as if blanks had been removed, the remaining portion of the ﬁeld right justiﬁed, and the blanks replaced
           as leading blanks. However, a ﬁeld containing only blanks has the value zero.
         3 The blank interpretation mode aﬀects only numeric editing (13.7.2) and generalized numeric editing (13.7.5.2)
           on input. It has no eﬀect on output.
           13.8.7   RU, RD, RZ, RN, RC, and RP editing
         1 The round edit descriptors temporarily change (12.5.2) the connection’s input/output rounding mode (12.5.6.16,
           12.6.2.13, 13.7.2.3.8). The round edit descriptors RU, RD, RZ, RN, RC, and RP set the input/output rounding
                                                               c
           282                                                ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           mode corresponding to the ROUND= speciﬁer values UP, DOWN, ZERO, NEAREST, COMPATIBLE, and
           PROCESSOR_DEFINED, respectively. The input/output rounding mode aﬀects the conversion of real and
           complex values in formatted input/output. It aﬀects only D, E, EN, ES, F, and G editing.
           13.8.8  DCand DP editing
         1 The decimal edit descriptors temporarily change (12.5.2) the decimal edit mode (12.5.6.7, 12.6.2.7, 13.6) for
           the connection. The edit descriptors DC and DP set the decimal edit mode corresponding to the DECIMAL=
           speciﬁer values COMMA and POINT, respectively.
         2 The decimal edit mode controls the representation of the decimal symbol (13.6) during conversion of real and
           complex values in formatted input/output. The decimal edit mode aﬀects only D, E, EN, ES, F, and G editing.
           13.9    Character string edit descriptors
         1 Acharacter string edit descriptor shall not be used on input.
         2 The character string edit descriptor causes characters to be written from the enclosed characters of the edit
           descriptor itself, including blanks. For a character string edit descriptor, the width of the ﬁeld is the number of
           characters between the delimiting characters. Within the ﬁeld, two consecutive delimiting characters are counted
           as a single character.
               NOTE13.25
               Adelimiter for a character string edit descriptor is either an apostrophe or quote.
           13.10    List-directed formatting
           13.10.1  Purpose of list-directed formatting
         1 List-directed input/output allows data editing according to the type of the list item instead of by a format
           speciﬁcation. It also allows data to be free-ﬁeld, that is, separated by commas (or semicolons) or blanks.
           13.10.2  Values and value separators
         1 The characters in one or more list-directed records constitute a sequence of values and value separators. The end
           of a record has the same eﬀect as a blank character, unless it is within a character constant. Any sequence of two
           or more consecutive blanks is treated as a single blank, unless it is within a character constant.
         2 Each value is either a null value, c, r*c, or r*, where c is a literal constant, optionally signed if integer or real,
           or an undelimited character constant and r is an unsigned, nonzero, integer literal constant. Neither c nor r
           shall have kind type parameters speciﬁed. The constant c is interpreted as though it had the same kind type
           parameter as the corresponding list item. The r*c form is equivalent to r successive appearances of the constant
           c, and the r* form is equivalent to r successive appearances of the null value. Neither of these forms may contain
           embedded blanks, except where permitted within the constant c.
         3 Avalue separator is
              • a comma optionally preceded by one or more contiguous blanks and optionally followed by one or more
               contiguous blanks, unless the decimal edit mode is COMMA, in which case a semicolon is used in place of
               the comma,
              • a slash optionally preceded by one or more contiguous blanks and optionally followed by one or more
               contiguous blanks, or
              • one or more contiguous blanks between two nonblank values or following the last nonblank value, where a
               nonblank value is a constant, an r*c form, or an r* form.
           c
           ISO/IEC 2017 – All rights reserved                                                 283
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE13.26
                  Although a slash encountered in an input record is referred to as a separator, it actually causes termination
                  of list-directed and namelist input statements; it does not actually separate two values.
                  NOTE13.27
                  If no list items are speciﬁed in a list-directed input/output statement, one input record is skipped or one
                  empty output record is written.
             13.10.3    List-directed input
             13.10.3.1  List-directed input forms
          1 Input forms acceptable to edit descriptors for a given type are acceptable for list-directed formatting, except as
             noted below. If the form of the input value is not acceptable to the processor for the type of the next eﬀective
             item in the list, an error condition occurs. Blanks are never used as zeros, and embedded blanks are not permitted
             in constants, except within character constants and complex constants as speciﬁed below.
          2 For the r*c form of an input value, the constant c is interpreted as an undelimited character constant if the ﬁrst
             list item corresponding to this value is default, ASCII, or ISO 10646 character, there is a nonblank character
             immediately after r*, and that character is not an apostrophe or a quotation mark; otherwise, c is interpreted as
             a literal constant.
                  NOTE13.28
                  The end of a record has the eﬀect of a blank, except when it appears within a character constant.
          3 When the next eﬀective item is of type integer, the value in the input record is interpreted as if an Iw edit
             descriptor with a suitable value of w were used.
          4 Whenthenexteﬀective item is of type real, the input form is that of a numeric input ﬁeld. A numeric input ﬁeld
             is a ﬁeld suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless a decimal symbol
             appears within the ﬁeld.
          5 When the next eﬀective item is of type complex, the input form consists of a left parenthesis followed by an
             ordered pair of numeric input ﬁelds separated by a comma (if the decimal edit mode is POINT) or semicolon
             (if the decimal edit mode is COMMA), and followed by a right parenthesis. The ﬁrst numeric input ﬁeld is the
             real part of the complex constant and the second is the imaginary part. Each of the numeric input ﬁelds may be
             preceded or followed by any number of blanks and ends of records. The end of a record may occur after the real
             part or before the imaginary part.
          6 When the next eﬀective item is of type logical, the input form shall not include value separators among the
             optional characters permitted for L editing.
          7 Whenthenexteﬀective item is of type character, the input form consists of a possibly delimited sequence of zero
             or more rep-chars whose kind type parameter is implied by the kind of the eﬀective item. Character sequences
             may be continued from the end of one record to the beginning of the next record, but the end of record shall
             not occur between a doubled apostrophe in an apostrophe-delimited character sequence, nor between a doubled
             quote in a quote-delimited character sequence. The end of the record does not cause a blank or any other
             character to become part of the character sequence. The character sequence may be continued on as many
             records as needed. The characters blank, comma, semicolon, and slash may appear in default, ASCII, or ISO
             10646 character sequences.
          8 If the next eﬀective item is default, ASCII, or ISO 10646 character and
                • the character sequence does not contain value separators,
                • the character sequence does not cross a record boundary,
                • the ﬁrst nonblank character is not a quotation mark or an apostrophe,
                                                                          c
             284                                                         ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                • the leading characters are not digits followed by an asterisk, and
                • the character sequence contains at least one character,
             the delimiting apostrophes or quotation marks are not required. If the delimiters are omitted, the character
             sequence is terminated by the ﬁrst blank, comma (if the decimal edit mode is POINT), semicolon (if the decimal
             edit mode is COMMA), slash, or end of record; in this case apostrophes and quotation marks within the datum
             are not to be doubled.
          9 Let len be the current length of the next eﬀective item, and let w be the length of the character sequence. If len
             is less than or equal to w, the leftmost len characters of the sequence are transmitted to the next eﬀective item.
             If len is greater than w, the sequence is transmitted to the leftmost w characters of the next eﬀective item and
             the remaining len−w characters of the next eﬀective item are ﬁlled with blanks.
                  NOTE13.29
                  An allocatable, deferred-length character eﬀective item does not have its allocation status or allocated
                  length changed as a result of list-directed input.
             13.10.3.2  Null values
          1 Anull value is speciﬁed by
                • the r* form,
                • no characters between consecutive value separators, or
                • no characters before the ﬁrst value separator in the ﬁrst record read by each execution of a list-directed
                  input statement.
                  NOTE13.30
                  Theendofarecordfollowing any other value separator, with or without separating blanks, does not specify
                  a null value in list-directed input.
          2 A null value has no eﬀect on the deﬁnition status of the next eﬀective item. A null value shall not be used for
             either the real or imaginary part of a complex constant, but a single null value may represent an entire complex
             constant.
          3 A slash encountered as a value separator during execution of a list-directed input statement causes termination
             of execution of that input statement after the transference of the previous value. Any characters remaining in the
             current record are ignored. If there are additional items in the input list, the eﬀect is as if null values had been
             supplied for them. Any do-variable in the input list becomes deﬁned as if enough null values had been supplied
             for any remaining input list items.
                  NOTE13.31
                  All blanks encountered during list-directed input are considered to be part of some value separator except
                  for
                     • blanks embedded in a character sequence,
                     • embedded blanks surrounding the real or imaginary part of a complex constant, and
                     • leading blanks in the ﬁrst record read by each execution of a list-directed input statement, unless
                       immediately followed by a slash or comma.
                  NOTE13.32
                  List-directed input example:
                         INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
                         ...
                         READ *, I, X, P, Z, G
              c
             ISO/IEC 2017 – All rights reserved                                                                  285
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE13.32 (cont.)
                  The input data records are:
                  12345,12345,,2*1.5,4*
                  ISN’T_BOB’S,(123,0),.TEXAS$
                  The results are:
                          Variable                       Value
                          I                              12345
                          X(1)                           12345.0
                          X(2)                           unchanged
                          X(3)                           1.5
                          X(4)                           1.5
                          X(5) – X (8)                   unchanged
                          P                              ISN’T_BOB’S
                          Z                              (123.0,0.0)
                          G                              true
             13.10.4     List-directed output
           1 The form of the values produced is the same as that required for input, except as noted otherwise. With the
             exception of adjacent undelimited character sequences, the values are separated by one or more blanks or by a
             comma, or a semicolon if the decimal edit mode is COMMA, optionally preceded by one or more blanks and
             optionally followed by one or more blanks. Two undelimited character sequences are considered adjacent when
             both were written using list-directed input/output, no intervening data transfer or ﬁle positioning operations on
             that unit occurred, and both were written either by a single data transfer statement, or during the execution of
             a parent data transfer statement along with its child data transfer statements. The form of the values produced
             by deﬁned output (12.6.4.8) is determined by the deﬁned output procedure; this form need not be compatible
             with list-directed input.
           2 Theprocessor may begin new records as necessary, but the end of record shall not occur within a constant except
             as speciﬁed for complex constants and character sequences. The processor shall not insert blanks within character
             sequences or within constants, except as speciﬁed for complex constants.
           3 Logical output values are T for the value true and F for the value false.
           4 Integer output constants are produced with the eﬀect of an Iw edit descriptor.
           5 Real constants are produced with the eﬀect of either an F edit descriptor or an E edit descriptor, depending on
                                                        d1          d2
             the magnitude x of the value and a range 10   ≤x<10 ,whered andd are processor-dependent integers. If
                                                                              1       2
             the magnitude x is within this range or is zero, the constant is produced using 0PFw.d; otherwise, 1PEw.d Ee is
             used.
           6 For numeric output, reasonable processor-dependent values of w, d, and e are used for each of the numeric
             constants output.
           7 Complex constants are enclosed in parentheses with a separator between the real and imaginary parts, each
             produced as deﬁned above for real constants. The separator is a comma if the decimal edit mode is POINT; it
             is a semicolon if the decimal edit mode is COMMA. The end of a record may occur between the separator and
             the imaginary part only if the entire constant is as long as, or longer than, an entire record. The only embedded
             blanks permitted within a complex constant are between the separator and the end of a record and one blank at
             the beginning of the next record.
           8 Character sequences produced when the delimiter mode has a value of NONE
                 • are not delimited by apostrophes or quotation marks,
                                                                            c
             286                                                           ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
             • are not separated from each other by value separators,
             • have each internal apostrophe or quotation mark represented externally by one apostrophe or quotation
               mark, and
             • have a blank character inserted by the processor at the beginning of any record that begins with the
               continuation of a character sequence from the preceding record.
        9 Character sequences produced when the delimiter mode has a value of QUOTE are delimited by quotes, are
           preceded and followed by a value separator, and have each internal quote represented on the external medium by
           two contiguous quotes.
        10 Character sequences produced when the delimiter mode has a value of APOSTROPHE are delimited by apo-
           strophes, are preceded and followed by a value separator, and have each internal apostrophe represented on the
           external medium by two contiguous apostrophes.
        11 Iftwoormoresuccessivevaluesinanoutputrecordhaveidenticalvalues, theprocessorhastheoptionofproducing
           a repeated constant of the form r*c instead of the sequence of identical values.
        12 Slashes, as value separators, and null values are not produced as output by list-directed formatting.
        13 Except for new records created by explicit formatting within a deﬁned output procedure or by continuation of
           delimited character sequences, each output record begins with a blank character.
              NOTE13.33
              The length of the output records is not speciﬁed and is processor dependent.
           13.11    Namelist formatting
           13.11.1  Purpose of namelist formatting
        1 Namelistinput/output allows data editing with name-value subsequences. This facilitates documentation of input
           and output ﬁles and more ﬂexibility on input.
           13.11.2  Name-value subsequences
        1 The characters in one or more namelist records constitute a sequence of name-value subsequences, each of which
           consists of an object designator followed by an equals and followed by one or more values and value separators.
           Theequals may optionally be preceded or followed by one or more contiguous blanks. The end of a record has the
           sameeﬀect as a blank character, unless it is within a character constant. Any sequence of two or more consecutive
           blanks is treated as a single blank, unless it is within a character constant.
        2 Each object designator shall begin with a name from the namelist-group-object-list (8.9) and shall follow the
           syntax of designator (R901). It shall not contain a vector subscript or an image-selector and shall not designate a
           zero-sized array, a zero-sized array section, or a zero-length character string. Each subscript, stride, and substring
           range expression shall be an optionally signed integer literal constant with no kind type parameter speciﬁed. If
           a section subscript list appears, the number of section subscripts shall be equal to the rank of the object. If
           the namelist group object is of derived type, the designator in the input record may be either the name of the
           variable or the designator of one of its components, indicated by qualifying the variable name with the appropriate
           component name. Successive qualiﬁcations may be applied as appropriate to the shape and type of the variable
           represented. Each designator may be preceded and followed by one or more optional blanks but shall not contain
           embedded blanks.
        3 A value separator for namelist formatting is the same as for list-directed formatting (13.10.2), or one or more
           contiguous blanks between a nonblank value and the following object designator or namelist comment (13.11.3.6).
           c
           ISO/IEC 2017 – All rights reserved                                               287
             ISO/IEC DIS 1539-1:2017 (E)
             13.11.3    Namelist input
             13.11.3.1  Overall syntax
          1 Input for a namelist input statement consists of
                   (1)   optional blanks and namelist comments,
                   (2)   the character & followed immediately by the namelist-group-name as speciﬁed in the NAMELIST
                         statement,
                   (3)   one or more blanks,
                   (4)   a sequence of zero or more name-value subsequences separated by value separators, and
                   (5)   a slash to terminate the namelist input.
                  NOTE13.34
                  Aslash encountered in a namelist input record causes the input statement to terminate. A slash cannot be
                  used to separate two values in a namelist input statement.
          2 The order of the name-value subsequences in the input records need not match the order of the namelist-group-
             object-list. The input records need not specify all objects in the namelist-group-object-list. They may specify a
             part of an object more than once.
          3 Agroup name or object name is without regard to case.
             13.11.3.2  Namelist input processing
          1 The name-value subsequences are evaluated serially, in left-to-right order. A namelist group object designator
             may appear in more than one name-value subsequence. The deﬁnition status of an object that is not a subobject
             of a designator in any name-value subsequence remains unchanged.
          2 When the designator in the input record represents an array variable or a variable of derived type, the eﬀect is
             as if the variable represented were expanded into a sequence of scalar list items, in the same way that formatted
             input/output list items are expanded (12.6.3). The number of values following the equals shall not exceed the
             number of list items in the expanded sequence, but may be less; in the latter case, the eﬀect is as if suﬃcient
             null values had been appended to match any remaining list items in the expanded sequence. Except as noted
             elsewhere in this subclause, if an input value is not acceptable to the processor for the type of the list item in the
             corresponding position in the expanded sequence, an error condition occurs.
                  NOTE13.35
                  For example, if the designator in the input record designates an integer array of size 100, at most 100
                  values, each of which is either a digit string or a null value, can follow the equals; these values would then
                  be assigned to the elements of the array in array element order.
          3 A slash encountered as a value separator during the execution of a namelist input statement causes termination
             of execution of that input statement after transference of the previous value. If there are additional items in the
             namelist group object being transferred, the eﬀect is as if null values had been supplied for them.
          4 Successive namelist records are read by namelist input until a slash is encountered; the remainder of the record
             is ignored.
          5 A namelist comment may appear after any value separator except a slash (which terminates namelist input). A
             namelist comment is also permitted to start in the ﬁrst nonblank position of an input record except within a
             character literal constant.
             13.11.3.3  Namelist input values
          1 Each value is either a null value (13.11.3.4), c, r*c, or r*, where c is a literal constant, optionally signed if integer
             or real, and r is an unsigned, nonzero, integer literal constant. A kind type parameter shall not be speciﬁed for c
                                                                          c
             288                                                         ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
             or r. The constant c is interpreted as though it had the same kind type parameter as the corresponding eﬀective
             item. The r*c form is equivalent to r successive appearances of the constant c, and the r* form is equivalent to r
             successive null values. Neither of these forms may contain embedded blanks, except where permitted within the
             constant c.
          2 Thedatumc(13.11)isanyinputvalueacceptabletoformatspeciﬁcationsforagiventype, except for a restriction
             on the form of input values corresponding to list items of types logical, integer, and character as speciﬁed in this
             subclause. The form of a real or complex value is dependent on the decimal edit mode in eﬀect (13.6). The form
             of an input value shall be acceptable for the type of the namelist group object list item. The number and forms
             of the input values that may follow the equals in a name-value subsequence depend on the shape and type of
             the object represented by the name in the input record. When the name in the input record is that of a scalar
             variable of an intrinsic type, the equals shall not be followed by more than one value. Blanks are never used
             as zeros, and embedded blanks are not permitted in constants except within character constants and complex
             constants as speciﬁed in this subclause.
          3 Whenthe next eﬀective item is of type real, the input form of the input value is that of a numeric input ﬁeld. A
             numeric input ﬁeld is a ﬁeld suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless
             a decimal symbol appears within the ﬁeld.
          4 When the next eﬀective item is of type complex, the input form of the input value consists of a left parenthesis
             followed by an ordered pair of numeric input ﬁelds separated by a comma (if the decimal edit mode is POINT) or
             a semicolon (if the decimal edit mode is COMMA), and followed by a right parenthesis. The ﬁrst numeric input
             ﬁeld is the real part of the complex constant and the second ﬁeld is the imaginary part. Each of the numeric
             input ﬁelds may be preceded or followed by any number of blanks and ends of records. The end of a record may
             occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary
             part.
          5 Whenthenext eﬀective item is of type logical, the input form of the input value shall not include equals or value
             separators among the optional characters permitted for L editing (13.7.3).
          6 When the next eﬀective item is of type integer, the value in the input record is interpreted as if an Iw edit
             descriptor with a suitable value of w were used.
          7 Whenthenext eﬀective item is of type character, the input form consists of a sequence of zero or more rep-chars
             whose kind type parameter is implied by the kind of the corresponding list item, delimited by apostrophes or
             quotes. Such a sequence may be continued from the end of one record to the beginning of the next record, but the
             end of record shall not occur between a doubled apostrophe in an apostrophe-delimited sequence, nor between a
             doubled quote in a quote-delimited sequence. The end of the record does not cause a blank or any other character
             to become part of the sequence. The sequence may be continued on as many records as needed. The characters
             blank, comma, semicolon, and slash may appear in such character sequences.
                  NOTE13.36
                  The delimiters in the input form for a namelist input item of type character avoid the ambiguity that could
                  arise between undelimited character sequences and object names. The value of the DELIM= speciﬁer, if
                  any, in the OPEN statement for an external ﬁle is ignored during namelist input (12.5.6.8).
          8 Let len be the length of the next eﬀective item, and let w be the length of the character sequence. If len is less
             than or equal to w, the leftmost len characters of the sequence are transmitted to the next eﬀective item. If len
             is greater than w, the constant is transmitted to the leftmost w characters of the next eﬀective item and the
             remaining len−w characters of the next eﬀective item are ﬁlled with blanks. The eﬀect is as though the sequence
             were assigned to the next eﬀective item in an intrinsic assignment statement (10.2.1.3).
             13.11.3.4  Null values
          1 Anull value is speciﬁed by
                • the r* form,
              c
             ISO/IEC 2017 – All rights reserved                                                                  289
             ISO/IEC DIS 1539-1:2017 (E)
                • blanks between two consecutive nonblank value separators following an equals,
                • a value separator that is the ﬁrst nonblank character following an equals, or
                • two consecutive nonblank value separators.
          2 A null value has no eﬀect on the deﬁnition status of the corresponding input list item. If the namelist group
             object list item is deﬁned, it retains its previous value; if it is undeﬁned, it remains undeﬁned. A null value shall
             not be used as either the real or imaginary part of a complex constant, but a single null value may represent an
             entire complex constant.
                  NOTE13.37
                  The end of a record following a value separator, with or without intervening blanks, does not specify a null
                  value in namelist input.
             13.11.3.5  Blanks
          1 All blanks in a namelist input record are considered to be part of some value separator except for
                • blanks embedded in a character constant,
                • embedded blanks surrounding the real or imaginary part of a complex constant,
                • leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the
                  decimal edit mode is COMMA, and
                • blanks between a name and the following equals.
             13.11.3.6  Namelist comments
          1 Except within a character literal constant, a “!” character after a value separator or in the ﬁrst nonblank position
             of a namelist input record initiates a comment. The comment extends to the end of the record and may contain
             any graphic character in the processor-dependent character set. The comment is ignored. A slash within the
             namelist comment does not terminate execution of the namelist input statement. Namelist comments are not
             allowed in stream input because comments depend on record structure.
                  NOTE13.38
                  Namelist input example:
                  INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
                  NAMELIST / TODAY / G, I, P, Z, X
                  READ (*, NML = TODAY)
                  The input data records are:
                  &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5, I=6, ! This is a comment.
                  P = ’’ISN’T_BOB’S’’, Z = (123,0)/
                  The results stored are:
                         Variable                      Value
                         I                             6
                         X(1)                          12345.0
                         X(2)                          unchanged
                         X(3)                          1.5
                         X(4)                          1.5
                         X(5) – X (8)                  unchanged
                         P                             ISN’T_BOB’S
                         Z                             (123.0,0.0)
                         G                             unchanged
                                                                          c
             290                                                         ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
             13.11.4    Namelist output
             13.11.4.1  Form of namelist output
          1 The form of the output produced by intrinsic namelist output shall be suitable for input, except for character
             output. The names in the output are in upper case. With the exception of adjacent undelimited character
             values, the values are separated by one or more blanks or by a comma, or a semicolon if the decimal edit mode is
             COMMA,optionally preceded by one or more blanks and optionally followed by one or more blanks. The form
             of the output produced by deﬁned output (12.6.4.8) is determined by the deﬁned output procedure; this form
             need not be compatible with namelist input.
          2 Namelist output shall not include namelist comments.
          3 The processor may begin new records as necessary. However, except for complex constants and character values,
             the end of a record shall not occur within a constant, character value, or name, and blanks shall not appear
             within a constant, character value, or name.
                  NOTE13.39
                  The length of the output records is not speciﬁed exactly and is processor dependent.
             13.11.4.2  Namelist output editing
          1 Values in namelist output records are edited as for list-directed output (13.10.4).
                  NOTE13.40
                  Namelist output records produced with a DELIM= speciﬁer with a value of NONE and which contain a
                  character sequence might not be acceptable as namelist input records.
             13.11.4.3  Namelist output records
          1 If two or more successive values for the same namelist group item in an output record produced have identical
             values, the processor has the option of producing a repeated constant of the form r*c instead of the sequence of
             identical values.
          2 The name of each namelist group object list item is placed in the output record followed by an equals and a list
             of values of the namelist group object list item.
          3 Anampersand character followed immediately by a namelist-group-name is placed at the start of the ﬁrst output
             record to indicate which particular group of data objects is being output. A slash is placed in the output record
             to indicate the end of the namelist formatting.
          4 Anull value is not produced by namelist formatting.
          5 Except for new records created by explicit formatting within a deﬁned output procedure or by continuation of
             delimited character sequences, each output record begins with a blank character.
              c
             ISO/IEC 2017 – All rights reserved                                                                  291
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      292                          ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                14 Program units
                14.1       Main program
            1 A Fortran main program is a program unit that does not contain a SUBROUTINE, FUNCTION, MODULE,
                SUBMODULE,orBLOCKDATA statement as its ﬁrst statement.
                R1401 main-program                        is  [ program-stmt ]
                                                                   [ speciﬁcation-part ]
                                                                   [ execution-part ]
                                                                   [ internal-subprogram-part ]
                                                                   end-program-stmt
                R1402 program-stmt                        is  PROGRAMprogram-name
                R1403 end-program-stmt                    is  END[PROGRAM[program-name ] ]
                C1401 (R1401) The program-name may be included in the end-program-stmt only if the optional program-stmt
                         is used and, if included, shall be identical to the program-name speciﬁed in the program-stmt.
                     NOTE14.1
                     Theprogramnameisglobaltotheprogram(19.2). For explanatory information about uses for the program
                     name, see subclause C.9.1.
                     NOTE14.2
                     An example of a main program is:
                     PROGRAM ANALYZE
                         REAL A, B, C (10,10)              !   Specification part
                         CALL FIND                         !   Execution part
                     CONTAINS
                         SUBROUTINE FIND                   !   Internal subprogram
                               ...
                         END SUBROUTINE FIND
                     END PROGRAM ANALYZE
            2 The main program may be deﬁned by means other than Fortran; in that case, the program shall not contain a
                main-program program unit.
            3 Areference to a Fortran main-program shall not appear in any program unit in the program, including itself.
                14.2       Modules
                14.2.1      Module syntax and semantics
            1 Amodulecontains declarations, speciﬁcations, and deﬁnitions. Public identiﬁers of module entities are accessible
                to other program units by use association as speciﬁed in 14.2.2. A module that is provided as an inherent part
                of the processor is an intrinsic module. A nonintrinsic module is deﬁned by a module program unit or a means
                other than Fortran.
            2 Procedures and types deﬁned in an intrinsic module are not themselves intrinsic.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       293
                ISO/IEC DIS 1539-1:2017 (E)
                R1404 module                              is  module-stmt
                                                                   [ speciﬁcation-part ]
                                                                   [ module-subprogram-part ]
                                                                   end-module-stmt
                R1405 module-stmt                         is  MODULEmodule-name
                R1406 end-module-stmt                     is  END[MODULE[module-name ] ]
                R1407 module-subprogram-part              is  contains-stmt
                                                                   [ module-subprogram ] ...
                R1408 module-subprogram                   is  function-subprogram
                                                          or subroutine-subprogram
                                                          or separate-module-subprogram
                C1402 (R1404) If the module-name is speciﬁed in the end-module-stmt, it shall be identical to the module-name
                         speciﬁed in the module-stmt.
                C1403 (R1404) A module speciﬁcation-part shall not contain a stmt-function-stmt, an entry-stmt, or a format-stmt.
            3 If a procedure declared in the scoping unit of a module has an implicit interface, it shall be given the EXTERNAL
                attribute in that scoping unit; if it is a function, its type and type parameters shall be explicitly declared in a
                type declaration statement in that scoping unit.
            4 If an intrinsic procedure is declared in the scoping unit of a module, it shall explicitly be given the INTRINSIC
                attribute in that scoping unit or be used as an intrinsic procedure in that scoping unit.
                     NOTE14.3
                     The module name is global to the program (19.2).
                     NOTE14.4
                     Although statement function deﬁnitions, ENTRY statements, and FORMAT statements cannot appear in the spe-
                     ciﬁcation part of a module, they can appear in the speciﬁcation part of a module subprogram in the module.
                     NOTE14.5
                     For a discussion of the impact of modules on dependent compilation, see subclause C.9.2.
                     NOTE14.6
                     For examples of the use of modules, see subclause C.9.3.
                14.2.2      The USE statement and use association
            1 The USE statement speciﬁes use association. A USE statement is a reference to the module it speciﬁes. At the
                time a USE statement is processed, the public portions of the speciﬁed module shall be available. A module shall
                not reference itself, either directly or indirectly.
            2 The USE statement provides the means by which a scoping unit accesses named data objects, derived types,
                procedures, abstract interfaces, generic identiﬁers, and namelist groups in a module. The entities in the scoping
                unit are use associated with the entities in the module. The accessed entities have the attributes speciﬁed
                in the module, except that an accessed entity may have a diﬀerent accessibility attribute, it may have the
                ASYNCHRONOUSattributeevenif the associated module entity does not, and if it is not a coarray it may have
                the VOLATILEattributeeveniftheassociatedmoduleentitydoesnot. Theentitiesmadeaccessibleareidentiﬁed
                by the names or generic identiﬁers used to identify them in the module. By default, the accessed entities are
                identiﬁed by the same identiﬁers in the scoping unit containing the USE statement, but it is possible to specify
                                                                                         c
                294                                                                      ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                that diﬀerent identiﬁers are used. A use-associated variable is considered to have been previously declared; any
                other use-associated entity is considered to have been previously deﬁned.
                     NOTE14.7
                     The accessibility of module entities can be controlled by accessibility attributes (7.5.2.2, 8.5.2), and the
                     ONLYoptionoftheUSEstatement. Deﬁnability of module entities can be controlled by the PROTECTED
                     attribute (8.5.15).
                R1409 use-stmt                            is  USE [ [ , module-nature ] :: ] module-name [ , rename-list ]
                                                          or USE [ [ , module-nature ] :: ] module-name ,
                                                                 ONLY:[only-list ]
                R1410 module-nature                       is  INTRINSIC
                                                          or NON_INTRINSIC
                R1411 rename                              is  local-name => use-name
                                                          or OPERATOR(local-deﬁned-operator) =>
                                                                 OPERATOR(use-deﬁned-operator)
                R1412 only                                is  generic-spec
                                                          or only-use-name
                                                          or rename
                R1413 only-use-name                       is  use-name
                C1404 (R1409) If module-nature is INTRINSIC, module-name shall be the name of an intrinsic module.
                C1405 (R1409)Ifmodule-nature is NON_INTRINSIC,module-name shallbethenameofanonintrinsicmodule.
                C1406 (R1409) A scoping unit shall not directly reference an intrinsic module and a nonintrinsic module of the
                         same name.
                C1407 (R1411) OPERATOR (use-deﬁned-operator) shall not identify a type-bound generic interface.
                C1408 (R1412) The generic-spec shall not identify a type-bound generic interface.
                     NOTE14.8
                     Constraints C1407 and C1408 do not prevent accessing a generic-spec that is declared by an interface block,
                     even if a type-bound generic interface has the same generic-spec.
                C1409 Each generic-spec, use-name, and use-deﬁned-operator in a USE statement shall be a public identiﬁer of
                         the module.
                C1410 An only-use-name shall be a nongeneric name.
                R1414 local-deﬁned-operator               is  deﬁned-unary-op
                                                          or deﬁned-binary-op
                R1415 use-deﬁned-operator                 is  deﬁned-unary-op
                                                          or deﬁned-binary-op
            3 A use-stmt without a module-nature provides access either to an intrinsic or to a nonintrinsic module. If the
                module-name is the name of both an intrinsic and a nonintrinsic module, the nonintrinsic module is accessed.
            4 The USE statement without the ONLY option provides access to all public entities in the speciﬁed module.
            5 A USE statement with the ONLY option provides access only to those entities that appear as generic-specs,
                use-names, or use-deﬁned-operators in the only-list.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       295
          ISO/IEC DIS 1539-1:2017 (E)
        6 MorethanoneUSEstatementforagivenmodulemayappearinaspeciﬁcationpart. IfoneoftheUSEstatements
          is without an ONLY option, all public entities in the module are accessible. If all the USE statements have ONLY
          options, only those entities in one or more of the only-lists are accessible.
        7 An accessible entity in the referenced module is associated with one or more accessed entities, each with its own
          identiﬁer. These identiﬁers are
            • the identiﬁer of the entity in the referenced module if that identiﬁer appears as an only-use-name or as the
              deﬁned-operator of a generic-spec in any only for that module,
            • each of the local-names or local-deﬁned-operators that the entity is given in any rename for that module,
              and
            • the identiﬁer of the entity in the referenced module if that identiﬁer does not appear as a use-name or
              use-deﬁned-operator in any rename for that module.
        8 An ultimate entity is a module entity that is not accessed by use association. An accessed entity shall not be
          associated with two or more ultimate entities unless its identiﬁer is not used, or the ultimate entities are generic
          interfaces. Generic interfaces are handled as described in 15.4.3.4.
             NOTE14.9
             There is no prohibition against a use-name or use-deﬁned-operator appearing multiple times in one USE
             statement or in multiple USE statements involving the same module. As a result, it is possible for one
             use-associated entity to be accessible by more than one local identiﬁer.
        9 The local identiﬁer of an entity made accessible by a USE statement shall not appear in any other nonexecutable
          statement that would cause any attribute (8.5) of the entity to be speciﬁed in the scoping unit that contains the
          USEstatement, except that it may appear in a PUBLIC or PRIVATE statement in the scoping unit of a module
          and it may be given the ASYNCHRONOUS or VOLATILE attribute.
       10 An entity in a scoping unit that is accessed by use association through more than one use path, has the ASYN-
          CHRONOUSorVOLATILEattribute in any of those use paths, and is not given that attribute in that scoping
          unit, shall have that attribute in all use paths.
             NOTE14.10
             The constraints in subclauses 8.10.1, 8.10.2, and 8.9 prohibit the local-name from appearing as a common-
             block-object in a COMMON statement, an equivalence-object in an EQUIVALENCE statement, or a namelist-group-name
             in a NAMELIST statement, respectively. There is no prohibition against the local-name appearing as a
             common-block-name or a namelist-group-object.
             NOTE14.11
             For a discussion of the impact of the ONLY option and renaming on dependent compilation, see subclause
             C.9.2.1.
             NOTE14.12
             Examples:
             USE STATS_LIB
             provides access to all public entities in the module STATS_LIB.
             USE MATH_LIB; USE STATS_LIB, SPROD => PROD
             provides access to all public identiﬁers in both MATH_LIB and STATS_LIB. If MATH_LIB contains an
             entity named PROD, it can be accessed by that name, while the entity PROD of STATS_LIB can be
             accessed by the name SPROD.
                                                        c
          296                                           ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                     NOTE14.12 (cont.)
                     USE STATS_LIB, ONLY: YPROD; USE STATS_LIB, ONLY : PROD
                     provides access to YPROD and PROD in STAT_LIB.
                     USE STATS_LIB, ONLY : YPROD; USE STATS_LIB
                     provides access to all public identiﬁers in STAT_LIB.
                14.2.3      Submodules
            1 Asubmodule is a program unit that extends a module or another submodule. The program unit that it extends
                is its host, and is speciﬁed by the parent-identiﬁer in the submodule-stmt.
            2 Amodule or submodule is an ancestor program unit of all of its descendants, which are its submodules and their
                descendants. The submodule identiﬁer is the ordered pair whose ﬁrst element is the ancestor module name and
                whose second element is the submodule name; the submodule name by itself is not a local or global identiﬁer.
                     NOTE14.13
                     Amodule and its submodules stand in a tree-like relationship one to another, with the module at the root.
                     Therefore, a submodule has exactly one ancestor module and can have one or more ancestor submodules.
            3 A submodule may provide implementations for separate module procedures (15.6.2.5), each of which is declared
                (15.4.3.2) within that submodule or one of its ancestors, and declarations and deﬁnitions of other entities that
                are accessible by host association in its descendants.
                R1416 submodule                           is  submodule-stmt
                                                                    [ speciﬁcation-part ]
                                                                    [ module-subprogram-part ]
                                                                   end-submodule-stmt
                R1417 submodule-stmt                      is  SUBMODULE(parent-identiﬁer ) submodule-name
                R1418 parent-identiﬁer                    is  ancestor-module-name [ : parent-submodule-name ]
                R1419 end-submodule-stmt                  is  END[SUBMODULE[submodule-name ] ]
                C1411 (R1416) A submodule speciﬁcation-part shall not contain a format-stmt, entry-stmt, or stmt-function-stmt.
                C1412 (R1418) The ancestor-module-name shall be the name of a nonintrinsic module that declares a separate
                         module procedure; the parent-submodule-name shall be the name of a descendant of that module.
                C1413 (R1416) If a submodule-name appears in the end-submodule-stmt, it shall be identical to the one in the
                         submodule-stmt.
                14.3       Block data program units
            1 Ablock data program unit is used to provide initial values for data objects in named common blocks.
                R1420    block-data                       is  block-data-stmt
                                                                   [ speciﬁcation-part ]
                                                                   end-block-data-stmt
                R1421    block-data-stmt                  is  BLOCKDATA[block-data-name ]
                R1422    end-block-data-stmt              is  END[BLOCKDATA[block-data-name ] ]
                C1414    (R1420) The block-data-name shall be included in the end-block-data-stmt only if it was provided in the block-data-stmt
                         and, if included, shall be identical to the block-data-name in the block-data-stmt.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       297
             ISO/IEC DIS 1539-1:2017 (E)
             C1415   (R1420) A block-data speciﬁcation-part shall contain only derived-type deﬁnitions and ASYNCHRONOUS, BIND, COM-
                     MON, DATA, DIMENSION, EQUIVALENCE, IMPLICIT, INTRINSIC, PARAMETER, POINTER, SAVE, TARGET,
                     USE, VOLATILE, and type declaration statements.
             C1416   (R1420) A type declaration statement in a block-data speciﬁcation-part shall not contain ALLOCATABLE, EXTERNAL,
                     or BIND attribute speciﬁers.
          2 If an object in a named common block is initially deﬁned, all storage units in the common block storage sequence shall be speciﬁed
             even if they are not all initially deﬁned. More than one named common block may have objects initially deﬁned in a single block
             data program unit.
          3 Only an object in a named common block may be initially deﬁned in a block data program unit.
          4 The same named common block shall not be speciﬁed in more than one block data program unit in a program.
          5 There shall not be more than one unnamed block data program unit in a program.
                                                                           c
             298                                                          ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             15 Procedures
             15.1      Concepts
          1 The concept of a procedure was introduced in 5.2.3. This clause contains a complete description of procedures.
             The actions speciﬁed by a procedure are performed when the procedure is invoked by execution of a reference to
             it.
          2 The sequence of actions encapsulated by a procedure has access to entities in the procedure reference by way of
             argument association (15.5.2). A name that appears as a dummy-arg-name in the SUBROUTINE, FUNCTION,
             or ENTRY statement in the declaration of a procedure (R1536) is a dummy argument. Dummy arguments are
             also speciﬁed for intrinsic procedures and procedures in intrinsic modules in Clauses 16, 17, and 18.
             15.2      Procedure classiﬁcations
             15.2.1     Procedure classiﬁcation by reference
          1 Thedeﬁnition of a procedure speciﬁes it to be a function or a subroutine. A reference to a function either appears
             explicitly as a primary within an expression, or is implied by a deﬁned operation (10.1.6) within an expression.
             Areference to a subroutine is a CALL statement, a deﬁned assignment statement (10.2.1.4), the appearance of
             an object processed by deﬁned input/output (12.6.4.8) in an input/output list, or ﬁnalization (7.5.6).
          2 Aprocedure is classiﬁed as elemental if it is a procedure that may be referenced elementally (15.8).
             15.2.2     Procedure classiﬁcation by means of deﬁnition
             15.2.2.1   Intrinsic procedures
          1 Aprocedure that is provided as an inherent part of the processor is an intrinsic procedure.
             15.2.2.2   External, internal, and module procedures
          1 Anexternalprocedure is a procedure that is deﬁned by an external subprogram or by a means other than Fortran.
          2 An internal procedure is a procedure that is deﬁned by an internal subprogram. Internal subprograms may
             appear in the main program, in an external subprogram, or in a module subprogram. Internal subprograms shall
             not appear in other internal subprograms. Internal subprograms are the same as external subprograms except
             that the name of the internal procedure is not a global identiﬁer, an internal subprogram shall not contain an ENTRY
             statement, and the internal subprogram has access to host entities by host association.
          3 Amodule procedure is a procedure that is deﬁned by a module subprogram.
          4 A subprogram deﬁnes a procedure for the SUBROUTINE or FUNCTION statement. If the subprogram has one or
             more ENTRY statements, it also deﬁnes a procedure for each of them.
             15.2.2.3   Dummy procedures
          1 A dummy argument that is speciﬁed to be a procedure or appears as the procedure designator in a procedure
             reference is a dummy procedure. A dummy procedure with the POINTER attribute is a dummy procedure
             pointer.
              c
             ISO/IEC 2017 – All rights reserved                                                                     299
             ISO/IEC DIS 1539-1:2017 (E)
             15.2.2.4   Procedure pointers
          1 A procedure pointer is a procedure that has the EXTERNAL and POINTER attributes; it may be pointer
             associated with an external procedure, an internal procedure, an intrinsic procedure, a module procedure, or a
             dummy procedure that is not a procedure pointer.
             15.2.2.5   Statement functions
          1 Afunction that is deﬁned by a single statement is a statement function (15.6.4).
             15.3      Characteristics
             15.3.1     Characteristics of procedures
          1 The characteristics of a procedure are the classiﬁcation of the procedure as a function or subroutine, whether it
             is pure, whether it is elemental, whether it has the BIND attribute, the characteristics of its dummy arguments,
             and the characteristics of its function result if it is a function.
             15.3.2     Characteristics of dummy arguments
             15.3.2.1   General
          1 Each dummy argument has the characteristic that it is a dummy data object, a dummy procedure, or an asterisk
             (alternate return indicator).
             15.3.2.2   Characteristics of dummy data objects
          1 The characteristics of a dummy data object are its declared type, its type parameters, its shape (unless it is
             assumed-rank), its corank, its codimensions, its intent (8.5.10, 8.6.9), whether it is optional (8.5.12, 8.6.10),
             whether it is allocatable (8.5.3), whether it has the ASYNCHRONOUS (8.5.4), CONTIGUOUS (8.5.7), VALUE
             (8.5.18), or VOLATILE (8.5.19) attributes, whether it is polymorphic, and whether it is a pointer (8.5.14, 8.6.12)
             or a target (8.5.17, 8.6.15). If a type parameter of an object or a bound of an array is not a constant expression,
             the exact dependence on the entities in the expression is a characteristic. If a rank, shape, size, type, or type
             parameter is assumed or deferred, it is a characteristic.
             15.3.2.3   Characteristics of dummy procedures
          1 The characteristics of a dummy procedure are the explicitness of its interface (15.4.2), its characteristics as a
             procedure if the interface is explicit, whether it is a pointer, and whether it is optional (8.5.12, 8.6.10).
             15.3.2.4   Characteristics of asterisk dummy arguments
          1 Adummyargument that is an asterisk has no other characteristic.
             15.3.3     Characteristics of function results
          1 The characteristics of a function result are its declared type, type parameters, rank, whether it is polymorphic,
             whether it is allocatable, whether it is a pointer, whether it has the CONTIGUOUS attribute, and whether it is a
             procedure pointer. If a function result is an array that is not allocatable or a pointer, its shape is a characteristic.
             If a type parameter of a function result or a bound of a function result array is not a constant expression, the
             exact dependence on the entities in the expression is a characteristic. If type parameters of a function result are
             deferred, which parameters are deferred is a characteristic. Whether the length of a character function result is assumed
             is a characteristic.
                                                                            c
             300                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             15.4      Procedure interface
             15.4.1     Interface and abstract interface
          1 Theinterface of a procedure determines the forms of reference through which it may be invoked. The procedure’s
             interface consists of its name, binding label, generic identiﬁers, characteristics, and the names of its dummy
             arguments. The characteristics and binding label of a procedure are ﬁxed, but the remainder of the interface may
             diﬀer in diﬀering contexts, except that for a separate module procedure body (15.6.2.5), the dummy argument
             names and whether it has the NON_RECURSIVE attribute shall be the same as in its corresponding module
             procedure interface body (15.4.3.2).
          2 An abstract interface is a set of procedure characteristics with the dummy argument names.
             15.4.2     Implicit and explicit interfaces
             15.4.2.1   Interfaces and scopes
          1 The interface of a procedure is either explicit or implicit. It is explicit if it is
                 • an internal procedure, module procedure, or intrinsic procedure,
                 • a subroutine, or a function with a separate result name, within the scoping unit that deﬁnes it, or
                 • a procedure declared by a procedure declaration statement that speciﬁes an explicit interface, or by an
                   interface body.
             Otherwise, the interface of the identiﬁer is implicit. The interface of a statement function is always implicit.
                  NOTE15.1
                  For example, the subroutine LLS of C.9.3.4 has an explicit interface.
             15.4.2.2   Explicit interface
          1 Within the scope of a procedure identiﬁer, the procedure shall have an explicit interface if it is not a statement
             function and
                   (1)   a reference to the procedure appears with an argument keyword (15.5.2),
                   (2)   the procedure is used in a context that requires it to be pure (15.7),
                   (3)   the procedure has a dummy argument that
                         (a)   has the ALLOCATABLE, ASYNCHRONOUS, OPTIONAL, POINTER, TARGET, VALUE,
                               or VOLATILE attribute,
                         (b)   is an assumed-shape array,
                         (c)   is assumed-rank,
                         (d)   is a coarray,
                         (e)   is of a parameterized derived type, or
                         (f)   is polymorphic,
                   (4)   the procedure has a result that
                         (a)   is an array,
                         (b)   is a pointer or is allocatable, or
                         (c)   has a nonassumed type parameter value that is not a constant expression,
                   (5)   the procedure is elemental, or
                   (6)   the procedure has the BIND attribute.
              c
             ISO/IEC 2017 – All rights reserved                                                                     301
             ISO/IEC DIS 1539-1:2017 (E)
             15.4.3     Speciﬁcation of the procedure interface
             15.4.3.1   General
          1 The interface for an internal, external, module, or dummy procedure is speciﬁed by a FUNCTION, SUB-
             ROUTINE, or ENTRY statement and by speciﬁcation statements for the dummy arguments and the result of
             a function. These statements may appear in the procedure deﬁnition, in an interface body, or both, except that
             the ENTRY statement shall not appear in an interface body.
                  NOTE15.2
                  An interface body cannot be used to describe the interface of an internal procedure, a module procedure
                  that is not a separate module procedure, or an intrinsic procedure because the interfaces of such procedures
                  are already explicit. However, the name of a procedure can appear in a PROCEDURE statement in an
                  interface block (15.4.3.2).
             15.4.3.2   Interface block
             R1501 interface-block               is  interface-stmt
                                                         [ interface-speciﬁcation ] ...
                                                         end-interface-stmt
             R1502 interface-speciﬁcation        is  interface-body
                                                 or procedure-stmt
             R1503 interface-stmt                is  INTERFACE [ generic-spec ]
                                                 or ABSTRACTINTERFACE
             R1504 end-interface-stmt            is  ENDINTERFACE[generic-spec ]
             R1505 interface-body                is  function-stmt
                                                         [ speciﬁcation-part ]
                                                         end-function-stmt
                                                 or subroutine-stmt
                                                         [ speciﬁcation-part ]
                                                         end-subroutine-stmt
             R1506 procedure-stmt                is  [ MODULE ] PROCEDURE [ :: ] speciﬁc-procedure-list
             R1507 speciﬁc-procedure             is  procedure-name
             R1508 generic-spec                  is  generic-name
                                                 or OPERATOR(deﬁned-operator )
                                                 or ASSIGNMENT ( = )
                                                 or deﬁned-io-generic-spec
             R1509 deﬁned-io-generic-spec        is  READ(FORMATTED)
                                                 or READ(UNFORMATTED)
                                                 or WRITE(FORMATTED)
                                                 or WRITE(UNFORMATTED)
             C1501 (R1501) An interface-block in a subprogram shall not contain an interface-body for a procedure deﬁned
                     by that subprogram.
             C1502 (R1501) If the end-interface-stmt includes a generic-spec, the interface-stmt shall specify the same
                     generic-spec, except that if one generic-spec has a deﬁned-operator that is .LT., .LE., .GT., .GE., .EQ.,
                     or .NE., the other generic-spec may have a deﬁned-operator that is the corresponding operator <, <=,
                     >, >=, ==, or /=.
                                                                            c
             302                                                           ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
          C1503 (R1503) If the interface-stmt is ABSTRACT INTERFACE, then the function-name in the function-stmt
                or the subroutine-name in the subroutine-stmt shall not be the same as a keyword that speciﬁes an
                intrinsic type.
          C1504 (R1502) A procedure-stmt is allowed only in an interface block that has a generic-spec.
          C1505 (R1505) An interface-body of a pure procedure shall specify the intents of all dummy arguments except
                alternate return indicators, dummy procedures, and arguments with the POINTER or VALUE attribute.
          C1506 (R1505) An interface-body shall not contain a data-stmt, format-stmt, entry-stmt, or stmt-function-stmt.
          C1507 (R1506) If MODULE appears in a procedure-stmt, each procedure-name in that statement shall denote a
                module procedure.
          C1508 (R1507) A procedure-name shall denote a nonintrinsic procedure that has an explicit interface.
          C1509 (R1501) An interface-speciﬁcation in a generic interface block shall not specify a procedure that was
                speciﬁed previously in any accessible interface with the same generic identiﬁer.
        1 An external or module subprogram speciﬁes a speciﬁc interface for each procedure deﬁned in that subprogram.
        2 An interface block introduced by ABSTRACT INTERFACE is an abstract interface block. An interface body
          in an abstract interface block speciﬁes an abstract interface. An interface block with a generic speciﬁcation is
          a generic interface block. An interface block with neither ABSTRACT nor a generic speciﬁcation is a speciﬁc
          interface block.
        3 Thenameoftheentity declared by an interface body is the function-name in the function-stmt or the subroutine-
          name in the subroutine-stmt that begins the interface body.
        4 Amoduleprocedure interface body is an interface body whose initial statement contains the keyword MODULE.
          It speciﬁes the interface for a separate module procedure (15.6.2.5). A separate module procedure is accessible
          by use association if and only if its interface body is declared in the speciﬁcation part of a module and is public.
          If a corresponding (15.6.2.5) separate module procedure is not deﬁned, the interface may be used to specify an
          explicit speciﬁc interface but the procedure shall not be used in any other way.
        5 An interface body in a generic or speciﬁc interface block speciﬁes the EXTERNAL attribute and an explicit
          speciﬁc interface for an external procedure, dummy procedure, or procedure pointer. If the name of the declared
          procedure is that of a dummy argument in the subprogram containing the interface body, the procedure is a
          dummyprocedure. If the procedure has the POINTER attribute, it is a procedure pointer. If it is not a dummy
          procedure or procedure pointer, it is an external procedure.
        6 An interface body speciﬁes all of the characteristics of the explicit speciﬁc interface or abstract interface. The
          speciﬁcation part of an interface body may specify attributes or deﬁne values for data entities that do not
          determine characteristics of the procedure. Such speciﬁcations have no eﬀect.
        7 Ifanexplicitspeciﬁcinterface for an external procedure is speciﬁed by an interface body or a procedure declaration
          statement (15.4.3.6), the characteristics shall be consistent with those speciﬁed in the procedure deﬁnition, except
          that the interface may specify a procedure that is not pure even if the procedure is deﬁned to be pure. An interface
          for a procedure deﬁned by an ENTRY statement may be speciﬁed by using the entry name as the procedure name in the interface body.
          If an external procedure does not exist in the program, an interface body for it may be used to specify an explicit
          speciﬁc interface but the procedure shall not be used in any other way. A procedure shall not have more than
          one explicit speciﬁc interface in a given scoping unit, except that if the interface is accessed by use association,
          there may be more than one local name for the procedure. If a procedure is accessed by use association, each
          access shall be to the same procedure declaration or deﬁnition.
             NOTE15.3
             Thedummyargumentnamesinaninterfacebodycanbediﬀerentfromthecorrespondingdummyargument
             names in the procedure deﬁnition because the name of a dummy argument is not a characteristic.
          c
          ISO/IEC 2017 – All rights reserved                                         303
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.4
                  An example of a speciﬁc interface block is:
                  INTERFACE
                     SUBROUTINE EXT1 (X, Y, Z)
                         REAL, DIMENSION (100, 100) :: X, Y, Z
                     END SUBROUTINE EXT1
                     SUBROUTINE EXT2 (X, Z)
                         REAL X
                         COMPLEX (KIND = 4) Z (2000)
                     END SUBROUTINE EXT2
                     FUNCTION EXT3 (P, Q)
                         LOGICAL EXT3
                         INTEGER P (1000)
                         LOGICAL Q (1000)
                     END FUNCTION EXT3
                  END INTERFACE
                  This interface block speciﬁes explicit interfaces for the three external procedures EXT1, EXT2, and EXT3.
                  Invocations of these procedures can use argument keywords (15.5.2); for example:
                  PRINT *, EXT3 (Q = P_MASK (N+1 : N+1000), P = ACTUAL_P)
             15.4.3.3   GENERIC statement
          1 A GENERIC statement speciﬁes a generic identiﬁer for one or more speciﬁc procedures, in the same way as a
             generic interface block that does not contain interface bodies.
             R1510 generic-stmt                  is  GENERIC[ , access-spec ] :: generic-spec => speciﬁc-procedure-list
             C1510 (R1510) A speciﬁc-procedure in a GENERIC statement shall not specify a procedure that was speciﬁed
                     previously in any accessible interface with the same generic identiﬁer.
          2 If access-spec appears, it speciﬁes the accessibility (8.5.2) of generic-spec.
             15.4.3.4   Generic interfaces
             15.4.3.4.1   Generic identiﬁers
          1 A generic interface block speciﬁes a generic interface for each of the procedures in the interface block. The
             PROCEDUREstatementlistsprocedurepointers, external procedures, dummy procedures, or module procedures
             that have this generic interface. A GENERIC statement speciﬁes a generic interface for each of the procedures
             named in its speciﬁc-procedure-list. A generic interface is always explicit.
          2 The generic-spec in an interface-stmt is a generic identiﬁer for all the procedures in the interface block. The
             generic-spec in a GENERIC statement is a generic identiﬁer for all of the procedures named in its speciﬁc-
             procedure-list. The rules specifying how any two procedures with the same generic identiﬁer shall diﬀer are given
             in 15.4.3.4.5. They ensure that any generic invocation applies to at most one speciﬁc procedure. If a speciﬁc
             procedure in a generic interface has a function dummy argument, that argument shall have its type and type
             parameters explicitly declared in the speciﬁc interface.
          3 Ageneric name is a generic identiﬁer that refers to all of the procedure names in the generic interface. A generic
             name may be the same as any one of the procedure names in the generic interface, or the same as any accessible
             generic name.
          4 A generic name may be the same as a derived-type name, in which case all of the procedures in the generic
             interface shall be functions.
                                                                            c
             304                                                           ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
           5 Aninterface-stmt having a deﬁned-io-generic-spec is an interface for a deﬁned input/output procedure (12.6.4.8).
                  NOTE15.5
                  An example of a generic procedure interface is:
                  INTERFACE SWITCH
                      SUBROUTINE INT_SWITCH (X, Y)
                         INTEGER, INTENT (INOUT) :: X, Y
                      END SUBROUTINE INT_SWITCH
                      SUBROUTINE REAL_SWITCH (X, Y)
                         REAL, INTENT (INOUT) :: X, Y
                      END SUBROUTINE REAL_SWITCH
                      SUBROUTINE COMPLEX_SWITCH (X, Y)
                         COMPLEX, INTENT (INOUT) :: X, Y
                      END SUBROUTINE COMPLEX_SWITCH
                  END INTERFACE SWITCH
                  Any of these three subroutines (INT_SWITCH, REAL_SWITCH, COMPLEX_SWITCH) can be ref-
                  erenced with the generic name SWITCH, as well as by its speciﬁc name. For example, a reference to
                  INT_SWITCHcould take the form:
                  CALL SWITCH (MAX_VAL, LOC_VAL) ! MAX_VAL and LOC_VAL are of type INTEGER
                  NOTE15.6
                  Atype-bound-generic-stmt within a derived-type deﬁnition (7.5.5) speciﬁes a generic identiﬁer for a set of
                  type-bound procedures.
             15.4.3.4.2   Deﬁned operations
           1 If OPERATOR is speciﬁed in a generic speciﬁcation, all of the procedures speciﬁed in the generic interface shall
             befunctions that may be referenced as deﬁned operations (10.1.6, 15.5). In the case of functions of two arguments,
             inﬁx binary operator notation is implied. In the case of functions of one argument, preﬁx operator notation is
             implied. OPERATOR shall not be speciﬁed for functions with no arguments or for functions with more than two
             arguments. The dummy arguments shall be nonoptional dummy data objects and shall have the INTENT (IN)
             or VALUE attribute. The function result shall not have assumed character length. If the operator is an intrinsic-operator
             (R608), the number of dummy arguments shall be consistent with the intrinsic uses of that operator, and the
             types, kind type parameters, or ranks of the dummy arguments shall diﬀer from those required for the intrinsic
             operation (10.1.5).
           2 A deﬁned operation is treated as a reference to the function.    For a unary deﬁned operation, the operand
             corresponds to the function’s dummy argument; for a binary operation, the left-hand operand corresponds to the
             ﬁrst dummy argument of the function and the right-hand operand corresponds to the second dummy argument.
             All restrictions and constraints that apply to actual arguments in a reference to the function also apply to the
             corresponding operands in the expression as if they were used as actual arguments.
           3 Agiven deﬁned operator may, as with generic names, apply to more than one function, in which case it is generic
             in exact analogy to generic procedure names. For intrinsic operator symbols, the generic properties include the
             intrinsic operations they represent. Because both forms of each relational operator have the same interpretation
             (10.1.6.2), extending one form (such as <=) has the eﬀect of deﬁning both forms (<= and .LE.).
                  NOTE15.7
                  An example of the use of the OPERATOR generic speciﬁcation is:
                          INTERFACE OPERATOR ( * )
                              FUNCTION BOOLEAN_AND (B1, B2)
                                 LOGICAL, INTENT (IN) :: B1 (:), B2 (SIZE (B1))
              c
             ISO/IEC 2017 – All rights reserved                                                                      305
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.7 (cont.)
                                 LOGICAL :: BOOLEAN_AND (SIZE (B1))
                              END FUNCTION BOOLEAN_AND
                          END INTERFACE OPERATOR ( * )
                  This allows, for example
                          SENSOR (1:N) * ACTION (1:N)
                  as an alternative to the function reference
                          BOOLEAN_AND (SENSOR (1:N), ACTION (1:N))           ! SENSOR and ACTION are
                                                                             ! of type LOGICAL
             15.4.3.4.3   Deﬁned assignments
           1 If ASSIGNMENT ( = ) is speciﬁed in a generic speciﬁcation, all the procedures in the generic interface shall
             be subroutines that may be referenced as deﬁned assignments (10.2.1.4, 10.2.1.5). Deﬁned assignment may, as
             with generic names, apply to more than one subroutine, in which case it is generic in exact analogy to generic
             procedure names.
           2 Eachof these subroutines shall have exactly two dummy arguments. The dummy arguments shall be nonoptional
             dummy data objects. The ﬁrst argument shall have INTENT (OUT) or INTENT (INOUT) and the second
             argument shall have the INTENT (IN) or VALUE attribute. Either the second argument shall be an array whose
             rank diﬀers from that of the ﬁrst argument, the declared types and kind type parameters of the arguments shall
             not conform as speciﬁed in Table 10.8, or the ﬁrst argument shall be of derived type. A deﬁned assignment is
             treated as a reference to the subroutine, with the left-hand side as the ﬁrst argument and the right-hand side
             enclosed in parentheses as the second argument. All restrictions and constraints that apply to actual arguments
             in a reference to the subroutine also apply to the left-hand-side and to the right-hand-side enclosed in parentheses
             as if they were used as actual arguments. The ASSIGNMENT generic speciﬁcation speciﬁes that assignment is
             extended or redeﬁned.
                  NOTE15.8
                  An example of the use of the ASSIGNMENT generic speciﬁcation is:
                          INTERFACE ASSIGNMENT ( = )
                              SUBROUTINE LOGICAL_TO_NUMERIC (N, B)
                                 INTEGER, INTENT (OUT) :: N
                                 LOGICAL, INTENT (IN)      :: B
                              END SUBROUTINE LOGICAL_TO_NUMERIC
                              SUBROUTINE CHAR_TO_STRING (S, C)
                                 USE STRING_MODULE           ! Contains definition of type STRING
                                 TYPE (STRING), INTENT (OUT) :: S        ! A variable-length string
                                 CHARACTER (*), INTENT (IN) ::        C
                              END SUBROUTINE CHAR_TO_STRING
                          END INTERFACE ASSIGNMENT ( = )
                  Example assignments are:
                          KOUNT = SENSOR (J)       ! CALL LOGICAL_TO_NUMERIC (KOUNT, (SENSOR (J)))
                          NOTE   = ’89AB’          ! CALL CHAR_TO_STRING (NOTE, (’89AB’))
                  NOTE15.9
                  A procedure which has a generic identiﬁer of ASSIGNMENT ( = ) and whose second dummy argument
                  has the ALLOCATABLE or POINTER attribute cannot be directly invoked by deﬁned assignment. This
                  is because the actual argument associated with that dummy argument is the right-hand side of the as-
                                                                             c
             306                                                            ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.9 (cont.)
                  signment enclosed in parentheses, which makes the actual argument an expression that does not have the
                  ALLOCATABLE, POINTER, or TARGET attribute.
             15.4.3.4.4   Deﬁned input/output procedure interfaces
           1 All of the procedures speciﬁed in an interface block for a deﬁned input/output procedure shall be subroutines
             that have interfaces as described in 12.6.4.8.2.
             15.4.3.4.5   Restrictions on generic declarations
           1 This subclause contains the rules that shall be satisﬁed by every pair of speciﬁc procedures that have the same
             generic identiﬁer within the scope of the identiﬁer. If a generic procedure is accessed from a module, the rules
             apply to all the speciﬁc versions even if some of them are inaccessible by their speciﬁc names.
                  NOTE15.10
                  In most scoping units, the possible sources of procedures with a particular generic identiﬁer are the accessible
                  generic identiﬁers speciﬁed by generic interface blocks or GENERIC statements and the generic bindings
                  other than names for the accessible objects in that scoping unit. In a type deﬁnition, they are the generic
                  bindings, including those from a parent type.
           2 A dummy argument is type, kind, and rank compatible, or TKR compatible, with another dummy argument if
             the ﬁrst is type compatible with the second, the kind type parameters of the ﬁrst have the same values as the
             corresponding kind type parameters of the second, and both have the same rank or either is assumed-rank.
           3 Two dummy arguments are distinguishable if
                 • one is a procedure and the other is a data object,
                 • they are both data objects or known to be functions, and neither is TKR compatible with the other,
                 • one has the ALLOCATABLE attribute and the other has the POINTER attribute and not the INTENT
                   (IN) attribute, or
                 • one is a function with nonzero rank and the other is not known to be a function.
             C1511 Within the scope of a generic operator, if two procedures with that identiﬁer have the same number of
                     arguments, one shall have a dummy argument that corresponds by position in the argument list to a
                     dummy argument of the other that is distinguishable from it.
             C1512 Within the scope of the generic ASSIGNMENT (=) identiﬁer, if two procedures have that identiﬁer, one
                     shall have a dummy argument that corresponds by position in the argument list to a dummy argument
                     of the other that is distinguishable from it.
             C1513 Within the scope of a deﬁned-io-generic-spec, if two procedures have that generic identiﬁer, their dtv
                     arguments (12.6.4.8.2) shall be distinguishable.
             C1514 Within the scope of a generic name, each pair of procedures identiﬁed by that name shall both be
                     subroutines or both be functions, and
                     (1)    there is a non-passed-object dummy data object in one or the other of them such that
                            (a)   the number of dummy data objects in one that are nonoptional, are not passed-object, and
                                  with which that dummy data object is TKR compatible, possibly including that dummy
                                  data object itself,
                            exceeds
                            (b)   the number of non-passed-object dummy data objects, both optional and nonoptional, in
                                  the other that are not distinguishable from that dummy data object,
              c
             ISO/IEC 2017 – All rights reserved                                                                      307
              ISO/IEC DIS 1539-1:2017 (E)
                       (2)   the number of nonoptional dummy procedures in one of them exceeds the number of dummy
                             procedures in the other,
                       (3)   both have passed-object dummy arguments and the passed-object dummy arguments are distin-
                             guishable, or
                       (4)   at least one of them shall have both
                             (a)    a nonoptional non-passed-object dummy argument at an eﬀective position such that either
                                    the other procedure has no dummy argument at that eﬀective position or the dummy argu-
                                    ment at that position is distinguishable from it, and
                             (b)    a nonoptional non-passed-object dummy argument whose name is such that either the other
                                    procedure has no dummy argument with that name or the dummy argument with that name
                                    is distinguishable from it,
                             and the dummy argument that disambiguates by position shall either be the same as or occur
                             earlier in the argument list than the one that disambiguates by name.
           4 The eﬀective position of a dummy argument is its position in the argument list after any passed-object dummy
              argument has been removed.
           5 Within the scope of a generic name that is the same as the generic name of an intrinsic procedure, the intrinsic
              procedure is not accessible by its generic name if the procedures in the interface and the intrinsic procedure are
              not all functions or not all subroutines. If a generic invocation is consistent with both a speciﬁc procedure from
              an interface and an accessible intrinsic procedure, it is the speciﬁc procedure from the interface that is referenced.
                   NOTE15.11
                   An extensive explanation of the application of these rules is in C.10.6.
              15.4.3.5   EXTERNAL statement
           1 An EXTERNAL statement speciﬁes the EXTERNAL attribute (8.5.9) for a list of names.
              R1511 external-stmt                    is  EXTERNAL[:: ] external-name-list
           2 The appearance of the name of a block data program unit in an EXTERNAL statement conﬁrms that the block
              data program unit is a part of the program.
                   NOTE15.12
                   For explanatory information on potential portability problems with external procedures, see subclause
                   C.10.1.
                   NOTE15.13
                   An example of an EXTERNAL statement is:
                            EXTERNAL FOCUS
              15.4.3.6   Procedure declaration statement
           1 A procedure declaration statement declares procedure pointers, dummy procedures, and external procedures. It
              speciﬁes the EXTERNAL attribute (8.5.9) for all entities in the proc-decl-list.
              R1512 procedure-declaration-stmt       is  PROCEDURE([proc-interface ] )
                                                           [ [ , proc-attr-spec ] ... :: ] proc-decl-list
              R1513 proc-interface                   is  interface-name
                                                     or declaration-type-spec
              R1514 proc-attr-spec                   is  access-spec
                                                     or proc-language-binding-spec
                                                                                 c
              308                                                                ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                                                          or INTENT ( intent-spec )
                                                          or OPTIONAL
                                                          or POINTER
                                                          or PROTECTED
                                                          or SAVE
                R1515 proc-decl                           is  procedure-entity-name [ => proc-pointer-init ]
                R1516 interface-name                      is  name
                R1517 proc-pointer-init                   is  null-init
                                                          or initial-proc-target
                R1518 initial-proc-target                 is  procedure-name
                C1515 (R1516) The name shall be the name of an abstract interface or of a procedure that has an explicit
                         interface. If name is declared by a procedure-declaration-stmt it shall be previously declared. If name
                         denotes an intrinsic procedure it shall be one that is listed in Table 16.2.
                C1516 (R1516) The name shall not be the same as a keyword that speciﬁes an intrinsic type.
                C1517 (R1512) If a proc-interface describes an elemental procedure, each procedure-entity-name shall specify an
                         external procedure.
                C1518 (R1515) If => appears in proc-decl, the procedure entity shall have the POINTER attribute.
                C1519 (R1518) The procedure-name shall be the name of a nonelemental external or module procedure, or a
                         speciﬁc intrinsic function listed in Table 16.2.
                C1520 (R1512) If proc-language-binding-spec with NAME= is speciﬁed, then proc-decl-list shall contain exactly
                         one proc-decl, which shall neither have the POINTER attribute nor be a dummy procedure.
                C1521 (R1512)If proc-language-binding-spec is speciﬁed, the proc-interface shall appear, it shall be an interface-
                         name, and interface-name shall be declared with a proc-language-binding-spec.
            2 If proc-interface appears and consists of interface-name, it speciﬁes an explicit speciﬁc interface (15.4.3.2) for the
                declared procedure entities. The abstract interface (15.4) is that speciﬁed by the interface named by interface-
                name. The interface speciﬁed by interface-name shall not depend on any characteristic of a procedure identiﬁed
                by a procedure-entity-name in the proc-decl-list of the same procedure declaration statement.
            3 If proc-interface appears and consists of declaration-type-spec, it speciﬁes that the declared procedure entities are
                functions having implicit interfaces and the speciﬁed result type. If a type is speciﬁed for an external function,
                its function deﬁnition (15.6.2.2) shall specify the same result type and type parameters.
            4 If proc-interface does not appear, the procedure declaration statement does not specify whether the declared
                procedure entities are subroutines or functions.
            5 If a proc-attr-spec other than a proc-language-binding-spec appears, it speciﬁes that the declared procedure entities
                have that attribute. These attributes are described in 8.5. If a proc-language-binding-spec with NAME= appears,
                it speciﬁes a binding label or its absence, as described in 18.10.2. A proc-language-binding-spec without NAME=
                is allowed, but is redundant with the proc-interface required by C1521.
            6 If => appears in a proc-decl in a procedure-declaration-stmt it speciﬁes the initial association status of the
                corresponding procedure entity, and implies the SAVE attribute, which may be conﬁrmed by explicit speciﬁcation.
                If => null-init appears, the procedure entity is initially disassociated. If => initial-proc-target appears, the
                procedure entity is initially associated with the target.
            7 If procedure-entity-name has an explicit interface, its characteristics shall be the same as initial-proc-target except
                that initial-proc-target may be pure even if procedure-entity-name is not pure and initial-proc-target may be an elemental
                intrinsic procedure.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       309
             ISO/IEC DIS 1539-1:2017 (E)
          8 If the characteristics of procedure-entity-name or initial-proc-target are such that an explicit interface is required,
             both procedure-entity-name and initial-proc-target shall have an explicit interface.
          9 If procedure-entity-name has an implicit interface and is explicitly typed or referenced as a function, initial-proc-
             target shall be a function. If procedure-entity-name has an implicit interface and is referenced as a subroutine,
             initial-proc-target shall be a subroutine.
         10 If initial-proc-target and procedure-entity-name are functions, their results shall have the same characteristics.
                  NOTE15.14
                  The following code illustrates procedure declaration statements. NOTE 10.47 illustrates the use of the P
                  and BESSEL deﬁned by this code.
                  ABSTRACT INTERFACE
                    FUNCTION REAL_FUNC (X)
                       REAL, INTENT (IN) :: X
                       REAL :: REAL_FUNC
                    END FUNCTION REAL_FUNC
                  END INTERFACE
                  INTERFACE
                    SUBROUTINE SUB (X)
                       REAL, INTENT (IN) :: X
                    END SUBROUTINE SUB
                  END INTERFACE
                  !-- Some external or dummy procedures with explicit interface.
                  PROCEDURE (REAL_FUNC) :: BESSEL, GFUN
                  PROCEDURE (SUB) :: PRINT_REAL
                  !-- Some procedure pointers with explicit interface,
                  !-- one initialized to NULL().
                  PROCEDURE (REAL_FUNC), POINTER :: P, R => NULL ()
                  PROCEDURE (REAL_FUNC), POINTER :: PTR_TO_GFUN
                  !-- A derived type with a procedure pointer component ...
                  TYPE STRUCT_TYPE
                     PROCEDURE (REAL_FUNC), POINTER, NOPASS :: COMPONENT
                  END TYPE STRUCT_TYPE
                  !-- ... and a variable of that type.
                  TYPE(STRUCT_TYPE) :: STRUCT
                  !-- An external or dummy function with implicit interface
                  PROCEDURE (REAL) :: PSI
             15.4.3.7   INTRINSIC statement
          1 An INTRINSIC statement speciﬁes the INTRINSIC attribute (8.5.11) for a list of names.
             R1519 intrinsic-stmt                is  INTRINSIC [ :: ] intrinsic-procedure-name-list
             C1522 (R1519) Each intrinsic-procedure-name shall be the name of an intrinsic procedure.
             15.4.3.8   Implicit interface speciﬁcation
          1 If the interface of a function is implicit, the type and type parameters of the function result are speciﬁed by an
             implicit or explicit type speciﬁcation of the function name. The type, type parameters, and shape of the dummy
             arguments of a procedure invoked from where the interface of the procedure is implicit shall be such that each
             actual argument is consistent with the characteristics of the corresponding dummy argument.
                                                                            c
             310                                                           ISO/IEC 2017 – All rights reserved
                                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                15.5       Procedure reference
                15.5.1      Syntax of a procedure reference
            1 The form of a procedure reference is dependent on the interface of the procedure or procedure pointer, but is
                independent of the means by which the procedure is deﬁned. The forms of procedure references are as follows.
                R1520 function-reference                  is  procedure-designator ( [ actual-arg-spec-list ] )
                C1523 (R1520) The procedure-designator shall designate a function.
                C1524 (R1520) The actual-arg-spec-list shall not contain an alt-return-spec.
                R1521 call-stmt                           is  CALLprocedure-designator [ ( [ actual-arg-spec-list ] ) ]
                C1525 (R1521) The procedure-designator shall designate a subroutine.
                R1522 procedure-designator                is  procedure-name
                                                          or proc-component-ref
                                                          or data-ref % binding-name
                C1526 (R1522) A procedure-name shall be a generic name or the name of a procedure.
                C1527 (R1522) A binding-name shall be a binding name (7.5.5) of the declared type of data-ref.
                C1528 (R1522) A data-ref shall not be a polymorphic subobject of a coindexed object.
                C1529 (R1522) If data-ref is an array, the referenced type-bound procedure shall have the PASS attribute.
            2 The data-ref in a procedure-designator shall not be an unallocated allocatable variable or a pointer that is not
                associated.
            3 Resolving references to type-bound procedures is described in 15.5.6.
            4 A function may also be referenced as a deﬁned operation (10.1.6). A subroutine may also be referenced as a
                deﬁned assignment (10.2.1.4, 10.2.1.5), by deﬁned input/output (12.6.4.8), or by ﬁnalization (7.5.6).
                     NOTE15.15
                     When resolving type-bound procedure references, constraints on the use of coindexed objects ensure that
                     the coindexed object (on the remote image) has the same dynamic type as the corresponding object on the
                     local image. Thus a processor can resolve the type-bound procedure using the coarray variable on its own
                     image and pass the coindexed object as the actual argument.
                R1523 actual-arg-spec                     is  [ keyword = ] actual-arg
                R1524 actual-arg                          is  expr
                                                          or variable
                                                          or procedure-name
                                                          or proc-component-ref
                                                          or alt-return-spec
                R1525    alt-return-spec                  is  * label
                C1530 (R1523) The keyword = shall not appear if the interface of the procedure is implicit.
                C1531 (R1523) The keyword = shall not be omitted from an actual-arg-spec unless it has been omitted from
                         each preceding actual-arg-spec in the argument list.
                C1532 (R1523) Each keyword shall be the name of a dummy argument in the explicit interface of the procedure.
                c
                ISO/IEC 2017 – All rights reserved                                                                                       311
            ISO/IEC DIS 1539-1:2017 (E)
            C1533 (R1524) A nonintrinsic elemental procedure shall not be used as an actual argument.
            C1534 (R1524) A procedure-name shall be the name of an external, internal, module, or dummy procedure, a
                  speciﬁc intrinsic function listed in Table 16.2, or a procedure pointer.
            C1535 (R1524) expr shall not be a variable.
            C1536 (R1525) The label shall be the statement label of a branch target statement that appears in the same inclusive scope as the
                  call-stmt.
            C1537 An actual argument that is a coindexed object shall not have a pointer ultimate component.
                NOTE15.16
                Examples of procedure reference using procedure pointers:
                       P => BESSEL
                       WRITE (*, *) P(2.5)     !-- BESSEL(2.5)
                       S => PRINT_REAL
                       CALL S(3.14)
                NOTE15.17
                Aninternal procedure cannot be invoked using a procedure pointer from either Fortran or C after the host
                instance completes execution, because the pointer is then undeﬁned. While the host instance is active,
                however, if an internal procedure was passed as an actual argument or is the target of a procedure pointer,
                it could be invoked from outside of the host subprogram.
                Assume there is a procedure with the following interface that calculates Rbf(x)dx.
                                                                             a
                       INTERFACE
                          FUNCTION INTEGRATE(F, A, B) RESULT(INTEGRAL) BIND(C)
                             USE ISO_C_BINDING
                             INTERFACE
                                FUNCTION F(X) BIND(C) ! Integrand
                                   USE ISO_C_BINDING
                                   REAL(C_FLOAT), VALUE :: X
                                   REAL(C_FLOAT) :: F
                                END FUNCTION
                             END INTERFACE
                             REAL(C_FLOAT), VALUE :: A, B ! Bounds
                             REAL(C_FLOAT) :: INTEGRAL
                          END FUNCTION INTEGRATE
                       END INTERFACE
                ThisprocedurecanbecalledfromFortranorC,andcouldbewrittenineitherFortranorC.TheargumentF
                representing the mathematical function f(x) can be written as an internal procedure; this internal procedure
                will have access to any host instance local variables necessary to actually calculate f(x). For example:
                       REAL FUNCTION MY_INTEGRATION(N, A, B) RESULT(INTEGRAL)
                          ! Integrate f(x)=x^n over [a,b]
                          USE ISO_C_BINDING
                          INTEGER, INTENT(IN) :: N
                          REAL, INTENT(IN) :: A, B
                          INTEGRAL = INTEGRATE(MY_F, REAL (A, C_FLOAT), REAL (B, C_FLOAT))
                             ! This will call the internal function MY_F to calculate f(x).
                             ! The above interface of INTEGRATE needs to be explicit and available.
                                                                  c
            312                                                  ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.17 (cont.)
                          CONTAINS
                             REAL(C_FLOAT) FUNCTION MY_F(X) BIND(C) ! Integrand
                                 REAL(C_FLOAT), VALUE :: X
                                 MY_F = X**N ! N is taken from the host instance of MY_INTEGRATION.
                             END FUNCTION
                          END FUNCTION MY_INTEGRATION
                  The function INTEGRATE cannot retain a function pointer to MY_F and use it after INTEGRATE has
                  ﬁnished execution, because the host instance of MY_F might no longer exist, making the pointer undeﬁned.
                  If such a pointer is retained, then it can only be used to invoke MY_F during the execution of the instance
                  of MY_INTEGRATION that called INTEGRATE.
             15.5.2     Actual arguments, dummy arguments, and argument association
             15.5.2.1   Argument correspondence
          1 In either a subroutine reference or a function reference, the actual argument list identiﬁes the correspondence
             between the actual arguments and the dummy arguments of the procedure. This correspondence may be estab-
             lished either by keyword or by position. If an argument keyword appears, the actual argument corresponds to
             the dummy argument whose name is the same as the argument keyword (using the dummy argument names from
             the interface accessible by the procedure reference). In the absence of an argument keyword, an actual argument
             corresponds to the dummy argument occupying the corresponding position in the reduced dummy argument list;
             that is, the ﬁrst actual argument corresponds to the ﬁrst dummy argument in the reduced list, the second actual
             argument corresponds to the second dummy argument in the reduced list, etc. The reduced dummy argument
             list is either the full dummy argument list or, if there is a passed-object dummy argument (7.5.4.5), the dummy
             argument list with the passed-object dummy argument omitted. Exactly one actual argument shall correspond
             to each nonoptional dummy argument. At most one actual argument shall correspond to each optional dummy
             argument. Each actual argument shall correspond to a dummy argument.
                  NOTE15.18
                  For example, the procedure deﬁned by
                  SUBROUTINE SOLVE (FUNCT, SOLUTION, METHOD, STRATEGY, PRINT)
                     INTERFACE
                         FUNCTION FUNCT (X)
                            REAL FUNCT, X
                         END FUNCTION FUNCT
                     END INTERFACE
                     REAL SOLUTION
                     INTEGER, OPTIONAL :: METHOD, STRATEGY, PRINT
                     ...
                  can be invoked with
                  CALL SOLVE (FUN, SOL, PRINT = 6)
                  provided its interface is explicit, and if the interface is speciﬁed by an interface body, the name of the last
                  argument is PRINT.
             15.5.2.2   The passed-object dummy argument and argument correspondence
          1 In a reference to a type-bound procedure, or a procedure pointer component, that has a passed-object dummy
             argument (7.5.4.5), the data-ref of the function-reference or call-stmt corresponds, as an actual argument, with
             the passed-object dummy argument.
              c
             ISO/IEC 2017 – All rights reserved                                                                     313
             ISO/IEC DIS 1539-1:2017 (E)
             15.5.2.3   Argument association
          1 Except in references to intrinsic inquiry functions, a pointer actual argument that corresponds to a nonoptional
             nonpointer dummy argument shall be pointer associated with a target.
          2 If a nonpointer dummy argument without the VALUE attribute corresponds to a pointer actual argument that
             is pointer associated with a target,
                 • if the dummy argument is polymorphic, it becomes argument associated with that target;
                 • if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
                   that target.
          3 If a present nonpointer dummy argument without the VALUE attribute corresponds to a nonpointer actual
             argument,
                 • if the dummy argument is polymorphic, it becomes argument associated with that actual argument;
                 • if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
                   that actual argument.
          4 ApresentdummyargumentwiththeVALUEattributebecomesargumentassociatedwithadeﬁnableanonymous
             data object whose initial value is the value of the actual argument.
          5 Apresent pointer dummy argument that corresponds to a pointer actual argument becomes argument associated
             with that actual argument. A present pointer dummy argument that does not correspond to a pointer actual
             argument is not argument associated.
          6 The entity that is argument associated with a dummy argument is called its eﬀective argument.
          7 Theultimateargumentistheeﬀectiveargumentiftheeﬀectiveargumentisnotadummyargumentorasubobject
             of a dummy argument. If the eﬀective argument is a dummy argument, the ultimate argument is the ultimate
             argument of that dummy argument. If the eﬀective argument is a subobject of a dummy argument, the ultimate
             argument is the corresponding subobject of the ultimate argument of that dummy argument.
                  NOTE15.19
                  For the sequence of subroutine calls
                         INTEGER :: X(100)
                         CALL SUBA (X)
                         ...
                         SUBROUTINE SUBA(A)
                         INTEGER :: A(:)
                         CALL SUBB (A(1:5), A(5:1:-1))
                         ...
                         SUBROUTINE SUBB(B, C)
                         INTEGER :: B(:), C(:)
                  the ultimate argument of B is X(1:5). The ultimate argument of C is X(5:1:-1) and this is not the same
                  object as the ultimate argument of B.
                  NOTE15.20
                  Fortran argument association is usually similar to call by reference and call by value-result. If the VALUE
                  attribute is speciﬁed, the eﬀect is as if the actual argument were assigned to a temporary variable, and
                  that variable were then argument associated with the dummy argument. Subsequent changes to the value
                  or deﬁnition status of the dummy argument do not aﬀect the actual argument. The actual mechanism by
                  which this happens is determined by the processor.
                                                                            c
             314                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             15.5.2.4   Ordinary dummy variables
          1 The requirements in this subclause apply to actual arguments that correspond to nonallocatable nonpointer
             dummy data objects.
          2 Thedummyargumentshallbetypecompatiblewiththeactualargument. Iftheactualargumentisapolymorphic
             coindexed object, the dummy argument shall not be polymorphic. If the actual argument is a polymorphic
             assumed-size array, the dummy argument shall be polymorphic. If the actual argument is of a derived type that
             has type parameters, type-bound procedures, or ﬁnal subroutines, the dummy argument shall not be assumed-
             type.
          3 The kind type parameter values of the actual argument shall agree with the corresponding ones of the dummy
             argument. The length type parameter values of a present actual argument shall agree with the corresponding
             ones of the dummy argument that are not assumed, except for the case of the character length parameter of
             an actual argument of type character with default kind or C character kind (18.2.2) associated with a dummy
             argument that is not assumed-shape or assumed-rank.
          4 If a present scalar dummy argument is of type character with default kind or C character kind, the length len of
             the dummy argument shall be less than or equal to the length of the actual argument. The dummy argument
             becomes associated with the leftmost len characters of the actual argument. If a present array dummy argument
             is of type character with default kind or C character kind and is not assumed-shape or assumed-rank, it becomes
             associated with the leftmost characters of the actual argument element sequence (15.5.2.11).
          5 The values of assumed type parameters of a dummy argument are assumed from the corresponding type para-
             meters of its eﬀective argument.
          6 If the actual argument is a coindexed object with an allocatable ultimate component, the dummy argument shall
             have the INTENT (IN) or the VALUE attribute.
                  NOTE15.21
                  If the actual argument is a coindexed object, a processor that uses distributed memory might create a copy
                  on the executing image of the actual argument, including copies of any allocated allocatable subobjects,
                  and associate the dummy argument with that copy. If necessary, on return from the procedure, the value
                  of the copy would be copied back to the actual argument.
          7 Exceptinreferences to intrinsic inquiry functions, if the dummy argument is nonoptional and the actual argument
             is allocatable, the corresponding actual argument shall be allocated.
          8 If the dummyargumentdoesnothavetheTARGETattribute,anypointersassociatedwiththeeﬀectiveargument
             do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
             dummy argument is used as an actual argument that corresponds to a dummy argument with the TARGET
             attribute, whether any pointers associated with the original eﬀective argument become associated with the dummy
             argument with the TARGET attribute is processor dependent.
          9 If the dummy argument has the TARGET attribute, does not have the VALUE attribute, and either the eﬀective
             argument is simply contiguous or the dummy argument is scalar, assumed-rank, or assumed-shape, and does not
             have the CONTIGUOUSattribute, and the eﬀective argument has the TARGET attribute but is not a coindexed
             object or an array section with a vector subscript then
                 • any pointers associated with the eﬀective argument become associated with the corresponding dummy
                   argument on invocation of the procedure, and
                 • when execution of the procedure completes, any pointers that do not become undeﬁned (19.5.2.5) and are
                   associated with the dummy argument remain associated with the eﬀective argument.
         10 If the dummy argument has the TARGET attribute and is an explicit-shape array, an assumed-shape array with
             the CONTIGUOUS attribute, an assumed-rank object with the CONTIGUOUS attribute, or an assumed-size
             array, and the eﬀective argument has the TARGET attribute but is not simply contiguous and is not an array
              c
             ISO/IEC 2017 – All rights reserved                                                                     315
         ISO/IEC DIS 1539-1:2017 (E)
         section with a vector subscript then
           • on invocation of the procedure, whether any pointers associated with the eﬀective argument become asso-
            ciated with the corresponding dummy argument is processor dependent, and
           • when execution of the procedure completes, the pointer association status of any pointer that is pointer
            associated with the dummy argument is processor dependent.
      11 If the dummy argument has the TARGET attribute and the eﬀective argument does not have the TARGET
         attribute or is an array section with a vector subscript, any pointers associated with the dummy argument
         become undeﬁned when execution of the procedure completes.
      12 If the dummy argument has the TARGET attribute and the VALUE attribute, any pointers associated with the
         dummy argument become undeﬁned when execution of the procedure completes.
      13 If the actual argument is a coindexed scalar, the corresponding dummy argument shall be scalar. If the actual
         argumentisanoncoindexedscalar, the corresponding dummy argument shall be scalar unless the actual argument
         is default character, of type character with the C character kind (18.2.2), or is an element or substring of an element
         of an array that is not an assumed-shape, pointer, or polymorphic array. If the procedure is nonelemental and is
         referenced by a generic name or as a deﬁned operator or deﬁned assignment, the ranks of the actual arguments
         and corresponding dummy arguments shall agree.
      14 If a dummy argument is an assumed-shape array, the rank of the actual argument shall be the same as the rank
         of the dummy argument, and the actual argument shall not be an assumed-size array.
      15 Anactual argument of any rank may correspond to an assumed-rank dummy argument. The rank and extents of
         the dummy argument are the rank and extents of the corresponding actual argument. The lower bound of each
         dimension of the dummy argument is equal to one. The upper bound is equal to the extent, except for the last
         dimension when the actual argument is assumed-size.
      16 Except when a procedure reference is elemental (15.8), each element of an array actual argument or of a sequence
         in a sequence association (15.5.2.11) is associated with the element of the dummy array that has the same position
         in array element order (9.5.3.2).
            NOTE15.22
            For default character sequence associations, the interpretation of element is provided in 15.5.2.11.
      17 A scalar dummy argument of a nonelemental procedure shall correspond only to a scalar actual argument.
      18 If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be deﬁnable. If a
         dummy argument has INTENT (OUT), the eﬀective argument becomes undeﬁned at the time the association is
         established, except for direct components of an object of derived type for which default initialization has been
         speciﬁed.
      19 If the procedure is nonelemental, the dummy argument does not have the VALUE attribute, and the actual
         argument is an array section having a vector subscript, the dummy argument is not deﬁnable and shall not have
         the ASYNCHRONOUS, INTENT (OUT), INTENT (INOUT), or VOLATILE attributes.
      20 If the dummy argument has a coarray ultimate component, the corresponding actual argument shall have the
         VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute.
            NOTE15.23
            Argument intent speciﬁcations serve several purposes. See NOTE 8.18.
            NOTE15.24
            For more explanatory information on targets as dummy arguments, see subclause C.10.4.
                                                  c
         316                                     ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             C1538 AnactualargumentthatisacoindexedobjectwiththeASYNCHRONOUSorVOLATILEattributeshall
                     not correspond to a dummy argument that has either the ASYNCHRONOUS or VOLATILE attribute,
                     unless the dummy argument has the VALUE attribute.
             C1539 (R1524) If an actual argument is a nonpointer array that has the ASYNCHRONOUS or VOLATILE
                     attribute but is not simply contiguous (9.5.4), and the corresponding dummy argument has either the
                     ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute, that dummy
                     argument shall be assumed-shape or assumed-rank and shall not have the CONTIGUOUS attribute.
             C1540 (R1524) If an actual argument is an array pointer that has the ASYNCHRONOUS or VOLATILE
                     attribute but does not have the CONTIGUOUS attribute, and the corresponding dummy argument
                     has either the ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute,
                     that dummy argument shall be an array pointer, an assumed-shape array without the CONTIGUOUS
                     attribute, or an assumed-rank entity without the CONTIGUOUS attribute.
                  NOTE15.25
                  The constraints on an actual argument with the ASYNCHRONOUS or VOLATILE attribute that corres-
                  ponds to a dummy argument with either the ASYNCHRONOUS or VOLATILE attribute are designed to
                  avoid forcing a processor to use the so-called copy-in/copy-out argument passing mechanism. Making a
                  copy of an actual argument whose value is likely to change due to an asynchronous input/output operation
                  completing or in some unpredictable manner will cause the new value to be lost when a called procedure
                  returns and the copy-out overwrites the actual argument.
             15.5.2.5   Allocatable and pointer dummy variables
          1 TherequirementsinthissubclauseapplytoanactualargumentwiththeALLOCATABLEorPOINTERattribute
             that corresponds to a dummy argument with the same attribute.
          2 The actual argument shall be polymorphic if and only if the associated dummy argument is polymorphic, and
             either both the actual and dummy arguments shall be unlimited polymorphic, or the declared type of the actual
             argument shall be the same as the declared type of the dummy argument.
                  NOTE15.26
                  The dynamic type of a polymorphic allocatable or pointer dummy argument can change as a result of
                  execution of an ALLOCATE statement or pointer assignment in the subprogram. Because of this the
                  corresponding actual argument needs to be polymorphic and have a declared type that is the same as the
                  declared type of the dummy argument or an extension of that type. However, type compatibility requires
                  that the declared type of the dummy argument be the same as, or an extension of, the type of the actual
                  argument. Therefore, the dummy and actual arguments need to have the same declared type.
                  Dynamictypeinformation is not maintained for a nonpolymorphic allocatable or pointer dummy argument.
                  However, allocating or pointer-assigning such a dummy argument would require maintenance of this inform-
                  ation if the corresponding actual argument is polymorphic. Therefore, the corresponding actual argument
                  needs to be nonpolymorphic.
          3 The rank of the actual argument shall be the same as that of the dummy argument, unless the dummy argument
             is assumed-rank. The type parameter values of the actual argument shall agree with the corresponding ones of
             the dummy argument that are not assumed or deferred. The values of assumed type parameters of the dummy
             argument are assumed from the corresponding type parameters of its eﬀective argument.
          4 The actual argument shall have deferred the same type parameters as the dummy argument.
             15.5.2.6   Allocatable dummy variables
          1 Therequirementsinthis subclause apply to actual arguments that correspond to allocatable dummy data objects.
          2 The actual argument shall be allocatable. It is permissible for the actual argument to have an allocation status
             of unallocated.
              c
             ISO/IEC 2017 – All rights reserved                                                                     317
             ISO/IEC DIS 1539-1:2017 (E)
          3 The corank of the actual argument shall be the same as that of the dummy argument.
          4 If the actual argument is a coindexed object, the dummy argument shall have the INTENT (IN) attribute.
          5 If the dummy argument does not have the TARGET attribute, any pointers associated with the actual argument
             do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
             dummy argument is used as an actual argument that is associated with a dummy argument with the TARGET
             attribute, whether any pointers associated with the original actual argument become associated with the dummy
             argument with the TARGET attribute is processor dependent.
          6 If the dummy argument has the TARGET attribute, does not have the INTENT (OUT) or VALUE attribute,
             and the corresponding actual argument has the TARGET attribute then
                 • any pointers associated with the actual argument become associated with the corresponding dummy argu-
                   ment on invocation of the procedure, and
                 • when execution of the procedure completes, any pointers that do not become undeﬁned (19.5.2.5) and are
                   associated with the dummy argument remain associated with the actual argument.
          7 If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be deﬁnable. If a
             dummy argument has INTENT (OUT) and its associated actual argument is allocated, the actual argument is
             deallocated on procedure invocation (9.7.3.2).
             15.5.2.7   Pointer dummy variables
          1 The requirements in this subclause apply to actual arguments that correspond to dummy data pointers.
             C1541 The actual argument corresponding to a dummy pointer with the CONTIGUOUS attribute shall be
                     simply contiguous (9.5.4).
             C1542 The actual argument corresponding to a dummy pointer shall not be a coindexed object.
                  NOTE15.27
                  Constraint C1542 does not apply to any intrinsic procedure because an intrinsic procedure is deﬁned in
                  terms of its actual arguments.
          2 If the dummy argument does not have INTENT (IN), the actual argument shall be a pointer. Otherwise, the
             actual argument shall be a pointer or a valid target for the dummy pointer in a pointer assignment statement. If
             the actual argument is not a pointer, the dummy pointer becomes pointer associated with the actual argument.
          3 If the dummy argument has INTENT (OUT), the pointer association status of the actual argument becomes
             undeﬁned on invocation of the procedure.
                  NOTE15.28
                  For more explanatory information on pointers as dummy arguments, see subclause C.10.4.
             15.5.2.8   Coarray dummy variables
          1 If the dummy argument is a coarray, the corresponding actual argument shall be a coarray and shall have the
             VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute.
          2 If the dummy argument is an array coarray that has the CONTIGUOUS attribute or is not of assumed shape,
             the corresponding actual argument shall be simply contiguous or an element of a simply contiguous array.
                  NOTE15.29
                  Consider the invocation of a procedure on a particular image. Each dummy coarray is associated with its
                  ultimate argument on the image. In addition, during this execution of the procedure, this image can access
                  the coarray corresponding to the ultimate argument on any other image. For example, consider
                                                                            c
             318                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.29 (cont.)
                          INTERFACE
                             SUBROUTINE SUB(X)
                                 REAL :: X[*]
                             END SUBROUTINE SUB
                          END INTERFACE
                          ...
                          REAL :: A(1000)[*]
                          ...
                          CALL SUB(A(10))
                  During execution of this invocation of SUB, the executing image has access through the syntax X[P] to
                  A(10) on image P.
                  NOTE15.30
                  Eachinvocationofaprocedurewithanonallocatablecoarraydummyargumentestablishesadummycoarray
                  for the image with its own bounds and cobounds. During this execution of the procedure, this image can
                  use its own bounds and cobounds to access the coarray corresponding to the ultimate argument on any
                  other image. For example, consider
                          INTERFACE
                             SUBROUTINE SUB(X,N)
                                 INTEGER :: N
                                 REAL :: X(N,N)[N,*]
                             END SUBROUTINE SUB
                          END INTERFACE
                          ...
                          REAL :: A(1000)[*]
                          ...
                          CALL SUB(A,10)
                  During execution of this invocation of SUB, the executing image has access through the syntax X(1,2)[3,4]
                  to A(11) on the image with image index 33.
                  NOTE15.31
                  The requirements on an actual argument that corresponds to a dummy coarray that is not of assumed-
                  shape or has the CONTIGUOUS attribute are designed to avoid forcing a processor to use the so-called
                  copy-in/copy-out argument passing mechanism.
             15.5.2.9   Actual arguments associated with dummy procedure entities
          1 If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as
             those of its eﬀective argument, except that a pure eﬀective argument may be associated with a dummy argument
             that is not pure and an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be
             elemental).
          2 If the interface of a dummy procedure is implicit and either the dummy argument is explicitly typed or referenced
             as a function, it shall not be referenced as a subroutine and any corresponding actual argument shall be a function,
             function procedure pointer, or dummy procedure. If both the actual argument and dummy argument are known
             to be functions, they shall have the same type and type parameters. If only the dummy argument is known to
             be a function, the function that would be invoked by a reference to the dummy argument shall have the same
             type and type parameters, except that an external function with assumed character length may be associated with a dummy
             argument with explicit character length.
          3 If the interface of a dummy procedure is implicit and a reference to it appears as a subroutine reference, any
             corresponding actual argument shall be a subroutine, subroutine procedure pointer, or dummy procedure.
              c
             ISO/IEC 2017 – All rights reserved                                                                     319
             ISO/IEC DIS 1539-1:2017 (E)
          4 If a dummy argument is a dummy procedure without the POINTER attribute, its eﬀective argument shall be an
             external, internal, module, or dummy procedure, or a speciﬁc intrinsic procedure listed in Table 16.2. If the speciﬁc name
             is also a generic name, only the speciﬁc procedure is associated with the dummy argument.
          5 If a dummy argument is a procedure pointer, the corresponding actual argument shall be a procedure pointer, a
             reference to a function that returns a procedure pointer, a reference to the intrinsic function NULL, or a valid
             target for the dummy pointer in a pointer assignment statement. If the actual argument is not a pointer, the
             dummy argument shall have INTENT (IN) and becomes pointer associated with the actual argument.
          6 When the actual argument is a procedure, the host instance of the dummy argument is the host instance of the
             actual argument (15.6.2.4).
          7 If an external procedure or a dummy procedure is used as an actual argument, its interface shall be explicit or it
             shall be explicitly declared to have the EXTERNAL attribute.
             15.5.2.10  Actual arguments and alternate return indicators
          1 If a dummy argument is an asterisk (15.6.2.3), the corresponding actual argument shall be an alternate return speciﬁer (R1525).
             15.5.2.11  Sequence association
          1 An actual argument represents an element sequence if it is an array expression, an array element designator, a
             default character scalar, or a scalar of type character with the C character kind (18.2.2). If the actual argument is
             an array expression, the element sequence consists of the elements in array element order. If the actual argument
             is an array element designator, the element sequence consists of that array element and each element that follows
             it in array element order.
          2 If the actual argument is default character or of type character with the C character kind, and is an array
             expression, array element, or array element substring designator, the element sequence consists of the storage
             units beginning with the ﬁrst storage unit of the actual argument and continuing to the end of the array. The
             storage units of an array element substring designator are viewed as array elements consisting of consecutive
             groups of storage units having the character length of the dummy array.
          3 If the actual argument is default character or of type character with the C character kind, and is a scalar that is
             not an array element or array element substring designator, the element sequence consists of the storage units of
             the actual argument.
                  NOTE15.32
                  Some of the elements in the element sequence might consist of storage units from diﬀerent elements of the
                  original array.
          4 Anactual argument that represents an element sequence and corresponds to a dummy argument that is an array
             is sequence associated with the dummy argument if the dummy argument is an explicit-shape or assumed-size
             array. The rank and shape of the actual argument need not agree with the rank and shape of the dummy
             argument, but the number of elements in the dummy argument shall not exceed the number of elements in the
             element sequence of the actual argument. If the dummy argument is assumed-size, the number of elements in the
             dummy argument is exactly the number of elements in the element sequence.
             15.5.2.12  Argument presence and restrictions on arguments not present
          1 A dummy argument or an entity that is host associated with a dummy argument is not present if the dummy
             argument
                • does not correspond to an actual argument,
                • corresponds to an actual argument that is not present, or
                • does not have the ALLOCATABLE or POINTER attribute, and corresponds to an actual argument that
                     – has the ALLOCATABLE attribute and is not allocated, or
                                                                          c
             320                                                         ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                       – has the POINTER attribute and is disassociated;
              otherwise, it is present.
           2 A nonoptional dummy argument shall be present. If an optional nonpointer dummy argument corresponds to a
              present pointer actual argument, the pointer association status of the actual argument shall not be undeﬁned.
           3 An optional dummy argument that is not present is subject to the following restrictions.
                     (1)   If it is a data object, it shall not be referenced or be deﬁned. If it is of a type that has default
                           initialization, the initialization has no eﬀect.
                     (2)   It shall not be used as the data-target or proc-target of a pointer assignment.
                     (3)   If it is a procedure or procedure pointer, it shall not be invoked.
                     (4)   It shall not be supplied as an actual argument corresponding to a nonoptional dummy argument
                           other than as the argument of the intrinsic function PRESENT or as an argument of a function
                           reference that is a constant expression.
                     (5)   Adesignator with it as the base object and with one or more subobject selectors shall not be supplied
                           as an actual argument.
                     (6)   If it is an array, it shall not be supplied as an actual argument to an elemental procedure unless an
                           array of the same rank is supplied as an actual argument corresponding to a nonoptional dummy
                           argument of that elemental procedure.
                     (7)   If it is a pointer, it shall not be allocated, deallocated, nulliﬁed, pointer-assigned, or supplied as an
                           actual argument corresponding to an optional nonpointer dummy argument.
                     (8)   If it is allocatable, it shall not be allocated, deallocated, or supplied as an actual argument corres-
                           ponding to an optional nonallocatable dummy argument.
                     (9)   If it has length type parameters, they shall not be the subject of an inquiry.
                     (10)  It shall not be used as the selector in an ASSOCIATE, SELECTRANK,orSELECTTYPEconstruct.
                     (11)  It shall not be supplied as the data-ref in a procedure-designator.
                     (12)  If shall not be supplied as the scalar-variable in a proc-component-ref.
           4 Except as noted in the list above, it may be supplied as an actual argument corresponding to an optional dummy
              argument, which is then also considered not to be present.
              15.5.2.13    Restrictions on entities associated with dummy arguments
           1 While an entity is associated with a dummy argument, the following restrictions hold.
                     (1)   Action that aﬀects the allocation status of the entity or a subobject thereof shall be taken through
                           the dummy argument.
                     (2)   If the allocation status of the entity or a subobject thereof is aﬀected through the dummy argument,
                           then at any time during the invocation and execution of the procedure, either before or after the
                           allocation or deallocation, it shall be referenced only through the dummy argument.
                     (3)   Action that aﬀects the value of the entity or any subobject of it shall be taken only through the
                           dummy argument unless
                           (a)   the dummy argument has the POINTER attribute,
                           (b)   the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
                                 GETattribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
                                 ment is a target other than a coindexed object or an array section with a vector subscript,
                           (c)   the dummy argument is an assumed-rank object with the TARGET attribute and not the
                                 INTENT (IN) attribute, and the actual argument is a scalar target, or
                           (d)   the dummy argument is a coarray and the action is a coindexed deﬁnition of the corresponding
                                 ultimate argument coarray by a diﬀerent image.
                     (4)   If the value of the entity or any subobject of it is aﬀected through the dummy argument, then at
                           any time during the invocation and execution of the procedure, either before or after the deﬁnition,
                           it may be referenced only through that dummy argument unless
               c
              ISO/IEC 2017 – All rights reserved                                                                            321
              ISO/IEC DIS 1539-1:2017 (E)
                           (a)   the dummy argument has the POINTER attribute,
                           (b)   the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
                                 GETattribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
                                 ment is a target other than a coindexed object or an array section with a vector subscript,
                           (c)   the dummy argument is an assumed-rank object with the TARGET attribute and not the
                                 INTENT (IN) attribute, and the actual argument is a scalar target, or
                           (d)   the dummyargumentisacoarrayandthereferenceisacoindexedreferenceofitscorresponding
                                 ultimate argument coarray by a diﬀerent image.
                   NOTE15.33
                   In
                            SUBROUTINE OUTER
                                REAL, POINTER :: A (:)
                                ...
                                ALLOCATE (A (1:N))
                                ...
                                CALL INNER (A)
                                ...
                            CONTAINS
                                SUBROUTINE INNER (B)
                                   REAL :: B (:)
                                   ...
                                END SUBROUTINE INNER
                                SUBROUTINE SET (C, D)
                                   REAL, INTENT (OUT) :: C
                                   REAL, INTENT (IN) :: D
                                   C = D
                                END SUBROUTINE SET
                            END SUBROUTINE OUTER
                   an assignment statement such as
                            A (1) = 1.0
                   would not be permitted during the execution of INNER because this would be changing A without using
                   B, but statements such as
                            B (1) = 1.0
                   or
                            CALL SET (B (1), 1.0)
                   would be allowed. Similarly,
                            DEALLOCATE (A)
                   would not be allowed because this aﬀects the allocation of B without using B. In this case,
                            DEALLOCATE (B)
                   also would not be permitted. If B were declared with the POINTER attribute, either of the statements
                            DEALLOCATE (A)
                   and
                            DEALLOCATE (B)
                   would be permitted, but not both.
                                                                                 c
              322                                                                ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                NOTE15.34
                If there is a partial or complete overlap between the eﬀective arguments of two diﬀerent dummy arguments
                of the same procedure and the dummy arguments have neither the POINTER nor TARGET attribute,
                the overlapped portions cannot be deﬁned, redeﬁned, or become undeﬁned during the execution of the
                procedure. For example, in
                       CALL SUB (A (1:5), A (3:9))
                the array section A (3:5) cannot be deﬁned, redeﬁned, or become undeﬁned through the ﬁrst dummy
                argument because it is part of the argument associated with the second dummy argument and cannot be
                deﬁned, redeﬁned, or become undeﬁned through the second dummy argument because it is part of the
                argument associated with the ﬁrst dummy argument. The array section A (1:2) remains deﬁnable through
                the ﬁrst dummy argument and A (6:9) remains deﬁnable through the second dummy argument.
                This restriction applies equally to pointer targets. In
                       REAL, DIMENSION (10), TARGET :: A
                       REAL, DIMENSION (:), POINTER :: B, C
                       B => A (1:5)
                       C => A (3:9)
                       CALL SUB (B, C)  ! The dummy arguments of SUB are neither pointers nor targets.
                the array section B (3:5) cannot be deﬁned because it is part of the argument associated with the second
                dummyargument. Thearraysection C (1:3) cannot be deﬁned because it is part of the argument associated
                with the ﬁrst dummy argument. The array section A (1:2), which is associated with B (1:2), remains
                deﬁnable through the ﬁrst dummy argument and A (6:9), which is associated with C (4:7), remains deﬁnable
                through the second dummy argument.
                NOTE15.35
                In
                       MODULE DATA
                          REAL :: W, X, Y, Z
                       END MODULE DATA
                       PROGRAM MAIN
                          USE DATA
                             ...
                          CALL INIT (X)
                             ...
                       END PROGRAM MAIN
                       SUBROUTINE INIT (V)
                          USE DATA
                             ...
                          READ (*, *) V
                             ...
                       END SUBROUTINE INIT
                variable X cannot be directly referenced at any time during the execution of INIT because it is being deﬁned
                through the dummy argument V. X can be (indirectly) referenced through V. W, Y, and Z can be directly
                referenced. X can, of course, be directly referenced once execution of INIT is complete.
                NOTE15.36
                The restrictions on entities associated with dummy arguments are intended to facilitate a variety of optim-
                izations in the translation of the subprogram, including implementations of argument association in which
                the value of an actual argument that is neither a pointer nor a target is maintained in a register or in local
                storage.
            c
            ISO/IEC 2017 – All rights reserved                                                      323
              ISO/IEC DIS 1539-1:2017 (E)
                   NOTE15.37
                  Theexceptiontothealiasingrestrictions for dummy coarrays enables cross-image access while the procedure
                  is executing. Because nonatomic accesses from diﬀerent images typically need to be separated by an image
                  control statement, code optimization within segments is not unduly inhibited.
              15.5.3    Function reference
           1 A function is invoked during expression evaluation by a function-reference or by a deﬁned operation (10.1.6).
              When it is invoked, all actual argument expressions are evaluated, then the arguments are associated, and then
              the function is executed. When execution of the function is complete, the value of the function result is available
              for use in the expression that caused the function to be invoked. The characteristics of the function result (15.3.3)
              are determined by the interface of the function. If a reference to an elemental function (15.8) is an elemental
              reference, all array arguments shall have the same shape.
              15.5.4    Subroutine reference
           1 AsubroutineisinvokedbyexecutionofaCALLstatement,executionofadeﬁnedassignmentstatement(10.2.1.4),
              deﬁned input/output (12.6.4.8.3), or ﬁnalization(7.5.6).  When a subroutine is invoked, all actual argument
              expressions are evaluated, then the arguments are associated, and then the subroutine is executed. When the
              actions speciﬁed by the subroutine are completed, the execution of the CALL statement, the execution of the
              deﬁned assignment statement, the processing of an input or output list item, or ﬁnalization of an object is
              also completed. If a CALL statement includes one or more alternate return speciﬁers among its arguments, a branch to one
              of the statements indicated might occur, depending on the action speciﬁed by the subroutine. If a reference to an elemental
              subroutine (15.8) is an elemental reference, at least one actual argument shall correspond to an INTENT (OUT)
              or INTENT (INOUT) dummy argument, all such actual arguments shall be arrays, and all actual arguments
              shall be conformable.
              15.5.5    Resolving named procedure references
              15.5.5.1  Establishment of procedure names
           1 The rules for interpreting a procedure reference depend on whether the procedure name in the reference is
              established by the available declarations and speciﬁcations to be generic in the scoping unit containing the
              reference, is established to be only speciﬁc in the scoping unit containing the reference, or is not established.
           2 Aprocedure name is established to be generic in a scoping unit
                    (1)   if that scoping unit contains an interface block with that name;
                    (2)   if that scoping unit contains a GENERIC statement with a generic-spec that is that name;
                    (3)   if that scoping unit contains an INTRINSIC attribute speciﬁcation for that name and it is the generic
                          name of an intrinsic procedure;
                    (4)   if that scoping unit contains a USE statement that makes that procedure name accessible and the
                          corresponding name in the module is established to be generic; or
                    (5)   if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
                          and that name is established to be generic in the host scoping unit.
           3 A procedure name is established to be only speciﬁc in a scoping unit if it is established to be speciﬁc and not
              established to be generic. It is established to be speciﬁc
                    (1)   if that scoping unit contains a module subprogram, internal subprogram, or statement function statement
                          that deﬁnes a procedure with that name;
                    (2)   if that scoping unit is of a subprogram that deﬁnes a procedure with that name;
                    (3)   if that scoping unit contains an INTRINSIC attribute speciﬁcation for that name and it is the name of a speciﬁc
                          intrinsic procedure;
                    (4)   if that scoping unit contains an explicit EXTERNAL attribute speciﬁcation for that name;
                                                                              c
              324                                                            ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                     (5)   if that scoping unit contains a USE statement that makes that procedure name accessible and the
                           corresponding name in the module is established to be speciﬁc; or
                     (6)   if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
                           and that name is established to be speciﬁc in the host scoping unit.
           4 Aprocedure name is not established in a scoping unit if it is neither established to be generic nor established to
              be speciﬁc.
              15.5.5.2   Resolving procedure references to names established to be generic
           1 If the reference is consistent with a nonelemental reference to one of the speciﬁc interfaces of a generic interface
              that has that name and either is deﬁned in the scoping unit in which the reference appears or is made accessible
              by a USE statement in the scoping unit, the reference is to the speciﬁc procedure in the interface block that
              provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such speciﬁc procedure.
           2 Otherwise, if the reference is consistent with an elemental reference to one of the speciﬁc interfaces of a generic
              interface that has that name and either is deﬁned in the scoping unit in which the reference appears or is made
              accessible by a USE statement in the scoping unit, the reference is to the speciﬁc elemental procedure in the
              interface block that provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such
              speciﬁc elemental procedure.
           3 Otherwise, if the scoping unit contains either an INTRINSIC attribute speciﬁcation for that name or a USE
              statement that makes that name accessible from a module in which the corresponding name is speciﬁed to have
              the INTRINSIC attribute, and if the reference is consistent with the interface of that intrinsic procedure, the
              reference is to that intrinsic procedure.
           4 Otherwise, if the scoping unit has a host scoping unit, the name is established to be generic in that host scoping
              unit, and there is agreement between the scoping unit and the host scoping unit as to whether the name is a
              function name or a subroutine name, the name is resolved by applying the rules in this subclause to the host
              scoping unit as if the reference appeared there.
           5 Otherwise, if the nameis that of an intrinsic procedure and the reference is consistent with that intrinsic procedure,
              the reference is to that intrinsic procedure.
                   NOTE15.38
                   Because of the renaming facility of the USE statement, the name in the reference can be diﬀerent from the
                   usual name of the intrinsic procedure.
                   NOTE15.39
                   These rules allow particular speciﬁc procedures with the same generic identiﬁer to be used for particular
                   array ranks and a general elemental version to be used for other ranks. For example, given an interface
                   block such as
                            INTERFACE RANF
                                ELEMENTAL FUNCTION SCALAR_RANF(X)
                                   REAL, INTENT(IN) :: X
                                END FUNCTION SCALAR_RANF
                                FUNCTION VECTOR_RANDOM(X)
                                   REAL X(:)
                                   REAL VECTOR_RANDOM(SIZE(X))
                                END FUNCTION VECTOR_RANDOM
                            END INTERFACE RANF
                   and a declaration such as:
                            REAL A(10,10), AA(10,10)
                   then the statement
               c
              ISO/IEC 2017 – All rights reserved                                                                            325
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.39 (cont.)
                          A = RANF(AA)
                  is an elemental reference to SCALAR_RANF. The statement
                          A(6:10,2) = RANF(AA(6:10,2))
                  is a nonelemental reference to VECTOR_RANDOM.
             15.5.5.3   Resolving procedure references to names established to be only speciﬁc
          1 If the name has the EXTERNAL attribute,
                 • if it is a procedure pointer, the reference is to its target;
                 • if it is a dummy procedure that is not a procedure pointer, the reference is to the eﬀective argument
                   corresponding to that name;
                 • otherwise, the reference is to the external procedure with that name.
          2 If the name is that of an accessible external procedure, internal procedure, module procedure, intrinsic procedure,
             or statement function, the reference is to that procedure.
                  NOTE15.40
                  Because of the renaming facility of the USE statement, the name in the reference can be diﬀerent from the
                  original name of the procedure.
             15.5.5.4   Resolving procedure references to names not established
          1 If the name is the name of a dummy argument of the scoping unit, the dummy argument is a dummy procedure
             and the reference is to that dummy procedure. That is, the procedure invoked by executing that reference is the
             eﬀective argument corresponding to that dummy procedure.
          2 Otherwise, if the name is the name of an intrinsic procedure, and if there is agreement between the reference and
             the status of the intrinsic procedure as being a function or subroutine, the reference is to that intrinsic procedure.
          3 Otherwise, the reference is to an external procedure with that name.
             15.5.6     Resolving type-bound procedure references
          1 If the binding-name in a procedure-designator (R1522) is that of a speciﬁc type-bound procedure, the procedure
             referenced is the one bound to that name in the dynamic type of the data-ref.
          2 If the binding-name in a procedure-designator is that of a generic type bound procedure, the generic binding with
             that name in the declared type of the data-ref is used to select a speciﬁc binding using the following criteria.
                 • If the reference is consistent with one of the speciﬁc bindings of that generic binding, that speciﬁc binding
                   is selected.
                 • Otherwise, the reference shall be consistent with an elemental reference to one of the speciﬁc bindings of
                   that generic binding; that speciﬁc binding is selected.
          3 The reference is to the procedure bound to the same name as the selected speciﬁc binding in the dynamic type
             of the data-ref.
                                                                            c
             326                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             15.6      Procedure deﬁnition
             15.6.1     Intrinsic procedure deﬁnition
          1 Intrinsic procedures are deﬁned as an inherent part of the processor. A standard-conforming processor shall
             include the intrinsic procedures described in Clause 16, but may include others. However, a standard-conforming
             program shall not make use of intrinsic procedures other than those described in Clause 16.
             15.6.2     Procedures deﬁned by subprograms
             15.6.2.1   General
          1 Aprocedure is deﬁned by the initial SUBROUTINE or FUNCTION statement of a subprogram, and each ENTRY
             statement deﬁnes an additional procedure (15.6.2.6).
          2 Asubprogram is speciﬁed to have the NON_RECURSIVE attribute, or to be elemental (15.8), pure (15.7), or a
             separate module subprogram (15.6.2.5) by a preﬁx in its initial SUBROUTINE or FUNCTION statement.
             R1526 preﬁx                         is  preﬁx-spec [ preﬁx-spec ] ...
             R1527 preﬁx-spec                    is  declaration-type-spec
                                                 or ELEMENTAL
                                                 or IMPURE
                                                 or MODULE
                                                 or NON_RECURSIVE
                                                 or PURE
                                                 or RECURSIVE
             C1543 (R1526) A preﬁx shall contain at most one of each preﬁx-spec.
             C1544 (R1526) A preﬁx shall not specify both PURE and IMPURE.
             C1545 (R1526) A preﬁx shall not specify both NON_RECURSIVE and RECURSIVE.
             C1546 An elemental procedure shall not have the BIND attribute.
             C1547 (R1526) MODULE shall appear only in the function-stmt or subroutine-stmt of a module subprogram or
                     of a nonabstract interface body that is declared in the scoping unit of a module or submodule.
             C1548 (R1526) If MODULE appears in the preﬁx of a module subprogram, it shall have been declared to be a
                     separate module procedure in the containing program unit or an ancestor of that program unit.
             C1549 (R1526) If MODULE appears in the preﬁx of a module subprogram, the subprogram shall specify the
                     same characteristics and dummy argument names as its corresponding module procedure interface body.
             C1550 (R1526) If MODULE appears in the preﬁx of a module subprogram and a binding label is speciﬁed, it
                     shall be the same as the binding label speciﬁed in the corresponding module procedure interface body.
             C1551 (R1526) If MODULE appears in the preﬁx of a module subprogram, NON_RECURSIVE shall appear
                     if and only if NON_RECURSIVE appears in the preﬁx in the corresponding module procedure interface
                     body.
          3 The NON_RECURSIVE preﬁx-spec shall not appear if any procedure deﬁned by the subprogram directly or
             indirectly invokes itself or any other procedure deﬁned by the subprogram. If a subprogram deﬁnes a function whose name is
             declared with an asterisk type-param-value, no procedure deﬁned by the subprogram shall directly or indirectly invoke itself or any
             other procedure deﬁned by the subprogram.
          4 If the preﬁx-spec PURE appears, or the preﬁx-spec ELEMENTAL appears and IMPURE does not appear, the
             subprogram is a pure subprogram and shall meet the additional constraints of 15.7.
              c
             ISO/IEC 2017 – All rights reserved                                                                     327
             ISO/IEC DIS 1539-1:2017 (E)
          5 Ifthepreﬁx-spec ELEMENTALappears,thesubprogramisanelementalsubprogramandshallmeettheadditional
             constraints of 15.8.1.
             R1528 proc-language-binding-spec  is  language-binding-spec
          6 A proc-language-binding-spec speciﬁes that the procedure deﬁned or declared by the statement is interoperable
             (18.3.7).
             C1552 A proc-language-binding-spec with a NAME= speciﬁer shall not be speciﬁed in the function-stmt or
                     subroutine-stmt of an internal procedure, or of an interface body for an abstract interface or a dummy
                     procedure.
             C1553 Ifproc-language-binding-spec is speciﬁed for a function, the function result shall be an interoperable scalar
                     variable.
             C1554 If proc-language-binding-spec is speciﬁed for a procedure, each of its dummy arguments shall be an inter-
                     operable procedure (18.3.7) or a variable that is interoperable (18.3.5, 18.3.6), assumed-shape, assumed-
                     rank, assumed-type, of type CHARACTER with assumed length, or that has the ALLOCATABLE or
                     POINTERattribute.
             C1555 A variable that is a dummy argument of a procedure that has a proc-language-binding-spec shall be
                     assumed-type or of interoperable type and kind type parameters.
             C1556 If proc-language-binding-spec is speciﬁed for a procedure, it shall not have a default-initialized dummy
                     argument with the ALLOCATABLE or POINTER attribute.
             C1557 If proc-language-binding-spec is speciﬁed for a procedure, it shall not have a dummy argument that is a
                     coarray.
             C1558 If proc-language-binding-spec is speciﬁed for a procedure, it shall not have an array dummy argument
                     with the VALUE attribute.
             15.6.2.2  Function subprogram
          1 Afunction subprogram is a subprogram that has a FUNCTION statement as its ﬁrst statement.
             R1529 function-subprogram         is  function-stmt
                                                       [ speciﬁcation-part ]
                                                       [ execution-part ]
                                                       [ internal-subprogram-part ]
                                                       end-function-stmt
             R1530 function-stmt               is  [ preﬁx ] FUNCTION function-name
                                                     ( [ dummy-arg-name-list ] ) [ suﬃx ]
             C1559 (R1530) If RESULT appears, result-name shall not be the same as function-name and shall not be the same
                     as the entry-name in any ENTRY statement in the subprogram.
             C1560 (R1530) If RESULT appears, the function-name shall not appear in any speciﬁcation statement in the
                     scoping unit of the function subprogram.
             R1531 dummy-arg-name              is  name
             C1561 (R1531) A dummy-arg-name shall be the name of a dummy argument.
             R1532 suﬃx                        is  proc-language-binding-spec [ RESULT ( result-name ) ]
                                               or RESULT ( result-name ) [ proc-language-binding-spec ]
             R1533 end-function-stmt           is  END[FUNCTION[function-name ] ]
                                                                         c
             328                                                         ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
         C1562 (R1529) An internal function subprogram shall not contain an internal-subprogram-part.
         C1563 (R1533) If a function-name appears in the end-function-stmt, it shall be identical to the function-name
              speciﬁed in the function-stmt.
       2 The name of the function is function-name.
       3 The type and type parameters (if any) of the result of the function deﬁned by a function subprogram may be
         speciﬁed by a type speciﬁcation in the FUNCTION statement or by the name of the function result appearing
         in a type declaration statement in the speciﬁcation part of the function subprogram. They shall not be speciﬁed
         both ways. If they are not speciﬁed either way, they are determined by the implicit typing rules in eﬀect within
         the function subprogram. If the function result is an array, allocatable, or a pointer, this shall be speciﬁed by
         speciﬁcations of the name of the function result within the function body. The speciﬁcations of the function
         result attributes, the speciﬁcation of dummy argument attributes, and the information in the procedure heading
         collectively deﬁne the characteristics of the function (15.3.1).
       4 If RESULT appears, the name of the function result of the function is result-name and all occurrences of the
         function name in execution-part statements in its scope refer to the function itself. If RESULT does not appear,
         the name of the function result is function-name and all occurrences of the function name in execution-part
         statements in its scope are references to the function result. On completion of execution of the function, the value
         returned is that of its function result. If the function result is a data pointer, the shape of the value returned by
         the function is determined by the shape of the function result when the execution of the function is completed. If
         the function result is not a pointer, its value shall be deﬁned by the function. If the function result is a pointer,
         on return the pointer association status of the function result shall not be undeﬁned.
            NOTE15.41
            The function result is similar to any other entity (variable or procedure pointer) local to a function sub-
            program. Its existence begins when execution of the function is initiated and ends when execution of the
            function is terminated. However, because the ﬁnal value of this entity is used subsequently in the evaluation
            of the expression that invoked the function, an implementation might defer releasing the storage occupied
            by that entity until after its value has been used in expression evaluation.
            NOTE15.42
            Thefollowing is an example of the declaration of an interface body with the BIND attribute, and a reference
            to the procedure declared.
            USE, INTRINSIC :: ISO_C_BINDING
            INTERFACE
             FUNCTION JOE (I, J, R) BIND(C,NAME="FrEd")
               USE, INTRINSIC :: ISO_C_BINDING
               INTEGER(C_INT) :: JOE
               INTEGER(C_INT), VALUE :: I, J
               REAL(C_FLOAT), VALUE :: R
             END FUNCTION JOE
            END INTERFACE
            INT = JOE(1_C_INT, 3_C_INT, 4.0_C_FLOAT)
            END PROGRAM
            The invocation of the function JOE results in a reference to a function with a binding label "FrEd". FrEd
            could be a C function described by the C prototype
             int FrEd(int n, int m, float x);
         c
         ISO/IEC 2017 – All rights reserved                                 329
             ISO/IEC DIS 1539-1:2017 (E)
             15.6.2.3   Subroutine subprogram
          1 Asubroutine subprogram is a subprogram that has a SUBROUTINE statement as its ﬁrst statement.
             R1534 subroutine-subprogram         is  subroutine-stmt
                                                         [ speciﬁcation-part ]
                                                         [ execution-part ]
                                                         [ internal-subprogram-part ]
                                                         end-subroutine-stmt
             R1535 subroutine-stmt               is  [ preﬁx ] SUBROUTINE subroutine-name
                                                        [ ( [ dummy-arg-list ] ) [ proc-language-binding-spec ] ]
             C1564 (R1535) The preﬁx of a subroutine-stmt shall not contain a declaration-type-spec.
             R1536 dummy-arg                     is  dummy-arg-name
                                                 or *
             R1537 end-subroutine-stmt           is  END[SUBROUTINE[subroutine-name ] ]
             C1565 (R1534) An internal subroutine subprogram shall not contain an internal-subprogram-part.
             C1566 (R1537) If a subroutine-name appears in the end-subroutine-stmt, it shall be identical to the subroutine-
                     name speciﬁed in the subroutine-stmt.
          2 The name of the subroutine is subroutine-name.
             15.6.2.4   Instances of a subprogram
          1 Whenaprocedure deﬁned by a subprogram is invoked, an instance of that subprogram is created. Each instance
             has an independent sequence of execution and an independent set of dummy arguments, unsaved local variables,
             and unsaved local procedure pointers. Saved local entities are shared by all instances of the subprogram.
          2 Whenastatement function is invoked, an instance of that statement function is created.
          3 When execution of an instance completes it ceases to exist.
          4 The caller of an instance of a procedure is the instance of the main program, subprogram, or statement function
             that invoked it. The call sequence of an instance of a procedure is its caller, followed by the call sequence of its
             caller. The call sequence of the main program is empty. The host instance of an instance of a statement function
             or an internal procedure that is invoked by its name is the ﬁrst element of the call sequence that is an instance
             of the host of the statement function or internal subprogram. The host instance of an internal procedure that is
             invoked via a dummy procedure or procedure pointer is the host instance of the associating entity from when the
             argument association or pointer association was established (19.5.5). The host instance of a module procedure is
             the module or submodule in which it is deﬁned. A main program or external subprogram has no host instance.
             15.6.2.5   Separate module procedures
          1 A separate module procedure is a module procedure deﬁned by a separate-module-subprogram, by a function-
             subprogram whose initial statement contains the keyword MODULE, or by a subroutine-subprogram whose initial
             statement contains the keyword MODULE.
             R1538 separate-module-subprogram is     mp-subprogram-stmt
                                                         [ speciﬁcation-part ]
                                                         [ execution-part ]
                                                         [ internal-subprogram-part ]
                                                         end-mp-subprogram-stmt
             R1539 mp-subprogram-stmt            is  MODULEPROCEDUREprocedure-name
                                                                            c
             330                                                           ISO/IEC 2017 – All rights reserved
                                                                           ISO/IEC DIS 1539-1:2017 (E)
            R1540 end-mp-subprogram-stmt    is END[PROCEDURE[procedure-name]]
            C1567 (R1538)Theprocedure-name shallhavebeendeclaredtobeaseparatemoduleprocedureinthecontaining
                   program unit or an ancestor of that program unit.
            C1568 (R1540)Ifaprocedure-name appearsintheend-mp-subprogram-stmt,itshallbeidenticaltotheprocedure-
                   name in the mp-subprogram-stmt.
         2 Aseparate module procedure shall not be deﬁned more than once.
         3 Theinterfaceofaproceduredeﬁnedbyaseparate-module-subprogram isexplicitly declared by the mp-subprogram-
            stmt to be the same as its module procedure interface body. It has the NON_RECURSIVE attribute if and only
            if it was declared to have that attribute by the interface body. If it is a function its result name is determined
            by the FUNCTION statement in the interface body.
                NOTE15.43
                Aseparate module procedure can be accessed by use association only if its interface body is declared in the
                speciﬁcation part of a module and is public.
            15.6.2.6 ENTRY statement
         1 AnENTRYstatementpermitsaprocedurereferencetobeginwithaparticularexecutablestatementwithinthefunctionorsubroutine
            subprogram in which the ENTRY statement appears.
            R1541  entry-stmt               is ENTRYentry-name [ ( [ dummy-arg-list ] ) [ suﬃx ] ]
            C1569  (R1541) If RESULT appears, the entry-name shall not appear in any speciﬁcation or type declaration statement in the
                   scoping unit of the function program.
            C1570  (R1541) An entry-stmt shall appear only in an external-subprogram or a module-subprogram that does not deﬁne a separate
                   module procedure. An entry-stmt shall not appear within an executable-construct.
            C1571  (R1541) RESULT shall appear only if the entry-stmt is in a function subprogram.
            C1572  (R1541) A dummy-arg shall not be an alternate return indicator if the ENTRY statement is in a function subprogram.
            C1573  (R1541) If RESULT appears, result-name shall not be the same as the function-name in the FUNCTION statement and
                   shall not be the same as the entry-name in any ENTRY statement in the subprogram.
         2 Optionally, a subprogram may have one or more ENTRY statements.
         3 If the ENTRY statement is in a function subprogram, an additional function is deﬁned by that subprogram. The name of the
            function is entry-name and the name of its result is result-name or is entry-name if no result-name is provided. The dummy
            arguments of the function are those speciﬁed in the ENTRY statement. If the characteristics of the result of the function named in
            the ENTRY statement are the same as the characteristics of the result of the function named in the FUNCTION statement, their
            result names identify the same entity, although their names need not be the same. Otherwise, they are storage associated and shall
            all be nonpointer, nonallocatable scalar variables that are default integer, default real, double precision real, default complex, or
            default logical.
         4 If the ENTRY statement is in a subroutine subprogram, an additional subroutine is deﬁned by that subprogram. The name of the
            subroutine is entry-name. The dummy arguments of the subroutine are those speciﬁed in the ENTRY statement.
         5 The order, number, types, kind type parameters, and names of the dummy arguments in an ENTRY statement may diﬀer from the
            order, number, types, kind type parameters, and names of the dummy arguments in the FUNCTION or SUBROUTINE statement
            in the containing subprogram.
         6 Because an ENTRY statement deﬁnes an additional function or an additional subroutine, it is referenced in the same manner as any
            other function or subroutine (15.5).
         7 In a subprogram, a dummy argument speciﬁed in an ENTRY statement shall not appear in an executable statement preceding that
            ENTRY statement, unless it also appears in a FUNCTION, SUBROUTINE, or ENTRY statement that precedes the executable
            c
            ISO/IEC 2017 – All rights reserved                                                         331
               ISO/IEC DIS 1539-1:2017 (E)
               statement. A function result speciﬁed by a result-name in an ENTRY statement shall not appear in any executable statement that
               precedes the ﬁrst RESULT clause with that name.
            8 In a subprogram, a dummy argument speciﬁed in an ENTRY statement shall not appear in the expression of a statement function
               that precedes the ﬁrst dummy-arg with that name in the subprogram. A function result speciﬁed by a result-name in an ENTRY
               statement shall not appear in the expression of a statement function that precedes the ﬁrst RESULT clause with that name.
            9 If a dummy argument appears in an executable statement, the execution of the executable statement is permitted during the
               execution of a reference to the function or subroutine only if the dummy argument appears in the dummy argument list of the
               referenced procedure.
           10 If a dummy argument is used in a speciﬁcation expression to specify an array bound or character length of an object, the appearance
               of the object in a statement that is executed during a procedure reference is permitted only if the dummy argument appears in the
               dummy argument list of the referenced procedure and it is present (15.5.2.12).
           11 The NON_RECURSIVE and RECURSIVE keywords are not used in an ENTRY statement. Instead, the presence or absence of
               NON_RECURSIVEin the initial SUBROUTINE or FUNCTION statement controls whether the procedure deﬁned by an ENTRY
               statement is permitted to reference itself or another procedure deﬁned by the subprogram.
           12 The keywords PURE and IMPURE are not used in an ENTRY statement. Instead, the procedure deﬁned by an ENTRY statement
               is pure if and only if the subprogram is a pure subprogram.
           13 ThekeywordELEMENTALisnotusedinanENTRYstatement. Instead,theproceduredeﬁnedbyanENTRYstatementiselemental
               if and only if ELEMENTAL is speciﬁed in the SUBROUTINE or FUNCTION statement.
               15.6.2.7     RETURN statement
               R1542 return-stmt                         is   RETURN[scalar-int-expr ]
               C1574 (R1542) The return-stmt shall be in the inclusive scope of a function or subroutine subprogram.
               C1575 (R1542) The scalar-int-expr is allowed only in the inclusive scope of a subroutine subprogram.
            1 Execution of the RETURN statement completes execution of the instance of the subprogram in which it appears.
               If the expression appears and has a value n between 1 and the number of asterisks in the dummy argument list, the CALL statement
                                                                                                            th
               that invoked the subroutine branches (11.2) to the branch target statement identiﬁed by the n   alternate return speciﬁer in the
               actual argument list of the referenced procedure. If the expression is omitted or has a value outside the required range, there is no
               transfer of control to an alternate return.
            2 Execution of an end-function-stmt, end-mp-subprogram-stmt, or end-subroutine-stmt is equivalent to execution
               of a RETURN statement with no expression.
               15.6.2.8     CONTAINS statement
               R1543 contains-stmt                       is   CONTAINS
            1 The CONTAINS statement separates the body of a main program, module, submodule, or subprogram from any
               internal or module subprograms it might contain, or it introduces the type-bound procedure part of a derived-type
               deﬁnition (7.5.5). The CONTAINS statement is not executable.
               15.6.3       Deﬁnition and invocation of procedures by means other than Fortran
            1 A procedure may be deﬁned by means other than Fortran. The interface of a procedure deﬁned by means other
               than Fortran may be speciﬁed by an interface body or procedure declaration statement. A reference to such a
               procedure is made as though it were deﬁned by an external subprogram.
            2 A procedure deﬁned by means other than Fortran that is invoked by a Fortran procedure and does not cause
               termination of execution shall return to its caller.
                                                                                         c
               332                                                                      ISO/IEC 2017 – All rights reserved
                                                                                   ISO/IEC DIS 1539-1:2017 (E)
                  NOTE15.44
                  Examples of code that might cause a transfer of control that bypasses the normal return mechanism of
                  a Fortran procedure are setjmp and longjmp in C and exception handling in other languages. No such
                  behavior is permitted by this document.
          3 If the interface of a procedure has a proc-language-binding-spec, the procedure is interoperable (18.10).
          4 Interoperation with C functions is described in 18.10.
                  NOTE15.45
                  For explanatory information on deﬁnition of procedures by means other than Fortran, see subclause C.10.2.
             15.6.4    Statement function
          1 Astatement function is a function deﬁned by a single statement.
             R1544   stmt-function-stmt         is  function-name ( [ dummy-arg-name-list ] ) = scalar-expr
             C1576   (R1544) Each primary in scalar-expr shall be a constant (literal or named), a reference to a variable, a reference to a
                     function, or an expression in parentheses. Each operation shall be intrinsic. If scalar-expr contains a reference to a
                     function, the reference shall not require an explicit interface, the function shall not require an explicit interface unless it is
                     an intrinsic function, the function shall not be a transformational intrinsic, and the result shall be scalar. If an argument to
                     a function is an array, it shall be an array name. If a reference to a statement function appears in scalar-expr, its deﬁnition
                     shall have been provided earlier in the scoping unit and shall not be the name of the statement function being deﬁned.
             C1577   (R1544) Named constants in scalar-expr shall have been declared earlier in the scoping unit or made accessible by use
                     or host association. If array elements appear in scalar-expr, the array shall have been declared as an array earlier in the
                     scoping unit or made accessible by use or host association.
             C1578   (R1544) If a dummy-arg-name, variable, function reference, or dummy function reference is typed by the implicit typing
                     rules, its appearance in any subsequent type declaration statement shall conﬁrm this implied type and the values of any
                     implied type parameters.
             C1579   (R1544) The function-name and each dummy-arg-name shall be speciﬁed, explicitly or implicitly, to be scalar.
             C1580   (R1544) A given dummy-arg-name shall not appear more than once in a given dummy-arg-name-list.
             C1581   Astatement function shall not be of a parameterized derived type.
          2 Thedeﬁnition of a statement function with the same name as an accessible entity from the host shall be preceded by the declaration
             of its type in a type declaration statement.
          3 The dummy arguments have a scope of the statement function statement. Each dummy argument has the same type and type
             parameters as the entity of the same name in the scoping unit containing the statement function statement.
          4 Astatement function shall not be supplied as an actual argument.
          5 Execution of a statement function consists of evaluating the expression using the values of the actual arguments for the values of the
             corresponding dummy arguments and, if necessary, converting the result to the declared type and type parameters of the function.
          6 A function reference in the scalar expression shall not cause a dummy argument of the statement function to become redeﬁned or
             undeﬁned.
             15.7      Pure procedures
          1 Apure procedure is
                • a pure intrinsic procedure (16.1),
                • a module procedure in an intrinsic module, if it is speciﬁed to be pure,
                • deﬁned by a pure subprogram,
              c
             ISO/IEC 2017 – All rights reserved                                                                   333
          ISO/IEC DIS 1539-1:2017 (E)
            • a dummy procedure that has been speciﬁed to be PURE, or
            • astatement function that references only pure functions and does not contain the designator of a variable with the VOLATILE
              attribute.
        2 A pure subprogram is a subprogram that has the preﬁx-spec PURE or that has the preﬁx-spec ELEMENTAL
          and does not have the preﬁx-spec IMPURE. The following additional constraints apply to pure subprograms.
          C1582 The speciﬁcation-part of a pure function subprogram shall specify that all its nonpointer dummy data
                objects have the INTENT (IN) or the VALUE attribute.
          C1583 The function result of a pure function shall not be such that ﬁnalization of a reference to the function
                would reference an impure procedure.
          C1584 The function result of a pure function shall not be both polymorphic and allocatable, or have a poly-
                morphic allocatable ultimate component.
          C1585 The speciﬁcation-part of a pure subroutine subprogram shall specify the intents of all its nonpointer
                dummy data objects that do not have the VALUE attribute.
          C1586 An INTENT (OUT) dummy argument of a pure procedure shall not be such that ﬁnalization of the
                actual argument would reference an impure procedure.
          C1587 An INTENT (OUT) dummy argument of a pure procedure shall not be polymorphic or have a poly-
                morphic allocatable ultimate component.
          C1588 A local variable of a pure subprogram, or of a BLOCK construct within a pure subprogram, shall not
                have the SAVE or VOLATILE attribute.
             NOTE15.46
             Variable initialization in a type-declaration-stmt or a data-stmt implies the SAVE attribute; therefore, such
             initialization is also disallowed.
          C1589 The speciﬁcation-part of a pure subprogram shall specify that all its dummy procedures are pure.
          C1590 Ifaprocedurethatisneitheranintrinsic procedure norastatementfunction is used in a context that requires
                it to be pure, then its interface shall be explicit in the scope of that use. The interface shall specify that
                the procedure is pure.
          C1591 All internal subprograms in a pure subprogram shall be pure.
          C1592 A designator of a variable with the VOLATILE attribute shall not appear in a pure subprogram.
          C1593 In a pure subprogram any designator with a base object that is in common or accessed by host or use
                association, is a pointer dummy argument of a pure function, is a dummy argument with the INTENT
                (IN) attribute, is a coindexed object, or an object that is storage associated with any such variable, shall
                not be used
                (1) in a variable deﬁnition context (19.6.7),
                (2) in a pointer association context (19.6.8),
                (3) as the data-target in a pointer-assignment-stmt,
                (4) as the expr corresponding to a component in a structure-constructor if the component has the
                    POINTERattribute or has a pointer component at any level of component selection,
                (5) as the expr of an intrinsic assignment statement in which the variable is of a derived type if the
                    derived type has a pointer component at any level of component selection,
                (6) as the source-expr in a SOURCE= speciﬁer if the designator is of a derived type that has a pointer
                    component at any level of component selection,
                (7) as an actual argument corresponding to a dummy argument with the POINTER attribute, or
                                                        c
          334                                           ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
                (8) as the actual argument to the function C_LOC from the intrinsic module ISO_C_BINDING.
             NOTE15.47
             Item 5 requires that processors be able to determine if entities with the PRIVATE attribute or with private
             components have a pointer component.
          C1594 Anyprocedurereferenced in a pure subprogram, including one referenced via a deﬁned operation, deﬁned
                assignment, deﬁned input/output, or ﬁnalization, shall be pure.
          C1595 A statement that might result in the deallocation of a polymorphic entity is not permitted in a pure
                procedure.
             NOTE15.48
             This includes intrinsic assignment to a variable that has a potential subobject component that is poly-
             morphic and allocatable.
          C1596 A pure subprogram shall not contain a print-stmt, open-stmt, close-stmt, backspace-stmt, endﬁle-stmt,
                rewind-stmt, ﬂush-stmt, wait-stmt, or inquire-stmt.
          C1597 A pure subprogram shall not contain a read-stmt or write-stmt whose io-unit is a ﬁle-unit-number or *.
          C1598 A pure subprogram shall not contain an image control statement (11.6.1).
             NOTE15.49
             Theaboveconstraintsaredesignedtoguaranteethatapureprocedureisfreefromsideeﬀects(modiﬁcations
             of data visible outside the procedure), which means that it is safe to reference it in constructs such as DO
             CONCURRENTandFORALL, where there is no explicit order of evaluation.
             The constraints on pure subprograms appear to be complicated, but it is not necessary for a programmer
             to be intimately familiar with them. From the programmer’s point of view, these constraints can be
             summarized as follows: a pure subprogram cannot contain any operation that could conceivably result in
             anassignment or pointer assignment to acommonvariable, a variable accessed by use or host association, or an
             INTENT(IN) dummy argument; nor can a pure subprogram contain any operation that could conceivably
             performanyexternalﬁleinput/outputorexecuteanimagecontrolstatement(includingaSTOPstatement).
             Note the use of the word conceivably; it is not suﬃcient for a pure subprogram merely to be side-eﬀect
             free in practice. For example, a function that contains an assignment to a global variable but in a block
             that is not executed in any invocation of the function is nevertheless not a pure function. The exclusion of
             functions of this nature is required if strict compile-time checking is to be used.
             It is expected that most library procedures will conform to the constraints required of pure procedures, and
             so can be declared pure and referenced in DO CONCURRENT constructs, FORALL statements and constructs,
             and within user-deﬁned pure procedures.
             NOTE15.50
             Pure subroutines are included to allow subroutine calls from pure procedures in a safe way, and to allow
             forall-assignment-stmts to be deﬁned assignments. The constraints for pure subroutines are based on the same
             principles as for pure functions, except that side eﬀects to INTENT (OUT), INTENT (INOUT), and pointer
             dummy arguments are permitted.
          15.8   Elemental procedures
          15.8.1  Elemental procedure declaration and interface
        1 An elemental procedure is an elemental intrinsic procedure or a procedure that is deﬁned by an elemental sub-
          program. An elemental procedure has only scalar dummy arguments, but may have array actual arguments.
          c
          ISO/IEC 2017 – All rights reserved                                         335
           ISO/IEC DIS 1539-1:2017 (E)
         2 An elemental subprogram has the preﬁx-spec ELEMENTAL. An elemental subprogram is a pure subprogram
           unless it has the preﬁx-spec IMPURE. The following additional constraints apply to elemental subprograms.
           C1599 All dummy arguments of an elemental procedure shall be scalar noncoarray dummy data objects and
                 shall not have the POINTER or ALLOCATABLE attribute.
           C15100 Theresultofanelementalfunctionshallbescalar, andshallnothavethePOINTERorALLOCATABLE
                 attribute.
           C15101 Thespeciﬁcation-part of an elemental subprogram shall specify the intents of all of its dummy arguments
                 that do not have the VALUE attribute.
           C15102 In the speciﬁcation-expr that speciﬁes a type parameter value of the result of an elemental function, an
                 object designator with a dummy argument of the function as the base object shall appear only as the
                 subject of a speciﬁcation inquiry (10.1.11), and that speciﬁcation inquiry shall not depend on a property
                 that is deferred.
         3 In a reference to an elemental procedure, if any argument is an array, each actual argument that corresponds to
           an INTENT (OUT) or INTENT (INOUT) dummy argument shall be an array. All actual arguments shall be
           conformable. An array actual argument is considered to be associated with the scalar dummy arguments of the
           procedure throughout the entire execution of the elemental reference; thus, the restrictions on actions speciﬁed
           in 15.5.2.13 apply to the entirety of the actual array argument.
           15.8.2  Elemental function actual arguments and results
         1 If a generic name or a speciﬁc name is used to reference an elemental function, the shape of the result is the
           same as the shape of the actual argument with the greatest rank. If there are no actual arguments or the actual
           arguments are all scalar, the result is scalar. In the array case, the values of the elements, if any, of the result are
           the same as would have been obtained if the scalar function had been applied separately, in array element order,
           to corresponding elements of each array actual argument.
               NOTE15.51
               An example of an elemental reference to the intrinsic function MAX:
               if X and Y are arrays of shape (M, N),
               MAX (X, 0.0, Y)
               is an array expression of shape (M, N) whose elements have values
               MAX (X(I, J), 0.0, Y(I, J)), I = 1, 2, ..., M, J = 1, 2, ..., N
           15.8.3  Elemental subroutine actual arguments
         1 Inareferencetoanelementalsubroutine, if the actual arguments corresponding to INTENT (OUT) and INTENT
           (INOUT) dummy arguments are arrays, the values of the elements, if any, of the results are the same as would
           be obtained if the subroutine had been applied separately, in array element order, to corresponding elements of
           each array actual argument.
                                                              c
           336                                               ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
          16 Intrinsic procedures and modules
          16.1   Classes of intrinsic procedures
        1 Intrinsic procedures are divided into eight classes: inquiry functions, elemental functions, transformational func-
          tions, elemental subroutines, pure subroutines, atomic subroutines, collective subroutines, and (impure) sub-
          routines.
        2 Anintrinsic inquiry function is one whose result depends on the properties of one or more of its arguments instead
          of their values; in fact, these argument values may be undeﬁned. Unless the description of an intrinsic inquiry
          function states otherwise, these arguments are permitted to be unallocated allocatable variables or pointers that
          are undeﬁned or disassociated. An elemental intrinsic function is one that is speciﬁed for scalar arguments,
          but may be applied to array arguments as described in 15.8. All other intrinsic functions are transformational
          functions; they almost all have one or more array arguments or an array result. All standard intrinsic functions
          are pure.
        3 Anatomic subroutine is an intrinsic subroutine that performs an atomic action. The semantics of atomic actions
          are described in 16.5.
        4 A collective subroutine is an intrinsic subroutine that performs a cooperative calculation on a team of images
          without requiring synchronization. The semantics of collective subroutines are described in 16.6.
        5 The subroutine MOVE_ALLOC with noncoarray argument FROM, and the elemental subroutine MVBITS, are
          pure. No other standard intrinsic subroutine is pure.
        6 Generic names of standard intrinsic procedures are listed in 16.7. In most cases, generic functions accept argu-
          ments of more than one type and the type of the result is the same as the type of the arguments. Speciﬁc names of
          standard intrinsic functions with corresponding generic names are listed in 16.8.
        7 If an intrinsic procedure is used as an actual argument to a procedure, its speciﬁc name shall be used and it may be referenced in
          the called procedure only with scalar arguments. If an intrinsic procedure does not have a speciﬁc name, it shall not be used as an
          actual argument (15.5.2.9).
        8 Elemental intrinsic procedures behave as described in 15.8.
          16.2   Arguments to intrinsic procedures
          16.2.1  General rules
        1 All intrinsic procedures may be invoked with either positional arguments or argument keywords (15.5). The
          descriptions in 16.7 through 16.9 give the argument keyword names and positional sequence for standard intrinsic
          procedures.
        2 Many of the intrinsic procedures have optional arguments. These arguments are identiﬁed by the notation
          “optional” in the argument descriptions. In addition, the names of the optional arguments are enclosed in square
          brackets in description headings and in lists of procedures. The valid forms of reference for procedures with
          optional arguments are described in 15.5.2.
             NOTE16.1
             The text CMPLX (X [, Y, KIND]) indicates that Y and KIND are both optional arguments. Valid ref-
             erence forms include CMPLX(x), CMPLX(x, y), CMPLX(x, KIND=kind), CMPLX(x, y, kind), and CM-
             PLX(KIND=kind, X=x, Y=y).
          c
          ISO/IEC 2017 – All rights reserved                                         337
           ISO/IEC DIS 1539-1:2017 (E)
               NOTE16.2
               Some intrinsic procedures impose additional requirements on their optional arguments. For example, SE-
               LECTED_REAL_KINDrequiresthat at least one of its optional arguments be present, and RANDOM_-
               SEEDrequires that at most one of its optional arguments be present.
         3 Thedummyarguments of the speciﬁc intrinsic procedures in 16.8 have INTENT (IN). The dummy arguments of the intrinsic
           procedures in 16.9 have INTENT (IN) if the intent is not stated explicitly.
         4 The actual argument corresponding to an intrinsic function dummy argument named KIND shall be a scalar
           integer constant expression and its value shall specify a representation method for the function result that exists
           on the processor.
         5 Intrinsic subroutines that assign values to arguments of type character do so in accordance with the rules of
           intrinsic assignment (10.2.1.3).
         6 In a reference to the intrinsic subroutine MVBITS, the actual arguments corresponding to the TO and FROM
           dummyarguments may be the same variable and may be associated scalar variables or associated array variables
           all of whose corresponding elements are associated. Apart from this, the actual arguments in a reference to an
           intrinsic subroutine shall be such that the execution of the intrinsic subroutine would satisfy the restrictions of
           15.5.2.13.
         7 An argument to an intrinsic procedure other than ASSOCIATED, NULL, or PRESENT shall be a data object.
           16.2.2  The shape of array arguments
         1 Unless otherwise speciﬁed, the intrinsic inquiry functions accept array arguments for which the shape need not
           be deﬁned. The shape of array arguments to transformational and elemental intrinsic functions shall be deﬁned.
           16.2.3  Mask arguments
         1 Some array intrinsic functions have an optional MASK argument of type logical that is used by the function to
           select the elements of one or more arguments to be operated on by the function. Any element not selected by the
           mask need not be deﬁned at the time the function is invoked.
         2 The MASK aﬀects only the value of the function, and does not aﬀect the evaluation, prior to invoking the
           function, of arguments that are array expressions.
           16.2.4  DIM arguments and reduction functions
         1 Some array intrinsic functions are “reduction” functions; that is, they reduce the rank of an array by collapsing
           one dimension (or all dimensions, usually producing a scalar result). These functions have a DIM argument that
           can specify the dimension to be reduced.
         2 The process of reducing a dimension usually combines the selected elements with a simple operation such as
           addition or an intrinsic function such as MAX, but more sophisticated reductions are also provided, e.g. by
           COUNTandMAXLOC.
           16.3    Bit model
           16.3.1  General
         1 The bit manipulation procedures are described in terms of a model for the representation and behavior of bits
           on a processor.
         2 For the purposes of these procedures, a bit is deﬁned to be a binary digit w located at position k of a nonnegative
           integer scalar object based on a model nonnegative integer deﬁned by
                                                              c
           338                                               ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                                                                z−1
                                                            j = Xwk×2k
                                                                k=0
             and for which w may have the value 0 or 1. This deﬁnes a sequence of bits w    . . . w , with w the leftmost
                             k                                                          z−1     0        z−1
             bit and w0 the rightmost bit. The positions of bits in the sequence are numbered from right to left, with the
             position of the rightmost bit being zero. The length of a sequence of bits is z. An example of a model number
             compatible with the examples used in 16.4 would have z = 32, thereby deﬁning a 32-bit integer.
          3 The interpretation of a negative integer as a sequence of bits is processor dependent.
          4 The inquiry function BIT_SIZE provides the value of the parameter z of the model.
          5 Eﬀectively, this model deﬁnes an integer object to consist of z bits in sequence numbered from right to left from
             0 to z − 1. This model is valid only in the context of the use of such an object as the argument or result of an
             intrinsic procedure that interprets that object as a sequence of bits. In all other contexts, the model deﬁned for
             an integer in 16.4 applies. In particular, whereas the models are identical for r = 2 and wz−1 = 0, they do not
             correspond for r 6= 2 or wz−1 = 1 and the interpretation of bits in such objects is processor dependent.
             16.3.2     Bit sequence comparisons
          1 When bit sequences of unequal length are compared, the shorter sequence is considered to be extended to the
             length of the longer sequence by padding with zero bits on the left.
          2 Bit sequences are compared from left to right, one bit at a time, until unequal bits are found or all bits have been
             compared and found to be equal. If unequal bits are found, the sequence with zero in the unequal position is
             considered to be less than the sequence with one in the unequal position. Otherwise the sequences are considered
             to be equal.
             16.3.3     Bit sequences as arguments to INT and REAL
          1 When a boz-literal-constant is the argument A of the intrinsic function INT or REAL,
                 • if the length of the sequence of bits speciﬁed by A is less than the size in bits of a scalar variable of the
                   same type and kind type parameter as the result, the boz-literal-constant is treated as if it were extended
                   to a length equal to the size in bits of the result by padding on the left with zero bits, and
                 • if the length of the sequence of bits speciﬁed by A is greater than the size in bits of a scalar variable of the
                   same type and kind type parameter as the result, the boz-literal-constant is treated as if it were truncated
                   from the left to a length equal to the size in bits of the result.
             C1601 If a boz-literal-constant is truncated as an argument to the intrinsic function REAL, the discarded bits
                     shall all be zero.
                  NOTE16.3
                  The result values of the intrinsic functions CMPLX and DBLE are deﬁned by references to the intrinsic
                  function REAL with the same arguments. Therefore, the padding and truncation of boz-literal-constant
                  arguments to those intrinsic functions is the same as for the intrinsic function REAL.
             16.4      Numeric models
          1 The numeric manipulation and inquiry functions are described in terms of a model for the representation and
             behavior of numbers on a processor. The model has parameters that are determined so as to make the model
             best ﬁt the machine on which the program is executed.
              c
             ISO/IEC 2017 – All rights reserved                                                                     339
             ISO/IEC DIS 1539-1:2017 (E)
          2 The model set for integer i is deﬁned by
                                                                q−1
                                                         i = s × Xwk ×rk
                                                                k=0
             where r is an integer exceeding one, q is a positive integer, each wk is a nonnegative integer less than r, and s is
             +1 or −1. The integer parameters r and q determine the set of model integers.
          3 The model set for real x is deﬁned by
                                                        0or
                                                        
                                                                   p
                                                    x=         e  X −k
                                                        s×b ×k=1fk×b
             where b and p are integers exceeding one; each f is a nonnegative integer less than b, with f nonzero; s is
                                                            k                                           1
             +1 or −1; and e is an integer that lies between some integer maximum e    and some integer minimum e
                                                                                   max                             min
             inclusively. For x = 0, its exponent e and digits fk are deﬁned to be zero. The integer parameters b, p, emin, and
             e    determine the set of model ﬂoating-point numbers.
              max
          4 The parameters of the integer and real models are available for each representation method of the integer and
             real types. The parameters characterize the set of available numbers in the deﬁnition of the model. Intrinsic
             functions provide the values of some parameters and other values related to the models.
          5 There is also an extended model set for each kind of real x; this extended model is the same as the ordinary
             model except that there are no limits on the range of the exponent e.
                  NOTE16.4
                  Some of the function descriptions use the models
                                                                  30
                                                          i = s × Xwk ×2k
                                                                  k=0
                  and
                                                                24         !
                                                      e    1   X −k
                                         x=0ors×2 × 2+k=2fk×2                , −126≤e≤127
             16.5     Atomic subroutines
          1 Anatomic subroutine is an intrinsic subroutine that performs an action on its ATOM argument, and if it has an
             OLDargument, determination of the value to be assigned to that argument, atomically. Deﬁnition or evaluation
             of any argument other than ATOM is not performed atomically.
          2 For any two executions in unordered segments of atomic subroutines whose ATOM argument is the same object,
             the eﬀect is as if one of the executions is performed completely before the other execution begins. Which execution
             is performed ﬁrst is processor dependent. The sequence of atomic actions within ordered segments is speciﬁed in
             5.3.5. If successive atomic subroutine invocations on image P redeﬁne a variable atomically in segments P and
             P , atomic references to that variable from image Q in a segment Q that is unordered relative to P and P imay
              j                                                             k                             i      j
             observe the changes in the value of that variable in any order.
          3 Atomic operations shall make asynchronous progress. If a variable X on image P is deﬁned by an atomic
             subroutine on image Q, image R repeatedly references X [P] by an atomic subroutine in an unordered segment,
             and no other image deﬁnes X [P] in an unordered segment, image R shall eventually receive the value assigned
                                                                          c
             340                                                         ISO/IEC 2017 – All rights reserved
                                                      ISO/IEC DIS 1539-1:2017 (E)
         by image Q, even if none of the images P, Q, or R execute an image control statement until after the deﬁnition
         of X [P] by image Q and the reception of that value by image R.
       4 If the STAT argument is present in an invocation of an atomic subroutine and no error condition occurs, it is
         assigned the value zero.
       5 If the STAT argument is present in an invocation of an atomic subroutine and an error condition occurs, any
         other argument that is not INTENT (IN) becomes undeﬁned. If the ATOM argument is on a failed image, an
         error condition occurs and the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
         ENVis assigned to the STAT argument. If any other error condition occurs, the STAT argument is assigned a
         processor-dependent positive value that is diﬀerent from the value of STAT_FAILED_IMAGE.
       6 If the STAT argument is not present in an invocation of an atomic subroutine and an error condition occurs,
         error termination is initiated.
            NOTE16.5
            The properties of atomic subroutines are intended to support custom synchronization mechanisms. The
            program will need to handle all possible orderings of sequences of atomic subroutine executions that can
            arise as a consequence of the above rules; note that the orderings can appear to be diﬀerent on diﬀerent
            images even in the same program execution.
         16.6  Collective subroutines
       1 Successful execution of a collective subroutine performs a calculation on all the images of the current team and
         assigns a computed value on one or all of them. If it is invoked by one image, it shall be invoked by the same
         statement on all active images of its current team in segments that are not ordered with respect to each other;
         corresponding references participate in the same collective computation.
       2 Before execution of the ﬁrst CHANGE TEAM statement on an image, in between executions of CHANGE
         TEAMand/or END TEAMstatements, and after the last execution of an END TEAM statement, the sequence
         of invocations of collective subroutines shall be the same on all active images of a team. A collective subroutine
         shall not be referenced when an image control statement is not permitted to be executed (for example, in a
         procedure invoked from a CRITICAL construct).
         C1602 A reference to a collective subroutine shall not appear in a context where an image control statement is
              not permitted to appear.
       3 If the A argument in a reference to a collective subroutine is a coarray, the corresponding ultimate arguments on
         all active images of the current team shall be corresponding coarrays as described in 5.4.7.
       4 If the STAT argument is present in a reference to a collective subroutine on one image, it shall be present on all
         the corresponding references.
       5 If the STAT argument is present in a reference to a collective subroutine and its execution is successful, it is
         assigned the value zero.
       6 If the STAT argument is present in a reference to a collective subroutine and an error condition occurs, it is
         assigned a positive value and the A argument becomes undeﬁned.
       7 If the STAT argument is present and the current team contains stopped images, an error condition occurs and
         the value STAT_STOPPED_IMAGEfromtheintrinsic module ISO_FORTRAN_ENVisassignedtotheSTAT
         argument. Otherwise, if the current team contained failed images, an error condition occurs and the value
         STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV is assigned to the STAT argument.
         If any other error condition occurs, the STAT argument is assigned a processor-dependent positive value that is
         diﬀerent from the value of STAT_STOPPED_IMAGE or STAT_FAILED_IMAGE.
       8 If the STAT argument is not present in a reference to a collective subroutine and an error condition occurs, error
         termination is initiated.
         c
         ISO/IEC 2017 – All rights reserved                               341
         ISO/IEC DIS 1539-1:2017 (E)
       9 If the ERRMSG argument is present in a reference to a collective subroutine and an error condition occurs, it is
         assigned an explanatory message, truncated or padded with blanks if required. If no error condition occurs, the
         deﬁnition status and value of ERRMSG are unchanged.
            NOTE16.6
            The argument A becomes undeﬁned if an error condition occurs during execution of a collective subroutine
            because it is intended to allow the processor to use A for intermediate values during calculation.
            NOTE16.7
            Although the calculations performed by a collective subroutine have some internal synchronizations, a
            reference to a collective subroutine is not an image control statement.
         16.7  Standard generic intrinsic procedures
       1 For all of the standard intrinsic procedures, the arguments shown are the names that shall be used for argument
         keywords if the keyword form is used for actual arguments.
            NOTE16.8
            For example, a reference to CMPLX can be written in the form CMPLX (A, B, M) or in the form CM-
            PLX(Y=B,KIND=M,X=A).
            NOTE16.9
            Many of the argument keywords have names that are indicative of their usage. For example:
               KIND                    Describes the kind type parameter of the result
               STRING, STRING_A        An arbitrary character string
               BACK                    Controls the direction of string scan
                                         (forward or backward)
               MASK                    Amaskto be applied to the arguments
               DIM                     Aselected dimension of an array argument
       2 In the Class column of Table 16.1,
          A indicates that the procedure is an atomic subroutine,
          C indicates that the procedure is a collective subroutine,
           E indicates that the procedure is an elemental function,
          ES indicates that the procedure is an elemental subroutine,
           I indicates that the procedure is an inquiry function,
          PS indicates that the procedure is a pure subroutine when the FROM argument is not a coarray,
           S indicates that the procedure is an impure subroutine, and
          T indicates that the procedure in a transformational function.
                       Table 16.1: Standard generic intrinsic procedure summary
           Procedure       Arguments          Class Description
           ABS             (A)                 E  Absolute value.
           ACHAR           (I [, KIND])        E  Character from ASCII code value.
           ACOS            (X)                 E  Arccosine (inverse cosine) function.
           ACOSH           (X)                 E  Inverse hyperbolic cosine function.
           ADJUSTL         (STRING)            E  Left-justiﬁed string value.
           ADJUSTR         (STRING)            E  Right-justiﬁed string value.
           AIMAG           (Z)                 E  Imaginary part of a complex number.
           AINT            (A [, KIND])        E  Truncation toward 0 to a whole number.
                                                 c
         342                                    ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                                  Table 16.1: Standard generic intrinsic procedure summary                            (cont.)
                   Procedure                 Arguments                       Class Description
                   ALL                       (MASK) or (MASK, DIM)             T    Array reduced by .AND. operator.
                   ALLOCATED                 (ARRAY) or (SCALAR)               I    Allocation status of allocatable variable.
                   ANINT                     (A [, KIND])                      E    Nearest whole number.
                   ANY                       (MASK) or (MASK, DIM)             T    Array reduced by .OR. operator.
                   ASIN                      (X)                               E    Arcsine (inverse sine) function.
                   ASINH                     (X)                               E    Inverse hyperbolic sine function.
                   ASSOCIATED                (POINTER [, TARGET])              I    Pointer association status inquiry.
                   ATAN                      (X) or (Y, X)                     E    Arctangent (inverse tangent) function.
                   ATAN2                     (Y, X)                            E    Arctangent (inverse tangent) function.
                   ATANH                     (X)                               E    Inverse hyperbolic tangent function.
                   ATOMIC_ADD                (ATOM, VALUE [, STAT])            A    Atomic addition.
                   ATOMIC_AND                (ATOM, VALUE [, STAT])            A    Atomic bitwise AND.
                   ATOMIC_CAS                (ATOM, OLD, COMPARE,              A    Atomic compare and swap.
                                             VALUE[, STAT])
                   ATOMIC_DEFINE             (ATOM, VALUE [, STAT])            A    Deﬁne a variable atomically.
                   ATOMIC_FETCH_-            (ATOM, VALUE, OLD                 A    Atomic fetch and add.
                   ADD                       [, STAT])
                   ATOMIC_FETCH_-            (ATOM, VALUE, OLD                 A    Atomic fetch and bitwise AND.
                   AND                       [, STAT])
                   ATOMIC_FETCH_-            (ATOM, VALUE, OLD                 A    Atomic fetch and bitwise OR.
                   OR                        [, STAT])
                   ATOMIC_FETCH_-            (ATOM, VALUE, OLD                 A    Atomic fetch and bitwise exclusive OR.
                   XOR                       [, STAT])
                   ATOMIC_OR                 (ATOM, VALUE [, STAT])            A    Atomic bitwise OR.
                   ATOMIC_REF                (VALUE, ATOM [, STAT])            A    Reference a variable atomically.
                   ATOMIC_XOR                (ATOM, VALUE [, STAT])            A    Atomic bitwise exclusive OR.
                   BESSEL_J0                 (X)                               E    Bessel function of the 1st kind, order 0.
                   BESSEL_J1                 (X)                               E    Bessel function of the 1st kind, order 1.
                   BESSEL_JN                 (N, X)                            E    Bessel function of the 1st kind, order N.
                   BESSEL_JN                 (N1, N2, X)                       T    Bessel functions of the 1st kind.
                                                                                                            nd
                   BESSEL_Y0                 (X)                               E    Bessel function of the 2   kind, order 0.
                                                                                                            nd
                   BESSEL_Y1                 (X)                               E    Bessel function of the 2   kind, order 1.
                                                                                                            nd
                   BESSEL_YN                 (N, X)                            E    Bessel function of the 2   kind, order N.
                   BESSEL_YN                 (N1, N2, X)                       T    Bessel functions of the 2nd kind.
                   BGE                       (I, J)                            E    Bitwise greater than or equal to.
                   BGT                       (I, J)                            E    Bitwise greater than.
                   BIT_SIZE                  (I)                               I    Number of bits in integer model 16.3.
                   BLE                       (I, J)                            E    Bitwise less than or equal to.
                   BLT                       (I, J)                            E    Bitwise less than.
                   BTEST                     (I, POS)                          E    Test single bit in an integer.
                   CEILING                   (A [, KIND])                      E    Least integer greater than or equal to A.
                   CHAR                      (I [, KIND])                      E    Character from code value.
                   CMPLX                     (X [, KIND]) or                   E    Conversion to complex type.
                                             (X [, Y, KIND])
                   CO_BROADCAST              (A, SOURCE_IMAGE [,               C    Broadcast value to images.
                                             STAT, ERRMSG])
                   CO_MAX                    (A [, RESULT_IMAGE,               C    Computemaximumvalueacrossimages.
                                             STAT, ERRMSG])
                   CO_MIN                    (A [, RESULT_IMAGE,               C    Computeminimumvalueacross images.
                                             STAT, ERRMSG])
                   CO_REDUCE                 (A, OPERATION [,                  C    Generalized reduction across images.
                                             RESULT_IMAGE, STAT,
                                             ERRMSG])
               c
              ISO/IEC 2017 – All rights reserved                                                                            343
            ISO/IEC DIS 1539-1:2017 (E)
                           Table 16.1: Standard generic intrinsic procedure summary             (cont.)
               Procedure            Arguments                 Class Description
               CO_SUM               (A [, RESULT_IMAGE,         C   Compute sum across images.
                                    STAT, ERRMSG])
               COMMAND_ARGU- ()                                 T   Number of command arguments.
               MENT_COUNT
               CONJG                (Z)                         E   Conjugate of a complex number.
               COS                  (X)                         E   Cosine function.
               COSH                 (X)                         E   Hyperbolic cosine function.
               COSHAPE              (COARRAY[, KIND])           I   Sizes of codimensions of a coarray.
               COUNT                (MASK[, DIM, KIND])         T   Logical array reduced by counting true
                                                                    values.
               CPU_TIME             (TIME)                      S   Processor time used.
               CSHIFT               (ARRAY, SHIFT [, DIM])      T   Circular shift of an array.
               DATE_AND_TIME        ([DATE, TIME, ZONE,         S   Date and time.
                                    VALUES])
               DBLE                 (A)                         E   Conversion to double precision real.
               DIGITS               (X)                         I   Signiﬁcant digits in numeric model.
               DIM                  (X, Y)                      E   Maximum of X − Y and zero.
               DOT_PRODUCT          (VECTOR_A,                  T   Dot product of two vectors.
                                    VECTOR_B)
               DPROD                (X, Y)                      E   Double precision real product.
               DSHIFTL              (I, J, SHIFT)               E   Combined left shift.
               DSHIFTR              (I, J, SHIFT)               E   Combined right shift.
               EOSHIFT              (ARRAY, SHIFT [,            T   End-oﬀ shift of the elements of an array.
                                    BOUNDARY,DIM])
               EPSILON              (X)                         I   Model number that is small compared
                                                                    to 1.
               ERF                  (X)                         E   Error function.
               ERFC                 (X)                         E   Complementary error function.
               ERFC_SCALED          (X)                         E   Scaled complementary error function.
               EVENT_QUERY          (EVENT, COUNT [, STAT])     S   Query event count.
               EXECUTE_COM-         (COMMAND[,WAIT,             S   Execute a command line.
               MAND_LINE            EXITSTAT, CMDSTAT,
                                    CMDMSG])
               EXP                  (X)                         E   Exponential function.
               EXPONENT             (X)                         E   Exponent of ﬂoating-point number.
               EXTENDS_TYPE_-       (A, MOLD)                   I   Dynamic type extension inquiry.
               OF
               FAILED_IMAGES        ([TEAM, KIND])              T   Indices of failed images.
               FINDLOC              (ARRAY, VALUE, DIM [,       T   Location(s) of a speciﬁed value.
                                    MASK, KIND, BACK]) or
                                    (ARRAY, VALUE [, MASK,
                                    KIND, BACK])
               FLOOR                (A [, KIND])                E   Greatest integer less than or equal to A.
               FRACTION             (X)                         E   Fractional part of number.
               GAMMA                (X)                         E   Gammafunction.
               GET_COMMAND          ([COMMAND, LENGTH,          S   Get program invocation command.
                                    STATUS, ERRMSG])
               GET_COMMAND_- (NUMBER[,VALUE,                    S   Get program invocation argument.
               ARGUMENT             LENGTH, STATUS,
                                    ERRMSG])
               GET_ENVIRON-         (NAME[, VALUE,              S   Get environment variable.
               MENT_VARIABLE        LENGTH, STATUS,
                                    TRIM_NAME,ERRMSG])
                                                                  c
            344                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                           Table 16.1: Standard generic intrinsic procedure summary             (cont.)
               Procedure            Arguments                 Class Description
               GET_TEAM             ([LEVEL])                   T   Team.
               HUGE                 (X)                         I   Largest model number.
               HYPOT                (X, Y)                      E   Euclidean distance function.
               IACHAR               (C [, KIND])                E   ASCII code value for character.
               IALL                 (ARRAY, DIM [, MASK]) or    T   Array reduced by IAND function.
                                    (ARRAY[, MASK])
               IAND                 (I, J)                      E   Bitwise AND.
               IANY                 (ARRAY, DIM [, MASK]) or    T   Array reduced by IOR function.
                                    (ARRAY[, MASK])
               IBCLR                (I, POS)                    E   I with bit POS replaced by zero.
               IBITS                (I, POS, LEN)               E   Speciﬁed sequence of bits.
               IBSET                (I, POS)                    E   I with bit POS replaced by one.
               ICHAR                (C [, KIND])                E   Code value for character.
               IEOR                 (I, J)                      E   Bitwise exclusive OR.
               IMAGE_INDEX          (COARRAY, SUB) or           I   Image index from cosubscripts.
                                    (COARRAY, SUB, TEAM)
                                    or (COARRAY, SUB,
                                    TEAM_NUMBER)
               IMAGE_STATUS         (IMAGE [, TEAM])            T   Image execution state.
               INDEX                (STRING, SUBSTRING [,       E   Character string search.
                                    BACK, KIND])
               INT                  (A [, KIND])                E   Conversion to integer type.
               IOR                  (I, J)                      E   Bitwise inclusive OR.
               IPARITY              (ARRAY, DIM [, MASK]) or    T   Array reduced by IEOR function.
                                    (ARRAY[, MASK])
               ISHFT                (I, SHIFT)                  E   Logical shift.
               ISHFTC               (I, SHIFT [, SIZE])         E   Circular shift of the rightmost bits.
               IS_CONTIGUOUS        (ARRAY)                     I   Array contiguity test (8.5.7).
               IS_IOSTAT_END        (I)                         E   IOSTAT value test for end of ﬁle.
               IS_IOSTAT_EOR        (I)                         E   IOSTAT value test for end of record.
               KIND                 (X)                         I   Value of the kind type parameter of X.
               LBOUND               (ARRAY[, DIM, KIND])        I   Lower bound(s).
               LCOBOUND             (COARRAY[, DIM, KIND])      I   Lower cobound(s) of a coarray.
               LEADZ                (I)                         E   Number of leading zero bits.
               LEN                  (STRING [, KIND])           I   Length of a character entity.
               LEN_TRIM             (STRING [, KIND])           E   Length without trailing blanks.
               LGE                  (STRING_A, STRING_B)        E   ASCII greater than or equal.
               LGT                  (STRING_A, STRING_B)        E   ASCII greater than.
               LLE                  (STRING_A, STRING_B)        E   ASCII less than or equal.
               LLT                  (STRING_A, STRING_B)        E   ASCII less than.
               LOG                  (X)                         E   Natural logarithm.
               LOG_GAMMA            (X)                         E   Logarithm of the absolute value of the
                                                                    gamma function.
               LOG10                (X)                         E   Common logarithm.
               LOGICAL              (L [, KIND])                E   Conversion between kinds of logical.
               MASKL                (I [, KIND])                E   Left justiﬁed mask.
               MASKR                (I [, KIND])                E   Right justiﬁed mask.
               MATMUL               (MATRIX_A, MATRIX_B)        T   Matrix multiplication.
               MAX                  (A1, A2 [, A3, ...])        E   Maximum value.
               MAXEXPONENT          (X)                         I   Maximum exponent of a real model.
               MAXLOC               (ARRAY, DIM [, MASK,        T   Location(s) of maximum value.
                                    KIND, BACK]) or (ARRAY
                                    [, MASK, KIND, BACK])
            c
            ISO/IEC 2017 – All rights reserved                                                      345
                ISO/IEC DIS 1539-1:2017 (E)
                                      Table 16.1: Standard generic intrinsic procedure summary                                        (cont.)
                     Procedure                     Arguments                           Class Description
                     MAXVAL                        (ARRAY, DIM [, MASK]) or               T     Maximum value(s) of array.
                                                   (ARRAY[, MASK])
                     MERGE                         (TSOURCE, FSOURCE,                     E     Expression value selection.
                                                   MASK)
                     MERGE_BITS                    (I, J, MASK)                           E     Merge of bits under mask.
                     MIN                           (A1, A2 [, A3, ...])                   E     Minimum value.
                     MINEXPONENT                   (X)                                    I     Minimum exponent of a real model.
                     MINLOC                        (ARRAY, DIM [, MASK,                   T     Location(s) of minimum value.
                                                   KIND, BACK]) or (ARRAY
                                                   [, MASK, KIND, BACK])
                     MINVAL                        (ARRAY, DIM [, MASK]) or               T     Minimum value(s) of array.
                                                   (ARRAY[, MASK])
                     MOD                           (A, P)                                 E     Remainder function.
                     MODULO                        (A, P)                                 E     Modulo function.
                     MOVE_ALLOC                    (FROM, TO [, STAT,                    PS     Move an allocation.
                                                   ERRMSG])
                     MVBITS                        (FROM, FROMPOS, LEN,                  ES     Copy a sequence of bits.
                                                   TO, TOPOS)
                     NEAREST                       (X, S)                                 E     Adjacent machine number.
                     NEW_LINE                      (A)                                    I     Newline character.
                     NINT                          (A [, KIND])                           E     Nearest integer.
                     NORM2                         (X) or (X, DIM)                        T     L2 norm of an array.
                     NOT                           (I)                                    E     Bitwise complement.
                     NULL                          ([MOLD])                               T     Disassociated pointer or unallocated al-
                                                                                                locatable entity.
                     NUM_IMAGES                    ( ) or (TEAM) or (TEAM_-               T     Number of images.
                                                   NUMBER)
                     OUT_OF_RANGE                  (X, MOLD [, ROUND])                    E     Whether a value cannot be converted
                                                                                                safely.
                     PACK                          (ARRAY, MASK [,                        T     Array packed into a vector.
                                                   VECTOR])
                     PARITY                        (MASK) or (MASK, DIM)                  T     Array reduced by .NEQV. operator.
                     POPCNT                        (I)                                    E     Number of one bits.
                     POPPAR                        (I)                                    E     Parity expressed as 0 or 1.
                     PRECISION                     (X)                                    I     Decimal precision of a real model.
                     PRESENT                       (A)                                    I     Presence of optional argument.
                     PRODUCT                       (ARRAY, DIM [, MASK]) or               T     Array reduced by multiplication.
                                                   (ARRAY[, MASK])
                     RADIX                         (X)                                    I     Base of a numeric model.
                     RANDOM_INIT                   (REPEATABLE, IMAGE_-                   S     Initialise  the pseudorandom number
                                                   DISTINCT)                                    generator.
                     RANDOM_NUMBER (HARVEST)                                              S     Generate pseudorandom number(s).
                     RANDOM_SEED                   ([SIZE, PUT, GET])                     S     Restart or query the pseudorandom
                                                                                                number generator.
                     RANGE                         (X)                                    I     Decimal exponent range of a numeric
                                                                                                model (16.4).
                     RANK                          (A)                                    I     Rank of a data object.
                     REAL                          (A [, KIND])                           E     Conversion to real type.
                     REDUCE                        (ARRAY,          OPERATION,            T     General reduction of array
                                                   DIM [, MASK, IDENTITY,
                                                   ORDERED]) or (ARRAY,
                                                   OPERATION           [,    MASK,
                                                   IDENTITY, ORDERED])
                                                                                            c
                346                                                                        ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                           Table 16.1: Standard generic intrinsic procedure summary             (cont.)
               Procedure            Arguments                 Class Description
               REPEAT               (STRING, NCOPIES)           T   Repetitive string concatenation.
               RESHAPE              (SOURCE, SHAPE [, PAD,      T   Arbitrary shape array construction.
                                    ORDER])
               RRSPACING            (X)                         E   Reciprocal of relative spacing of model
                                                                    numbers.
               SAME_TYPE_AS         (A, B)                      I   Dynamic type equality test.
               SCALE                (X, I)                      E   Real number scaled by radix power.
               SCAN                 (STRING, SET [, BACK,       E   Character set membership search.
                                    KIND])
               SELECTED_CHAR_- (NAME)                           T   Character kind selection.
               KIND
               SELECTED_INT_-       (R)                         T   Integer kind selection.
               KIND
               SELECTED_REAL_- ([P, R, RADIX])                  T   Real kind selection.
               KIND
               SET_EXPONENT         (X, I)                      E   Real value with speciﬁed exponent.
               SHAPE                (SOURCE [, KIND])           I   Shape of an array or a scalar.
               SHIFTA               (I, SHIFT)                  E   Right shift with ﬁll.
               SHIFTL               (I, SHIFT)                  E   Left shift.
               SHIFTR               (I, SHIFT)                  E   Right shift.
               SIGN                 (A, B)                      E   Magnitude of A with the sign of B.
               SIN                  (X)                         E   Sine function.
               SINH                 (X)                         E   Hyperbolic sine function.
               SIZE                 (ARRAY[, DIM, KIND])        I   Size of an array or one extent.
               SPACING              (X)                         E   Spacing of model numbers.
               SPREAD               (SOURCE, DIM, NCOPIES)      T   Value replicated in a new dimension.
               SQRT                 (X)                         E   Square root.
               STOPPED_IMAGES       ([TEAM, KIND])              T   Indices of stopped images.
               STORAGE_SIZE         (A [, KIND])                I   Storage size in bits.
               SUM                  (ARRAY, DIM [, MASK]) or    T   Array reduced by addition.
                                    (ARRAY[, MASK])
               SYSTEM_CLOCK         ([COUNT, COUNT_RATE,        S   Query system clock.
                                    COUNT_MAX])
               TAN                  (X)                         E   Tangent function.
               TANH                 (X)                         E   Hyperbolic tangent function.
               TEAM_NUMBER          ([TEAM])                    T   Team number.
               THIS_IMAGE           ([TEAM])                    T   Index of the invoking image.
               THIS_IMAGE           (COARRAY[, TEAM]) or        T   Cosubscript(s) for this image.
                                    (COARRAY, DIM [,
                                    TEAM])
               TINY                 (X)                         I   Smallest positive model number.
               TRAILZ               (I)                         E   Number of trailing zero bits.
               TRANSFER             (SOURCE, MOLD [, SIZE])     T   Transfer physical representation.
               TRANSPOSE            (MATRIX)                    T   Transpose of an array of rank two.
               TRIM                 (STRING)                    T   String without trailing blanks.
               UBOUND               (ARRAY[, DIM, KIND])        I   Upper bound(s).
               UCOBOUND             (COARRAY[, DIM, KIND])      I   Upper cobound(s) of a coarray.
               UNPACK               (VECTOR, MASK, FIELD)       T   Vector unpacked into an array.
               VERIFY               (STRING, SET [, BACK,       E   Character set non-membership search.
                                    KIND])
         3 The eﬀect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team is
            processor dependent.
            c
            ISO/IEC 2017 – All rights reserved                                                      347
              ISO/IEC DIS 1539-1:2017 (E)
           4 If RANDOM_INITorRANDOM_SEEDiscalledinasegmentA,andRANDOM_INIT,RANDOM_SEED,or
              RANDOM_NUMBERiscalledinsegmentB,thensegmentsAandBshallbeordered. Itis processor dependent
              whether each image uses a separate random number generator, or if some or all images use common random
              number generators.
           5 The use of all other standard intrinsic procedures in unordered segments is subject only to their argument use
              following the rules in 11.6.2.
              16.8       Speciﬁc names for standard intrinsic functions
           1 Except for AMAX0, AMIN0, MAX1, and MIN1, the result type of the speciﬁc function is the same that the result type of the
              corresponding generic function reference would be if it were invoked with the same arguments as the speciﬁc function.
           2 A function listed in Table 16.3 is not permitted to be used as an actual argument (15.5.1, C1534), as a target in a procedure
              pointer assignment statement (10.2.2.2, C1030), as an initial target in a procedure declaration statement (15.4.3.6, C1519), or to
              specify an interface (15.4.3.6, C1515).
                                               Table 16.2: Unrestricted speciﬁc intrinsic functions
                                               Speciﬁc name   Generic name   Argument type and kind
                                               ABS            ABS            default real
                                               ACOS           ACOS           default real
                                               AIMAG          AIMAG          default complex
                                               AINT           AINT           default real
                                               ALOG           LOG            default real
                                               ALOG10         LOG10          default real
                                               AMOD           MOD            default real
                                               ANINT          ANINT          default real
                                               ASIN           ASIN           default real
                                               ATAN           ATAN(X)        default real
                                               ATAN2          ATAN2          default real
                                               CABS           ABS            default complex
                                               CCOS           COS            default complex
                                               CEXP           EXP            default complex
                                               CLOG           LOG            default complex
                                               CONJG          CONJG          default complex
                                               COS            COS            default real
                                               COSH           COSH           default real
                                               CSIN           SIN            default complex
                                               CSQRT          SQRT           default complex
                                               DABS           ABS            double precision real
                                               DACOS          ACOS           double precision real
                                               DASIN          ASIN           double precision real
                                               DATAN          ATAN           double precision real
                                               DATAN2         ATAN2          double precision real
                                               DCOS           COS            double precision real
                                               DCOSH          COSH           double precision real
                                               DDIM           DIM            double precision real
                                               DEXP           EXP            double precision real
                                               DIM            DIM            default real
                                               DINT           AINT           double precision real
                                               DLOG           LOG            double precision real
                                               DLOG10         LOG10          double precision real
                                               DMOD           MOD            double precision real
                                               DNINT          ANINT          double precision real
                                               DPROD          DPROD          default real
                                               DSIGN          SIGN           double precision real
                                               DSIN           SIN            double precision real
                                               DSINH          SINH           double precision real
                                               DSQRT          SQRT           double precision real
                                               DTAN           TAN            double precision real
                                               DTANH          TANH           double precision real
                                               EXP            EXP            default real
                                               IABS           ABS            default integer
                                               IDIM           DIM            default integer
                                               IDNINT         NINT           double precision real
                                               INDEX          INDEX          default character
                                                                                  c
              348                                                                ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                                                 Unrestricted speciﬁc intrinsic functions    (cont.)
                                               Speciﬁc name   Generic name   Argument type and kind
                                               ISIGN          SIGN           default integer
                                               LEN            LEN            default character
                                               MOD            MOD            default integer
                                               NINT           NINT           default real
                                               SIGN           SIGN           default real
                                               SIN            SIN            default real
                                               SINH           SINH           default real
                                               SQRT           SQRT           default real
                                               TAN            TAN            default real
                                               TANH           TANH           default real
                                                Table 16.3: Restricted speciﬁc intrinsic functions
                                            Speciﬁc name   Generic name         Argument type and kind
                                            AMAX0(...)     REAL(MAX(...))       default integer
                                            AMAX1          MAX                  default real
                                            AMIN0 (...)    REAL(MIN(...))       default integer
                                            AMIN1          MIN                  default real
                                            CHAR           CHAR                 default integer
                                            DMAX1          MAX                  double precision real
                                            DMIN1          MIN                  double precision real
                                            FLOAT          REAL                 default integer
                                            ICHAR          ICHAR                default character
                                            IDINT          INT                  double precision real
                                            IFIX           INT                  default real
                                            INT            INT                  default real
                                            LGE            LGE                  default character
                                            LGT            LGT                  default character
                                            LLE            LLE                  default character
                                            LLT            LLT                  default character
                                            MAX0           MAX                  default integer
                                            MAX1(...)      INT (MAX (...))      default real
                                            MIN0           MIN                  default integer
                                            MIN1 (...)     INT (MIN (...))      default real
                                            REAL           REAL                 default integer
                                            SNGL           REAL                 double precision real
              16.9       Speciﬁcations of the standard intrinsic procedures
              16.9.1     General
           1 Detailed speciﬁcations of the standard generic intrinsic procedures are provided in 16.9 in alphabetical order.
           2 The types and type parameters of standard intrinsic procedure arguments and function results are determined
              by these speciﬁcations. The “Argument(s)” paragraphs specify requirements on the actual arguments of the
              procedures. The result characteristics are sometimes speciﬁed in terms of the characteristics of the arguments. A
              program shall not invoke an intrinsic procedure under circumstances where a value to be assigned to a subroutine
              argumentorreturnedasafunctionresultisnotrepresentablebyobjectsofthespeciﬁedtypeandtypeparameters.
           3 If an IEEE inﬁnity is assigned or returned by an intrinsic procedure, the intrinsic module IEEE_ARITHMETIC
              is accessible, and the actual arguments were ﬁnite numbers, the ﬂag IEEE_OVERFLOW or IEEE_DIVIDE_-
              BY_ZEROshall signal. If an IEEE NaN is assigned or returned, the actual arguments were ﬁnite numbers, the
              intrinsic module IEEE_ARITHMETIC is accessible, and the exception IEEE_INVALID is supported, the ﬂag
              IEEE_INVALID shall signal. If no IEEE inﬁnity or NaN is assigned or returned, these ﬂags shall have the same
              status as when the intrinsic procedure was invoked.
               c
              ISO/IEC 2017 – All rights reserved                                                                             349
             ISO/IEC DIS 1539-1:2017 (E)
             16.9.2       ABS (A)
           1 Description. Absolute value.
           2 Class. Elemental function.
           3 Argument. A shall be of type integer, real, or complex.
           4 Result Characteristics. The same as A except that if A is complex, the result is real.
           5 Result Value. If A is of type integer or real, the value of the result is |A|; if A is complex with value (x,y),
                                                                           p 2      2
             the result is equal to a processor-dependent approximation to   x +y computed without undue overﬂow or
             underﬂow.
           6 Example. ABS ((3.0, 4.0)) has the value 5.0 (approximately).
             16.9.3       ACHAR (I [, KIND])
           1 Description. Character from ASCII code value.
           2 Class. Elemental function.
           3 Arguments.
             I            shall be of type integer.
             KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Character of length one. If KIND is present, the kind type parameter is that speciﬁed
             by the value of KIND; otherwise, the kind type parameter is that of default character.
           5 Result Value. If I has a value in the range 0 ≤ I ≤ 127, the result is the character in position I of the ASCII
             collating sequence, provided the processor is capable of representing that character in the character kind of the
             result; otherwise, the result is processor dependent. ACHAR (IACHAR (C)) shall have the value C for any
             character C capable of representation as a default character.
           6 Example. ACHAR (88) has the value ’X’.
             16.9.4       ACOS (X)
           1 Description. Arccosine (inverse cosine) function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real with a value that satisﬁes the inequality |X| ≤ 1, or of type complex.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to arccos(X). If it is real
             it is expressed in radians and lies in the range 0 ≤ ACOS (X) ≤ π. If it is complex the real part is expressed in
             radians and lies in the range 0 ≤ REAL (ACOS (X)) ≤ π.
           6 Example. ACOS (0.54030231) has the value 1.0 (approximately).
             16.9.5       ACOSH (X)
           1 Description. Inverse hyperbolic cosine function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real or complex.
                                                                            c
             350                                                           ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
         4 Result Characteristics. Same as X.
         5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
           cosine function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
           0 ≤ AIMAG (ACOSH (X))≤π
         6 Example. ACOSH (1.5430806) has the value 1.0 (approximately).
           16.9.6    ADJUSTL (STRING)
         1 Description. Left-justiﬁed string value.
         2 Class. Elemental function.
         3 Argument. STRING shall be of type character.
         4 Result Characteristics. Character of the same length and kind type parameter as STRING.
         5 Result Value. The value of the result is the same as STRING except that any leading blanks have been deleted
           and the same number of trailing blanks have been inserted.
         6 Example. ADJUSTL (’ WORD’) has the value ’WORD ’.
           16.9.7    ADJUSTR (STRING)
         1 Description. Right-justiﬁed string value.
         2 Class. Elemental function.
         3 Argument. STRING shall be of type character.
         4 Result Characteristics. Character of the same length and kind type parameter as STRING.
         5 Result Value. The value of the result is the same as STRING except that any trailing blanks have been deleted
           and the same number of leading blanks have been inserted.
         6 Example. ADJUSTR (’WORD ’) has the value ’ WORD’.
           16.9.8    AIMAG (Z)
         1 Description. Imaginary part of a complex number.
         2 Class. Elemental function.
         3 Argument. Z shall be of type complex.
         4 Result Characteristics. Real with the same kind type parameter as Z.
         5 Result Value. If Z has the value (x,y), the result has the value y.
         6 Example. AIMAG ((2.0, 3.0)) has the value 3.0.
           16.9.9    AINT (A [, KIND])
         1 Description. Truncation toward 0 to a whole number.
         2 Class. Elemental function.
         3 Arguments.
           A          shall be of type real.
           KIND (optional) shall be a scalar integer constant expression.
           c
           ISO/IEC 2017 – All rights reserved                                                 351
              ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. The result is of type real. If KIND is present, the kind type parameter is that speciﬁed
              by the value of KIND; otherwise, the kind type parameter is that of A.
           5 Result Value. If |A| < 1, AINT (A) has the value 0; if |A| ≥ 1, AINT (A) has a value equal to the integer
              whose magnitude is the largest integer that does not exceed the magnitude of A and whose sign is the same as
              the sign of A.
           6 Examples. AINT (2.783) has the value 2.0. AINT (−2.783) has the value −2.0.
              16.9.10      ALL (MASK) or ALL (MASK, DIM)
           1 Description. Array reduced by .AND. operator.
           2 Class. Transformational function.
           3 Arguments.
              MASK         shall be a logical array.
              DIM          shall be an integer scalar with value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
           4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
              if DIM does not appear or n = 1; otherwise, the result has rank n − 1 and shape [d , d , ..., d      , d      ,
              . . . , d ] where [d , d , ..., d ] is the shape of MASK.                          1   2       DIM−1    DIM+1
                   n          1   2       n
           5 Result Value.
              Case (i):    The result of ALL (MASK) has the value true if all elements of MASK are true or if MASK has
                           size zero, and the result has value false if any element of MASK is false.
              Case (ii):   If MASK has rank one, ALL (MASK, DIM) is equal to ALL (MASK). Otherwise, the value of
                           element (s , s , ..., s     , s     , . . . , s ) of ALL (MASK, DIM) is equal to ALL (MASK (s ,
                                     1   2       DIM−1   DIM+1        n                                                    1
                           s , ..., s     , :, s    , . . . , s )).
                            2       DIM−1     DIM+1        n
           6 Examples.
              Case (i):    The value of ALL ([.TRUE., .FALSE., .TRUE.]) is false.
              Case (ii):   If B is the array  1  3   5  and C is the array  0   3   5  then ALL (B /= C, DIM = 1) is
                                               2  4   6                         7  4   8
                           [true, false, false] and ALL (B /= C, DIM = 2) is [false, false].
              16.9.11      ALLOCATED (ARRAY) or ALLOCATED (SCALAR)
           1 Description. Allocation status of allocatable variable.
           2 Class. Inquiry function.
           3 Arguments.
              ARRAY        shall be an allocatable array.
              SCALAR       shall be an allocatable scalar.
           4 Result Characteristics. Default logical scalar.
           5 Result Value. The result has the value true if the argument (ARRAY or SCALAR) is allocated and has the
              value false if the argument is unallocated.
              16.9.12      ANINT (A [, KIND])
           1 Description. Nearest whole number.
           2 Class. Elemental function.
                                                                              c
              352                                                            ISO/IEC 2017 – All rights reserved
                                                                                                                                             ISO/IEC DIS 1539-1:2017 (E)
                 3 Arguments.
                      A                     shall be of type real.
                      KIND (optional) shall be a scalar integer constant expression.
                 4 Result Characteristics. The result is of type real. If KIND is present, the kind type parameter is that speciﬁed
                      by the value of KIND; otherwise, the kind type parameter is that of A.
                 5 Result Value. The result is the integer nearest A, or if there are two integers equally near A, the result is
                      whichever such integer has the greater magnitude.
                 6 Examples. ANINT (2.783) has the value 3.0. ANINT (−2.783) has the value −3.0.
                      16.9.13              ANY(MASK) or ANY (MASK, DIM)
                 1 Description. Array reduced by .OR. operator.
                 2 Class. Transformational function.
                 3 Arguments.
                      MASK                  shall be a logical array.
                      DIM                   shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
                 4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
                      if DIM does not appear or n = 1; otherwise, the result has rank n − 1 and shape [d , d , ..., d                                                                       , d           ,
                      . . . , d ] where [d , d , ..., d ] is the shape of MASK.                                                                               1     2             DIM−1         DIM+1
                               n                 1     2            n
                 5 Result Value.
                      Case (i):             The result of ANY (MASK) has the value true if any element of MASK is true and has the value
                                            false if no elements are true or if MASK has size zero.
                      Case (ii):            If MASK has rank one, ANY (MASK, DIM) is equal to ANY (MASK). Otherwise, the value of
                                            element (s , s , ..., s                     , s           , . . . , s  ) of ANY (MASK, DIM) is equal to ANY (MASK (s ,
                                                            1     2            DIM−1        DIM+1                n                                                                                      1
                                            s , ..., s              , :, s           , . . . , s )).
                                             2            DIM−1            DIM+1                n
                 6 Examples.
                      Case (i):             The value of ANY ([.TRUE., .FALSE., .TRUE.]) is true.
                      Case (ii):            If B is the array  1                3     5  and C is the array  0                      3    5  then ANY (B /= C, DIM = 1) is
                                                                            2    4     6                                         7     4    8
                                            [true, false, true] and ANY (B /= C, DIM = 2) is [true, true].
                      16.9.14              ASIN (X)
                 1 Description. Arcsine (inverse sine) function.
                 2 Class. Elemental function.
                 3 Argument. X shall be of type real with a value that satisﬁes the inequality |X| ≤ 1, or of type complex.
                 4 Result Characteristics. Same as X.
                 5 Result Value. The result has a value equal to a processor-dependent approximation to arcsin(X). If it is real it
                      is expressed in radians and lies in the range −π/2 ≤ ASIN (X) ≤ π/2. If it is complex the real part is expressed
                      in radians and lies in the range −π/2 ≤ REAL (ASIN (X)) ≤ π/2.
                 6 Example. ASIN (0.84147098) has the value 1.0 (approximately).
                       c
                      ISO/IEC 2017 – All rights reserved                                                                                                                                          353
              ISO/IEC DIS 1539-1:2017 (E)
              16.9.15       ASINH (X)
           1 Description. Inverse hyperbolic sine function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real or complex.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
              sine function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
              −π/2≤AIMAG(ASINH(X))≤π/2.
           6 Example. ASINH (1.1752012) has the value 1.0 (approximately).
              16.9.16       ASSOCIATED (POINTER [, TARGET])
           1 Description. Pointer association status inquiry.
           2 Class. Inquiry function.
           3 Arguments.
              POINTER shall be a pointer. It may be of any type or may be a procedure pointer. Its pointer association
                             status shall not be undeﬁned.
              TARGET(optional) shallbeallowableasthedata-target orproc-target inapointerassignmentstatement(10.2.2)
                             in which POINTER is data-pointer-object or proc-pointer-object. If TARGET is a pointer then its
                             pointer association status shall not be undeﬁned.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):      If TARGET is absent, the result is true if and only if POINTER is associated with a target.
              Case (ii):     If TARGET is present and is a procedure, the result is true if and only if POINTER is associated
                             with TARGET and, if TARGET is an internal procedure, they have the same host instance.
              Case (iii):    If TARGET is present and is a procedure pointer, the result is true if and only if POINTER and
                             TARGET are associated with the same procedure and, if the procedure is an internal procedure,
                             they have the same host instance.
              Case (iv):     If TARGET is present and is a scalar target, the result is true if and only if TARGET is not a zero-
                             sized storage sequence and POINTER is associated with a target that occupies the same storage
                             units as TARGET.
              Case (v):      If TARGETispresent and is an array target, the result is true if and only if POINTER is associated
                             withatargetthathasthesameshapeasTARGET,isneitherofsizezeronoranarraywhoseelements
                             are zero-sized storage sequences, and occupies the same storage units as TARGET in array element
                             order.
              Case (vi):     If TARGET is present and is a scalar pointer, the result is true if and only if POINTER and
                             TARGET are associated, the targets are not zero-sized storage sequences, and they occupy the
                             same storage units.
              Case (vii):    If TARGET is present and is an array pointer, the result is true if and only if POINTER and
                             TARGET are both associated, have the same shape, are neither of size zero nor arrays whose
                             elements are zero-sized storage sequences, and occupy the same storage units in array element
                             order.
                                                                                  c
              354                                                                 ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                 NOTE16.10
                 The references to TARGET in the above cases are referring to properties that might be possessed by the
                 actual argument, so the case of TARGET being a disassociated pointer will be covered by case (iii), (vi),
                 or (vii).
          6 Examples. ASSOCIATED (CURRENT, HEAD) is true if CURRENT is associated with the target HEAD.
             After the execution of
                 A_PART => A (:N)
             ASSOCIATED (A_PART, A) is true if N is equal to UBOUND (A, DIM = 1). After the execution of
                 NULLIFY (CUR); NULLIFY (TOP)
             ASSOCIATED (CUR, TOP) is false.
             16.9.17     ATAN (X) or ATAN (Y, X)
          1 Description. Arctangent (inverse tangent) function.
          2 Class. Elemental function.
          3 Arguments.
             Y           shall be of type real.
             X           If Y appears, X shall be of type real with the same kind type parameter as Y. If Y has the value
                         zero, X shall not have the value zero. If Y does not appear, X shall be of type real or complex.
          4 Result Characteristics. Same as X.
          5 Result Value. If Y appears, the result is the same as the result of ATAN2 (Y,X). If Y does not appear, the
             result has a value equal to a processor-dependent approximation to arctan(X) whose real part is expressed in
             radians and lies in the range −π/2 ≤ ATAN (X) ≤ π/2.
          6 Example. ATAN (1.5574077) has the value 1.0 (approximately).
             16.9.18     ATAN2 (Y, X)
          1 Description. Arctangent (inverse tangent) function.
          2 Class. Elemental function.
          3 Arguments.
             Y           shall be of type real.
             X           shall be of the same type and kind type parameter as Y. If Y has the value zero, X shall not have
                         the value zero.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the principal value of
             the argument of the complex number (X, Y), expressed in radians. It lies in the range −π ≤ ATAN2 (Y,X)
             ≤ π and is equal to a processor-dependent approximation to a value of arctan(Y/X) if X 6= 0. If Y > 0, the
             result is positive. If Y = 0 and X > 0, the result is Y. If Y = 0 and X < 0, then the result is approximately
             π if Y is positive real zero or the processor does not distinguish between positive and negative real zero, and
             approximately −π if Y is negative real zero. If Y < 0, the result is negative. If X = 0, the absolute value of the
             result is approximately π/2.
          6 Examples. ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately). If Y has the value  1     1  and X
                           −1 1                                                3π/4     π/4      −1 −1
             has the value  −1 1 ,the value of ATAN2 (Y, X) is approximately      −3π/4 −π/4 .
             c
             ISO/IEC 2017 – All rights reserved                                                                 355
           ISO/IEC DIS 1539-1:2017 (E)
           16.9.19   ATANH (X)
        1 Description. Inverse hyperbolic tangent function.
        2 Class. Elemental function.
        3 Argument. X shall be of type real or complex.
        4 Result Characteristics. Same as X.
        5 Result Value. The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
           tangent function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
           −π/2≤AIMAG(ATANH(X))≤π/2.
        6 Example. ATANH (0.76159416) has the value 1.0 (approximately).
           16.9.20   ATOMIC_ADD (ATOM, VALUE [, STAT])
        1 Description. Atomic addition.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of ATOM + VALUE.
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
                     VALUEshall be representable in kind ATOMIC_INT_KIND.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALL ATOMIC_ADD (I [3], 42) will cause I on image 3 to become deﬁned with the value 46 if the
           value of I [3] is 4 when the atomic operation is executed.
           16.9.21   ATOMIC_AND (ATOM, VALUE [, STAT])
        1 Description. Atomic bitwise AND.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                     entable in kind ATOMIC_INT_KIND.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALL ATOMIC_AND (I [3], 6) will cause I on image 3 to become deﬁned with the value 4 if the
           value of I [3] is 5 when the atomic operation is executed.
                                                            c
           356                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
           16.9.22   ATOMIC_CAS (ATOM, OLD, COMPARE, NEW [, STAT])
        1 Description. Atomic compare and swap.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
                     LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT)
                     argument. If an error condition occurs, ATOM becomes undeﬁned; otherwise, if ATOM is of type
                     integer and equal to COMPARE, or of type logical and equivalent to COMPARE, it becomes deﬁned
                     with the value of NEW.
           OLD       shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
                     an error condition occurs, it becomes undeﬁned; otherwise, it becomes deﬁned with the value that
                     ATOMhadatthe start of the atomic operation.
           COMPARE shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
           NEW       shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. If the value of I on image 3 is equal to 13 at the beginning of the atomic operation performed by
           CALL ATOMIC_CAS (I [3], OLD, 0, 1), the value of I on image 3 will be unchanged, and OLD will become
           deﬁned with the value 13. If the value of I on image 3 is equal to 0 at the beginning of the atomic operation
           performed by CALL ATOMIC_CAS (I [3], OLD, 0, 1), I on image 3 will become deﬁned with the value 1, and
           OLDwill become deﬁned with the value 0.
           16.9.23   ATOMIC_DEFINE (ATOM, VALUE [, STAT])
        1 Description. Deﬁne a variable atomically.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
                     LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (OUT)
                     argument. On successful execution, it becomes deﬁned with the value of VALUE. If an error
                     condition occurs, it becomes undeﬁned.
           VALUE     shall be scalar and of the same type as ATOM. It is an INTENT (IN) argument.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALL ATOMIC_DEFINE (I [3], 4) causes I on image 3 to become deﬁned with the value 4.
           16.9.24   ATOMIC_FETCH_ADD (ATOM, VALUE, OLD [, STAT])
        1 Description. Atomic fetch and add.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
           c
           ISO/IEC 2017 – All rights reserved                                               357
           ISO/IEC DIS 1539-1:2017 (E)
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of ATOM + VALUE.
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
                     VALUEshall be representable in kind ATOMIC_INT_KIND.
           OLD       shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
                     an error condition occurs, it becomes undeﬁned; otherwise, it becomes deﬁned with the value that
                     ATOMhadatthe start of the atomic operation.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALLATOMIC_FETCH_ADD(I[3],7,J)willcauseIonimage3tobecomedeﬁnedwiththevalue
           12, and J to become deﬁned with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
           16.9.25   ATOMIC_FETCH_AND (ATOM, VALUE, OLD [, STAT])
        1 Description. Atomic fetch and bitwise AND.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                     entable in kind ATOMIC_INT_KIND.
           OLD       shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
                     an error condition occurs, it becomes undeﬁned; otherwise, it becomes deﬁned with the value that
                     ATOMhadatthe start of the atomic operation.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALLATOMIC_FETCH_AND(I[3],6,J)willcauseIonimage3tobecomedeﬁnedwiththevalue
           4, and J to become deﬁned with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
           16.9.26   ATOMIC_FETCH_OR (ATOM, VALUE, OLD [, STAT])
        1 Description. Atomic fetch and bitwise OR.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                     entable in kind ATOMIC_INT_KIND.
           OLD       shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
                     an error condition occurs, it becomes undeﬁned; otherwise, it becomes deﬁned with the value that
                     ATOMhadatthe start of the atomic operation.
                                                            c
           358                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALL ATOMIC_FETCH_OR (I [3], 1, J) will cause I on image 3 to become deﬁned with the value
           3, and J to become deﬁned with the value 2, if the value of I [3] is 2 when the atomic operation is executed.
           16.9.27   ATOMIC_FETCH_XOR (ATOM, VALUE, OLD [, STAT])
        1 Description. Atomic fetch and bitwise exclusive OR.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                     entable in kind ATOMIC_INT_KIND.
           OLD       shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
                     an error condition occurs, it becomes undeﬁned; otherwise, it becomes deﬁned with the value that
                     ATOMhadatthe start of the atomic operation.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALLATOMIC_FETCH_XOR(I[3],1,J)willcauseIonimage3tobecomedeﬁnedwiththevalue
           2, and J to become deﬁned with the value 3, if the value of I [3] is 3 when the atomic operation is executed.
           16.9.28   ATOMIC_OR (ATOM, VALUE [, STAT])
        1 Description. Atomic bitwise OR.
        2 Class. Atomic subroutine.
        3 Arguments.
           ATOM      shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                     KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                     an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                     of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
           VALUE     shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                     entable in kind ATOMIC_INT_KIND.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                     and STAT is not present, error termination is initiated.
        4 Example. CALLATOMIC_OR(I[3],1)willcause I on image 3 to become deﬁned with the value 3 if the value
           of I [3] is 2 when the atomic operation is executed.
           16.9.29   ATOMIC_REF (VALUE, ATOM [, STAT])
        1 Description. Reference a variable atomically.
        2 Class. Atomic subroutine.
           c
           ISO/IEC 2017 – All rights reserved                                               359
             ISO/IEC DIS 1539-1:2017 (E)
          3 Arguments.
             VALUE        shall be scalar and of the same type as ATOM. It is an INTENT (OUT) argument. On successful
                          execution, it becomes deﬁned with the value of ATOM. If an error condition occurs, it becomes
                          undeﬁned.
             ATOM         shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                          KINDfromtheintrinsicmoduleISO_FORTRAN_ENV,oroftypelogicalwithkindATOMIC_LO-
                          GICAL_KINDfromtheintrinsicmoduleISO_FORTRAN_ENV.ItisanINTENT(IN)argument.
             STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                          INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                          and STAT is not present, error termination is initiated.
          4 Example. CALL ATOMIC_REF (VAL, I [3]) causes VAL to become deﬁned with the value of I on image 3.
             16.9.30      ATOMIC_XOR (ATOM, VALUE [, STAT])
          1 Description. Atomic bitwise exclusive OR.
          2 Class. Atomic subroutine.
          3 Arguments.
             ATOM         shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
                          KINDfrom the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
                          an error condition occurs, ATOM becomes undeﬁned; otherwise, it becomes deﬁned with the value
                          of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
             VALUE        shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
                          entable in kind ATOMIC_INT_KIND.
             STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                          INTENT (OUT) argument. It is assigned a value as speciﬁed in 16.5. If an error condition occurs
                          and STAT is not present, error termination is initiated.
          4 Example. CALL ATOMIC_XOR (I [3], 1) will cause I on image 3 to become deﬁned with the value 2 if the
             value of I [3] is 3 when the atomic operation is executed.
             16.9.31      BESSEL_J0 (X)
                                                 st
          1 Description. Bessel function of the 1   kind, order 0.
          2 Class. Elemental function.
          3 Argument. X shall be of type real.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
             the ﬁrst kind and order zero of X.
          6 Example. BESSEL_J0 (1.0) has the value 0.765 (approximately).
             16.9.32      BESSEL_J1 (X)
                                                 st
          1 Description. Bessel function of the 1   kind, order 1.
          2 Class. Elemental function.
          3 Argument. X shall be of type real.
          4 Result Characteristics. Same as X.
                                                                          c
             360                                                          ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
             the ﬁrst kind and order one of X.
          6 Example. BESSEL_J1 (1.0) has the value 0.440 (approximately).
             16.9.33      BESSEL_JN (N, X) or BESSEL_JN (N1, N2, X)
                                                   st
          1 Description. Bessel functions of the 1   kind.
          2 Class.
             Case (i):    BESSEL_JN (N,X) is an elemental function.
             Case (ii):   BESSEL_JN (N1,N2,X) is a transformational function.
          3 Arguments.
             N            shall be of type integer and nonnegative.
             N1           shall be an integer scalar with a nonnegative value.
             N2           shall be an integer scalar with a nonnegative value.
             X            shall be of type real; if the function is transformational, X shall be scalar.
          4 Result Characteristics. Same type and kind as X. The result of BESSEL_JN (N1, N2, X) is a rank-one array
             with extent MAX (N2−N1+1, 0).
          5 Result Value.
             Case (i):    The result value of BESSEL_JN (N, X) is a processor-dependent approximation to the Bessel
                          function of the ﬁrst kind and order N of X.
             Case (ii):   Element i of the result value of BESSEL_JN (N1, N2, X) is a processor-dependent approximation
                          to the Bessel function of the ﬁrst kind and order N1+i −1 of X.
          6 Example. BESSEL_JN (2, 1.0) has the value 0.115 (approximately).
             16.9.34      BESSEL_Y0 (X)
                                                  nd
          1 Description. Bessel function of the 2    kind, order 0.
          2 Class. Elemental function.
          3 Argument. X shall be of type real. Its value shall be greater than zero.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
             the second kind and order zero of X.
          6 Example. BESSEL_Y0 (1.0) has the value 0.088 (approximately).
             16.9.35      BESSEL_Y1 (X)
                                                  nd
          1 Description. Bessel function of the 2    kind, order 1.
          2 Class. Elemental function.
          3 Argument. X shall be of type real. Its value shall be greater than zero.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the Bessel function of
             the second kind and order one of X.
              c
             ISO/IEC 2017 – All rights reserved                                                                    361
             ISO/IEC DIS 1539-1:2017 (E)
          6 Example. BESSEL_Y1 (1.0) has the value −0.781 (approximately).
             16.9.36      BESSEL_YN (N, X) or BESSEL_YN (N1, N2, X)
                                                   nd
          1 Description. Bessel functions of the 2   kind.
          2 Class.
             Case (i):    BESSEL_YN(N, X) is an elemental function.
             Case (ii):   BESSEL_YN(N1, N2, X) is a transformational function.
          3 Arguments.
             N            shall be of type integer and nonnegative.
             N1           shall be an integer scalar with a nonnegative value.
             N2           shall be an integer scalar with a nonnegative value.
             X            shall be of type real; if the function is transformational, X shall be scalar. Its value shall be greater
                          than zero.
          4 Result Characteristics. Same type and kind as X. The result of BESSEL_YN (N1, N2, X) is a rank-one array
             with extent MAX (N2−N1+1, 0).
          5 Result Value.
             Case (i):    The result value of BESSEL_YN (N, X) is a processor-dependent approximation to the Bessel
                          function of the second kind and order N of X.
             Case (ii):   Element i of the result value of BESSEL_YN (N1, N2, X) is a processor-dependent approximation
                          to the Bessel function of the second kind and order N1+i−1 of X.
          6 Example. BESSEL_YN (2, 1.0) has the value −1.651 (approximately).
             16.9.37      BGE (I, J)
          1 Description. Bitwise greater than or equal to.
          2 Class. Elemental function.
          3 Arguments.
             I            shall be of type integer or a boz-literal-constant.
             J            shall be of type integer or a boz-literal-constant.
          4 Result Characteristics. Default logical.
          5 Result Value. The result is true if the sequence of bits represented by I is greater than or equal to the sequence
             of bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is
             false.
          6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
             integer value as a sequence of bits is described in 16.3.
          7 Example. If BIT_SIZE (J) has the value 8, BGE (Z’FF’, J) has the value true for any value of J. BGE (0, −1)
             has the value false.
             16.9.38      BGT(I, J)
          1 Description. Bitwise greater than.
          2 Class. Elemental function.
                                                                           c
             362                                                          ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        3 Arguments.
           I         shall be of type integer or a boz-literal-constant.
           J         shall be of type integer or a boz-literal-constant.
        4 Result Characteristics. Default logical.
        5 Result Value. The result is true if the sequence of bits represented by I is greater than the sequence of bits
           represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
        6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
           integer value as a sequence of bits is described in 16.3.
        7 Example. BGT (Z’FF’, Z’FC’) has the value true. BGT (0, −1) has the value false.
           16.9.39   BIT_SIZE (I)
        1 Description. Number of bits in integer model 16.3.
        2 Class. Inquiry function.
        3 Argument. I shall be of type integer. It may be a scalar or an array.
        4 Result Characteristics. Scalar integer with the same kind type parameter as I.
        5 Result Value. The result has the value of the number of bits z of the model integer deﬁned for bit manipulation
           contexts in 16.3.
        6 Example. BIT_SIZE (1) has the value 32 if z of the model is 32.
           16.9.40   BLE (I, J)
        1 Description. Bitwise less than or equal to.
        2 Class. Elemental function.
        3 Arguments.
           I         shall be of type integer or a boz-literal-constant.
           J         shall be of type integer or a boz-literal-constant.
        4 Result Characteristics. Default logical.
        5 Result Value. The result is true if the sequence of bits represented by I is less than or equal to the sequence of
           bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
        6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
           integer value as a sequence of bits is described in 16.3.
        7 Example. BLE (0, J) has the value true for any value of J. BLE (−1, 0) has the value false.
           16.9.41   BLT (I, J)
        1 Description. Bitwise less than.
        2 Class. Elemental function.
        3 Arguments.
           I         shall be of type integer or a boz-literal-constant.
           J         shall be of type integer or a boz-literal-constant.
           c
           ISO/IEC 2017 – All rights reserved                                               363
              ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. Default logical.
           5 Result Value. The result is true if the sequence of bits represented by I is less than the sequence of bits
              represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
           6 The interpretation of a boz-literal-constant as a sequence of bits is described in 7.7. The interpretation of an
              integer value as a sequence of bits is described in 16.3.
           7 Example. BLT (0, −1) has the value true. BLT (Z’FF’, Z’FC’) has the value false.
              16.9.42       BTEST (I, POS)
           1 Description. Test single bit in an integer.
           2 Class. Elemental function.
           3 Arguments.
              I             shall be of type integer.
              POS           shall be of type integer. It shall be nonnegative and be less than BIT_SIZE (I).
           4 Result Characteristics. Default logical.
           5 Result Value. The result has the value true if bit POS of I has the value 1 and has the value false if bit POS
              of I has the value 0. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
                                                                                        1 2 
           6 Examples. BTEST (8, 3) has the value true. If A has the value                3  4   , the value of BTEST (A, 2) is
               false   false  and the value of BTEST (2, A) is  true      false  .
                 false  true                                          false  false
              16.9.43       CEILING (A [, KIND])
           1 Description. Least integer greater than or equal to A.
           2 Class. Elemental function.
           3 Arguments.
              A             shall be of type real.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type.
           5 Result Value. The result has a value equal to the least integer greater than or equal to A.
           6 Examples. CEILING (3.7) has the value 4. CEILING (−3.7) has the value −3.
              16.9.44       CHAR(I [, KIND])
           1 Description. Character from code value.
           2 Class. Elemental function.
           3 Arguments.
              I             shall be of type integer with a value in the range 0 ≤ I ≤ n−1, where n is the number of characters
                            in the collating sequence associated with the speciﬁed kind type parameter.
              KIND (optional) shall be a scalar integer constant expression.
                                                                                  c
              364                                                                ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        4 Result Characteristics. Character of length one. If KIND is present, the kind type parameter is that speciﬁed
           by the value of KIND; otherwise, the kind type parameter is that of default character.
        5 Result Value. The result is the character in position I of the collating sequence associated with the spe-
           ciﬁed kind type parameter. ICHAR (CHAR (I, KIND (C))) shall have the value I for 0 ≤ I ≤ n − 1 and
           CHAR (ICHAR (C), KIND (C)) shall have the value C for any character C capable of representation in the
           processor.
        6 Example. CHAR(88)hasthevalue’X’onaprocessorusingtheASCIIcollatingsequence for default characters.
           16.9.45   CMPLX(X[, KIND]) or CMPLX (X [, Y, KIND])
        1 Description. Conversion to complex type.
        2 Class. Elemental function.
        3 Arguments for CMPLX(X [, KIND]).
           X         shall be of type complex.
           KIND (optional) shall be a scalar integer constant expression.
        4 Arguments for CMPLX(X [, Y, KIND]).
           X         shall be of type integer or real, or a boz-literal-constant.
           Y(optional) shall be of type integer or real, or a boz-literal-constant.
           KIND (optional) shall be a scalar integer constant expression.
        5 Result Characteristics. The result is of type complex. If KIND is present, the kind type parameter is that
           speciﬁed by the value of KIND; otherwise, the kind type parameter is that of default real kind.
        6 Result Value. If Y is absent and X is not complex, it is as if Y were present with the value zero. If KIND is
           absent, it is as if KIND were present with the value KIND (0.0). If X is complex, the result is the same as that
           of CMPLX (REAL (X), AIMAG (X), KIND). The result of CMPLX (X, Y, KIND) has the complex value whose
           real part is REAL (X, KIND) and whose imaginary part is REAL (Y, KIND).
        7 Example. CMPLX (−3) has the value (−3.0, 0.0).
           16.9.46   CO_BROADCAST (A, SOURCE_IMAGE [, STAT, ERRMSG])
        1 Description. Broadcast value to images.
        2 Class. Collective subroutine.
        3 Arguments.
           A         shall have the same shape, dynamic type, and type parameter values, in corresponding references.
                     It shall not be a coindexed object. It is an INTENT (INOUT) argument. If no error condition
                     occurs, A becomes deﬁned, as if by intrinsic assignment, on all images in the current team with the
                     value of A on image SOURCE_IMAGE.
           SOURCE_IMAGE shall be an integer scalar. It is an INTENT (IN) argument. Its value shall be that of an
                     image index of an image in the current team. The value shall be the same in all corresponding
                     references.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument.
           ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
        4 The semantics of STAT and ERRMSG are described in 16.6.
           c
           ISO/IEC 2017 – All rights reserved                                               365
           ISO/IEC DIS 1539-1:2017 (E)
        5 Example. If A is the array [1, 5, 3] on image one, after execution of
                 CALL CO_BROADCAST (A, 1)
           the value of A on all images of the current team is [1, 5, 3].
           16.9.47   CO_MAX(A[, RESULT_IMAGE, STAT, ERRMSG])
        1 Description. Compute maximum value across images.
        2 Class. Collective subroutine.
        3 Arguments.
           A         shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
                     values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
                     argument. If it is scalar, the computed value is equal to the maximum value of A in all corresponding
                     references. If it is an array each element of the computed value is equal to the maximum value of
                     all corresponding elements of A in all corresponding references.
                     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
                     absent, or the executing image is the one identiﬁed by RESULT_IMAGE. Otherwise, A becomes
                     undeﬁned.
           RESULT_IMAGE(optional) shallbeanintegerscalar. It is an INTENT (IN) argument. Its presence, and value
                     if present, shall be the same in all corresponding references. If it is present, its value shall be that
                     of an image index in the current team.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument.
           ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
        4 The semantics of STAT and ERRMSG are described in 16.6.
        5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
           1, 6] on the other image, the value of A after executing the statement CALL CO_MAX (A) is [4, 5, 6] on both
           images.
           16.9.48   CO_MIN (A [, RESULT_IMAGE, STAT, ERRMSG])
        1 Description. Compute minimum value across images.
        2 Class. Collective subroutine.
        3 Arguments.
           A         shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
                     values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
                     argument. If it is scalar, the computed value is equal to the minimum value of A in all corresponding
                     references. If it is an array each element of the computed value is equal to the minimum value of
                     all corresponding elements of A in all corresponding references.
                     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
                     absent, or the executing image is the one identiﬁed by RESULT_IMAGE. Otherwise, A becomes
                     undeﬁned.
           RESULT_IMAGE(optional) shallbeanintegerscalar. It is an INTENT (IN) argument. Its presence, and value
                     if present, shall be the same in all corresponding references. If it is present, its value shall be that
                     of an image index in the current team.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument.
           ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
                                                            c
           366                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        4 The semantics of STAT and ERRMSG are described in 16.6.
        5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
           1, 6] on the other image, the value of A after executing the statement CALL CO_MIN (A) is [1, 1, 3] on both
           images.
           16.9.49   CO_REDUCE(A,OPERATION[,RESULT_IMAGE,STAT,ERRMSG])
        1 Description. Generalized reduction across images.
        2 Class. Collective subroutine.
        3 Arguments.
           A         shall not be polymorphic. It shall have the same shape, type, and type parameter values, in
                     corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT) argument.
                     If A is scalar, the computed value is the result of the reduction operation of applying OPERATION
                     to the values of A in all corresponding references. If A is an array, each element of the computed
                     value is equal to the result of the reduction operation of applying OPERATION to corresponding
                     elements of A in all corresponding references.
                     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
                     absent, or the executing image is the one identiﬁed by RESULT_IMAGE. Otherwise, A becomes
                     undeﬁned.
           OPERATION shall be a pure function with exactly two arguments; the result and each argument shall be
                     a scalar, nonallocatable, nonpointer, nonpolymorphic data object with the same type and type
                     parameters as A. The arguments shall not be optional. If one argument has the ASYNCHRONOUS,
                     TARGET,orVALUEattribute, the other shall have that attribute. OPERATION shall implement
                     a mathematically associative operation. OPERATION shall be the same function on all images in
                     corresponding references.
                     Thecomputedvalueof a reduction operation over a set of values is the result of an iterative process.
                     Each iteration involves the evaluation of OPERATION (x, y) for x and y in the set, the removal of
                     x and y from the set, and the addition of the value of OPERATION (x, y) to the set. The process
                     terminates when the set has only one element; this is the computed value.
           RESULT_IMAGE(optional) shallbeanintegerscalar. It is an INTENT (IN) argument. Its presence, and value
                     if present, shall be the same in all corresponding references. If it is present, its value shall be that
                     of an image index in the current team.
           STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument.
           ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
        4 The semantics of STAT and ERRMSG are described in 16.6.
        5 Example. The subroutine below demonstrates how to use CO_REDUCE to create a collective counterpart to
           the intrinsic function ALL:
            SUBROUTINE co_all(boolean)
              LOGICAL, INTENT(INOUT) :: boolean
              CALL CO_REDUCE(boolean,both)
            CONTAINS
              PURE FUNCTION both(lhs,rhs) RESULT(lhs_and_rhs)
                LOGICAL, INTENT(IN) :: lhs,rhs
                LOGICAL :: lhs_and_rhs
                lhs_and_rhs = lhs .AND. rhs
              END FUNCTION both
            END SUBROUTINE co_all
           c
           ISO/IEC 2017 – All rights reserved                                               367
         ISO/IEC DIS 1539-1:2017 (E)
            NOTE16.11
            If the OPERATION function is not mathematically commutative, the result of calling CO_REDUCE can
            depend on the order of evaluations.
         16.9.50 CO_SUM(A[, RESULT_IMAGE, STAT, ERRMSG])
       1 Description. Compute sum across images.
       2 Class. Collective subroutine.
       3 Arguments.
         A       shall be of numeric type. It shall have the same shape, type, and type parameter values, in cor-
                 responding references. It shall not be a coindexed object. It is an INTENT (INOUT) argument.
                 If it is scalar, the computed value is equal to a processor-dependent approximation to the sum of
                 the values of A in corresponding references. If it is an array, each element of the computed value
                 is equal to a processor-dependent approximation to the sum of all corresponding elements of A in
                 corresponding references.
                 The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
                 absent, or the executing image is the one identiﬁed by RESULT_IMAGE. Otherwise, A becomes
                 undeﬁned.
         RESULT_IMAGE(optional) shallbeanintegerscalar. It is an INTENT (IN) argument. Its presence, and value
                 if present, shall be the same in all corresponding references. If it is present, its value shall be that
                 of an image index in the current team.
         STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                 INTENT (OUT) argument.
         ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
       4 The semantics of STAT and ERRMSG are described in 16.6.
       5 Example. If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
         1, 6] on the other image, the value of A after executing the statement CALL CO_SUM(A) is [5, 6, 9] on both
         images.
         16.9.51 COMMAND_ARGUMENT_COUNT()
       1 Description. Number of command arguments.
       2 Class. Transformational function.
       3 Argument. None.
       4 Result Characteristics. Default integer scalar.
       5 Result Value. The result value is equal to the number of command arguments available. If there are no
         command arguments available or if the processor does not support command arguments, then the result has the
         value zero. If the processor has a concept of a command name, the command name does not count as one of the
         command arguments.
       6 Example. See 16.9.83.
         16.9.52 CONJG (Z)
       1 Description. Conjugate of a complex number.
       2 Class. Elemental function.
                                                  c
         368                                     ISO/IEC 2017 – All rights reserved
                                                                                                ISO/IEC DIS 1539-1:2017 (E)
            3 Argument. Z shall be of type complex.
            4 Result Characteristics. Same as Z.
            5 Result Value. If Z has the value (x,y), the result has the value (x,−y).
            6 Example. CONJG ((2.0, 3.0)) has the value (2.0, −3.0).
               16.9.53        COS (X)
            1 Description. Cosine function.
            2 Class. Elemental function.
            3 Argument. X shall be of type real or complex.
            4 Result Characteristics. Same as X.
            5 Result Value. The result has a value equal to a processor-dependent approximation to cos(X). If X is of type
               real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
            6 Example. COS (1.0) has the value 0.54030231 (approximately).
               16.9.54        COSH (X)
            1 Description. Hyperbolic cosine function.
            2 Class. Elemental function.
            3 Argument. X shall be of type real or complex.
            4 Result Characteristics. Same as X.
            5 Result Value. The result has a value equal to a processor-dependent approximation to cosh(X). If X is of type
               complex its imaginary part is regarded as a value in radians.
            6 Example. COSH (1.0) has the value 1.5430806 (approximately).
               16.9.55        COSHAPE (COARRAY [, KIND])
            1 Description. Sizes of codimensions of a coarray.
            2 Class. Inquiry function.
            3 Arguments.
               COARRAY shall be a coarray of any type. It shall not be an unallocated allocatable coarray. If its designator
                              has more than one part-ref, the rightmost part-ref shall have nonzero corank.
               KIND (optional) shall be a scalar integer constant expression.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value
               of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
               whose size is equal to the corank of COARRAY.
                                                                 th                                      th
            5 Result Value. Theresult has a value whose i           element is equal to the size of the i   codimension of COARRAY,
               as given by UCOBOUND (COARRAY, i) − LCOBOUND (COARRAY, i) +1.
            6 Example.
               The following code allocates the coarray D with the same size in each codimension as that of the coarray C, with
               the lower cobound 1.
                c
               ISO/IEC 2017 – All rights reserved                                                                                   369
             ISO/IEC DIS 1539-1:2017 (E)
                 REAL, ALLOCATABLE :: C[:,:], D[:,:]
                 INTEGER, ALLOCATABLE :: COSHAPE_C(:)
                 ...
                 COSHAPE_C = COSHAPE(C)
                 ALLOCATE ( D[COSHAPE_C(1),*] )
             16.9.56      COUNT(MASK[, DIM, KIND])
           1 Description. Logical array reduced by counting true values.
           2 Class. Transformational function.
           3 Arguments.
             MASK         shall be a logical array.
             DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
                          The corresponding actual argument shall not be an optional dummy argument, a disassociated
                          pointer, or an unallocated allocatable.
             KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
             KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is absent or
             n=1;otherwise, the result has rank n−1 and shape [d , d , ..., d      , d      , . . . , d ] where [d , d , ..., d ]
             is the shape of MASK.                                 1  2       DIM−1   DIM+1       n          1  2       n
           5 Result Value.
             Case (i):    If DIM is absent or MASK has rank one, the result has a value equal to the number of true elements
                          of MASK or has the value zero if MASK has size zero.
             Case (ii):   If DIM is present and MASK has rank n > 1, the value of element (s1, s2, ..., sDIM−1, sDIM+1, ...,
                          s ) of the result is equal to the number of true elements of MASK (s , s , ..., s    , :, s    ,
                           n                                                                  1  2       DIM−1     DIM+1
                          . . . , sn).
           6 Examples.
             Case (i):    The value of COUNT ([.TRUE., .FALSE., .TRUE.]) is 2.
                                             1 3 5                         0 3 5 
             Case (ii):   If B is the array   2  4   6   and C is the array   7   4  8  , COUNT (B /= C, DIM = 1) is
                          [2, 0, 1] and COUNT (B /= C, DIM = 2) is [1, 2].
             16.9.57      CPU_TIME (TIME)
           1 Description. Processor time used.
           2 Class. Subroutine.
           3 Argument. TIME shall be a real scalar. It is an INTENT (OUT) argument. If the processor cannot provide
             a meaningful value for the time, it is assigned a processor-dependent negative value; otherwise, it is assigned a
             processor-dependent approximation to the processor time in seconds. Whether the value assigned is an approx-
             imation to the amount of time used by the invoking image, or the amount of time used by the whole program, is
             processor dependent.
           4 Example.
                        REAL T1, T2
                        ...
                        CALL CPU_TIME(T1)
                                                                            c
             370                                                           ISO/IEC 2017 – All rights reserved
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
                         ...    ! Code to be timed.
                         CALL CPU_TIME(T2)
                         WRITE (*,*) ’Time taken by code was ’, T2-T1, ’ seconds’
              writes the processor time taken by a piece of code.
                   NOTE16.12
                   A processor for which a single result is inadequate (for example, a parallel processor) might choose to
                   provide an additional version for which time is an array.
                   The exact deﬁnition of time is left imprecise because of the variability in what diﬀerent processors are able
                   to provide. The primary purpose is to compare diﬀerent algorithms on the same processor or discover which
                   parts of a calculation are the most expensive.
                   The start time is left imprecise because the purpose is to time sections of code, as in the example.
                   Most computer systems have multiple concepts of time. One common concept is that of time expended by
                   the processor for a given program. This might or might not include system overhead, and has no obvious
                   connection to elapsed “wall clock” time.
              16.9.58      CSHIFT (ARRAY, SHIFT [, DIM])
           1 Description. Circular shift of an array.
           2 Class. Transformational function.
           3 Arguments.
              ARRAY        may be of any type. It shall be an array.
              SHIFT        shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
                           of rank n−1 and of shape [d , d , ..., d       , d      , . . . , d ] where [d , d , ..., d ] is the shape
                           of ARRAY.                    1   2       DIM−1   DIM+1        n          1   2       n
              DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                           If DIM is absent, it is as if it were present with the value 1.
           4 Result Characteristics. The result is of the type and type parameters of ARRAY, and has the shape of
              ARRAY.
           5 Result Value.
              Case (i):    If ARRAY has rank one, element i of the result is ARRAY (1 + MODULO (i + SHIFT − 1, SIZE
                           (ARRAY))).
              Case (ii):   If ARRAY has rank greater than one, section (s , s , ..., s       , :, s     , . . . ., s ) of the result
                                                                            1  2       DIM−1      DIM+1        n
                           has a value equal to CSHIFT (ARRAY (s , s , ..., s          , :, s    , . . . ., s ), sh, 1), where sh is
                                                                     1   2       DIM−1     DIM+1         n
                           SHIFT or SHIFT (s , s , ..., s        , s      , . . . , s ).
                                                1  2       DIM−1    DIM+1        n
           6 Examples.
              Case (i):    If V is the array [1, 2, 3, 4, 5, 6], the eﬀect of shifting V circularly to the left by two positions is
                           achieved by CSHIFT (V, SHIFT = 2) which has the value [3, 4, 5, 6, 1, 2]; CSHIFT (V, SHIFT =
                           −2) achieves a circular shift to the right by two positions and has the value [5, 6, 1, 2, 3, 4].
              Case (ii):   The rows of an array of rank two may all be shifted by the same amount or by diﬀerent amounts.
                                              1 2 3 
                           If M is the array  4   5  6 , the value of
                                               7   8  9                         
                                                                        3  1  2
                           CSHIFT (M, SHIFT = −1, DIM = 2) is  6 4 5 , and the value of
                                                                        9  7  8
               c
              ISO/IEC 2017 – All rights reserved                                                                         371
            ISO/IEC DIS 1539-1:2017 (E)
                                                                     3 1 2 
                                                                     5 6 4 
                         CSHIFT (M, SHIFT = [−1, 1, 0], DIM = 2) is   7  8  9   .
            16.9.59      DATE_AND_TIME ([DATE, TIME, ZONE, VALUES])
          1 Description. Date and time.
          2 Class. Subroutine.
          3 Arguments.
            DATE(optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
                         of the form YYYYMMDD, where YYYY is the year in the Gregorian calendar, MM is the month
                         within the year, and DD is the day within the month. The characters of this value shall all be
                         decimal digits. If there is no date available, DATE is assigned all blanks.
            TIME(optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
                         of the form hhmmss.sss, where hh is the hour of the day, mm is the minutes of the hour, and ss.sss
                         is the seconds and milliseconds of the minute. Except for the decimal point, the characters of this
                         value shall all be decimal digits. If there is no clock available, TIME is assigned all blanks.
            ZONE(optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value of
                         the form +hhmm or -hhmm, where hh and mm are the time diﬀerence with respect to Coordinated
                         Universal Time (UTC) in hours and minutes, respectively. The characters of this value following
                         the sign character shall all be decimal digits. If this information is not available, ZONE is assigned
                         all blanks.
            VALUES(optional) shall be a rank-one array of type integer with a decimal exponent range of at least four. It
                         is an INTENT (OUT) argument. Its size shall be at least 8. The values assigned to VALUES are
                         as follows:
               VALUES(1) the year, including the century (for example, 2008), or −HUGE (VALUES) if there is no date
                         available;
               VALUES(2) the month of the year, or −HUGE (VALUES) if there is no date available;
               VALUES(3) the day of the month, or −HUGE (VALUES) if there is no date available;
               VALUES(4) the time diﬀerence from Coordinated Universal Time (UTC) in minutes, or −HUGE (VALUES)
                         if this information is not available;
               VALUES(5) the hour of the day, in the range of 0 to 23, or −HUGE (VALUES) if there is no clock;
               VALUES(6) the minutes of the hour, in the range 0 to 59, or −HUGE (VALUES) if there is no clock;
               VALUES(7) the seconds of the minute, in the range 0 to 60, or −HUGE (VALUES) if there is no clock;
               VALUES(8) the milliseconds of the second, in the range 0 to 999, or −HUGE (VALUES) if there is no clock.
          4 The date, clock, and time zone information might be available on some images and not others. If the date, clock,
            or time zone information is available on more than one image, it is processor dependent whether or not those
            images share the same information.
          5 Example. If run in Geneva, Switzerland on April 12, 2008 at 15:27:35.5 with a system conﬁgured for the
            local time zone, this example would have assigned the value 20080412 to BIG_BEN (1), the value 152735.500 to
            BIG_BEN(2),thevalue+0100toBIG_BEN(3),andthevalue[2008,4,12,60,15,27,35,500]toDATE_TIME.
                    INTEGER DATE_TIME (8)
                    CHARACTER (LEN = 10) BIG_BEN (3)
                    CALL DATE_AND_TIME (BIG_BEN (1), BIG_BEN (2), BIG_BEN (3), DATE_TIME)
                                                                       c
            372                                                       ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
            NOTE16.13
            These forms are compatible with the representations deﬁned in ISO 8601:2004. UTC is established by the
            International Bureau of Weights and Measures (BIPM, i.e. Bureau International des Poids et Mesures) and
            the International Earth Rotation Service (IERS).
         16.9.60 DBLE (A)
       1 Description. Conversion to double precision real.
       2 Class. Elemental function.
       3 Argument. A shall be of type integer, real, complex, or a boz-literal-constant.
       4 Result Characteristics. Double precision real.
       5 Result Value. The result has the value REAL (A, KIND (0.0D0)).
       6 Example. DBLE (−3) has the value −3.0D0.
         16.9.61 DIGITS (X)
       1 Description. Signiﬁcant digits in numeric model.
       2 Class. Inquiry function.
       3 Argument. X shall be of type integer or real. It may be a scalar or an array.
       4 Result Characteristics. Default integer scalar.
       5 Result Value. The result has the value q if X is of type integer and p if X is of type real, where q and p are as
         deﬁned in 16.4 for the model representing numbers of the same type and kind type parameter as X.
       6 Example. DIGITS (X) has the value 24 for real X whose model is as in NOTE 16.4.
         16.9.62 DIM (X, Y)
       1 Description. Maximum of X − Y and zero.
       2 Class. Elemental function.
       3 Arguments.
         X       shall be of type integer or real.
         Y       shall be of the same type and kind type parameter as X.
       4 Result Characteristics. Same as X.
       5 Result Value. The value of the result is the maximum of X − Y and zero.
       6 Example. DIM (−3.0, 2.0) has the value 0.0.
         16.9.63 DOT_PRODUCT(VECTOR_A, VECTOR_B)
       1 Description. Dot product of two vectors.
       2 Class. Transformational function.
       3 Arguments.
         VECTOR_A shall be of numeric type (integer, real, or complex) or of logical type. It shall be a rank-one array.
         c
         ISO/IEC 2017 – All rights reserved                                 373
              ISO/IEC DIS 1539-1:2017 (E)
              VECTOR_B shall be of numeric type if VECTOR_A is of numeric type or of type logical if VECTOR_A is of
                            type logical. It shall be a rank-one array. It shall be of the same size as VECTOR_A.
           4 Result Characteristics. If the arguments are of numeric type, the type and kind type parameter of the result
              are those of the expression VECTOR_A * VECTOR_B determined by the types and kinds of the arguments
              according to 10.1.9.3. If the arguments are of type logical, the result is of type logical with the kind type parameter
              of the expression VECTOR_A .AND. VECTOR_B according to 10.1.9.3. The result is scalar.
           5 Result Value.
              Case (i):     If VECTOR_Aisoftypeinteger or real, the result has the value SUM (VECTOR_A*VECTOR_-
                            B). If the vectors have size zero, the result has the value zero.
              Case (ii):    If VECTOR_Aisof type complex, the result has the value SUM (CONJG (VECTOR_A)*VECT-
                            OR_B). If the vectors have size zero, the result has the value zero.
              Case (iii):   If VECTOR_Aisoftypelogical,theresulthasthevalueANY(VECTOR_A.AND.VECTOR_B).
                            If the vectors have size zero, the result has the value false.
           6 Example. DOT_PRODUCT ([1, 2, 3], [2, 3, 4]) has the value 20.
              16.9.64       DPROD(X, Y)
           1 Description. Double precision real product.
           2 Class. Elemental function.
           3 Arguments.
              X             shall be default real.
              Y             shall be default real.
           4 Result Characteristics. Double precision real.
           5 Result Value. The result has a value equal to a processor-dependent approximation to the product of X and
              Y. DPROD (X, Y) should have the same value as DBLE (X) * DBLE (Y).
           6 Example. DPROD (−3.0, 2.0) has the value −6.0D0.
              16.9.65       DSHIFTL (I, J, SHIFT)
           1 Description. Combined left shift.
           2 Class. Elemental function.
           3 Arguments.
              I             shall be of type integer or a boz-literal-constant.
              J             shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
                            the same kind type parameter. I and J shall not both be boz-literal-constants.
              SHIFT         shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
                            type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
           4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
           5 Result Value. If either I or J is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function INT to
              type integer with the kind type parameter of the other. The rightmost SHIFT bits of the result value are the same
              as the leftmost bits of J, and the remaining bits of the result value are the same as the rightmost bits of I. This
              is equal to IOR (SHIFTL (I, SHIFT), SHIFTR (J, BIT_SIZE (J)−SHIFT)). The model for the interpretation of
              an integer value as a sequence of bits is in 16.3.
                                                                                c
              374                                                              ISO/IEC 2017 – All rights reserved
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
           6 Examples. DSHIFTL (1, 2**30, 2) has the value 5 if default integer has 32 bits. DSHIFTL (I, I, SHIFT) has
              the same result value as ISHFTC (I, SHIFT).
              16.9.66      DSHIFTR (I, J, SHIFT)
           1 Description. Combined right shift.
           2 Class. Elemental function.
           3 Arguments.
              I            shall be of type integer or a boz-literal-constant.
              J            shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
                           the same kind type parameter. I and J shall not both be boz-literal-constants.
              SHIFT        shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
                           type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
           4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
           5 Result Value. If either I or J is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function INT to
              type integer with the kind type parameter of the other. The leftmost SHIFT bits of the result value are the same
              as the rightmost bits of I, and the remaining bits of the result value are the same as the leftmost bits of J. This
              is equal to IOR (SHIFTL (I, BIT_SIZE (I)−SHIFT), SHIFTR (J, SHIFT)). The model for the interpretation of
              an integer value as a sequence of bits is in 16.3.
           6 Examples. DSHIFTR (1, 16, 3) has the value 229+2 if default integer has 32 bits. DSHIFTR (I, I, SHIFT) has
              the same result value as ISHFTC (I,−SHIFT).
              16.9.67      EOSHIFT (ARRAY, SHIFT [, BOUNDARY, DIM])
           1 Description. End-oﬀ shift of the elements of an array.
           2 Class. Transformational function.
           3 Arguments.
              ARRAY        shall be an array be of any type.
              SHIFT        shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
                           of rank n−1 and of shape [d , d , ..., d       , d      , . . . , d ] where [d , d , ..., d ] is the shape
                           of ARRAY.                    1   2       DIM−1   DIM+1        n          1   2       n
              BOUNDARY(optional) shall be of the same type and type parameters as ARRAY and shall be scalar if ARRAY
                           has rank one; otherwise, it shall be either scalar or of rank n−1 and of shape [d1, d2, ..., dDIM−1,
                           d       , . . . , d ]. BOUNDARY is permitted to be absent only for the types in Table 16.4, and in
                             DIM+1        n
                           this case it is as if it were present with the scalar value shown, converted if necessary to the kind
                           type parameter value of ARRAY.
                                       Table 16.4: Default BOUNDARY values for EOSHIFT
                                                 Type of ARRAY       Value of BOUNDARY
                                                      Integer                  0
                                                       Real                   0.0
                                                     Complex               (0.0, 0.0)
                                                      Logical               .FALSE.
                                                  Character (len)          len blanks
              DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                           If DIM is absent, it is as if it were present with the value 1.
               c
              ISO/IEC 2017 – All rights reserved                                                                         375
             ISO/IEC DIS 1539-1:2017 (E)
          4 Result Characteristics. The result has the type, type parameters, and shape of ARRAY.
          5 Result Value. Element (s , s , ..., s ) of the result has the value ARRAY (s , s , ..., s      , s    +sh,
                                        1  2       n                                      1   2       DIM−1   DIM
             s      , . . . , s ) where sh is SHIFT or SHIFT (s , s , ..., s   , s     , . . . , s ) provided the inequality
              DIM+1        n                                 1   2       DIM−1   DIM+1        n
             LBOUND (ARRAY, DIM) ≤ s           +sh ≤ UBOUND (ARRAY, DIM) holds and is otherwise BOUNDARY or
                                           DIM
             BOUNDARY(s , s , ..., s         , s     , . . . , s ).
                            1   2      DIM−1   DIM+1        n
          6 Examples.
             Case (i):    If V is the array [1, 2, 3, 4, 5, 6], the eﬀect of shifting V end-oﬀ to the left by 3 positions is achieved
                          by EOSHIFT (V, SHIFT = 3), which has the value [4, 5, 6, 0, 0, 0]; EOSHIFT (V, SHIFT = −2,
                          BOUNDARY=99)achievesanend-oﬀ shift to the right by 2 positions with the boundary value of
                          99 and has the value [99, 99, 1, 2, 3, 4].
             Case (ii):   The rows of an array of rank two may all be shifted by the same amount or by diﬀerent amounts
                                                                                                 A B C 
                                                                                                 D E F 
                          and the boundary elements can be the same or diﬀerent. If M is the array            , then the
                                                                                                 G HI
                                                                                              *  A B
                                                                                             * D E 
                          value of EOSHIFT (M, SHIFT = −1, BOUNDARY=’*’, DIM=2)is             ∗ G H ,andthevalue
                                                                                                        * A B 
                                                                                                        E F / 
                          of EOSHIFT (M, SHIFT = [−1, 1, 0], BOUNDARY = [’*’, ’/’, ’?’], DIM = 2) is     G H I .
             16.9.68      EPSILON (X)
          1 Description. Model number that is small compared to 1.
          2 Class. Inquiry function.
          3 Argument. X shall be of type real. It may be a scalar or an array.
          4 Result Characteristics. Scalar of the same type and kind type parameter as X.
                                                      1−p
          5 Result Value. The result has the value b      where b and p are as deﬁned in 16.4 for the model representing
             numbers of the same type and kind type parameter as X.
                                                     −23
          6 Example. EPSILON (X) has the value 2         for real X whose model is as in NOTE 16.4.
             16.9.69      ERF (X)
          1 Description. Error function.
          2 Class. Elemental function.
          3 Argument. X shall be of type real.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the error function of X,
              2 RX        2
             √ 0 exp(−t )dt.
               π
          6 Example. ERF (1.0) has the value 0.843 (approximately).
             16.9.70      ERFC (X)
          1 Description. Complementary error function.
          2 Class. Elemental function.
                                                                          c
             376                                                          ISO/IEC 2017 – All rights reserved
                                                                                        ISO/IEC DIS 1539-1:2017 (E)
           3 Argument. X shall be of type real.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to the complementary error
                                                                 2 R∞         2
              function of X, 1 − ERF (X); this is equivalent to √   X exp(−t )dt.
                                                                 π
           6 Example. ERFC (1.0) has the value 0.157 (approximately).
              16.9.71      ERFC_SCALED (X)
           1 Description. Scaled complementary error function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to the exponentially-scaled
                                                         2  2 R∞         2
              complementary error function of X, exp(X )√π X exp(−t )dt.
           6 Example. ERFC_SCALED (20.0) has the value 0.02817434874 (approximately).
                   NOTE16.14
                                                                               2      √
                   The complementary error function is asymptotic to exp(−X )/(X π). As such it underﬂows for X >≈ 9
                   when using ISO/IEC/IEEE 60559:2011 single precision arithmetic. The exponentially-scaled complement-
                                                            √                                                          √
                   ary error function is asymptotic to 1/(X  π). As such it does not underﬂow until X > HUGE (X)/ π.
              16.9.72      EVENT_QUERY (EVENT, COUNT [, STAT])
           1 Description. Query event count.
           2 Class. Subroutine.
           3 Arguments.
              EVENT        shall be an event variable (16.10.2.10). It shall not be coindexed. It is an INTENT (IN) argument.
                           The EVENT argument is accessed atomically with respect to the execution of EVENT POST
                           statements in unordered segments, in exact analogy to atomic subroutines.
              COUNT        shall be an integer scalar with a decimal exponent range no smaller than that of default integer. It
                           is an INTENT (OUT) argument. If no error condition occurs, COUNT is assigned the value of the
                           count of EVENT; otherwise, it is assigned the value −1.
              STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                           INTENT (OUT) argument. If the STAT argument is present, it is assigned a processor-dependent
                           positive value if an error condition occurs; otherwise it is assigned the value zero. If the STAT
                           argument is not present and an error condition occurs, error termination is initiated.
           4 Example. If EVENT is an event variable for which there have been no successful posts or waits in preceding
              segments, and for which there are no posts or waits in an unordered segment, after execution of
                      CALL EVENT_QUERY (EVENT, COUNT)
              the integer variable COUNT will have the value zero. If there have been ten successful posts to EVENT and two
              successful waits without an UNTIL_COUNT= speciﬁer in preceding segments, and for which there are no posts
              or waits in an unordered segment, after execution of
                      CALL EVENT_QUERY (EVENT, COUNT)
              the variable COUNT will have the value eight.
               c
              ISO/IEC 2017 – All rights reserved                                                                         377
         ISO/IEC DIS 1539-1:2017 (E)
            NOTE16.15
            Execution of EVENT_QUERY does not imply any synchronization.
         16.9.73 EXECUTE_COMMAND_LINE (COMMAND [, WAIT, EXITSTAT,
                 CMDSTAT, CMDMSG ])
       1 Description. Execute a command line.
       2 Class. Subroutine.
       3 Arguments.
         COMMAND shall be a default character scalar. It is an INTENT (IN) argument. Its value is the command line
                  to be executed. The interpretation is processor dependent.
         WAIT(optional) shall be a logical scalar. It is an INTENT (IN) argument. If WAIT is present with the value
                  false, and the processor supports asynchronous execution of the command, the command is executed
                  asynchronously; otherwise it is executed synchronously.
         EXITSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least nine. It is an
                  INTENT (INOUT) argument. If the command is executed synchronously, it is assigned the value
                  of the processor-dependent exit status. Otherwise, the value of EXITSTAT is unchanged.
         CMDSTAT(optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                  INTENT(OUT)argument. It is assigned the value −1 if the processor does not support command
                  line execution, a processor-dependent positive value if an error condition occurs, or the value −2
                  if no error condition occurs but WAIT is present with the value false and the processor does not
                  support asynchronous execution. Otherwise it is assigned the value 0.
         CMDMSG(optional) shall be a default character scalar. It is an INTENT (INOUT) argument. If an error condi-
                  tion occurs, it is assigned a processor-dependent explanatory message. Otherwise, it is unchanged.
       4 If the processor supports command line execution, it shall support synchronous and may support asynchronous
         execution of the command line.
       5 Whenthecommandisexecuted synchronously, EXECUTE_COMMAND_LINEreturns after the command line
         has completed execution. Otherwise, EXECUTE_COMMAND_LINE returns without waiting.
       6 If a condition occurs that would assign a nonzero value to CMDSTAT but the CMDSTAT variable is not present,
         error termination is initiated.
         16.9.74 EXP (X)
       1 Description. Exponential function.
       2 Class. Elemental function.
       3 Argument. X shall be of type real or complex.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to eX. If X is of type
         complex, its imaginary part is regarded as a value in radians.
       6 Example. EXP (1.0) has the value 2.7182818 (approximately).
         16.9.75 EXPONENT (X)
       1 Description. Exponent of ﬂoating-point number.
       2 Class. Elemental function.
                                                  c
         378                                      ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        3 Argument. X shall be of type real.
        4 Result Characteristics. Default integer.
        5 Result Value. The result has a value equal to the exponent e of the representation for the value of X in the
           extended real model for the kind of X (16.4), provided X is nonzero and e is within the range for default integers.
           If X has the value zero, the result has the value zero. If X is an IEEE inﬁnity or NaN, the result has the value
           HUGE(0).
        6 Examples. EXPONENT (1.0) has the value 1 and EXPONENT (4.1) has the value 3 for reals whose model is
           as in NOTE 16.4.
           16.9.76   EXTENDS_TYPE_OF (A, MOLD)
        1 Description. Dynamic type extension inquiry.
        2 Class. Inquiry function.
        3 Arguments.
           A         shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
                     pointer, it shall not have an undeﬁned association status.
           MOLD      shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
                     pointer, it shall not have an undeﬁned association status.
        4 Result Characteristics. Default logical scalar.
        5 Result Value. If MOLDisunlimitedpolymorphicandiseitheradisassociatedpointer or unallocated allocatable
           variable, the result is true; otherwise if A is unlimited polymorphic and is either a disassociated pointer or
           unallocated allocatable variable, the result is false; otherwise if the dynamic type of A or MOLD is extensible, the
           result is true if and only if the dynamic type of A is an extension type of the dynamic type of MOLD; otherwise
           the result is processor dependent.
              NOTE16.16
              The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type.
              NOTE16.17
              The test performed by EXTENDS_TYPE_OF is not the same as the test performed by the type guard
              CLASS IS. The test performed by EXTENDS_TYPE_OF does not consider kind type parameters.
        6 Example. Given the declarations and assignments
                 TYPE T1
                    REAL C
                 END TYPE
                 TYPE, EXTENDS(T1) :: T2
                 END TYPE
                 CLASS(T1), POINTER :: P, Q
                 ALLOCATE (P)
                 ALLOCATE (T2 :: Q)
           the result of EXTENDS_TYPE_OF (P, Q) will be false, and the result of EXTENDS_TYPE_OF (Q, P) will
           be true.
           c
           ISO/IEC 2017 – All rights reserved                                               379
               ISO/IEC DIS 1539-1:2017 (E)
               16.9.77        FAILED_IMAGES ([TEAM, KIND])
            1 Description. Indices of failed images.
            2 Class. Transformational function.
            3 Arguments.
               TEAM(optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
                              value shall be that of the current or an ancestor team. If TEAM is absent, the team speciﬁed is the
                              current team.
               KIND (optional) shall be a scalar integer constant expression.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value
               of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
               whose size is equal to the number of images in the speciﬁed team that are known by the invoking image to have
               failed.
            5 Result Value. The elements of the result are the values of the image indices of the known failed images in the
               speciﬁed team, in numerically increasing order. If the executing image has previously executed an image control
               statement whose STAT= speciﬁer assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_-
               FORTRAN_ENV, or referenced a collective subroutine whose STAT argument was set to STAT_FAILED_-
               IMAGE, at least one image in the set of images participating in that image control statement or collective
               subroutine reference shall be known to have failed.
            6 Examples. If image 3 is the only image in the current team that is known by the invoking image to have failed,
               FAILED_IMAGES() will have the value [3]. If there are no images in the current team that are known by the
               invoking image to have failed, the value of FAILED_IMAGES() will be a zero-sized array.
               16.9.78        FINDLOC (ARRAY, VALUE, DIM [, MASK, KIND, BACK]) or
                              FINDLOC (ARRAY, VALUE [, MASK, KIND, BACK])
            1 Description. Location(s) of a speciﬁed value.
            2 Class. Transformational function.
            3 Arguments.
               ARRAY          shall be an array of intrinsic type.
               VALUE          shall be scalar and in type conformance with ARRAY, as speciﬁed in Table 10.2 for the operator
                              ==orthe operator .EQV..
               DIM            shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
               MASK(optional) shall be of type logical and shall be conformable with ARRAY.
               KIND (optional) shall be a scalar integer constant expression.
               BACK(optional) shall be a logical scalar.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
               KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
               an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
               [d , d , ..., d       , d       , . . . , d ], where [d , d , ..., d ] is the shape of ARRAY.
                 1   2        DIM−1     DIM+1          n            1   2        n
            5 Result Value.
               Case (i):      Theresult of FINDLOC (ARRAY, VALUE) is a rank-one array whose element values are the values
                              of the subscripts of an element of ARRAY whose value matches VALUE. If there is such a value,
                              the ith element value is in the range 1 to e , where e is the extent of the ith dimension of ARRAY.
                                                                             i          i
                              If no elements match VALUE or ARRAY has size zero, all elements of the result are zero.
                                                                                        c
               380                                                                     ISO/IEC 2017 – All rights reserved
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
              Case (ii):     The result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-one array whose element
                             values are the values of the subscripts of an element of ARRAY, corresponding to a true element
                                                                                                         th
                             of MASK, whose value matches VALUE. If there is such a value, the i            element value is in the
                                                                          th
                             range 1 to e , where e is the extent of the i   dimension of ARRAY. If no elements match VALUE,
                                         i         i
                             ARRAYhassize zero, or every element of MASK has the value false, all elements of the result are
                             zero.
              Case (iii):    If ARRAY has rank one, the result of
                             FINDLOC (ARRAY, VALUE, DIM=DIM [, MASK = MASK]) is a scalar whose value is equal to
                             that of the ﬁrst element of FINDLOC (ARRAY, VALUE [, MASK = MASK]). Otherwise, the value
                             of element (s1, s2, ..., sDIM−1, sDIM+1, ..., sn ) of the result is equal to FINDLOC (ARRAY (s1,
                             s , ..., s      , :, s     , . . . , s ), VALUE, DIM=1 [, MASK = MASK (s , s , ..., s               , :,
                              2       DIM−1       DIM+1         n                                             1   2        DIM−1
                             s      , . . . , s )]).
                              DIM+1        n
           6 If both ARRAYandVALUEareoftypelogical, the comparison is performed with the .EQV. operator; otherwise,
              the comparison is performed with the == operator. If the value of the comparison is true, that element of ARRAY
              matches VALUE.
           7 If DIM is not present, more than one element matches VALUE, and BACK is absent or present with the value
              false, the value returned indicates the ﬁrst such element, taken in array element order. If DIM is not present and
              BACKis present with the value true, the value returned indicates the last such element, taken in array element
              order.
           8 Examples.
              Case (i):      The value of FINDLOC ([2, 6, 4, 6], VALUE=6) is [2], and the value of FINDLOC ([2, 6, 4, 6],
                             VALUE=6, BACK=.TRUE.) is [4].
                                                 0 −5       7   7                           T T F T 
                                                 3    4    −1 2                             T T F T 
              Case (ii):     If A has the value                      , and M has the value                       , FINDLOC (A, 7,
                                                   1   5     6   7                              T T F T
                             MASK = M) has the value [1, 4] and FINDLOC (A, 7, MASK = M, BACK = .TRUE.) has the
                             value [3, 4]. This is independent of the declared lower bounds for A.
              Case (iii):    The value of FINDLOC ([2, 6, 4], VALUE=6, DIM=1) is 2. If B has the value
                              1 2 −9 
                               2   2   6    , FINDLOC (B, VALUE=2, DIM=1) has the value [2, 1, 0] and FINDLOC (B,
                             VALUE=2,DIM=2)hasthevalue [2, 1]. This is independent of the declared lower bounds for B.
              16.9.79       FLOOR (A [, KIND])
           1 Description. Greatest integer less than or equal to A.
           2 Class. Elemental function.
           3 Arguments.
              A              shall be of type real.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type.
           5 Result Value. The result has a value equal to the greatest integer less than or equal to A.
           6 Examples. FLOOR (3.7) has the value 3. FLOOR (−3.7) has the value −4.
              16.9.80       FRACTION (X)
           1 Description. Fractional part of number.
           2 Class. Elemental function.
               c
              ISO/IEC 2017 – All rights reserved                                                                              381
               ISO/IEC DIS 1539-1:2017 (E)
            3 Argument. X shall be of type real.
            4 Result Characteristics. Same as X.
                                                                     −e
            5 Result Value. The result has the value X×b               , where b and e are as deﬁned in 16.4 for the representation of
               Xin the extended real model for the kind of X. If X has the value zero, the result is zero. If X is an IEEE NaN,
               the result is that NaN. If X is an IEEE inﬁnity, the result is an IEEE NaN.
            6 Example. FRACTION (3.0) has the value 0.75 for reals whose model is as in NOTE 16.4.
               16.9.81         GAMMA(X)
            1 Description. Gamma function.
            2 Class. Elemental function.
            3 Argument. X shall be of type real. Its value shall not be a negative integer or zero.
            4 Result Characteristics. Same as X.
            5 Result Value. The result has a value equal to a processor-dependent approximation to the gamma function of
               X,
                                R∞tX−1exp(−t)dt                                 X>0
                               
                      Γ(X)= R0                           P          k
                                ∞ X−1                       n    (−t)
                                0 t           exp(−t)−      k=0    k!    dt     −n−1<X<−n,naninteger ≥0
            6 Example. GAMMA (1.0) has the value 1.000 (approximately).
               16.9.82         GET_COMMAND([COMMAND,LENGTH,STATUS, ERRMSG])
            1 Description. Get program invocation command.
            2 Class. Subroutine.
            3 Arguments.
               COMMAND(optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned
                               the entire command by which the program was invoked. If the command cannot be determined,
                               COMMANDisassigned all blanks.
               LENGTH(optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                               INTENT (OUT) argument. It is assigned the signiﬁcant length of the command by which the
                               program was invoked. The signiﬁcant length may include trailing blanks if the processor allows
                               commandswith signiﬁcant trailing blanks. This length does not consider any possible truncation or
                               padding in assigning the command to the COMMAND argument; in fact the COMMAND argument
                               need not even be present. If the command length cannot be determined, a length of 0 is assigned.
               STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                               INTENT(OUT)argument. It is assigned the value −1 if the COMMAND argument is present and
                               has a length less than the signiﬁcant length of the command. It is assigned a processor-dependent
                               positive value if the command retrieval fails. Otherwise it is assigned the value 0.
               ERRMSG(optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned a
                               processor-dependent explanatory message if the command retrieval fails. Otherwise, it is unchanged.
            4 Example. If the program below is invoked with the command “example” on a processor that supports command
               retrieval, it will display “Hello example”.
                                                                                         c
               382                                                                      ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
                 PROGRAM hello
                   CHARACTER(:), ALLOCATABLE :: cmd
                   INTEGER :: cmdlen
                   CALL GET_COMMAND(LENGTH=cmdlen)
                   IF (cmdlen>0) THEN
                     ALLOCATE(CHARACTER(cmdlen) :: cmd)
                     CALL GET_COMMAND(cmd)
                     PRINT *, ’Hello ’, cmd
                   END IF
                 END PROGRAM
           16.9.83   GET_COMMAND_ARGUMENT(NUMBER[,VALUE,LENGTH,
                     STATUS, ERRMSG])
        1 Description. Get program invocation argument.
        2 Class. Subroutine.
        3 Arguments.
           NUMBER shallbeanintegerscalar. ItisanINTENT(IN)argumentthatspeciﬁesthenumberofthecommand
                     argument that the other arguments give information about.
                     Commandargument 0 always exists, and is the command name by which the program was invoked
                     if the processor has such a concept; otherwise, the value of command argument 0 is processor
                     dependent. The remaining command arguments are numbered consecutively from 1 to the argument
                     count in an order determined by the processor.
           VALUE(optional) shall be a default character scalar. It is an INTENT (OUT) argument. If the command
                     argument speciﬁed by NUMBER exists, its value is assigned to VALUE; otherwise, VALUE is
                     assigned all blanks.
           LENGTH(optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                     INTENT(OUT)argument. If the command argument speciﬁed by NUMBER exists, its signiﬁcant
                     length is assigned to LENGTH; otherwise, LENGTH is assigned the value zero. It is processor
                     dependent whether the signiﬁcant length includes trailing blanks. This length does not consider any
                     possible truncation or padding in assigning the command argument value to the VALUE argument;
                     in fact the VALUE argument need not even be present.
           STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                     INTENT(OUT)argument. If NUMBER is less than zero or greater than the argument count that
                     would be returned by the intrinsic function COMMAND_ARGUMENT_COUNT, or command
                     retrieval fails, STATUS is assigned a processor-dependent positive value. Otherwise, if VALUE is
                     present and has a length less than the signiﬁcant length of the speciﬁed command argument, it is
                     assigned the value −1. Otherwise it is assigned the value 0.
           ERRMSG(optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
                     a processor-dependent explanatory message if the optional argument STATUS is, or would be if
                     present, assigned a positive value. Otherwise, it is unchanged.
        4 Example. On a processor that supports command arguments, the following program displays the arguments of
           the command by which it was invoked.
                 PROGRAM show_arguments
                   INTEGER :: i
                   CHARACTER :: command*32, arg*128
                   CALL get_command_argument(0, command)
           c
           ISO/IEC 2017 – All rights reserved                                               383
           ISO/IEC DIS 1539-1:2017 (E)
                   WRITE (*,*) "Command name is: ", command
                   DO i = 1, command_argument_count()
                     CALL get_command_argument(i, arg)
                     WRITE (*,*) "Argument ", i, " is ", arg
                   END DO
                 END PROGRAM show_arguments
           16.9.84   GET_ENVIRONMENT_VARIABLE (NAME [, VALUE, LENGTH,
                     STATUS, TRIM_NAME, ERRMSG])
        1 Description. Get environment variable.
        2 Class. Subroutine.
        3 Arguments.
           NAME      shall be a default character scalar. It is an INTENT (IN) argument. The interpretation of case is
                     processor dependent.
           VALUE(optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned the value
                     of the environment variable speciﬁed by NAME. VALUE is assigned all blanks if the environment
                     variable does not exist or does not have a value or if the processor does not support environment
                     variables.
           LENGTH(optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                     INTENT(OUT)argument. If the speciﬁed environment variable exists and has a value, LENGTH
                     is assigned the value of its length. Otherwise LENGTH is assigned the value zero.
           STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
                     INTENT (OUT) argument. If the environment variable exists and either has no value, its value is
                     successfully assigned to VALUE, or the VALUE argument is not present, STATUS is assigned the
                     value zero. STATUS is assigned the value −1 if the VALUE argument is present and has a length
                     less than the signiﬁcant length of the environment variable. It is assigned the value 1 if the speciﬁed
                     environment variable does not exist, or 2 if the processor does not support environment variables.
                     Processor-dependent values greater than 2 may be assigned for other error conditions.
           TRIM_NAME(optional) shall be a logical scalar. It is an INTENT (IN) argument. If TRIM_NAME is present
                     with the value false then trailing blanks in NAME are considered signiﬁcant if the processor sup-
                     ports trailing blanks in environment variable names. Otherwise trailing blanks in NAME are not
                     considered part of the environment variable’s name.
           ERRMSG(optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
                     a processor-dependent explanatory message if the optional argument STATUS is, or would be if
                     present, assigned a positive value. Otherwise, it is unchanged.
        4 It is processor dependent whether an environment variable that exists on an image also exists on another image,
           and if it does exist on both images, whether the values are the same or diﬀerent.
        5 Example. If the value of the environment variable DATAFILE is dataﬁle.dat, executing the statement sequence
           below will assign the value ’dataﬁle.dat’ to FILENAME.
                 CHARACTER(:),ALLOCATABLE :: FILENAME
                 INTEGER :: NAMELEN
                 CALL GET_ENVIRONMENT_VARIABLE ("DATAFILE", LENGTH=NAMELEN)
                 IF (LENGTH>0) THEN
                   ALLOCATE(CHARACTER(LENGTH) :: FILENAME)
                   CALL GET_ENVIRONMENT_VARIABLE("DATAFILE", FILENAME)
                 END IF
                                                            c
           384                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
           16.9.85   GET_TEAM([LEVEL])
        1 Description. Team.
        2 Class. Transformational function.
        3 Argument. LEVEL (optional) shall be a scalar integer whose value is equal to one of the named constants
           INITIAL_TEAM,PARENT_TEAM,orCURRENT_TEAMfromtheintrinsicmoduleISO_FORTRAN_ENV.
        4 Result Characteristics. Scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
        5 Result Value. The result is a TEAM_TYPE value that identiﬁes the current team if LEVEL is not present,
           present with the value CURRENT_TEAM, or if the current team is the initial team. Otherwise, the result
           identiﬁes the parent team if LEVEL is present with the value PARENT_TEAM, and identiﬁes the initial team
           if LEVEL is present with the value INITIAL_TEAM.
        6 Examples.
                 PROGRAM EXAMPLE1
                    USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
                    TYPE(TEAM_TYPE) :: WORLD_TEAM, TEAM2
                    ! Define a team variable representing the initial team
                    WORLD_TEAM = GET_TEAM()
                 END PROGRAM
                 SUBROUTINE EXAMPLE2 (A)
                    USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
                    REAL A[*]
                    TYPE(TEAM_TYPE) :: NEW_TEAM, PARENT_TEAM
                    ... ! Form NEW_TEAM
                    PARENT_TEAM = GET_TEAM ()
                    CHANGE TEAM (NEW_TEAM)
                      ! Reference image 1 in parent’s team
                      A [1,TEAM=PARENT_TEAM] = 4.2
                      ! Reference image 1 in current team
                      A [1] = 9.0
                    END TEAM
                 END SUBROUTINE EXAMPLE2
              NOTE16.18
              Because the result of GET_TEAM is of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_-
              ENV, a program unit that assigns the result of a reference to GET_TEAM to a local variable will also
              need access to the deﬁnition of TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
           c
           ISO/IEC 2017 – All rights reserved                                               385
             ISO/IEC DIS 1539-1:2017 (E)
             16.9.86      HUGE(X)
          1 Description. Largest model number.
          2 Class. Inquiry function.
          3 Argument. X shall be of type integer or real. It may be a scalar or an array.
          4 Result Characteristics. Scalar of the same type and kind type parameter as X.
                                                      q                                     −p emax
          5 Result Value. The result has the value r − 1 if X is of type integer and (1 − b   )b     if X is of type real,
             where r, q, b, p, and emax are as deﬁned in 16.4 for the model representing numbers of the same type and kind
             type parameter as X.
          6 Example. HUGE (X) has the value (1−2−24)×2127 for real X whose model is as in NOTE 16.4.
             16.9.87      HYPOT(X, Y)
          1 Description. Euclidean distance function.
          2 Class. Elemental function.
          3 Arguments.
             X            shall be of type real.
             Y            shall be of type real with the same kind type parameter as X.
          4 Result Characteristics. Same as X.
          5 Result Value. The result has a value equal to a processor-dependent approximation to the Euclidean distance,
             p 2      2
               X +Y , without undue overﬂow or underﬂow.
          6 Example. HYPOT (3.0, 4.0) has the value 5.0 (approximately).
             16.9.88      IACHAR (C [, KIND])
          1 Description. ASCII code value for character.
          2 Class. Elemental function.
          3 Arguments.
             C            shall be of type character and of length one.
             KIND (optional) shall be a scalar integer constant expression.
          4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
             KIND; otherwise, the kind type parameter is that of default integer type.
          5 Result Value. If C is in the collating sequence deﬁned by the codes speciﬁed in ISO/IEC 646:1991 (International
             Reference Version), the result is the position of C in that sequence; it is nonnegative and less than or equal to
             127. The value of the result is processor dependent if C is not in the ASCII collating sequence. The results
             are consistent with the LGE, LGT, LLE, and LLT comparison functions. For example, if LLE (C, D) is true,
             IACHAR(C) <= IACHAR (D) is true where C and D are any two characters representable by the processor.
          6 Example. IACHAR (’X’) has the value 88.
             16.9.89      IALL (ARRAY, DIM [, MASK]) or IALL (ARRAY [, MASK])
          1 Description. Array reduced by IAND function.
          2 Class. Transformational function.
                                                                          c
             386                                                          ISO/IEC 2017 – All rights reserved
                                                                                                                                               ISO/IEC DIS 1539-1:2017 (E)
                 3 Arguments.
                      ARRAY                 shall be an array of type integer.
                      DIM                   shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                      MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                 4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
                      DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank n − 1 and shape [d ,
                      d , ..., d               , d            , . . . , d ] where [d , d , ..., d ] is the shape of ARRAY.                                                                                 1
                        2            DIM−1          DIM+1                n                 1     2            n
                 5 Result Value.
                      Case (i):             If ARRAY has size zero the result value is equal to NOT (INT (0, KIND (ARRAY))). Otherwise,
                                            the result of IALL (ARRAY) has a value equal to the bitwise AND of all the elements of ARRAY.
                      Case (ii):            The result of IALL (ARRAY, MASK=MASK) has a value equal to
                                            IALL (PACK (ARRAY, MASK)).
                      Case (iii):           TheresultofIALL(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequaltothatofIALL(AR-
                                            RAY [ , MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (s , s , ...,
                                                                                                                                                                                             1     2
                                            s           , s           , . . . , s ) of the result is equal to IALL (ARRAY (s , s , ..., s                                                  , :, s           ,
                                              DIM−1         DIM+1                 n                                                                          1     2             DIM−1            DIM+1
                                            . . . , s  ) [, MASK = MASK (s , s , ..., s                                   , :, s            , . . . , s )]).
                                                     n                                        1    2            DIM−1             DIM+1                n
                 6 Examples. IALL ([14, 13, 11]) has the value 8. IALL ([14, 13, 11], MASK=[.true., .false., .true]) has the value
                      10.
                      16.9.90               IAND (I, J)
                 1 Description. Bitwise AND.
                 2 Class. Elemental function.
                 3 Arguments.
                      I                     shall be of type integer or a boz-literal-constant.
                      J                     shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
                                            the same kind type parameter. I and J shall not both be boz-literal-constants.
                 4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
                 5 Result Value. If either I or J is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function INT to
                      type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
                      bit-by-bit according to the following table:
                                                                                                  I     J     IAND (I, J)
                                                                                                  1     1              1
                                                                                                  1     0              0
                                                                                                  0     1              0
                                                                                                  0     0              0
                 6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
                 7 Example. IAND (1, 3) has the value 1.
                      16.9.91               IANY (ARRAY, DIM [, MASK]) or IANY (ARRAY [, MASK])
                 1 Description. Reduce array with bitwise OR operation.
                 2 Class. Transformational function.
                       c
                      ISO/IEC 2017 – All rights reserved                                                                                                                                             387
                      ISO/IEC DIS 1539-1:2017 (E)
                 3 Arguments.
                      ARRAY                 shall be of type integer. It shall be an array.
                      DIM                   shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                      MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                 4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
                      DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank n − 1 and shape [d ,
                      d , ..., d               , d            , . . . , d ] where [d , d , ..., d ] is the shape of ARRAY.                                                                                 1
                        2            DIM−1          DIM+1                n                 1     2            n
                 5 Result Value.
                      Case (i):             The result of IANY (ARRAY) is the bitwise OR of all the elements of ARRAY. If ARRAY has size
                                            zero the result value is equal to zero.
                      Case (ii):            The result of IANY (ARRAY, MASK=MASK) has a value equal to
                                            IANY (PACK (ARRAY, MASK)).
                      Case (iii):           TheresultofIANY(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequaltothatofIANY(AR-
                                            RAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (s , s , ...,
                                                                                                                                                                                             1     2
                                            s           , s           , . . . , s ) of the result is equal to IANY (ARRAY (s , s , ..., s                                                  , :, s           ,
                                              DIM−1         DIM+1                 n                                                                           1    2             DIM−1            DIM+1
                                            . . . , s  ) [, MASK = MASK (s , s , ..., s                                   , :, s            , . . . , s )]).
                                                     n                                        1    2            DIM−1             DIM+1                n
                 6 Examples. IANY ([14, 13, 8]) has the value 15. IANY ([14, 13, 8], MASK=[.true., .false., .true]) has the value
                      14.
                      16.9.92               IBCLR (I, POS)
                 1 Description. I with bit POS replaced by zero.
                 2 Class. Elemental function.
                 3 Arguments.
                      I                     shall be of type integer.
                      POS                   shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
                 4 Result Characteristics. Same as I.
                 5 Result Value. The result has the value of the sequence of bits of I, except that bit POS is zero. The model for
                      the interpretation of an integer value as a sequence of bits is in 16.3.
                 6 Examples. IBCLR(14,1)hasthevalue12. If V has the value [1, 2, 3, 4], the value of IBCLR (POS = V, I = 31)
                      is [29, 27, 23, 15].
                      16.9.93               IBITS (I, POS, LEN)
                 1 Description. Speciﬁed sequence of bits.
                 2 Class. Elemental function.
                 3 Arguments.
                      I                     shall be of type integer.
                      POS                   shall be of type integer. It shall be nonnegative and POS + LEN shall be less than or equal to
                                            BIT_SIZE (I).
                      LEN                   shall be of type integer and nonnegative.
                 4 Result Characteristics. Same as I.
                 5 Result Value. The result has the value of the sequence of LEN bits in I beginning at bit POS, right-adjusted
                      and with all other bits zero. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
                                                                                                                                c
                      388                                                                                                      ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        6 Example. IBITS (14, 1, 3) has the value 7.
           16.9.94   IBSET (I, POS)
        1 Description. I with bit POS replaced by one.
        2 Class. Elemental function.
        3 Arguments.
           I         shall be of type integer.
           POS       shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
        4 Result Characteristics. Same as I.
        5 Result Value. The result has the value of the sequence of bits of I, except that bit POS is one. The model for
           the interpretation of an integer value as a sequence of bits is in 16.3.
        6 Examples. IBSET (12, 1) has the value 14. If V has the value [1, 2, 3, 4], the value of IBSET (POS=V, I=0)
           is [2, 4, 8, 16].
           16.9.95   ICHAR (C [, KIND])
        1 Description. Code value for character.
        2 Class. Elemental function.
        3 Arguments.
           C         shall be of type character and of length one. Its value shall be that of a character capable of
                     representation in the processor.
           KIND (optional) shall be a scalar integer constant expression.
        4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
           KIND; otherwise, the kind type parameter is that of default integer type.
        5 Result Value. The result is the position of C in the processor collating sequence associated with the kind type
           parameter of C; it is nonnegative and less than n, where n is the number of characters in the collating sequence.
           Thekindtypeparameteroftheresult shall specify an integer kind that is capable of representing n. For any char-
           acters C and D capable of representation in the processor, C <= D is true if and only if ICHAR (C) <= ICHAR (D)
           is true and C == D is true if and only if ICHAR (C) == ICHAR (D) is true.
        6 Example. ICHAR(’X’)hasthevalue88onaprocessorusingtheASCIIcollatingsequencefordefaultcharacters.
           16.9.96   IEOR (I, J)
        1 Description. Bitwise exclusive OR.
        2 Class. Elemental function.
        3 Arguments.
           I         shall be of type integer or a boz-literal-constant.
           J         shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
                     the same kind type parameter. I and J shall not both be boz-literal-constants.
        4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
        5 Result Value. If either I or J is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function INT to
           type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
           c
           ISO/IEC 2017 – All rights reserved                                               389
                 ISO/IEC DIS 1539-1:2017 (E)
                 bit-by-bit according to the following table:
                                                                         I    J   IEOR (I, J)
                                                                         1    1          0
                                                                         1    0          1
                                                                         0    1          1
                                                                         0    0          0
             6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
             7 Example. IEOR (1, 3) has the value 2.
                 16.9.97         IMAGE_INDEX (COARRAY, SUB) or (COARRAY, SUB, TEAM) or
                                 (COARRAY, SUB, TEAM_NUMBER)
             1 Description. Image index from cosubscripts.
             2 Class. Inquiry function.
             3 Arguments.
                 COARRAY shall be a coarray of any type. If its designator has more than one part-ref, the rightmost part-ref
                                 shall have nonzero corank. If TEAM_NUMBER appears and the current team is not the initial
                                 team, it shall be established in an ancestor of the current team. Otherwise, if TEAM appears, it
                                 shall be established in that team. Otherwise, it shall be established in the current team.
                 SUB             shall be a rank-one integer array of size equal to the corank of COARRAY.
                 TEAM            shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
                                 value that identiﬁes the current or an ancestor team.
                 TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a team whose parent is the
                                 same as that of the current team.
             4 Result Characteristics. Default integer scalar.
             5 Result Value. If the value of SUB is a valid sequence of cosubscripts for COARRAY in the team speciﬁed by
                 TEAMorTEAM_NUMBER,orthecurrent team if neither TEAM nor TEAM_NUMBER appears, the result
                 is the index of the corresponding image in that team. Otherwise, the result is zero.
             6 Examples. If A and B are declared as A [0:*] and B (10, 20) [10, 0:9, 0:*] respectively, IMAGE_INDEX (A, [0])
                 has the value 1 and IMAGE_INDEX (B, [3, 1, 2]) has the value 213 (on any image).
                 16.9.98         IMAGE_STATUS (IMAGE [, TEAM])
             1 Description. Image execution state.
             2 Class. Elemental function.
             3 Arguments.
                 IMAGE           shall be of type integer. Its value shall be positive and less than or equal to the number of images
                                 in the speciﬁed team.
                 TEAM(optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
                                 value shall represent the current or an ancestor team. If TEAM is absent, the team speciﬁed is the
                                 current team.
             4 Result Characteristics. Default integer.
                                                                                                c
                 390                                                                           ISO/IEC 2017 – All rights reserved
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
           5 Result Value. The result value is STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
              if the speciﬁed image has failed, STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
              if that image has initiated normal termination, and zero otherwise.
           6 Example. If image 3 of the current team has failed, IMAGE_STATUS (3) has the value STAT_FAILED_-
              IMAGE.
              16.9.99       INDEX (STRING, SUBSTRING [, BACK, KIND])
           1 Description. Character string search.
           2 Class. Elemental function.
           3 Arguments.
              STRING         shall be of type character.
              SUBSTRING shall be of type character with the same kind type parameter as STRING.
              BACK(optional) shall be of type logical.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise the kind type parameter is that of default integer type.
           5 Result Value.
              Case (i):      If STRING % LEN < SUBSTRING % LEN, the result has the value zero.
              Case (ii):     Otherwise, if there is an integer I in the range 1 ≤ I ≤ STRING % LEN − SUBSTRING % LEN
                             +1, such that STRING(I : I + SUBSTRING % LEN − 1) is equal to SUBSTRING, the result has
                             the value of the smallest such I if BACK is absent or present with the value false, and the greatest
                             such I if BACK is present with the value true.
              Case (iii):    Otherwise, the result has the value zero.
           6 Examples. INDEX (’FORTRAN’, ’R’) has the value 3.
              INDEX (’FORTRAN’, ’R’, BACK = .TRUE.) has the value 5.
              16.9.100 INT (A [, KIND])
           1 Description. Conversion to integer type.
           2 Class. Elemental function.
           3 Arguments.
              A              shall be of type integer, real, or complex, or a boz-literal-constant.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type.
           5 Result Value.
              Case (i):      If A is of type integer, INT (A) = A.
              Case (ii):     If A is of type real, there are two cases: if |A| < 1, INT (A) has the value 0; if |A| ≥ 1, INT (A)
                             is the integer whose magnitude is the largest integer that does not exceed the magnitude of A and
                             whose sign is the same as the sign of A.
              Case (iii):    If A is of type complex, INT (A) = INT (REAL (A, KIND (A))).
              Case (iv):     If A is a boz-literal-constant, the value of the result is the value whose bit sequence according to the
                             model in 16.3 is the same as that of A as modiﬁed by padding or truncation according to 16.3.3.
                             The interpretation of a bit sequence whose most signiﬁcant bit is 1 is processor dependent.
               c
              ISO/IEC 2017 – All rights reserved                                                                              391
             ISO/IEC DIS 1539-1:2017 (E)
          6 Example. INT (−3.7) has the value −3.
             16.9.101 IOR (I, J)
          1 Description. Bitwise inclusive OR.
          2 Class. Elemental function.
          3 Arguments.
             I            shall be of type integer or a boz-literal-constant.
             J            shall be of type integer or a boz-literal-constant. If both I and J are of type integer, they shall have
                          the same kind type parameter. I and J shall not both be boz-literal-constants.
          4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
          5 Result Value. If either I or J is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function INT to
             type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
             bit-by-bit according to the following table:
                                                          I   J  IOR (I, J)
                                                          1   1       1
                                                          1   0       1
                                                          0   1       1
                                                          0   0       0
          6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
          7 Example. IOR (5, 3) has the value 7.
             16.9.102 IPARITY (ARRAY, DIM [, MASK]) or IPARITY (ARRAY [, MASK])
          1 Description. Array reduced by IEOR function.
          2 Class. Transformational function.
          3 Arguments.
             ARRAY        shall be of type integer. It shall be an array.
             DIM          shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
             MASK(optional) shall be of type logical and shall be conformable with ARRAY.
          4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
             DIMdoesnotappear; otherwise, the result has rank n−1 and shape [d , d , ..., d      , d     , . . . , d ] where
             [d , d , ..., d ] is the shape of ARRAY.                           1   2      DIM−1    DIM+1       n
               1  2       n
          5 Result Value.
             Case (i):    The result of IPARITY (ARRAY) has a value equal to the bitwise exclusive OR of all the elements
                          of ARRAY. If ARRAY has size zero the result has the value zero.
             Case (ii):   The result of IPARITY (ARRAY, MASK=MASK) has a value equal to that of IPARITY (PACK
                          (ARRAY, MASK)).
             Case (iii):  The result of IPARITY (ARRAY, DIM=DIM [, MASK=MASK]) has a value equal to that of
                          IPARITY (ARRAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element
                          (s , s , ..., s    , s      , ..., s ) of the result is equal to IPARITY (ARRAY (s , s , ...,
                            1   2       DIM−1   DIM+1        n                                                1   2
                          s      , :, s    , . . . , s ) [, MASK = MASK (s , s , ..., s   , :, s    , . . . , s )]).
                           DIM−1     DIM+1        n                      1  2       DIM−1     DIM+1       n
                                                                           c
             392                                                          ISO/IEC 2017 – All rights reserved
                                                     ISO/IEC DIS 1539-1:2017 (E)
       6 Examples. IPARITY ([14, 13, 8]) has the value 11. IPARITY ([14, 13, 8], MASK=[.true., .false., .true]) has the
        value 6.
        16.9.103 ISHFT (I, SHIFT)
       1 Description. Logical shift.
       2 Class. Elemental function.
       3 Arguments.
        I        shall be of type integer.
        SHIFT    shall be of type integer. The absolute value of SHIFT shall be less than or equal to BIT_SIZE (I).
       4 Result Characteristics. Same as I.
       5 Result Value. The result has the value obtained by shifting the bits of I by SHIFT positions. If SHIFT is
        positive, the shift is to the left; if SHIFT is negative, the shift is to the right; if SHIFT is zero, no shift is
        performed. Bits shifted out from the left or from the right, as appropriate, are lost. Zeros are shifted in from the
        opposite end. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
       6 Example. ISHFT (3, 1) has the value 6.
        16.9.104 ISHFTC (I, SHIFT [, SIZE])
       1 Description. Circular shift of the rightmost bits.
       2 Class. Elemental function.
       3 Arguments.
        I        shall be of type integer.
        SHIFT    shall be of type integer. The absolute value of SHIFT shall be less than or equal to SIZE.
        SIZE (optional) shall be of type integer. The value of SIZE shall be positive and shall not exceed BIT_SIZE (I).
                 If SIZE is absent, it is as if it were present with the value of BIT_SIZE (I).
       4 Result Characteristics. Same as I.
       5 Result Value. The result has the value obtained by shifting the SIZE rightmost bits of I circularly by SHIFT
        positions. If SHIFT is positive, the shift is to the left; if SHIFT is negative, the shift is to the right; and if SHIFT
        is zero, no shift is performed. No bits are lost. The unshifted bits are unaltered. The model for the interpretation
        of an integer value as a sequence of bits is in 16.3.
       6 Example. ISHFTC (3, 2, 3) has the value 5.
        16.9.105 IS_CONTIGUOUS (ARRAY)
       1 Description. Array contiguity test (8.5.7).
       2 Class. Inquiry function.
       3 Argument. ARRAY may be of any type. It shall be assumed-rank or an array. If it is a pointer it shall be
        associated.
       4 Result Characteristics. Default logical scalar.
       5 Result Value. The result has the value true if ARRAY has rank zero or is contiguous, and false otherwise.
       6 Example. After the pointer assignment AP => TARGET (1:10:2), IS_CONTIGUOUS (AP) has the value
        false.
         c
        ISO/IEC 2017 – All rights reserved                              393
         ISO/IEC DIS 1539-1:2017 (E)
         16.9.106 IS_IOSTAT_END (I)
       1 Description. IOSTAT value test for end of ﬁle.
       2 Class. Elemental function.
       3 Argument. I shall be of type integer.
       4 Result Characteristics. Default logical.
       5 Result Value. The result has the value true if and only if I is a value for the stat-variable in an IOSTAT=
         speciﬁer (12.11.5) that would indicate an end-of-ﬁle condition.
         16.9.107 IS_IOSTAT_EOR (I)
       1 Description. IOSTAT value test for end of record.
       2 Class. Elemental function.
       3 Argument. I shall be of type integer.
       4 Result Characteristics. Default logical.
       5 Result Value. The result has the value true if and only if I is a value for the stat-variable in an IOSTAT=
         speciﬁer (12.11.5) that would indicate an end-of-record condition.
         16.9.108 KIND (X)
       1 Description. Value of the kind type parameter of X.
       2 Class. Inquiry function.
       3 Argument. X may be of any intrinsic type. It may be a scalar or an array.
       4 Result Characteristics. Default integer scalar.
       5 Result Value. The result has a value equal to the kind type parameter value of X.
       6 Example. KIND (0.0) has the kind type parameter value of default real.
         16.9.109 LBOUND (ARRAY [, DIM, KIND])
       1 Description. Lower bound(s).
       2 Class. Inquiry function.
       3 Arguments.
         ARRAY    shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
                  that is not associated.
         DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                  The corresponding actual argument shall not be an optional dummy argument, a disassociated
                  pointer, or an unallocated allocatable.
         KIND (optional) shall be a scalar integer constant expression.
       4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
         KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
         otherwise, the result is an array of rank one and size n, where n is the rank of ARRAY.
       5 Result Value.
                                                   c
         394                                      ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              Case (i):     If DIM is present, ARRAY is a whole array, and either ARRAY is an assumed-size array of rank
                            DIM or dimension DIM of ARRAY has nonzero extent, the result has a value equal to the lower
                            bound for subscript DIM of ARRAY. Otherwise, if DIM is present, the result value is 1.
                                                                     th
              Case (ii):    LBOUND(ARRAY)hasavaluewhosei elementisequaltoLBOUND(ARRAY,i),fori = 1, 2,
                            . . . , n, where n is the rank of ARRAY. LBOUND (ARRAY, KIND=KIND) has a value whose ith
                            element is equal to LBOUND (ARRAY, i, KIND), for i = 1, 2, ..., n, where n is the rank of
                            ARRAY.
                   NOTE16.19
                   If ARRAYisassumed-rankandhasrankzero,DIMcannotbepresentsinceitcannotsatisfytherequirement
                   1 ≤ DIM ≤ 0.
           6 Examples. If A is declared by the statement
           7       REAL A (2:3, 7:10)
           8 then LBOUND (A) is [2, 7] and LBOUND (A, DIM=2) is 7.
              16.9.110 LCOBOUND (COARRAY [, DIM, KIND])
           1 Description. Lower cobound(s) of a coarray.
           2 Class. Inquiry function.
           3 Arguments.
              COARRAY shall be a coarray and may be of any type. It may be a scalar or an array. If it is allocatable it
                            shall be allocated. If its designator has more than one part-ref, the rightmost part-ref shall have
                            nonzero corank.
              DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the corank
                            of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
                            disassociated pointer, or an unallocated allocatable.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
              otherwise, the result is an array of rank one and size n, where n is the corank of COARRAY.
           5 Result Value.
              Case (i):     If DIM is present, the result has a value equal to the lower cobound for codimension DIM of
                            COARRAY.
              Case (ii):    If DIM is absent, the result has a value whose ith element is equal to the lower cobound for codi-
                            mension i of COARRAY, for i = 1, 2,..., n, where n is the corank of COARRAY.
           6 Examples. If A is allocated by the statement ALLOCATE (A [2:3, 7:*]) then LCOBOUND (A) is [2, 7] and
              LCOBOUND(A,DIM=2)is7.
              16.9.111 LEADZ (I)
           1 Description. Number of leading zero bits.
           2 Class. Elemental function.
           3 Argument. I shall be of type integer.
           4 Result Characteristics. Default integer.
               c
              ISO/IEC 2017 – All rights reserved                                                                           395
         ISO/IEC DIS 1539-1:2017 (E)
       5 Result Value. If all of the bits of I are zero, the result has the value BIT_SIZE (I). Otherwise, the result has
         the value BIT_SIZE (I)−1−k, where k is the position of the leftmost 1 bit in I. The model for the interpretation
         of an integer value as a sequence of bits is in 16.3.
       6 Examples. LEADZ (1) has the value 31 if BIT_SIZE (1) has the value 32.
         16.9.112 LEN (STRING [, KIND])
       1 Description. Length of a character entity.
       2 Class. Inquiry function.
       3 Arguments.
         STRING    shall be of type character. If it is an unallocated allocatable variable or a pointer that is not
                   associated, its length type parameter shall not be deferred.
         KIND (optional) shall be a scalar integer constant expression.
       4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that speciﬁed by the
         value of KIND; otherwise the kind type parameter is that of default integer type.
       5 Result Value. The result has a value equal to the number of characters in STRING if it is scalar or in an
         element of STRING if it is an array.
       6 Example. If C is declared by the statement
       7     CHARACTER (11) C (100)
       8 LEN (C) has the value 11.
         16.9.113 LEN_TRIM (STRING [, KIND])
       1 Description. Length without trailing blanks.
       2 Class. Elemental function.
       3 Arguments.
         STRING    shall be of type character.
         KIND (optional) shall be a scalar integer constant expression.
       4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
         KIND; otherwise the kind type parameter is that of default integer type.
       5 Result Value. The result has a value equal to the number of characters remaining after any trailing blanks in
         STRING are removed. If the argument contains no nonblank characters, the result is zero.
       6 Examples. LEN_TRIM (’ A B ’) has the value 4 and LEN_TRIM (’ ’) has the value 0.
         16.9.114 LGE (STRING_A, STRING_B)
       1 Description. ASCII greater than or equal.
       2 Class. Elemental function.
       3 Arguments.
         STRING_A shall be default character or ASCII character.
         STRING_B shall be of type character with the same kind type parameter as STRING_A.
       4 Result Characteristics. Default logical.
                                                     c
         396                                         ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
       5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
         on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
         character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A follows
         STRING_Bin the ASCII collating sequence; otherwise, the result is false.
            NOTE16.20
            The result is true if both STRING_A and STRING_B are of zero length.
       6 Example. LGE (’ONE’, ’TWO’) has the value false.
         16.9.115 LGT (STRING_A, STRING_B)
       1 Description. ASCII greater than.
       2 Class. Elemental function.
       3 Arguments.
         STRING_A shall be default character or ASCII character.
         STRING_B shall be of type character with the same kind type parameter as STRING_A.
       4 Result Characteristics. Default logical.
       5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
         on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
         character set, the result is processor dependent. The result is true if STRING_A follows STRING_B in the
         ASCII collating sequence; otherwise, the result is false.
            NOTE16.21
            The result is false if both STRING_A and STRING_B are of zero length.
       6 Example. LGT (’ONE’, ’TWO’) has the value false.
         16.9.116 LLE (STRING_A, STRING_B)
       1 Description. ASCII less than or equal.
       2 Class. Elemental function.
       3 Arguments.
         STRING_A shall be default character or ASCII character.
         STRING_B shall be of type character with the same kind type parameter as STRING_A.
       4 Result Characteristics. Default logical.
       5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
         on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
         character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A
         precedes STRING_B in the ASCII collating sequence; otherwise, the result is false.
            NOTE16.22
            The result is true if both STRING_A and STRING_B are of zero length.
       6 Example. LLE (’ONE’, ’TWO’) has the value true.
         c
         ISO/IEC 2017 – All rights reserved                                 397
         ISO/IEC DIS 1539-1:2017 (E)
         16.9.117 LLT (STRING_A, STRING_B)
       1 Description. ASCII less than.
       2 Class. Elemental function.
       3 Arguments.
         STRING_A shall be default character or ASCII character.
         STRING_B shall be of type character with the same kind type parameter as STRING_A.
       4 Result Characteristics. Default logical.
       5 Result Value. If the strings are of unequal length, the comparison is made as if the shorter string were extended
         on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
         character set, the result is processor dependent. The result is true if STRING_A precedes STRING_B in the
         ASCII collating sequence; otherwise, the result is false.
            NOTE16.23
            The result is false if both STRING_A and STRING_B are of zero length.
       6 Example. LLT (’ONE’, ’TWO’) has the value true.
         16.9.118 LOG (X)
       1 Description. Natural logarithm.
       2 Class. Elemental function.
       3 Argument. X shall be of type real or complex. If X is real, its value shall be greater than zero. If X is complex,
         its value shall not be zero.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to logeX. A result of type
         complex is the principal value with imaginary part ω in the range −π ≤ ω ≤ π. If the real part of X is less
         than zero and the imaginary part of X is zero, then the imaginary part of the result is approximately π if the
         imaginary part of X is positive real zero or the processor does not distinguish between positive and negative real
         zero, and approximately −π if the imaginary part of X is negative real zero.
       6 Example. LOG (10.0) has the value 2.3025851 (approximately).
         16.9.119 LOG_GAMMA (X)
       1 Description. Logarithm of the absolute value of the gamma function.
       2 Class. Elemental function.
       3 Argument. X shall be of type real. Its value shall not be a negative integer or zero.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to the natural logarithm
         of the absolute value of the gamma function of X.
       6 Example. LOG_GAMMA(3.0) has the value 0.693 (approximately).
                                                  c
         398                                     ISO/IEC 2017 – All rights reserved
                                           ISO/IEC DIS 1539-1:2017 (E)
       16.9.120 LOG10 (X)
      1 Description. Common logarithm.
      2 Class. Elemental function.
      3 Argument. X shall be of type real. The value of X shall be greater than zero.
      4 Result Characteristics. Same as X.
      5 Result Value. The result has a value equal to a processor-dependent approximation to log10X.
      6 Example. LOG10 (10.0) has the value 1.0 (approximately).
       16.9.121 LOGICAL (L [, KIND])
      1 Description. Conversion between kinds of logical.
      2 Class. Elemental function.
      3 Arguments.
       L      shall be of type logical.
       KIND (optional) shall be a scalar integer constant expression.
      4 Result Characteristics. Logical. If KIND is present, the kind type parameter is that speciﬁed by the value of
       KIND; otherwise, the kind type parameter is that of default logical.
      5 Result Value. The value is that of L.
      6 Example. LOGICAL (L .OR. .NOT. L) has the value true and is default logical, regardless of the kind type
       parameter of the logical variable L.
       16.9.122 MASKL (I [, KIND])
      1 Description. Left justiﬁed mask.
      2 Class. Elemental function.
      3 Arguments.
       I      shall be of type integer. It shall be nonnegative and less than or equal to the number of bits z of
              the model integer deﬁned for bit manipulation contexts in 16.3 for the kind of the result.
       KIND (optional) shall be a scalar integer constant expression.
      4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
       KIND; otherwise, the kind type parameter is that of default integer type.
      5 Result Value. The result value has its leftmost I bits set to 1 and the remaining bits set to 0. The model for
       the interpretation of an integer value as a sequence of bits is in 16.3.
      6 Example. MASKL (3) has the value SHIFTL (7, BIT_SIZE (0) − 3).
       16.9.123 MASKR (I [, KIND])
      1 Description. Right justiﬁed mask.
      2 Class. Elemental function.
       c
       ISO/IEC 2017 – All rights reserved                  399
              ISO/IEC DIS 1539-1:2017 (E)
           3 Arguments.
              I             shall be of type integer. It shall be nonnegative and less than or equal to the number of bits z of
                            the model integer deﬁned for bit manipulation contexts in 16.3 for the kind of the result.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type.
           5 Result Value. The result value has its rightmost I bits set to 1 and the remaining bits set to 0. The model for
              the interpretation of an integer value as a sequence of bits is in 16.3.
           6 Example. MASKR (3) has the value 7.
              16.9.124 MATMUL (MATRIX_A, MATRIX_B)
           1 Description. Matrix multiplication.
           2 Class. Transformational function.
           3 Arguments.
              MATRIX_A shall be a rank-one or rank-two array of numeric type or logical type.
              MATRIX_B shall be of numeric type if MATRIX_A is of numeric type and of logical type if MATRIX_A is of
                            logical type. It shall be an array of rank one or two. MATRIX_A and MATRIX_B shall not both
                            have rank one. The size of the ﬁrst (or only) dimension of MATRIX_B shall equal the size of the
                            last (or only) dimension of MATRIX_A.
           4 Result Characteristics. If the arguments are of numeric type, the type and kind type parameter of the result
              are determined by the types of the arguments as speciﬁed in 10.1.9.3 for the * operator. If the arguments are of
              type logical, the result is of type logical with the kind type parameter of the arguments as speciﬁed in 10.1.9.3
              for the .AND. operator. The shape of the result depends on the shapes of the arguments as follows:
              Case (i):     If MATRIX_A has shape [n,m] and MATRIX_B has shape [m,k], the result has shape [n,k].
              Case (ii):    If MATRIX_A has shape [m] and MATRIX_B has shape [m,k], the result has shape [k].
              Case (iii):   If MATRIX_A has shape [n,m] and MATRIX_B has shape [m], the result has shape [n].
           5 Result Value.
              Case (i):     Element (i,j) of the result has the value SUM (MATRIX_A (i, :) * MATRIX_B (:, j)) if the
                            arguments are of numeric type and has the value ANY (MATRIX_A (i, :) .AND. MATRIX_B (:,
                            j)) if the arguments are of logical type.
              Case (ii):    Element(j)oftheresult has the value SUM (MATRIX_A(:) *MATRIX_B(:, j))ifthearguments
                            are of numeric type and has the value ANY (MATRIX_A (:) .AND. MATRIX_B (:, j)) if the
                            arguments are of logical type.
              Case (iii):   Element (i) of the result has the value SUM (MATRIX_A (i, :) * MATRIX_B (:)) if the arguments
                            are of numeric type and has the value ANY (MATRIX_A (i, :) .AND. MATRIX_B (:)) if the
                            arguments are of logical type.
                                                            1 2 3           1 2 
                                                                              2 3 
           6 Examples. Let A and B be the matrices           2   3  4    and           ; let X and Y be the vectors [1, 2] and
                                                                                3   4
              [1, 2, 3].
                                                                                                               14   20 
              Case (i):     The result of MATMUL (A, B) is the matrix-matrix product AB with the value          20   29 .
              Case (ii):    The result of MATMUL (X, A) is the vector-matrix product XA with the value [5, 8, 11].
              Case (iii):   The result of MATMUL (A, Y) is the matrix-vector product AY with the value [14, 20].
                                                                                c
              400                                                              ISO/IEC 2017 – All rights reserved
                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
               16.9.125 MAX (A1, A2 [, A3, ...])
            1 Description. Maximum value.
            2 Class. Elemental function.
            3 Arguments. Thearguments shall all have the same type which shall be integer, real, or character and they shall
               all have the same kind type parameter.
            4 Result Characteristics. Thetypeandkindtypeparameteroftheresultarethesameasthoseofthearguments.
               For arguments of character type, the length of the result is the length of the longest argument.
            5 Result Value. The value of the result is that of the largest argument. For arguments of character type, the
               result is the value that would be selected by application of intrinsic relational operators; that is, the collating
               sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
               shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
               argument.
            6 Examples. MAX (−9.0, 7.0, 2.0) has the value 7.0, MAX (’Z’, ’BB’) has the value ’Z ’, and MAX ([’A’, ’Z’],
               [’BB’, ’Y ’]) has the value [’BB’, ’Z ’].
               16.9.126 MAXEXPONENT (X)
            1 Description. Maximum exponent of a real model.
            2 Class. Inquiry function.
            3 Argument. X shall be of type real. It may be a scalar or an array.
            4 Result Characteristics. Default integer scalar.
            5 Result Value. The result has the value emax, as deﬁned in 16.4 for the model representing numbers of the same
               type and kind type parameter as X.
            6 Example. MAXEXPONENT (X) has the value 127 for real X whose model is as in NOTE 16.4.
               16.9.127 MAXLOC (ARRAY, DIM [, MASK, KIND, BACK]) or
                              MAXLOC(ARRAY[, MASK, KIND, BACK])
            1 Description. Location(s) of maximum value.
            2 Class. Transformational function.
            3 Arguments.
               ARRAY          shall be an array of type integer, real, or character.
               DIM            shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
               MASK(optional) shall be of type logical and shall be conformable with ARRAY.
               KIND (optional) shall be a scalar integer constant expression.
               BACK(optional) shall be a logical scalar.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
               KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
               an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
               [d , d , ..., d       , d       , . . . , d ], where [d , d , ..., d ] is the shape of ARRAY.
                 1   2        DIM−1     DIM+1          n            1   2        n
            5 Result Value.
               Case (i):      If DIM does not appear and MASK is absent, the result is a rank-one array whose element values
                              are the values of the subscripts of an element of ARRAY whose value equals the maximum value of
                c
               ISO/IEC 2017 – All rights reserved                                                                                     401
                    ISO/IEC DIS 1539-1:2017 (E)
                                         all of the elements of ARRAY. The ith subscript returned lies in the range 1 to e , where e is the
                                                                                                                                                                   i              i
                                         extent of the ith dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
                    Case (ii):           If DIM does not appear and MASK is present, the result is a rank-one array whose element values
                                         are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
                                                                                                                                                              th
                                         whose value equals the maximum value of all such elements of ARRAY. The i                                               subscript returned
                                                                                                                          th
                                         lies in the range 1 to ei, where ei is the extent of the i                           dimension of ARRAY. If ARRAY has size
                                         zero or every element of MASK has the value false, all elements of the result are zero.
                    Case (iii):          If ARRAYhasrankoneandDIMisspeciﬁed,theresulthasavalueequaltothatoftheﬁrstelement
                                         of MAXLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
                                         is speciﬁed, the value of element (s , s , ..., s                                , s           , . . . , s   ) of the result is equal to
                                                                                               1     2           DIM−1        DIM+1                n
                                                  MAXLOC(ARRAY(s ,s , ..., s                                   , :, s          , . . . , s ),
                                                                    DIM=1 1 2                         DIM−1           DIM+1              n
                                                                    [, MASK = MASK (s , s , ..., s                             , :, s          , . . . , s ),
                                                                     KIND = KIND,                    1    2           DIM−1           DIM+1              n
                                                                     BACK=BACK]).
                6 If only one element has the maximum value, that element’s subscripts are returned. Otherwise, if more than
                    one element has the maximum value and BACK is absent or present with the value false, the element whose
                    subscripts are returned is the ﬁrst such element, taken in array element order. If BACK is present with the value
                    true, the element whose subscripts are returned is the last such element, taken in array element order.
                7 If ARRAY has type character, the result is the value that would be selected by application of intrinsic relational
                    operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
                8 Examples.
                    Case (i):            The value of MAXLOC ([2, 6, 4, 6]) is [2] and the value of MAXLOC ([2, 6, 4, 6], BACK=.TRUE.)
                                         is [4].                                                  
                                                                     0 −5            8      −3 
                    Case (ii):           If A has the value             3      4     −1       2      , MAXLOC(A,MASK=A<6)hasthevalue[3,2]. This
                                                                        1      5      6      −4
                                         is independent of the declared lower bounds for A.                                                                             
                    Case (iii):          The value of MAXLOC ([5, −9, 3], DIM = 1) is 1. If B has the value                                              1    3    −9 , MAXLOC
                                                                                                                                                         2    2     6
                                         (B, DIM = 1) is [2, 1, 2] and MAXLOC (B, DIM = 2) is [2, 3]. This is independent of the declared
                                         lower bounds for B.
                    16.9.128 MAXVAL (ARRAY, DIM [, MASK]) or MAXVAL (ARRAY [, MASK])
                1 Description. Maximum value(s) of array.
                2 Class. Transformational function.
                3 Arguments.
                    ARRAY                shall be an array of type integer, real, or character.
                    DIM                  shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                    MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
                    does not appear; otherwise, the result has rank n − 1 and shape [d , d , ..., d                                                    , d           , . . . , d ] where
                    [d , d , ..., d ] is the shape of ARRAY.                                                                1     2           DIM−1         DIM+1               n
                       1     2           n
                5 Result Value.
                    Case (i):            The result of MAXVAL (ARRAY) has a value equal to the maximum value of all the elements of
                                         ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
                                         result has the value of the negative number of the largest magnitude supported by the processor
                                         for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
                                                                                                                      c
                    402                                                                                              ISO/IEC 2017 – All rights reserved
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
                             character, the result has the value of a string of characters of length LEN (ARRAY), with each
                             character equal to CHAR (0, KIND (ARRAY)).
              Case (ii):     The result of MAXVAL (ARRAY, MASK = MASK) has a value equal to that of MAXVAL (PACK
                             (ARRAY, MASK)).
              Case (iii):    The result of MAXVAL (ARRAY, DIM = DIM [,MASK = MASK]) has a value equal to that of
                             MAXVAL(ARRAY[,MASK=MASK])ifARRAYhasrankone. Otherwise, the value of element
                             (s , s , ..., s     , s      , . . . , s ) of the result is equal to
                               1  2        DIM−1    DIM+1        n
                                   MAXVAL(ARRAY(s ,s , ..., s                , :, s     , . . . , s )
                                                           1   2       DIM−1      DIM+1         n
                                   [, MASK = MASK (s , s , ..., s           , :, s     , . . . , s ) ] ).
                                                          1   2       DIM−1      DIM+1         n
           6 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
              operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
           7 Examples.
              Case (i):      The value of MAXVAL ([1, 2, 3]) is 3.
              Case (ii):     MAXVAL(C,MASK=C<0.0)isthemaximumofthe negative elements of C.
                                                1 3 5 
              Case (iii):    If B is the array   2   7  6   , MAXVAL (B, DIM=1) is [2, 7, 6] and MAXVAL (B, DIM=2) is
                             [5, 7].
              16.9.129 MERGE (TSOURCE, FSOURCE, MASK)
           1 Description. Expression value selection.
           2 Class. Elemental function.
           3 Arguments.
              TSOURCE maybeofanytype.
              FSOURCE shall be of the same type and type parameters as TSOURCE.
              MASK           shall be of type logical.
           4 Result Characteristics. Same type and type parameters as TSOURCE. Because TSOURCE and FSOURCE
              are required to have the same type and type parameters (for both the declared and dynamic types), the result is
              polymorphic if and only if both TSOURCE and FSOURCE are polymorphic.
           5 Result Value. The result is TSOURCE if MASK is true and FSOURCE otherwise.
                                                          1 6 5                                   0 3 2 
           6 Examples. If TSOURCE is the array              2  4   6   , FSOURCE is the array        7   4  8    and MASK is the
                      T . T 
              array     .  .  T , where “T” represents true and “.” represents false, then MERGE (TSOURCE, FSOURCE,
                           1 3 5 
              MASK)is       7   4  6   . The value of MERGE (1.0, 0.0, K > 0) is 1.0 for K = 5 and 0.0 for K = −2.
              16.9.130 MERGE_BITS (I, J, MASK)
           1 Description. Merge of bits under mask.
           2 Class. Elemental function.
           3 Arguments.
              I              shall be of type integer or a boz-literal-constant.
              J              shall be of type integer or a boz-literal-constant. If both I and J are of type integer they shall have
                             the same kind type parameter. I and J shall not both be boz-literal-constants.
               c
              ISO/IEC 2017 – All rights reserved                                                                              403
             ISO/IEC DIS 1539-1:2017 (E)
             MASK         shall be of type integer or a boz-literal-constant. If MASK is of type integer, it shall have the same
                          kind type parameter as each other argument of type integer.
          4 Result Characteristics. Same as I if I is of type integer; otherwise, same as J.
          5 Result Value. If any argument is a boz-literal-constant, it is ﬁrst converted as if by the intrinsic function
             INT to the type and kind type parameter of the result. The result has the value of IOR (IAND (I, MASK),
             IAND (J, NOT (MASK))).
          6 Example. MERGE_BITS (13, 18, 22) has the value 4.
             16.9.131 MIN (A1, A2 [, A3, ...])
          1 Description. Minimum value.
          2 Class. Elemental function.
          3 Arguments. The arguments shall all be of the same type which shall be integer, real, or character and they
             shall all have the same kind type parameter.
          4 Result Characteristics. Thetypeandkindtypeparameteroftheresultarethesameasthoseofthearguments.
             For arguments of character type, the length of the result is the length of the longest argument.
          5 Result Value. The value of the result is that of the smallest argument. For arguments of character type, the
             result is the value that would be selected by application of intrinsic relational operators; that is, the collating
             sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
             shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
             argument.
          6 Examples. MIN (−9.0, 7.0, 2.0) has the value −9.0, MIN (’A’, ’YY’) has the value ’A ’, and
             MIN([’Z’, ’A’], [’YY’, ’B ’]) has the value [’YY’, ’A ’].
             16.9.132 MINEXPONENT (X)
          1 Description. Minimum exponent of a real model.
          2 Class. Inquiry function.
          3 Argument. X shall be of type real. It may be a scalar or an array.
          4 Result Characteristics. Default integer scalar.
          5 Result Value. The result has the value e   , as deﬁned in 16.4 for the model representing numbers of the same
             type and kind type parameter as X.      min
          6 Example. MINEXPONENT (X) has the value −126 for real X whose model is as in NOTE 16.4.
             16.9.133 MINLOC (ARRAY, DIM [, MASK, KIND, BACK]) or
                         MINLOC (ARRAY [, MASK, KIND, BACK])
          1 Description. Location(s) of minimum value.
          2 Class. Transformational function.
          3 Arguments.
             ARRAY        shall be an array of type integer, real, or character.
             DIM          shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
             MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                                                                          c
             404                                                         ISO/IEC 2017 – All rights reserved
                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
               KIND (optional) shall be a scalar integer constant expression.
               BACK(optional) shall be a logical scalar.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
               KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
               an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n − 1 and shape
               [d , d , ..., d       , d       , . . . , d ], where [d , d , ..., d ] is the shape of ARRAY.
                 1   2        DIM−1     DIM+1          n            1   2        n
            5 Result Value.
               Case (i):      If DIM does not appear and MASK is absent the result is a rank-one array whose element values
                              are the values of the subscripts of an element of ARRAY whose value equals the minimum value
                              of all the elements of ARRAY. The ith subscript returned lies in the range 1 to e , where e is the
                                                                                                                         i          i
                              extent of the ith dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
               Case (ii):     If DIM does not appear and MASK is present, the result is a rank-one array whose element values
                              are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
                                                                                                                     th
                              whose value equals the minimum value of all such elements of ARRAY. The i                 subscript returned
                                                                                           th
                              lies in the range 1 to ei, where ei is the extent of the i     dimension of ARRAY. If ARRAY has size
                              zero or every element of MASK has the value false, all elements of the result are zero.
               Case (iii):    If ARRAYhasrankoneandDIMisspeciﬁed,theresulthasavalueequaltothatoftheﬁrstelement
                              of MINLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
                              is speciﬁed, the value of element (s , s , ..., s            , s       , ..., s ) of the result is equal to
                                                                       1   2         DIM−1    DIM+1           n
                                     MINLOC(ARRAY(s , s , ..., s                 , :, s      , . . . , s ),
                                                 DIM=1 1 2                DIM−1       DIM+1          n
                                                 [, MASK = MASK (s , s , ..., s              , :, s      , . . . , s ),
                                                  KIND = KIND,            1   2       DIM−1       DIM+1          n
                                                  BACK=BACK]).
            6 If only one element has the minimum value, that element’s subscripts are returned. Otherwise, if more than one
               element has the minimum value and BACK is absent or present with the value false, the element whose subscripts
               are returned is the ﬁrst such element, taken in array element order. If BACK is present with the value true, the
               element whose subscripts are returned is the last such element, taken in array element order.
            7 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
               operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
            8 Examples.
               Case (i):      The value of MINLOC ([4, 3, 6, 3]) is [2] and the value of MINLOC ([4, 3, 6, 3], BACK = .TRUE.)
                              is [4].                                     
                                                     0 −5        8   −3 
               Case (ii):     If A has the value       3    4    −1    2     , MINLOC (A, MASK = A > −4) has the value [1, 4].
                                                       1    5     6   −4
                              This is independent of the declared lower bounds for A.                                             
               Case (iii):    The value of MINLOC ([5, −9, 3], DIM = 1) is 2. If B has the value                       1  3   −9 , MIN-
                                                                                                                       2  2    6
                              LOC (B, DIM = 1) is [1, 2, 1] and MINLOC (B, DIM = 2) is [3, 1]. This is independent of
                              the declared lower bounds for B.
               16.9.134 MINVAL (ARRAY, DIM [, MASK]) or MINVAL (ARRAY [, MASK])
            1 Description. Minimum value(s) of array.
            2 Class. Transformational function.
            3 Arguments.
               ARRAY          shall be an array of type integer, real, or character.
               DIM            shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
               MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                c
               ISO/IEC 2017 – All rights reserved                                                                                     405
             ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
             does not appear; otherwise, the result has rank n − 1 and shape [d , d , ..., d      , d      , . . . , d ] where
             [d , d , ..., d ] is the shape of ARRAY.                            1  2       DIM−1    DIM+1        n
               1   2       n
           5 Result Value.
             Case (i):     The result of MINVAL (ARRAY) has a value equal to the minimum value of all the elements of
                           ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
                           result has the value of the positive number of the largest magnitude supported by the processor
                           for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
                           character, the result has the value of a string of characters of length LEN (ARRAY), with each
                           character equal to CHAR (n − 1, KIND (ARRAY)), where n is the number of characters in the
                           collating sequence for characters with the kind type parameter of ARRAY.
             Case (ii):    The result of MINVAL (ARRAY, MASK = MASK) has a value equal to that of MINVAL (PACK
                           (ARRAY, MASK)).
             Case (iii):   The result of MINVAL (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal to that of
                           MINVAL (ARRAY [, MASK = MASK]) if ARRAY has rank one. Otherwise, the value of element
                           (s , s , ..., s    , s     , . . . , s ) of the result is equal to
                             1  2       DIM−1   DIM+1        n
                                 MINVAL(ARRAY(s , s , ..., s           , :, s    , . . . , s )
                                                      1  2       DIM−1      DIM+1       n
                                 [, MASK= MASK (s , s , ..., s        , :, s     , . . . , s ) ] ).
                                                     1   2      DIM−1      DIM+1       n
           6 If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
             operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
           7 Examples.
             Case (i):     The value of MINVAL ([1, 2, 3]) is 1.
             Case (ii):    MINVAL(C, MASK = C>0.0) is the minimum of the positive elements of C.
                                            1 3 5 
             Case (iii):   If B is the array  2  4  6   , MINVAL (B, DIM = 1) is [1, 3, 5] and MINVAL (B, DIM = 2) is
                           [1, 2].
             16.9.135 MOD (A, P)
           1 Description. Remainder function.
           2 Class. Elemental function.
           3 Arguments.
             A             shall be of type integer or real.
             P             shall be of the same type and kind type parameter as A. P shall not be zero.
           4 Result Characteristics. Same as A.
           5 Result Value. The value of the result is A − INT (A/P) * P.
           6 Examples. MOD (3.0, 2.0) has the value 1.0 (approximately). MOD (8, 5) has the value 3. MOD (−8, 5) has
             the value −3. MOD (8, −5) has the value 3. MOD (−8, −5) has the value −3.
             16.9.136 MODULO (A, P)
           1 Description. Modulo function.
           2 Class. Elemental function.
           3 Arguments.
             A             shall be of type integer or real.
             P             shall be of the same type and kind type parameter as A. P shall not be zero.
                                                                             c
             406                                                            ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. Same as A.
           5 Result Value.
              Case (i):     Ais of type integer. MODULO (A, P) has the value R such that A = Q × P + R, where Q is an
                            integer, the inequalities 0 ≤ R < P hold if P > 0, and P < R ≤ 0 hold if P < 0.
              Case (ii):    Ais of type real. The value of the result is A − FLOOR (A / P) * P.
           6 Examples. MODULO (8, 5) has the value 3. MODULO (−8, 5) has the value 2. MODULO (8, −5) has the
              value −2. MODULO (−8, −5) has the value −3.
              16.9.137 MOVE_ALLOC (FROM, TO [, STAT, ERRMSG])
           1 Description. Move an allocation.
           2 Class. Subroutine, pure if and only if FROM is not a coarray.
           3 Arguments.
              FROM          may be of any type, rank, and corank. It shall be allocatable and shall not be a coindexed object.
                            It is an INTENT (INOUT) argument.
              TO            shall be type compatible (7.3.2.3) with FROM and have the same rank and corank. It shall be
                            allocatable and shall not be a coindexed object. It shall be polymorphic if FROM is polymorphic.
                            It is an INTENT (OUT) argument. Each nondeferred parameter of the declared type of TO shall
                            have the same value as the corresponding parameter of the declared type of FROM.
              STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
                            INTENT (OUT) argument.
              ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
           4 If execution of MOVE_ALLOC is successful, or if STAT_FAILED_IMAGE is assigned to STAT,
                 • On invocation of MOVE_ALLOC, if the allocation status of TO is allocated, it is deallocated. Then,
                    if FROM has an allocation status of allocated on entry to MOVE_ALLOC, TO becomes allocated with
                    dynamic type, type parameters, bounds, cobounds, and value identical to those that FROM had on entry
                    to MOVE_ALLOC. Note that if FROM and TO are the same variable, it shall be unallocated when
                    MOVE_ALLOCisinvoked.
                 • If TO has the TARGETattribute, any pointer associated with FROM on entry to MOVE_ALLOC becomes
                    correspondingly associated with TO. If TO does not have the TARGET attribute, the pointer association
                    status of any pointer associated with FROM on entry becomes undeﬁned.
                 • The allocation status of FROM becomes unallocated.
           5 Whenareference to MOVE_ALLOCisexecuted for which the FROM argument is a coarray, there is an implicit
              synchronization of all active images of the current team. On those images, execution of the segment (11.6.2)
              following the CALL statement is delayed until all other active images of the current team have executed the same
              statement the same number of times. When such a reference is executed, if any image of the current team has
              stopped or failed, an error condition occurs.
           6 If STAT is present and execution is successful, it is assigned the value zero.
           7 If an error condition occurs,
                 • if STAT is absent, error termination is initiated;
                 • otherwise, if FROM is a coarray and the current team contains a stopped image, STAT is assigned the value
                    STAT_STOPPED_IMAGEfromthe intrinsic module ISO_FORTRAN_ENV;
                 • otherwise, if FROM is a coarray and the current team contains a failed image, and no other error condition
                    occurs, STAT is assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
                    ENV;
               c
              ISO/IEC 2017 – All rights reserved                                                                           407
            ISO/IEC DIS 1539-1:2017 (E)
              • otherwise, STAT is assigned a processor-dependent positive value that diﬀers from that of STAT_STOP-
                PED_IMAGEorSTAT_FAILED_IMAGE.
         8 If the ERRMSG argument is present and an error condition occurs, it is assigned an explanatory message. If no
            error condition occurs, the deﬁnition status and value of ERRMSG are unchanged.
         9 Example. The example below demonstrates reallocation of GRID to twice its previous size, with its previous
            contents evenly distributed over the new elements so that intermediate points can be inserted.
                   REAL,ALLOCATABLE :: GRID(:),TEMPGRID(:)
                   ...
                   ALLOCATE(GRID(-N:N))       ! initial allocation of GRID
                   ...
                   ALLOCATE(TEMPGRID(-2*N:2*N)) ! allocate bigger grid
                   TEMPGRID(::2)=GRID ! distribute values to new locations
                   CALL MOVE_ALLOC(TO=GRID,FROM=TEMPGRID)
            The old grid is deallocated because TO is INTENT (OUT), and GRID then takes over the new grid allocation.
                NOTE16.24
                It is expected that the implementation of allocatable objects will typically involve descriptors to locate the
                allocated storage; MOVE_ALLOCcouldthenbeimplementedbytransferringthecontentsofthedescriptor
                for FROM to the descriptor for TO and clearing the descriptor for FROM.
            16.9.138 MVBITS (FROM, FROMPOS, LEN, TO, TOPOS)
         1 Description. Copy a sequence of bits.
         2 Class. Elemental subroutine.
         3 Arguments.
            FROM       shall be of type integer. It is an INTENT (IN) argument.
            FROMPOS shall be of type integer and nonnegative. It is an INTENT (IN) argument. FROMPOS + LEN
                       shall be less than or equal to BIT_SIZE (FROM). The model for the interpretation of an integer
                       value as a sequence of bits is in 16.3.
            LEN        shall be of type integer and nonnegative. It is an INTENT (IN) argument.
            TO         shall be a variable of the same type and kind type parameter value as FROM and may be associated
                       with FROM(15.8.3). It is an INTENT (INOUT) argument. TO is deﬁned by copying the sequence
                       of bits of length LEN, starting at position FROMPOS of FROM to position TOPOS of TO. No
                       other bits of TO are altered. On return, the LEN bits of TO starting at TOPOS are equal to
                       the value that the LEN bits of FROM starting at FROMPOS had on entry. The model for the
                       interpretation of an integer value as a sequence of bits is in 16.3.
            TOPOS      shall be of type integer and nonnegative. It is an INTENT (IN) argument. TOPOS + LEN shall
                       be less than or equal to BIT_SIZE (TO).
         4 Example. If TO has the initial value 6, its value after the statement CALL MVBITS (7, 2, 2, TO, 0) is 5.
            16.9.139 NEAREST (X, S)
         1 Description. Adjacent machine number.
         2 Class. Elemental function.
                                                                  c
            408                                                  ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
            3 Arguments.
               X             shall be of type real.
               S             shall be of type real and not equal to zero.
            4 Result Characteristics. Same as X.
            5 Result Value. The result has a value equal to the machine-representable number distinct from X and nearest
               to it in the direction of the ∞ with the same sign as S.
                                                                       −22
            6 Example. NEAREST (3.0, 2.0) has the value 3+2                 on a machine whose representation is that of the model
               in NOTE 16.4.
                    NOTE16.25
                    Unlike other ﬂoating-point manipulation functions, NEAREST operates on machine-representable numbers
                    rather than model numbers. On many systems there are machine-representable numbers that lie between
                    adjacent model numbers.
               16.9.140 NEW_LINE (A)
            1 Description. Newline character.
            2 Class. Inquiry function.
            3 Argument. A shall be of type character. It may be a scalar or an array.
            4 Result Characteristics. Character scalar of length one with the same kind type parameter as A.
            5 Result Value.
               Case (i):     If A is default character and the character in position 10 of the ASCII collating sequence is repres-
                             entable in the default character set, then the result is ACHAR (10).
               Case (ii):    If A is ASCII character or ISO 10646 character, then the result is CHAR (10, KIND (A)).
               Case (iii):   Otherwise, the result is a processor-dependent character that represents a newline in output to ﬁles
                             connected for formatted stream output if there is such a character.
               Case (iv):    Otherwise, the result is the blank character.
            6 Example. If there is a suitable newline character, and unit 10 is connected for formatted stream output, the
               statement
                        WRITE (10, ’(A)’) ’New’//NEW_LINE(’a’)//’Line’
               will write a record containing “New” and then a record containing “Line”.
               16.9.141 NINT (A [, KIND])
            1 Description. Nearest integer.
            2 Class. Elemental function.
            3 Arguments.
               A             shall be of type real.
               KIND (optional) shall be a scalar integer constant expression.
            4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
               KIND; otherwise, the kind type parameter is that of default integer type.
            5 Result Value. The result is the integer nearest A, or if there are two integers equally near A, the result is
               whichever such integer has the greater magnitude.
                c
               ISO/IEC 2017 – All rights reserved                                                                                 409
                       ISO/IEC DIS 1539-1:2017 (E)
                  6 Example. NINT (2.783) has the value 3.
                       16.9.142 NORM2 (X) or NORM2 (X, DIM)
                  1 Description. L2 norm of an array.
                  2 Class. Transformational function.
                  3 Arguments.
                       X                       shall be a real array.
                       DIM                     shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of X.
                  4 Result Characteristics. The result is of the same type and type parameters as X. It is scalar if DIM does not
                       appear; otherwise the result has rank n−1 and shape [d , d , ..., d                                                             , d            , . . . , d ], where n is the rank
                       of X and [d , d , ..., d ] is the shape of X.                                                    1     2             DIM−1          DIM+1                  n
                                           1     2             n
                  5 Result Value.
                       Case (i):               The result of NORM2 (X) has a value equal to a processor-dependent approximation to the gener-
                                               alized L2 norm of X, which is the square root of the sum of the squares of the elements of X. If X
                                               has size zero, the result has the value zero.
                       Case (ii):              The result of NORM2 (X, DIM=DIM) has a value equal to that of NORM2 (X) if X has rank
                                               one. Otherwise, the value of element (s , s , ..., s                                              , s           , . . .    s ) of the result is equal to
                                                                                                                  1     2             DIM−1          DIM+1                 n
                                               NORM2(X(s , s , ..., s                                , :, s            , . . .   s )).
                                                                      1     2             DIM−1             DIM+1                  n
                  6 It is recommended that the processor compute the result without undue overﬂow or underﬂow.
                  7 Example. The value of NORM2 ([3.0, 4.0]) is 5.0 (approximately). If X has the value  1.0                                                                                  2.0  then the
                                                                                                                                                                                      3.0      4.0
                       value of NORM2 (X, DIM=1) is [3.162, 4.472] (approximately) and the value of NORM2 (X, DIM=2) is [2.236,
                       5.0] (approximately).
                       16.9.143 NOT (I)
                  1 Description. Bitwise complement.
                  2 Class. Elemental function.
                  3 Argument. I shall be of type integer.
                  4 Result Characteristics. Same as I.
                  5 Result Value. Theresult has the value obtained by complementing I bit-by-bit according to the following table:
                                                                                                             I      NOT(I)
                                                                                                             1            0
                                                                                                             0            1
                  6 The model for the interpretation of an integer value as a sequence of bits is in 16.3.
                  7 Example. If I is represented by the string of bits 01010101, NOT (I) has the binary value 10101010.
                       16.9.144 NULL ([MOLD])
                  1 Description. Disassociated pointer or unallocated allocatable entity.
                  2 Class. Transformational function.
                                                                                                                                       c
                       410                                                                                                            ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
            3 Argument. MOLD shall be a pointer or allocatable. It may be of any type or may be a procedure pointer.
               If MOLD is a pointer its pointer association status may be undeﬁned, disassociated, or associated. If MOLD is
               allocatable its allocation status may be allocated or unallocated. It need not be deﬁned with a value.
            4 Result Characteristics. If MOLD is present, the characteristics are the same as MOLD. If MOLD has deferred
               type parameters, those type parameters of the result are deferred.
            5 If MOLD is absent, the characteristics of the result are determined by the entity with which the reference is
               associated. See Table 16.5. MOLD shall not be absent in any other context. If any type parameters of the
               contextual entity are deferred, those type parameters of the result are deferred. If any type parameters of the
               contextual entity are assumed, MOLD shall be present.
            6 If the context of the reference to NULL is an actual argument in a generic procedure reference, MOLD shall be
               present if the type, type parameters, or rank are required to resolve the generic reference.
                                           Table 16.5: Characteristics of the result of NULL ( )
                          Appearance of NULL ( )                          Type, type parameters, and rank of result:
                          right side of a pointer assignment              pointer on the left side
                          initialization for an object in a declaration   the object
                          default initialization for a component          the component
                          in a structure constructor                      the corresponding component
                          as an actual argument                           the corresponding dummy argument
                          in a DATA statement                             the corresponding pointer object
            7 Result. The result is a disassociated pointer or an unallocated allocatable entity.
            8 Examples.
               Case (i):     REAL, POINTER, DIMENSION (:) :: VEC => NULL ( ) deﬁnes the initial association status of
                             VECtobedisassociated.
               Case (ii):    The MOLD argument is required in the following:
                             INTERFACE GEN
                                  SUBROUTINE S1 (J, PI)
                                       INTEGER J
                                       INTEGER, POINTER :: PI
                                  END SUBROUTINE S1
                                  SUBROUTINE S2 (K, PR)
                                       INTEGER K
                                       REAL, POINTER :: PR
                                  END SUBROUTINE S2
                             END INTERFACE
                             REAL, POINTER :: REAL_PTR
                             CALL GEN (7, NULL (REAL_PTR) )                ! Invokes S2
               16.9.145 NUM_IMAGES ( ) or NUM_IMAGES (TEAM) or
                             NUM_IMAGES (TEAM_NUMBER)
            1 Description. Number of images.
            2 Class. Transformational function.
               c
               ISO/IEC 2017 – All rights reserved                                                                               411
              ISO/IEC DIS 1539-1:2017 (E)
           3 Arguments.
              TEAM          shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
                            value that identiﬁes the current or an ancestor team.
              TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a team whose parent is the
                            same as that of the current team.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. The number of images in the speciﬁed team, or in the current team if no team is speciﬁed.
           6 Example. The following code uses image 1 to read data and broadcast it to other images.
                       REAL :: P[*]
                       IF (THIS_IMAGE()==1) THEN
                          READ (6,*) P
                          DO I = 2, NUM_IMAGES()
                              P[I] = P
                          END DO
                       END IF
                       SYNC ALL
              16.9.146 OUT_OF_RANGE (X, MOLD [, ROUND])
           1 Description. Whether a value cannot be converted safely.
           2 Class. Elemental function.
           3 Arguments.
              X             shall be of type integer or real.
              MOLD          shall be an integer or real scalar. If it is a variable, it need not be deﬁned.
              ROUND(optional) shall be a logical scalar. ROUND shall be present only if X is of type real and MOLD is of
                            type integer.
           4 Result Characteristics. Default logical.
           5 Result Value.
              Case (i):     If MOLD is of type integer, and ROUND is absent or present with the value false, the result is true
                            if and only if the value of X is an IEEE inﬁnity or NaN, or if the integer with largest magnitude
                            that lies between zero and X inclusive is not representable by objects with the type and kind of
                            MOLD.
              Case (ii):    If MOLDis of type integer, and ROUND is present with the value true, the result is true if and only
                            if the value of X is an IEEE inﬁnity or NaN, or if the integer nearest X, or the integer of greater
                            magnitude if two integers are equally near to X, is not representable by objects with the type and
                            kind of MOLD.
              Case (iii):   Otherwise, the result is true if and only if the value of X is an IEEE inﬁnity or NaN that is not
                            supported by objects of the type and kind of MOLD, or if X is a ﬁnite number and the result of
                            rounding the value of X (according to the IEEE rounding mode if appropriate) to the extended
                            model for the kind of MOLD has magnitude larger than that of the largest ﬁnite number with the
                            same sign as X that is representable by objects with the type and kind of MOLD.
           6 Examples. If INT8 is the kind value for an 8-bit binary integer type, OUT_OF_RANGE (−128.5, 0_INT8)
              will have the value false and OUT_OF_RANGE (−128.5, 0_INT8, .TRUE.) will have the value true.
                                                                                c
              412                                                              ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
                  NOTE16.26
                  MOLDisrequired to be a scalar because the only information taken from it is its type and kind. Allowing
                  an array MOLD would require that it be conformable with X. ROUND is scalar because allowing an array
                  rounding mode would have severe performance diﬃculties on many processors.
              16.9.147 PACK (ARRAY, MASK [, VECTOR])
           1 Description. Array packed into a vector.
           2 Class. Transformational function.
           3 Arguments.
              ARRAY        shall be an array of any type.
              MASK         shall be of type logical and shall be conformable with ARRAY.
              VECTOR(optional) shall be of the same type and type parameters as ARRAY and shall have rank one. VEC-
                           TORshall have at least as many elements as there are true elements in MASK. If MASK is scalar
                           with the value true, VECTOR shall have at least as many elements as there are in ARRAY.
           4 Result Characteristics. The result is an array of rank one with the same type and type parameters as
              ARRAY. If VECTOR is present, the result size is that of VECTOR; otherwise, the result size is the number t
              of true elements in MASK unless MASK is scalar with the value true, in which case the result size is the size of
              ARRAY.
           5 Result Value. Element i of the result is the element of ARRAY that corresponds to the ith true element of
              MASK, taking elements in array element order, for i = 1, 2, ..., t. If VECTOR is present and has size n > t,
              element i of the result has the value VECTOR (i), for i = t + 1, ..., n.
                                                                                0 0 0 
           6 Examples. The nonzero elements of an array M with the value  9         0  0  can be “gathered” by the func-
                                                                                 0   0  7
              tion PACK. The result of PACK (M, MASK = M/=0) is [9, 7] and the result of PACK (M, M /= 0, VEC-
              TOR=[2,4, 6, 8, 10, 12]) is [9, 7, 6, 8, 10, 12].
              16.9.148 PARITY (MASK) or PARITY (MASK, DIM)
           1 Description. Array reduced by .NEQV. operation.
           2 Class. Transformational function.
           3 Arguments.
              MASK         shall be a logical array.
              DIM          shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of MASK.
           4 Result Characteristics. The result is of type logical with the same kind type parameter as MASK. It is scalar
              if DIM does not appear; otherwise, the result has rank n − 1 and shape [d , d , ..., d      , d      , . . . , d ]
              where [d , d , ..., d ] is the shape of MASK.                             1   2       DIM−1    DIM+1        n
                      1  2       n
           5 Result Value.
              Case (i):    The result of PARITY (MASK) has the value true if an odd number of the elements of MASK are
                           true, and false otherwise.
              Case (ii):   If MASK has rank one, PARITY (MASK, DIM) is equal to PARITY (MASK). Otherwise, the
                           value of element (s1, s2, ..., sDIM−1, sDIM+1, ..., sn) of PARITY (MASK, DIM) is equal to
                           PARITY (MASK (s , s , ..., s         , :, s    , . . . , s )).
                                               1  2       DIM−1     DIM+1        n
              c
              ISO/IEC 2017 – All rights reserved                                                                      413
              ISO/IEC DIS 1539-1:2017 (E)
           6 Examples.
              Case (i):     The value of PARITY ([T, T, T, F]) is true if T has the value true and F has the value false.
              Case (ii):    If B is the array  T    T F  , where T has the value true and F has the value false, then
                                                 T T T
                            PARITY (B, DIM=1) has the value [F, F, T] and PARITY (B, DIM=2) has the value [F, T].
              16.9.149 POPCNT (I)
           1 Description. Number of one bits.
           2 Class. Elemental function.
           3 Argument. I shall be of type integer.
           4 Result Characteristics. Default integer.
           5 Result Value. The result value is equal to the number of one bits in the sequence of bits of I. The model for
              the interpretation of an integer value as a sequence of bits is in 16.3.
           6 Examples. POPCNT ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 2, 1, 2, 2].
              16.9.150 POPPAR (I)
           1 Description. Parity expressed as 0 or 1.
           2 Class. Elemental function.
           3 Argument. I shall be of type integer.
           4 Result Characteristics. Default integer.
           5 Result Value. POPPAR (I) has the value 1 if POPCNT (I) is odd, and 0 if POPCNT (I) is even.
           6 Examples. POPPAR ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 0, 1, 0, 0].
              16.9.151 PRECISION (X)
           1 Description. Decimal precision of a real model.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real or complex. It may be a scalar or an array.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. The result has the value INT ((p − 1) * LOG10 (b)) + k, where b and p are as deﬁned in 16.4
              for the model representing real numbers with the same value for the kind type parameter as X, and where k is 1
              if b is an integral power of 10 and 0 otherwise.
           6 Example. PRECISION (X) has the value INT (23 * LOG10 (2.)) = INT (6.92...) = 6 for real X whose model
              is as in NOTE 16.4.
              16.9.152 PRESENT (A)
           1 Description. Presence of optional argument.
           2 Class. Inquiry function.
           3 Argument. A shall be the name of an optional dummy argument that is accessible in the subprogram in which
              the PRESENT function reference appears. There are no other requirements on A.
                                                                                c
              414                                                              ISO/IEC 2017 – All rights reserved
                                                                                                                                              ISO/IEC DIS 1539-1:2017 (E)
                 4 Result Characteristics. Default logical scalar.
                 5 Result Value. The result has the value true if A is present (15.5.2.12) and otherwise has the value false.
                      16.9.153 PRODUCT (ARRAY, DIM [, MASK]) or
                                            PRODUCT(ARRAY [, MASK])
                 1 Description. Array reduced by multiplication.
                 2 Class. Transformational function.
                 3 Arguments.
                      ARRAY                 shall be an array of numeric type.
                      DIM                   shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                      MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                 4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
                      DIMdoesnotappear; otherwise, the result has rank n−1 and shape [d , d , ..., d                                                                  , d           , . . . , d ] where
                      [d , d , ..., d ] is the shape of ARRAY.                                                                           1     2            DIM−1         DIM+1                n
                         1     2            n
                 5 Result Value.
                      Case (i):             The result of PRODUCT (ARRAY) has a value equal to a processor-dependent approximation to
                                            the product of all the elements of ARRAY or has the value one if ARRAY has size zero.
                      Case (ii):            The result of PRODUCT (ARRAY, MASK = MASK) has a value equal to a processor-dependent
                                            approximation to the product of the elements of ARRAY corresponding to the true elements of
                                            MASKorhasthe value one if there are no true elements.
                      Case (iii):           If ARRAYhasrankone, PRODUCT(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequal
                                            to that of PRODUCT (ARRAY [, MASK = MASK ]). Otherwise, the value of element (s , s , ...,
                                                                                                                                                                                             1     2
                                            s           , s           , . . . , s ) of PRODUCT (ARRAY, DIM = DIM [, MASK = MASK]) is equal to
                                              DIM−1         DIM+1                n
                                                      PRODUCT(ARRAY(s ,s ,...,s                                           , :, s           , . . . , s  ) [, MASK = MASK (s , s , ...,
                                                                                              1    2            DIM−1            DIM+1                n                                      1     2
                                                      s           , :, s           , . . . , s ) ] ).
                                                        DIM−1            DIM+1                n
                 6 Examples.
                      Case (i):             The value of PRODUCT ([1, 2, 3]) is 6.
                      Case (ii):            PRODUCT(C,MASK=C>0.0)formstheproduct of the positive elements of C.
                      Case (iii):           If B is the array  1               3    5 , PRODUCT(B,DIM=1)is[2,12,30]andPRODUCT(B,DIM=2)
                                                                          2     4    6
                                            is [15, 48].
                      16.9.154 RADIX (X)
                 1 Description. Base of a numeric model.
                 2 Class. Inquiry function.
                 3 Argument. X shall be of type integer or real. It may be a scalar or an array.
                 4 Result Characteristics. Default integer scalar.
                 5 Result Value. The result has the value r if X is of type integer and the value b if X is of type real, where r and
                      b are as deﬁned in 16.4 for the model representing numbers of the same type and kind type parameter as X.
                 6 Example. RADIX (X) has the value 2 for real X whose model is as in NOTE 16.4.
                       c
                      ISO/IEC 2017 – All rights reserved                                                                                                                                            415
         ISO/IEC DIS 1539-1:2017 (E)
         16.9.155 RANDOM_INIT (REPEATABLE, IMAGE_DISTINCT)
       1 Description. Initialize the pseudorandom number generator.
       2 Class. Subroutine.
       3 Arguments.
         REPEATABLE shall be a logical scalar. It is an INTENT (IN) argument. If it has the value true, the seed
                 accessed by the pseudorandom number generator is set to a processor-dependent value that is the
                 same each time RANDOM_INIT is called from the same image. If it has the value false, the seed
                 is set to a processor-dependent, unpredictably diﬀerent value on each call.
         IMAGE_DISTINCT shall be a logical scalar. It is an INTENT (IN) argument. If it has the value true, the
                 seed accessed by the pseudorandom number generator is set to a processor-dependent value that
                 is distinct from the value that would be set by a call to RANDOM_INIT by another image. If
                 it has the value false, the value to which the seed is set does not depend on which image calls
                 RANDOM_INIT.
       4 Example. The following statement initializes the pseudorandom number generator so that the seed is diﬀerent
         on each call and that the sequence generated will diﬀer from that of another image:
          CALL RANDOM_INIT (REPEATABLE=.FALSE., IMAGE_DISTINCT=.TRUE.)
         16.9.156 RANDOM_NUMBER (HARVEST)
       1 Description. Generate pseudorandom number(s).
       2 Class. Subroutine.
       3 Argument. HARVESTshallbeoftypereal. It is an INTENT (OUT) argument. It may be a scalar or an array.
         It is assigned pseudorandom numbers from the uniform distribution in the interval 0 ≤ x < 1. If images use a
         common generator, the interleaving of values assigned in unordered segments is processor dependent.
       4 Example.
         REAL X, Y (10, 10)
         ! Initialize X with a pseudorandom number
         CALL RANDOM_NUMBER (HARVEST = X)
         CALL RANDOM_NUMBER (Y)
         ! X and Y contain uniformly distributed random numbers
         16.9.157 RANDOM_SEED ([SIZE, PUT, GET])
       1 Description. Restart or query the pseudorandom number generator.
       2 Class. Subroutine.
       3 Arguments. There shall either be exactly one or no arguments present.
         SIZE (optional) shall be a default integer scalar. It is an INTENT (OUT) argument. It is assigned the number
                 N of integers that the processor uses to hold the value of the seed.
         PUT(optional) shall be a default integer array of rank one and size ≥ N. It is an INTENT (IN) argument. It
                 is used in a processor-dependent manner to compute the seed value accessed by the pseudorandom
                 number generator.
         GET(optional) shall be a default integer array of rank one and size ≥ N. It is an INTENT (OUT) argument.
                 It is assigned the value of the seed.
                                                 c
         416                                     ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
            4 If no argument is present, the processor assigns a processor-dependent value to the seed.
            5 ThepseudorandomnumbergeneratorusedbyRANDOM_NUMBERmaintainsaseedthatisupdatedduringthe
               execution of RANDOM_NUMBER and that can be retrieved or changed by RANDOM_SEED. Computation
               of the seed from the argument PUT is performed in a processor-dependent manner. The value assigned to GET
               need not be the same as the value of PUT in an immediately preceding reference to RANDOM_SEED. For
               example, following execution of the statements
                   CALL RANDOM_SEED (PUT=SEED1)
                   CALL RANDOM_SEED (GET=SEED2)
               SEED2 need not equal SEED1. When the values diﬀer, the use of either value as the PUT argument in a
               subsequent call to RANDOM_SEEDshallresultinthesamesequenceofpseudorandomnumbersbeinggenerated.
               For example, after execution of the statements
                   CALL RANDOM_SEED (PUT=SEED1)
                   CALL RANDOM_SEED (GET=SEED2)
                   CALL RANDOM_NUMBER (X1)
                   CALL RANDOM_SEED (PUT=SEED2)
                   CALL RANDOM_NUMBER (X2)
               X2 equals X1.
            6 Examples.
               CALL RANDOM_SEED                                 ! Processor initialization
               CALL RANDOM_SEED (SIZE = K)                      ! Puts size of seed in K
               CALL RANDOM_SEED (PUT = SEED (1 : K)) ! Define seed
               CALL RANDOM_SEED (GET = OLD (1 : K))             ! Read current seed
               16.9.158 RANGE (X)
            1 Description. Decimal exponent range of a numeric model (16.4).
            2 Class. Inquiry function.
            3 Argument. X shall be of type integer, real, or complex. It may be a scalar or an array.
            4 Result Characteristics. Default integer scalar.
            5 Result Value.
               Case (i):     If X is of type integer, the result has the value INT (LOG10 (HUGE (X))).
               Case (ii):    If X is of type real, the result has the value INT (MIN (LOG10 (HUGE (X)), −LOG10 (TINY (X)))).
               Case (iii):   If X is of type complex, the result has the value RANGE (REAL (X)).
            6 Examples. RANGE (X) has the value 38 for real X whose model is as in NOTE 16.4, because in this case
               HUGE(X)=(1−2−24)×2127 and TINY (X) = 2−127.
               16.9.159 RANK (A)
            1 Description. Rank of a data object.
            2 Class. Inquiry function.
            3 Argument. A shall be a data object of any type.
                c
               ISO/IEC 2017 – All rights reserved                                                                                 417
              ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. Default integer scalar.
           5 Result Value. The value of the result is the rank of A.
           6 Example. If X is an assumed-rank dummy argument and its associated eﬀective argument is an array of rank
              3, RANK(X) has the value 3.
              16.9.160 REAL (A [, KIND])
           1 Description. Conversion to real type.
           2 Class. Elemental function.
           3 Arguments.
              A             shall be of type integer, real, or complex, or a boz-literal-constant.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Real.
              Case (i):     If A is of type integer or real and KIND is present, the kind type parameter is that speciﬁed by the
                            value of KIND. If A is of type integer or real and KIND is not present, the kind type parameter is
                            that of default real kind.
              Case (ii):    If A is of type complex and KIND is present, the kind type parameter is that speciﬁed by the value
                            of KIND. If A is of type complex and KIND is not present, the kind type parameter is the kind
                            type parameter of A.
              Case (iii):   If A is a boz-literal-constant and KIND is present, the kind type parameter is that speciﬁed by the
                            value of KIND. If A is a boz-literal-constant and KIND is not present, the kind type parameter is
                            that of default real kind.
           5 Result Value.
              Case (i):     If A is of type integer or real, the result is equal to a processor-dependent approximation to A.
              Case (ii):    If A is of type complex, the result is equal to a processor-dependent approximation to the real part
                            of A.
              Case (iii):   If A is a boz-literal-constant, the value of the result is the value whose internal representation as a
                            bit sequence is the same as that of A as modiﬁed by padding or truncation according to 16.3.3. The
                            interpretation of the bit sequence is processor dependent.
           6 Examples. REAL (−3) has the value −3.0. REAL (Z) has the same kind type parameter and the same value
              as the real part of the complex variable Z.
              16.9.161 REDUCE (ARRAY, OPERATION [, MASK, IDENTITY, ORDERED])
                            or REDUCE (ARRAY, OPERATION, DIM [, MASK, IDENTITY,
                            ORDERED])
           1 Description. General reduction of array.
           2 Class. Transformational function.
           3 Arguments.
              ARRAY         shall be an array of any type.
              OPERATION shall be a pure function with exactly two arguments; each argument shall be a scalar, nonal-
                            locatable, nonpointer, nonpolymorphic, nonoptional dummy data object with the same type and
                            type parameters as ARRAY. If one argument has the ASYNCHRONOUS, TARGET, or VALUE
                            attribute, the other shall have that attribute. Its result shall be a nonpolymorphic scalar and have
                            the same type and type parameters as ARRAY. OPERATION should implement a mathematically
                            associative operation. It need not be commutative.
                                                                                c
              418                                                              ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
             DIM           shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
             MASK(optional) shall be of type logical and shall be conformable with ARRAY.
             IDENTITY (optional) shall be scalar with the same type and type parameters as ARRAY.
             ORDERED(optional) shall be a logical scalar.
           4 Result Characteristics. The result is of the same type and type parameters as ARRAY. It is scalar if DIM
             does not appear; otherwise, the result has rank n − 1 and shape [d , d , ..., d      , d      , . . . , d ] where
             [d , d , ..., d ] is the shape of ARRAY.                            1  2       DIM−1    DIM+1        n
               1   2       n
           5 Result Value.
             Case (i):     The result of REDUCE (ARRAY, OPERATION [, IDENTITY = IDENTITY, ORDERED =
                           ORDERED]) over the sequence of values in ARRAY is the result of an iterative process. The
                           initial order of the sequence is array element order. While the sequence has more than one element,
                           each iteration involves the execution of r = OPERATION(x, y) for adjacent x and y in the sequence,
                           with x immediately preceding y, and the subsequent replacement of x and y with r; if ORDERED
                           is present with the value true, x and y shall be the ﬁrst two elements of the sequence. The process
                           continues until the sequence has only one element which is the value of the reduction. If the initial
                           sequence is empty, the result has the value IDENTITY if IDENTITY is present, and otherwise,
                           error termination is initiated.
             Case (ii):    The result of REDUCE (ARRAY, OPERATION, MASK = MASK [, IDENTITY = IDENTITY,
                           ORDERED=ORDERED])isasforCase(i)exceptthattheinitialsequence is only those elements
                           of ARRAY for which the corresponding elements of MASK are true.
             Case (iii):   If ARRAY has rank one, REDUCE (ARRAY, OPERATION, DIM = DIM [, MASK = MASK,
                           IDENTITY=IDENTITY,ORDERED=ORDERED])hasavalueequaltothatofREDUCE(AR-
                           RAY, OPERATION [, MASK = MASK, IDENTITY = IDENTITY, ORDERED = ORDERED]).
                           Otherwise, the value of element (s1, s2, ..., sDIM−1, sDIM+1, ..., sn) of REDUCE (ARRAY,
                           DIM=DIM[,MASK=MASK,IDENTITY=IDENTITY])isequalto
                                REDUCE(ARRAY(s , s , ..., s             , :, s    , . . . , s ),
                                                      1   2       DIM−1     DIM+1        n
                                            OPERATION=OPERATION,
                                            DIM=1
                                            [, MASK = MASK (s , s , ..., s        , :, s    , . . . , s ),
                                                                 1  2       DIM−1     DIM+1        n
                                            IDENTITY = IDENTITY,
                                            ORDERED=ORDERED]).
           6 Examples. Thefollowing examples all use the function MY_MULT, which returns the product of its two integer
             arguments.
             Case (i):     The value of REDUCE ([1, 2, 3], MY_MULT) is 6.
             Case (ii):    REDUCE (C, MY_MULT, MASK= C > 0, IDENTITY=1) forms the product of the positive
                           elements of C.            
             Case (iii):   If B is the array 1  3  5   , REDUCE(B,MY_MULT,DIM=1)is[2,12,30]andREDUCE(B,
                                             2  4  6
                           MY_MULT,DIM=2)is[15, 48].
                  NOTE16.27
                  If OPERATIONisnotcomputationally associative, REDUCE without ORDERED=.TRUE. with the same
                  argument values might not always produce the same result, as the processor can apply the associative law
                  to the evaluation.
             16.9.162 REPEAT (STRING, NCOPIES)
           1 Description. Repetitive string concatenation.
           2 Class. Transformational function.
              c
             ISO/IEC 2017 – All rights reserved                                                                      419
              ISO/IEC DIS 1539-1:2017 (E)
           3 Arguments.
              STRING         shall be a character scalar.
              NCOPIES        shall be an integer scalar. Its value shall not be negative.
           4 Result Characteristics. Character scalar of length NCOPIES times that of STRING, with the same kind type
              parameter as STRING.
           5 Result Value. The value of the result is the concatenation of NCOPIES copies of STRING.
           6 Examples. REPEAT (’H’, 2) has the value HH. REPEAT (’XYZ’, 0) has the value of a zero-length string.
              16.9.163 RESHAPE (SOURCE, SHAPE [, PAD, ORDER])
           1 Description. Arbitrary shape array construction.
           2 Class. Transformational function.
           3 Arguments.
              SOURCE         shall be an array of any type. If PAD is absent or of size zero, the size of SOURCE shall be greater
                             than or equal to PRODUCT (SHAPE). The size of the result is the product of the values of the
                             elements of SHAPE.
              SHAPE          shall be a rank-one integer array. SIZE (x), where x is the actual argument corresponding to
                             SHAPE, shall be a constant expression whose value is positive and less than 16. It shall not have
                             an element whose value is negative.
              PAD(optional) shall be an array of the same type and type parameters as SOURCE.
              ORDER(optional) shall be of type integer, shall have the same shape as SHAPE, and its value shall be a
                             permutation of (1, 2, ..., n), where n is the size of SHAPE. If absent, it is as if it were present with
                             value (1, 2, ..., n).
           4 Result Characteristics. The result is an array of shape SHAPE (that is, SHAPE (RESHAPE (SOURCE,
              SHAPE, PAD, ORDER)) is equal to SHAPE) with the same type and type parameters as SOURCE.
           5 Result Value. The elements of the result, taken in permuted subscript order ORDER (1), ..., ORDER (n), are
              those of SOURCE in normal array element order followed if necessary by those of PAD in array element order,
              followed if necessary by additional copies of PAD in array element order.
                                                                                 1 3 5 
           6 Examples. RESHAPE ([1, 2, 3, 4, 5, 6], [2, 3]) has the value         2   4   6  .
              RESHAPE([1, 2, 3, 4, 5, 6], [2, 4], [0, 0], [2, 1]) has the value  1   2  3   4 .
                                                                                  5   6  0   0
              16.9.164 RRSPACING (X)
           1 Description. Reciprocal of relative spacing of model numbers.
           2 Class. Elemental function.
           3 Argument. X shall be of type real.
           4 Result Characteristics. Same as X.
                                                               −e     p
           5 Result Value. The result has the value |Y×b          |×b =ABS(FRACTION(Y))*RADIX(X)/EPSILON(X),
              where b, e, and p are as deﬁned in 16.4 for Y, the value nearest to X in the model for real values whose kind type
              parameter is that of X; if there are two such values, the value of greater absolute value is taken. If X is an IEEE
              inﬁnity, the result is an IEEE NaN. If X is an IEEE NaN, the result is that NaN.
           6 Example. RRSPACING (−3.0) has the value 0.75×224 for reals whose model is as in NOTE 16.4.
                                                                                  c
              420                                                                 ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            16.9.165 SAME_TYPE_AS (A, B)
         1 Description. Dynamic type equality test.
         2 Class. Inquiry function.
         3 Arguments.
            A          shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
                       pointer, it shall not have an undeﬁned association status.
            B          shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
                       pointer, it shall not have an undeﬁned association status.
         4 Result Characteristics. Default logical scalar.
         5 Result Value. If the dynamic type of A or B is extensible, the result is true if and only if the dynamic type of
            Ais the same as the dynamic type of B. If neither A nor B has extensible dynamic type, the result is processor
            dependent.
                NOTE16.28
                The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type. An
                unlimited polymorphic entity has no declared type.
                NOTE16.29
                The test performed by SAME_TYPE_AS is not the same as the test performed by the type guard TYPE
                IS. The test performed by SAME_TYPE_AS does not consider kind type parameters.
         6 Example. Given the declarations and assignments
                   TYPE T1
                      REAL C
                   END TYPE
                   TYPE, EXTENDS(T1) :: T2
                   END TYPE
                   CLASS(T1), POINTER :: P, Q, R
                   ALLOCATE(P, Q)
                   ALLOCATE(T2 :: R)
            the value of SAME_TYPE_AS (P, Q) will be true, and the value of SAME_TYPE_AS (P, R) will be false.
            16.9.166 SCALE (X, I)
         1 Description. Real number scaled by radix power.
         2 Class. Elemental function.
         3 Arguments.
            X          shall be of type real.
            I          shall be of type integer.
         4 Result Characteristics. Same as X.
                                                  I
         5 Result Value. The result has the value X×b , where b is deﬁned in 16.4 for model numbers representing values
            of X, provided this result is representable; if not, the result is processor dependent.
         6 Example. SCALE (3.0, 2) has the value 12.0 for reals whose model is as in NOTE 16.4.
            c
            ISO/IEC 2017 – All rights reserved                                                      421
              ISO/IEC DIS 1539-1:2017 (E)
              16.9.167 SCAN (STRING, SET [, BACK, KIND])
           1 Description. Character set membership search.
           2 Class. Elemental function.
           3 Arguments.
              STRING        shall be of type character.
              SET           shall be of type character with the same kind type parameter as STRING.
              BACK(optional) shall be of type logical.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise the kind type parameter is that of default integer type.
           5 Result Value.
              Case (i):     If BACK is absent or is present with the value false and if STRING contains at least one character
                            that is in SET, the value of the result is the position of the leftmost character of STRING that is
                            in SET.
              Case (ii):    If BACK is present with the value true and if STRING contains at least one character that is in
                            SET, the value of the result is the position of the rightmost character of STRING that is in SET.
              Case (iii):   The value of the result is zero if no character of STRING is in SET or if the length of STRING or
                            SET is zero.
           6 Examples.
              Case (i):     SCAN(’FORTRAN’, ’TR’) has the value 3.
              Case (ii):    SCAN(’FORTRAN’, ’TR’, BACK = .TRUE.) has the value 5.
              Case (iii):   SCAN(’FORTRAN’, ’BCD’) has the value 0.
              16.9.168 SELECTED_CHAR_KIND (NAME)
           1 Description. Character kind selection.
           2 Class. Transformational function.
           3 Argument. NAME shall be default character scalar.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. If NAME has the value DEFAULT, then the result has a value equal to that of the kind type
              parameter of default character. If NAME has the value ASCII, then the result has a value equal to that of the
              kind type parameter of ASCII character if the processor supports such a kind; otherwise the result has the value
              −1. If NAME has the value ISO_10646, then the result has a value equal to that of the kind type parameter of
              the ISO 10646 character kind (corresponding to UCS-4 as speciﬁed in ISO/IEC 10646) if the processor supports
              such a kind; otherwise the result has the value −1. If NAME is a processor-deﬁned name of some other character
              kind supported by the processor, then the result has a value equal to that kind type parameter value. If NAME is
              not the name of a supported character type, then the result has the value −1. The NAME is interpreted without
              respect to case or trailing blanks.
           6 Examples. SELECTED_CHAR_KIND (’ASCII’) has the value 1 on a processor that uses 1 as the kind type
              parameter for the ASCII character set. The following subroutine produces a Japanese date stamp.
                         SUBROUTINE create_date_string(string)
                           INTRINSIC date_and_time,selected_char_kind
                           INTEGER,PARAMETER :: ucs4 = selected_char_kind("ISO_10646")
                                                                                c
              422                                                              ISO/IEC 2017 – All rights reserved
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
                          CHARACTER(1,UCS4),PARAMETER :: nen=CHAR(INT(Z’5e74’),UCS4), & !year
                            gatsu=CHAR(INT(Z’6708’),UCS4), & !month
                            nichi=CHAR(INT(Z’65e5’),UCS4) !day
                          CHARACTER(len= *, kind= ucs4) string
                          INTEGER values(8)
                          CALL date_and_time(values=values)
                          WRITE(string,1) values(1),nen,values(2),gatsu,values(3),nichi
                        1 FORMAT(I0,A,I0,A,I0,A)
                        END SUBROUTINE
             16.9.169 SELECTED_INT_KIND (R)
           1 Description. Integer kind selection.
           2 Class. Transformational function.
           3 Argument. R shall be an integer scalar.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. The result has a value equal to the value of the kind type parameter of an integer type that
                                                     R            R
             represents all values n in the range −10   < n < 10 , or if no such kind type parameter is available on the
             processor, the result is −1. If more than one kind type parameter meets the criterion, the value returned is the
             one with the smallest decimal exponent range, unless there are several such values, in which case the smallest of
             these kind values is returned.
           6 Example. Assume a processor supports two integer kinds, 32 with representation method r = 2 and q = 31,
             and 64 with representation method r = 2 and q = 63. On this processor SELECTED_INT_KIND (9) has the
             value 32 and SELECTED_INT_KIND (10) has the value 64.
             16.9.170 SELECTED_REAL_KIND ([P, R, RADIX])
           1 Description. Real kind selection.
           2 Class. Transformational function.
           3 Arguments. At least one argument shall be present.
             P(optional) shall be an integer scalar.
             R(optional) shall be an integer scalar.
             RADIX(optional) shall be an integer scalar.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. If P or R is absent, the result value is the same as if it were present with the value zero. If
             RADIXis absent, there is no requirement on the radix of the selected kind.
           6 The result has a value equal to a value of the kind type parameter of a real type with decimal precision, as
             returned by the function PRECISION, of at least P digits, a decimal exponent range, as returned by the function
             RANGE,ofatleastR,andaradix, asreturned by the function RADIX, of RADIX, if such a kind type parameter
             is available on the processor.
           7 Otherwise, the result is −1 if the processor supports a real type with radix RADIX and exponent range of at least
             Rbutnotwithprecision of at least P, −2 if the processor supports a real type with radix RADIX and precision of
             at least P but not with exponent range of at least R, −3 if the processor supports a real type with radix RADIX
             but with neither precision of at least P nor exponent range of at least R, −4 if the processor supports a real type
              c
             ISO/IEC 2017 – All rights reserved                                                                     423
             ISO/IEC DIS 1539-1:2017 (E)
             with radix RADIX and either precision of at least P or exponent range of at least R but not both together, and
             −5 if the processor supports no real type with radix RADIX.
          8 If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
             decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
          9 Example. SELECTED_REAL_KIND (6, 70) has the value KIND (0.0) on a machine that supports a default
             real approximation method with b = 16, p = 6, e      = −64, and e     = 63 and does not have a less precise
             approximation method.                            min              max
             16.9.171 SET_EXPONENT (X, I)
          1 Description. Real value with speciﬁed exponent.
          2 Class. Elemental function.
          3 Arguments.
             X            shall be of type real.
             I            shall be of type integer.
          4 Result Characteristics. Same as X.
          5 Result Value. If X has the value zero, the result has the same value as X. If X is an IEEE inﬁnity, the result is
                                                                                                                    I−e
             an IEEE NaN. If X is an IEEE NaN, the result is the same NaN. Otherwise, the result has the value X × b   ,
             where b and e are as deﬁned in 16.4 for the representation for the value of X in the extended real model for the
             kind of X.
          6 Example. SET_EXPONENT (3.0, 1) has the value 1.5 for reals whose model is as in NOTE 16.4.
             16.9.172 SHAPE (SOURCE [, KIND])
          1 Description. Shape of an array or a scalar.
          2 Class. Inquiry function.
          3 Arguments.
             SOURCE       shall be a scalar or array of any type. It shall not be an unallocated allocatable variable or a pointer
                          that is not associated. It shall not be an assumed-size array.
             KIND (optional) shall be a scalar integer constant expression.
          4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value
             of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
             whose size is equal to the rank of SOURCE.
          5 Result Value. The result has a value whose ith element is equal to the extent of dimension i of SOURCE,
             except that if SOURCE is assumed-rank, and associated with an assumed-size array, the last element is equal to
             −1.
          6 Examples. The value of SHAPE (A (2:5, −1:1) ) is [4, 3]. The value of SHAPE (3) is the rank-one array of size
             zero.
             16.9.173 SHIFTA (I, SHIFT)
          1 Description. Right shift with ﬁll.
          2 Class. Elemental function.
                                                                           c
             424                                                          ISO/IEC 2017 – All rights reserved
                                           ISO/IEC DIS 1539-1:2017 (E)
      3 Arguments.
       I      shall be of type integer.
       SHIFT  shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
      4 Result Characteristics. Same as I.
      5 Result Value. The result has the value obtained by shifting the bits of I to the right SHIFT bits and replicating
       the leftmost bit of I in the left SHIFT bits.
      6 If SHIFT is zero the result is I. Bits shifted out from the right are lost. The model for the interpretation of an
       integer value as a sequence of bits is in 16.3.
      7 Example. SHIFTA (IBSET (0, BIT_SIZE (0) − 1), 2) is equal to SHIFTL (7, BIT_SIZE (0) − 3).
       16.9.174 SHIFTL (I, SHIFT)
      1 Description. Left shift.
      2 Class. Elemental function.
      3 Arguments.
       I      shall be of type integer.
       SHIFT  shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
      4 Result Characteristics. Same as I.
      5 Result Value. The value of the result is ISHFT (I, SHIFT).
      6 Examples. SHIFTL (3, 1) has the value 6.
       16.9.175 SHIFTR (I, SHIFT)
      1 Description. Right shift.
      2 Class. Elemental function.
      3 Arguments.
       I      shall be of type integer.
       SHIFT  shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
      4 Result Characteristics. Same as I.
      5 Result Value. The value of the result is ISHFT (I, −SHIFT).
      6 Examples. SHIFTR (3, 1) has the value 1.
       16.9.176 SIGN (A, B)
      1 Description. Magnitude of A with the sign of B.
      2 Class. Elemental function.
      3 Arguments.
       A      shall be of type integer or real.
       B      shall be of the same type as A.
      4 Result Characteristics. Same as A.
       c
       ISO/IEC 2017 – All rights reserved                  425
              ISO/IEC DIS 1539-1:2017 (E)
           5 Result Value.
              Case (i):     If B > 0, the value of the result is |A|.
              Case (ii):    If B < 0, the value of the result is -|A|.
              Case (iii):   If B is of type integer and B=0, the value of the result is |A|.
              Case (iv):    If B is of type real and is zero, then:
                               • if the processor does not distinguish between positive and negative real zero, or if B is positive
                                 real zero, the value of the result is |A|;
                               • if the processor distinguishes between positive and negative real zero, and B is negative real
                                 zero, the value of the result is -|A|.
           6 Example. SIGN (−3.0, 2.0) has the value 3.0.
              16.9.177 SIN (X)
           1 Description. Sine function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real or complex.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to sin(X). If X is of type
              real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
           6 Example. SIN (1.0) has the value 0.84147098 (approximately).
              16.9.178 SINH (X)
           1 Description. Hyperbolic sine function.
           2 Class. Elemental function.
           3 Argument. X shall be of type real or complex.
           4 Result Characteristics. Same as X.
           5 Result Value. The result has a value equal to a processor-dependent approximation to sinh(X). If X is of type
              complex its imaginary part is regarded as a value in radians.
           6 Example. SINH (1.0) has the value 1.1752012 (approximately).
              16.9.179 SIZE (ARRAY [, DIM, KIND])
           1 Description. Size of an array or one extent.
           2 Class. Inquiry function.
           3 Arguments.
              ARRAY         shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
                            that is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less
                            than the rank of ARRAY.
              DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that speciﬁed by the
              value of KIND; otherwise the kind type parameter is that of default integer type.
                                                                                c
              426                                                              ISO/IEC 2017 – All rights reserved
                                                                                                                             ISO/IEC DIS 1539-1:2017 (E)
               5 Result Value. If DIM is present, the result has a value equal to the extent of dimension DIM of ARRAY, except
                   that if ARRAY is assumed-rank and associated with an assumed-size array and DIM is present with a value equal
                   to the rank of ARRAY, the value is −1.
               6 If DIM is absent and ARRAY is assumed-rank, the result has a value equal to PRODUCT(SHAPE(ARRAY,
                   KIND)). Otherwise, the result has a value equal to the total number of elements of ARRAY.
               7 Examples. The value of SIZE (A (2:5, −1:1), DIM=2) is 3. The value of SIZE (A (2:5, −1:1)) is 12.
                           NOTE16.30
                          If ARRAYisassumed-rankandhasrankzero,DIMcannotbepresentsinceitcannotsatisfytherequirement
                          1 ≤ DIM ≤ 0.
                   16.9.180 SPACING (X)
               1 Description. Spacing of model numbers.
               2 Class. Elemental function.
               3 Argument. X shall be of type real.
               4 Result Characteristics. Same as X.
               5 Result Value. If X does not have the value zero and is not an IEEE inﬁnity or NaN, the result has the value
                     e−p
                   b      , where b, e, and p are as deﬁned in 16.4 for the value nearest to X in the model for real values whose kind
                   type parameter is that of X, provided this result is representable; otherwise, the result is the same as that of
                   TINY(X). If there are two extended model values equally near to X, the value of greater absolute value is taken.
                   If X has the value zero, the result is the same as that of TINY (X). If X is an IEEE inﬁnity, the result is an IEEE
                   NaN. If X is an IEEE NaN, the result is that NaN.
                                                                                 −22
               6 Example. SPACING (3.0) has the value 2                                for reals whose model is as in NOTE 16.4.
                   16.9.181 SPREAD (SOURCE, DIM, NCOPIES)
               1 Description. Value replicated in a new dimension.
               2 Class. Transformational function.
               3 Arguments.
                   SOURCE              shall be a scalar or array of any type. The rank of SOURCE shall be less than 15.
                   DIM                 shall be an integer scalar with value in the range 1 ≤ DIM ≤ n+1, where n is the rank of SOURCE.
                   NCOPIES             shall be an integer scalar.
               4 Result Characteristics. The result is an array of the same type and type parameters as SOURCE and of rank
                   n+1, where n is the rank of SOURCE.
                   Case (i):           If SOURCE is scalar, the shape of the result is (MAX (NCOPIES, 0)).
                   Case (ii):          If SOURCE is an array with shape [d , d , ..., d ], the shape of the result is [d , d , ..., d                                              ,
                                       MAX(NCOPIES, 0), d                     , . . . , d ]. 1    2          n                                           1    2           DIM−1
                                                                        DIM             n
               5 Result Value.
                   Case (i):           If SOURCE is scalar, each element of the result has a value equal to SOURCE.
                   Case (ii):          If SOURCE is an array, the element of the result with subscripts (r , r , ..., r                                       ) has the value
                                       SOURCE(r , r , ..., r                     , r         , . . . , r    ).                           1    2          n+1
                                                        1    2           DIM−1       DIM+1             n+1                                                             
                                                                                                                                                           2    3    4
               6 Examples. If A is the array [2, 3, 4], SPREAD (A, DIM=1, NCOPIES=NC) is the array  2                                                          3    4  if NC
                                                                                                                                                           2    3    4
                   has the value 3 and is a zero-sized array if NC has the value 0.
                    c
                   ISO/IEC 2017 – All rights reserved                                                                                                                       427
         ISO/IEC DIS 1539-1:2017 (E)
         16.9.182 SQRT (X)
       1 Description. Square root.
       2 Class. Elemental function.
       3 Argument. X shall be of type real or complex. If X is real, its value shall be greater than or equal to zero.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to the square root of X. A
         result of type complex is the principal value with the real part greater than or equal to zero. When the real part
         of the result is zero, the imaginary part has the same sign as the imaginary part of X.
       6 Example. SQRT (4.0) has the value 2.0 (approximately).
         16.9.183 STOPPED_IMAGES ([TEAM, KIND])
       1 Description. Indices of stopped images.
       2 Class. Transformational function.
       3 Arguments.
         TEAM(optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
                  whose value identiﬁes the current or an ancestor team. If TEAM is absent the team speciﬁed is the
                  current team.
         KIND (optional) shall be a scalar integer constant expression.
       4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value
         of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
         whose size is equal to the number of images in the speciﬁed team that have initiated normal termination.
       5 Result Value. The elements of the result are the values of the indices of the images that are known to have
         initiated normal termination in the speciﬁed team, in numerically increasing order. If the executing image has
         previously executed an image control statement whose STAT= speciﬁer assigned the value STAT_STOPPED_-
         IMAGEfrom the intrinsic module ISO_FORTRAN_ENV or invoked a collective subroutine whose STAT argu-
         ment was assigned STAT_STOPPED_IMAGE, at least one of the images participating in that image control
         statement or collective invocation shall be known to have initiated normal termination.
       6 Examples. If image 3 is the only image in the current team that is known to have initiated normal termination,
         STOPPED_IMAGES() will have the value [3]. If there are no images in the current team that have initiated
         normal termination, the value of STOPPED_IMAGES() will be a zero-sized array.
         16.9.184 STORAGE_SIZE (A [, KIND])
       1 Description. Storage size in bits.
       2 Class. Inquiry function.
       3 Arguments.
         A        shall be a data object of any type. If it is polymorphic it shall not be an undeﬁned pointer. If
                  it is unlimited polymorphic or has any deferred type parameters, it shall not be an unallocated
                  allocatable variable or a disassociated or undeﬁned pointer.
         KIND (optional) shall be a scalar integer constant expression.
       4 Result Characteristics. Integer scalar. If KIND is present, the kind type parameter is that speciﬁed by the
         value of KIND; otherwise, the kind type parameter is that of default integer type.
                                                   c
         428                                       ISO/IEC 2017 – All rights reserved
                                                                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
                  5 Result Value. The result value is the size expressed in bits for an element of an array that has the dynamic
                       type and type parameters of A. If the type and type parameters are such that storage association (19.5.3) applies,
                       the result is consistent with the named constants deﬁned in the intrinsic module ISO_FORTRAN_ENV.
                               NOTE16.31
                               Anarray element might take more bits to store than an isolated scalar, since any hardware-imposed align-
                               ment requirements for array elements might not apply to a simple scalar variable.
                               NOTE16.32
                               This is intended to be the size in memory that an object takes when it is stored; this might diﬀer from the
                               size it takes during expression handling (which might be the native register size) or when stored in a ﬁle.
                               If an object is never stored in memory but only in a register, this function nonetheless returns the size it
                               would take if it were stored in memory.
                  6 Example. STORAGE_SIZE(1.0) has the same value as the named constant NUMERIC_STORAGE_SIZE in
                       the intrinsic module ISO_FORTRAN_ENV.
                       16.9.185 SUM (ARRAY, DIM [, MASK]) or SUM (ARRAY [, MASK])
                  1 Description. Array reduced by addition.
                  2 Class. Transformational function.
                  3 Arguments.
                       ARRAY                 shall be an array of numeric type.
                       DIM                   shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                       MASK(optional) shall be of type logical and shall be conformable with ARRAY.
                  4 Result Characteristics. The result is of the same type and kind type parameter as ARRAY. It is scalar if
                       DIMdoesnotappear; otherwise, the result has rank n−1 and shape [d , d , ..., d                                                                    , d            , . . . , d ] where
                       [d , d , ..., d ] is the shape of ARRAY.                                                                             1     2            DIM−1          DIM+1                n
                          1     2            n
                  5 Result Value.
                       Case (i):             The result of SUM (ARRAY) has a value equal to a processor-dependent approximation to the sum
                                             of all the elements of ARRAY or has the value zero if ARRAY has size zero.
                       Case (ii):            The result of SUM (ARRAY, MASK = MASK) has a value equal to a processor-dependent approx-
                                             imation to the sum of the elements of ARRAY corresponding to the true elements of MASK or has
                                             the value zero if there are no true elements.
                       Case (iii):           If ARRAYhasrankone,SUM(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequaltothat
                                             of SUM(ARRAY[,MASK=MASK]).Otherwise,thevalueofelement(s ,s ,...,s                                                                                    , s           ,
                                                                                                                                                                      1    2            DIM−1 DIM+1
                                             . . . , sn) of SUM (ARRAY, DIM = DIM [ , MASK = MASK]) is equal to
                                                       SUM(ARRAY(s ,s ,...,s                                     , :, s           , . . . , s  ) [, MASK=MASK(s ,s ,...,s                                       ,
                                                                                    1     2            DIM−1            DIM+1                n                                      1    2            DIM−1
                                                       :, s            , . . . , s ) ] ).
                                                             DIM+1                n
                  6 Examples.
                       Case (i):             The value of SUM ([1, 2, 3]) is 6.
                       Case (ii):            SUM(C, MASK=C>0.0) forms the sum of the positive elements of C.
                                                                          1 3 5 
                       Case (iii):           If B is the array               2     4    6     , SUM (B, DIM = 1) is [3,7,11] and SUM (B, DIM = 2) is [9, 12].
                        c
                       ISO/IEC 2017 – All rights reserved                                                                                                                                                429
         ISO/IEC DIS 1539-1:2017 (E)
         16.9.186 SYSTEM_CLOCK ([COUNT, COUNT_RATE, COUNT_MAX])
       1 Description. Query system clock.
       2 Class. Subroutine.
       3 Arguments.
         COUNT(optional) shall be an integer scalar. It is an INTENT (OUT) argument. It is assigned a processor-
                  dependent value based on the value of a processor clock, or −HUGE (COUNT) if there is no clock
                  for the invoking image. The processor-dependent value is incremented by one for each clock count
                  until the value COUNT_MAX is reached and is reset to zero at the next count. It lies in the range
                  0 to COUNT_MAX if there is a clock.
         COUNT_RATE(optional) shall be an integer or real scalar. It is an INTENT (OUT) argument. It is assigned
                  a processor-dependent approximation to the number of processor clock counts per second, or zero
                  if there is no clock for the invoking image.
         COUNT_MAX(optional) shall be an integer scalar. It is an INTENT (OUT) argument. It is assigned the
                  maximum value that COUNT can have, or zero if there is no clock for the invoking image.
       4 Whether an image has no clock, has a single clock of its own, or shares a clock with another image, is processor
         dependent.
       5 Example. If the processor clock is a 24-hour clock that registers time at approximately 18.20648193 ticks per
         second, at 11:30 A.M. the reference
            CALL SYSTEM_CLOCK (COUNT = C, COUNT_RATE = R, COUNT_MAX = M)
         deﬁnesC=(11×3600+30×60)×18.20648193 =753748,R=18.20648193,andM=24×3600×18.20648193−1=
         1573039.
         16.9.187 TAN (X)
       1 Description. Tangent function.
       2 Class. Elemental function.
       3 Argument. X shall be of type real or complex.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to tan(X). If X is of type
         real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
       6 Example. TAN (1.0) has the value 1.5574077 (approximately).
         16.9.188 TANH (X)
       1 Description. Hyperbolic tangent function.
       2 Class. Elemental function.
       3 Argument. X shall be of type real or complex.
       4 Result Characteristics. Same as X.
       5 Result Value. The result has a value equal to a processor-dependent approximation to tanh(X). If X is of type
         complex its imaginary part is regarded as a value in radians.
       6 Example. TANH (1.0) has the value 0.76159416 (approximately).
                                                   c
         430                                       ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              16.9.189 TEAM_NUMBER ([TEAM])
           1 Description. Team number.
           2 Class. Transformational function.
           3 Argument. TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FOR-
              TRAN_ENV, whose value identiﬁes the current or an ancestor team. If TEAM is absent, the team speciﬁed is
              the current team.
           4 Result Characteristics. Default integer scalar.
           5 Result Value. The result has the value −1 if the speciﬁed team is the initial team; otherwise, the result value
              is equal to the positive integer that identiﬁes the speciﬁed team within its parent team.
           6 Example. The team number can be used to control which statements get executed, for example:
                       TYPE(TEAM_TYPE) :: ODD_EVEN
                       ...
                       FORM TEAM (2-MOD(ME,2), ODD_EVEN)
                       ...
                       CHANGE TEAM (ODD_EVEN)
                         SELECT CASE (TEAM_NUMBER())
                         CASE (1)
                           ! Case for images with odd image indices in the parent team.
                         CASE (2)
                           ! Case for images with even image indices in the parent team.
                         END SELECT
                       END TEAM
              16.9.190 THIS_IMAGE ([TEAM]) or THIS_IMAGE (COARRAY [, TEAM]) or
                            THIS_IMAGE (COARRAY, DIM [, TEAM])
           1 Description. Cosubscript(s) for this image.
           2 Class. Transformational function.
           3 Arguments.
              COARRAY shall be a coarray of any type. If it is allocatable it shall be allocated. If its designator has more
                            than one part-ref, the rightmost part-ref shall have nonzero corank. If it is of type TEAM_TYPE
                            from the intrinsic module ISO_FORTRAN_ENV, the TEAM argument shall appear.
              DIM           shall be an integer scalar. Its value shall be in the range 1 ≤ DIM ≤ n, where n is the corank of
                            COARRAY.
              TEAM(optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
                            whosevalueidentiﬁes the current or an ancestor team. If COARRAY appears, it shall be established
                            in that team.
           4 Result Characteristics. Default integer. It is scalar if COARRAY does not appear or DIM appears; otherwise,
              the result has rank one and its size is equal to the corank of COARRAY.
           5 Result Value.
              Case (i):     The result of THIS_IMAGE ([TEAM]) is a scalar with a value equal to the index of the invoking
                            image in the team speciﬁed by TEAM, if present, or in the current team if absent.
               c
              ISO/IEC 2017 – All rights reserved                                                                           431
              ISO/IEC DIS 1539-1:2017 (E)
              Case (ii):     Theresult of THIS_IMAGE(COARRAY[,TEAM=TEAM])isthesequenceofcosubscriptvalues
                             for COARRAY that would specify the invoking image in the team speciﬁed by TEAM, if present,
                             or in the current team if absent.
              Case (iii):    The result of THIS_IMAGE (COARRAY, DIM [, TEAM = TEAM]) is the value of cosubscript
                             DIMinthe sequence of cosubscript values for COARRAY that would specify the invoking image in
                             the team speciﬁed by TEAM, if present, or in the current team if absent.
           6 Examples. If A is declared by the statement
                   REAL A (10, 20) [10, 0:9, 0:*]
              then on image 5, THIS_IMAGE ( ) has the value 5 and THIS_IMAGE (A) has the value [5, 0, 0]. For the same
              coarray on image 213, THIS_IMAGE (A) has the value [3, 1, 2].
           7 The following code uses image 1 to read data. The other images then copy the data.
                  IF (THIS_IMAGE()==1) READ (*,*) P
                  SYNC ALL
                  P = P[1]
              16.9.191 TINY (X)
           1 Description. Smallest positive model number.
           2 Class. Inquiry function.
           3 Argument. X shall be a real scalar or array.
           4 Result Characteristics. Scalar with the same type and kind type parameter as X.
           5 Result Value. Theresult has the value bemin−1 where b and emin are as deﬁned in 16.4 for the model representing
              numbers of the same type and kind type parameter as X.
                                                      −127
           6 Example. TINY (X) has the value 2             for real X whose model is as in NOTE 16.4.
              16.9.192 TRAILZ (I)
           1 Description. Number of trailing zero bits.
           2 Class. Elemental function.
           3 Argument. I shall be of type integer.
           4 Result Characteristics. Default integer.
           5 Result Value. If all of the bits of I are zero, the result value is BIT_SIZE (I). Otherwise, the result value is the
              position of the rightmost 1 bit in I. The model for the interpretation of an integer value as a sequence of bits is
              in 16.3.
           6 Examples. TRAILZ (8) has the value 3.
              16.9.193 TRANSFER (SOURCE, MOLD [, SIZE])
           1 Description. Transfer physical representation.
           2 Class. Transformational function.
           3 Arguments.
              SOURCE         shall be a scalar or array of any type.
                                                                                  c
              432                                                                 ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              MOLD          shall be a scalar or array of any type. If it is a variable, it need not be deﬁned. If the storage size of
                            SOURCEis greater than zero and MOLD is an array, a scalar with the type and type parameters
                            of MOLD shall not have a storage size equal to zero.
              SIZE (optional) shall be an integer scalar. The corresponding actual argument shall not be an optional dummy
                            argument.
           4 Result Characteristics. The result is of the same type and type parameters as MOLD.
              Case (i):     If MOLD is a scalar and SIZE is absent, the result is a scalar.
              Case (ii):    If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small
                            as possible such that its physical representation is not shorter than that of SOURCE.
              Case (iii):   If SIZE is present, the result is an array of rank one and size SIZE.
           5 Result Value. If the physical representation of the result has the same length as that of SOURCE, the physical
              representation of the result is that of SOURCE. If the physical representation of the result is longer than that
              of SOURCE, the physical representation of the leading part is that of SOURCE and the remainder is processor
              dependent. If the physical representation of the result is shorter than that of SOURCE, the physical representation
              of the result is the leading part of SOURCE. If D and E are scalar variables such that the physical representation
              of D is as long as or longer than that of E, the value of TRANSFER (TRANSFER (E, D), E) shall be the value
              of E. IF D is an array and E is an array of rank one, the value of TRANSFER (TRANSFER (E, D), E, SIZE (E))
              shall be the value of E.
           6 Examples.
              Case (i):     TRANSFER(1082130432, 0.0) has the value 4.0 on a processor that represents the values 4.0 and
                            1082130432 as the string of binary digits 0100 0000 1000 0000 0000 0000 0000 0000.
              Case (ii):    TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)])) is a complex rank-one array of length two whose ﬁrst
                            element has the value (1.1, 2.2) and whose second element has a real part with the value 3.3. The
                            imaginary part of the second element is processor dependent.
              Case (iii):   TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)], 1) is a complex rank-one array of length one whose only
                            element has the value (1.1, 2.2).
              16.9.194 TRANSPOSE (MATRIX)
           1 Description. Transpose of an array of rank two.
           2 Class. Transformational function.
           3 Argument. MATRIX shall be a rank-two array of any type.
           4 Result Characteristics. The result is an array of the same type and type parameters as MATRIX and with
              rank two and shape [n,m] where [m,n] is the shape of MATRIX.
           5 Result Value. Element (i,j) of the result has the value MATRIX (j + LBOUND (MATRIX, 1) − 1, i +
              LBOUND(MATRIX,2)−1).
                                            1 2 3                                               1 4 7 
                                            4 5 6                                               2 5 8 
           6 Example. If A is the array                  , then TRANSPOSE (A) has the value                    .
                                              7  8   9                                              3  6   9
              16.9.195 TRIM (STRING)
           1 Description. String without trailing blanks.
           2 Class. Transformational function.
           3 Argument. STRING shall be a character scalar.
               c
              ISO/IEC 2017 – All rights reserved                                                                           433
                          ISO/IEC DIS 1539-1:2017 (E)
                    4 Result Characteristics. Character with the same kind type parameter value as STRING and with a length
                          that is the length of STRING less the number of trailing blanks in STRING. If STRING contains no nonblank
                          characters, the result has zero length.
                    5 Result Value. The value of the result is the same as STRING except any trailing blanks are removed.
                    6 Example. TRIM (’ A B ’) has the value ’ A B’.
                          16.9.196 UBOUND (ARRAY [, DIM, KIND])
                    1 Description. Upper bound(s).
                    2 Class. Inquiry function.
                    3 Arguments.
                          ARRAY                     shall be assumed-rank or an array. It shall not be an unallocated allocatable array or a pointer that
                                                    is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less than
                                                    the rank of ARRAY.
                          DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the rank of ARRAY.
                                                    The corresponding actual argument shall not be an optional dummy argument, a disassociated
                                                    pointer, or an unallocated allocatable.
                          KIND (optional) shall be a scalar integer constant expression.
                    4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
                          KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
                          otherwise, the result is an array of rank one and size n, where n is the rank of ARRAY.
                    5 Result Value.
                          Case (i):                 If DIM is present, ARRAY is a whole array, and dimension DIM of ARRAY has nonzero extent,
                                                    the result has a value equal to the upper bound for subscript DIM of ARRAY. Otherwise, if DIM
                                                    is present and ARRAY is assumed-rank, the value of the result is as if ARRAY were a whole array,
                                                    with the extent of the ﬁnal dimension of ARRAY when ARRAY is associated with an assumed-size
                                                    array being considered to be −1. Otherwise, if DIM is present, the result has a value equal to the
                                                    number of elements in dimension DIM of ARRAY.
                          Case (ii):                If ARRAY has rank zero, UBOUND (ARRAY) has a value that is a zero-sized array. Otherwise,
                                                                                                                                th
                                                    UBOUND(ARRAY)hasavaluewhosei elementisequaltoUBOUND(ARRAY,i),fori = 1, 2,
                                                    . . . ,  n, where n is the rank of ARRAY. UBOUND (ARRAY, KIND=KIND) has a value whose ith
                                                    element is equal to UBOUND (ARRAY, i, KIND=KIND), for i = 1, 2, ..., n, where n is the
                                                    rank of ARRAY.
                    6 Examples. If A is declared by the statement
                                  REAL A (2:3, 7:10)
                          then UBOUND (A) is [3, 10] and UBOUND (A, DIM = 2) is 10.
                                   NOTE16.33
                                   If ARRAYisassumed-rankandhasrankzero,DIMcannotbepresentsinceitcannotsatisfytherequirement
                                   1 ≤ DIM ≤ 0.
                          16.9.197 UCOBOUND (COARRAY [, DIM, KIND])
                    1 Description. Upper cobound(s) of a coarray.
                    2 Class. Inquiry function.
                                                                                                                                                     c
                          434                                                                                                                       ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
           3 Arguments.
              COARRAY shallbeacoarrayofanytype. Itmaybeascalaroranarray. Ifitisallocatable it shall be allocated.
                            If its designator has more than one part-ref, the rightmost part-ref shall have nonzero corank.
              DIM(optional) shall be an integer scalar with a value in the range 1 ≤ DIM ≤ n, where n is the corank
                            of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
                            disassociated pointer, or an unallocated allocatable.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
              otherwise, the result is an array of rank one and size n, where n is the corank of COARRAY.
           5 Result Value. The ﬁnal upper cobound is the ﬁnal cosubscript in the cosubscript list for the coarray that selects
              the image whose index is equal to the number of images in the team current when COARRAY was established.
              Case (i):     If DIM is present, the result has a value equal to the upper cobound for codimension DIM of
                            COARRAY.
              Case (ii):    If DIM is absent, the result has a value whose ith element is equal to the upper cobound for
                            codimension i of COARRAY, for i = 1, 2,..., n, where n is the corank of COARRAY.
           6 Examples. If NUM_IMAGES( ) has the value 30 and A is allocated by the statement
                  ALLOCATE (A [2:3, 0:7, *])
              then UCOBOUND (A) is [3, 7, 2] and UCOBOUND (A, DIM=2) is 7. Note that the cosubscripts [3, 7, 2] do
              not correspond to an actual image.
              16.9.198 UNPACK (VECTOR, MASK, FIELD)
           1 Description. Vector unpacked into an array.
           2 Class. Transformational function.
           3 Arguments.
              VECTOR        shall be a rank-one array of any type. Its size shall be at least t where t is the number of true
                            elements in MASK.
              MASK          shall be a logical array.
              FIELD         shall be of the same type and type parameters as VECTOR and shall be conformable with MASK.
           4 Result Characteristics. The result is an array of the same type and type parameters as VECTOR and the
              same shape as MASK.
           5 Result Value. The element of the result that corresponds to the ith true element of MASK, in array element
              order, has the value VECTOR (i) for i = 1, 2, ..., t, where t is the number of true values in MASK. Each other
              element has a value equal to FIELD if FIELD is scalar or to the corresponding element of FIELD if it is an array.
           6 Examples. Particularvalues can be “scattered” to particular positions in an array by using UNPACK. If M is the
                     1 0 0                                                          .    T . 
                     0 1 0                                                          T .       . 
              array               , V is the array [1, 2, 3], and Q is the logical mask             , where “T” represents true
                       0  0   1                                                          .   .  T                             
                                                                                                                     1   2  0
              and “.” represents false, then the result of UNPACK (V, MASK = Q, FIELD = M) has the value  1             1  0 
                                                                                                                   0   0  3
                                                                                          0   2  0
              and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value  1             0  0 .
                                                                                          0   0  3
               c
              ISO/IEC 2017 – All rights reserved                                                                           435
              ISO/IEC DIS 1539-1:2017 (E)
              16.9.199 VERIFY (STRING, SET [, BACK, KIND])
           1 Description. Character set non-membership search.
           2 Class. Elemental function.
           3 Arguments.
              STRING        shall be of type character.
              SET           shall be of type character with the same kind type parameter as STRING.
              BACK(optional) shall be of type logical.
              KIND (optional) shall be a scalar integer constant expression.
           4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
              KIND; otherwise the kind type parameter is that of default integer type.
           5 Result Value.
              Case (i):     If BACK is absent or has the value false and if STRING contains at least one character that is not
                            in SET, the value of the result is the position of the leftmost character of STRING that is not in
                            SET.
              Case (ii):    If BACK is present with the value true and if STRING contains at least one character that is not
                            in SET, the value of the result is the position of the rightmost character of STRING that is not in
                            SET.
              Case (iii):   Thevalue of the result is zero if each character in STRING is in SET or if STRING has zero length.
           6 Examples.
              Case (i):     VERIFY (’ABBA’, ’A’) has the value 2.
              Case (ii):    VERIFY (’ABBA’, ’A’, BACK = .TRUE.) has the value 3.
              Case (iii):   VERIFY (’ABBA’, ’AB’) has the value 0.
              16.10       Standard intrinsic modules
              16.10.1     General
           1 This document deﬁnes ﬁve standard intrinsic modules: a Fortran environment module, a set of three modules
              to support ﬂoating-point exceptions and IEEE arithmetic, and a module to support interoperability with the C
              programming language.
           2 The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES are described in
              Clause 17. The intrinsic module ISO_C_BINDING is described in Clause 18. The module procedures described
              in 16.10.2 are pure.
                   NOTE16.34
                   The types and procedures deﬁned in standard intrinsic modules are not themselves intrinsic.
           3 A processor may extend the standard intrinsic modules to provide public entities in them in addition to those
              speciﬁed in this document.
              16.10.2     The ISO_FORTRAN_ENV intrinsic module
              16.10.2.1   General
           1 The intrinsic module ISO_FORTRAN_ENV provides public entities relating to the Fortran environment.
                                                                                c
              436                                                              ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
          2 The processor shall provide the named constants, derived types, and procedures described in subclause 16.10.2.
             In the detailed descriptions below, procedure names are generic and not speciﬁc.
             16.10.2.2  ATOMIC_INT_KIND
          1 The value of the default integer scalar constant ATOMIC_INT_KIND is the kind type parameter value of type
             integer variables for which the processor supports atomic operations speciﬁed by atomic subroutines.
             16.10.2.3  ATOMIC_LOGICAL_KIND
          1 The value of the default integer scalar constant ATOMIC_LOGICAL_KIND is the kind type parameter value
             of type logical variables for which the processor supports atomic operations speciﬁed by atomic subroutines.
             16.10.2.4  CHARACTER_KINDS
          1 The values of the elements of the default integer array constant CHARACTER_KINDS are the kind values
             supported by the processor for variables of type character. The order of the values is processor dependent. The
             rank of the array is one, its lower bound is one, and its size is the number of character kinds supported.
             16.10.2.5  CHARACTER_STORAGE_SIZE
          1 The value of the default integer scalar constant CHARACTER_STORAGE_SIZE is the size expressed in bits
             of the character storage unit (19.5.3.2).
             16.10.2.6  COMPILER_OPTIONS ( )
          1 Description. Processor-dependent string describing the options that controlled the program translation phase.
          2 Class. Transformational function.
          3 Argument. None.
          4 Result Characteristics. Default character scalar with processor-dependent length.
          5 Result Value. A processor-dependent value which describes the options that controlled the translation phase of
             program execution. This value should include relevant information that could be useful for diagnosing problems
             at a later date.
          6 Example. COMPILER_OPTIONS ( ) might have the value ’/OPTIMIZE /FLOAT=IEEE’.
             16.10.2.7  COMPILER_VERSION ( )
          1 Description. Processor-dependent string identifying the program translation phase.
          2 Class. Transformational function.
          3 Argument. None.
          4 Result Characteristics. Default character scalar with processor-dependent length.
          5 Result Value. A processor-dependent value that identiﬁes the name and version of the program translation
             phaseoftheprocessor. Thisvalueshouldincluderelevantinformationthatcouldbeusefulfordiagnosingproblems
             at a later date.
          6 Example. COMPILER_VERSION ( ) might have the value ’Fast KL-10 Compiler Version 7’.
              c
             ISO/IEC 2017 – All rights reserved                                                                  437
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE16.35
                  Relevant information that could be useful for diagnosing problems at a later date might include compiler
                  release and patch level, default compiler arguments, environment variable values, and run time library
                  requirements. A processor might include this information in an object ﬁle automatically, without the user
                  needing to save the result of this function in a variable.
             16.10.2.8  CURRENT_TEAM
          1 The value of the default integer scalar constant CURRENT_TEAM identiﬁes the current team when it is used
             as the LEVEL argument to GET_TEAM.
             16.10.2.9  ERROR_UNIT
          1 The value of the default integer scalar constant ERROR_UNIT identiﬁes the processor-dependent preconnected
             external unit used for the purpose of error reporting (12.5). This unit may be the same as OUTPUT_UNIT.
             The value shall not be −1.
             16.10.2.10   EVENT_TYPE
          1 EVENT_TYPE is a derived type with private components. It is an extensible type with no type parameters.
             Each nonallocatable component is fully default-initialized.
          2 A scalar variable of type EVENT_TYPE is an event variable. The value of an event variable includes its event
             count, which is updated by execution of a sequence of EVENT POST or EVENT WAIT statements. The eﬀect
             of each change is as if the intrinsic subroutine ATOMIC_ADD were executed with a variable that stores the
             event count as its ATOM argument. A coarray that is of type EVENT_TYPE may be referenced or deﬁned
             during execution of a segment that is unordered relative to the execution of another segment in which that
             coarray is deﬁned. The event count is of type integer with kind ATOMIC_INT_KIND from the intrinsic module
             ISO_FORTRAN_ENV.Theinitial value of the event count of an event variable is zero.
             C1603 A named entity with declared type EVENT_TYPE, or which has a noncoarray potential subobject
                     component with declared type EVENT_TYPE, shall be a variable. A component that is of such a type
                     shall be a data component.
             C1604 A named variable with declared type EVENT_TYPE shall be a coarray. A named variable with a
                     noncoarray potential subobject component of type EVENT_TYPE shall be a coarray.
             C1605 An event variable shall not appear in a variable deﬁnition context except as the event-variable in an
                     EVENTPOSTorEVENTWAITstatement,asanallocate-object,orasanactualargumentinareference
                     to a procedure with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
             C1606 A variable with a nonpointer subobject of type EVENT_TYPE shall not appear in a variable deﬁnition
                     context except as an allocate-object in an ALLOCATE statement without a SOURCE= speciﬁer, as an
                     allocate-object in a DEALLOCATE statement, or as an actual argument in a reference to a procedure
                     with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
                  NOTE16.36
                  The restrictions against changing an event variable except via EVENT POST and EVENT WAIT state-
                  ments ensure the integrity of its value and facilitate eﬃcient implementation, particularly when special
                  synchronization is needed for correct event handling.
                  NOTE16.37
                  Updates to variables via atomic subroutines are coherent but not necessarily consistent, so a processor
                  might have to use extra synchronization to obtain the consistency required for the segments ordered by
                  EVENTPOSTandEVENTWAITstatements.
                                                                          c
             438                                                         ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
             16.10.2.11  FILE_STORAGE_SIZE
          1 The value of the default integer scalar constant FILE_STORAGE_SIZE is the size expressed in bits of the ﬁle
             storage unit (12.3.5).
             16.10.2.12  INITIAL_TEAM
          1 The value of the default integer scalar constant INITIAL_TEAM identiﬁes the initial team when it is used as
             the LEVEL argument to GET_TEAM.
             16.10.2.13  INPUT_UNIT
          1 The value of the default integer scalar constant INPUT_UNIT identiﬁes the same processor-dependent external
             unit preconnected for sequential formatted input as the one identiﬁed by an asterisk in a READ statement; this
             unit is the one used for a READ statement that does not contain an input/output control list (12.6.4.3). The
             value shall not be −1.
             16.10.2.14  INT8, INT16, INT32, and INT64
          1 The values of these default integer scalar constants shall be those of the kind type parameters that specify an
             INTEGERtypewhosestoragesizeexpressedinbitsis8, 16, 32, and 64 respectively. If, for any of these constants,
             the processor supports more than one kind of that size, it is processor dependent which kind value is provided. If
             the processor supports no kind of a particular size, that constant shall be equal to −2 if the processor supports
             a kind with larger size and −1 otherwise.
             16.10.2.15  INTEGER_KINDS
          1 Thevaluesoftheelements of the default integer array constant INTEGER_KINDS are the kind values supported
             by the processor for variables of type integer. The order of the values is processor dependent. The rank of the
             array is one, its lower bound is one, and its size is the number of integer kinds supported.
             16.10.2.16  IOSTAT_END
          1 ThevalueofthedefaultintegerscalarconstantIOSTAT_ENDisassignedtothevariablespeciﬁedinanIOSTAT=
             speciﬁer (12.11.5) if an end-of-ﬁle condition occurs during execution of an input statement and no error condition
             occurs. This value shall be negative.
             16.10.2.17  IOSTAT_EOR
          1 ThevalueofthedefaultintegerscalarconstantIOSTAT_EORisassignedtothevariablespeciﬁedinanIOSTAT=
             speciﬁer (12.11.5) if an end-of-record condition occurs during execution of an input statement and no end-of-ﬁle
             or error condition occurs. This value shall be negative and diﬀerent from the value of IOSTAT_END.
             16.10.2.18  IOSTAT_INQUIRE_INTERNAL_UNIT
          1 The value of the default integer scalar constant IOSTAT_INQUIRE_INTERNAL_UNIT is assigned to the
             variable speciﬁed in an IOSTAT= speciﬁer in an INQUIRE statement (12.10) if a ﬁle-unit-number identiﬁes an
             internal unit in that statement.
                 NOTE16.38
                 This can only occur when a deﬁned input/output procedure is called by the processor as the result of
                 executing a parent data transfer statement (12.6.4.8.3) for an internal unit.
             c
             ISO/IEC 2017 – All rights reserved                                                                439
             ISO/IEC DIS 1539-1:2017 (E)
             16.10.2.19  LOCK_TYPE
          1 LOCK_TYPE is a derived type with private components; no component is allocatable or a pointer. It is an
             extensible type with no type parameters. All components have default initialization.
          2 Ascalar variable of type LOCK_TYPE is a lock variable. A lock variable can have one of two states: locked and
             unlocked. The unlocked state is represented by the one value that is the default value of a LOCK_TYPE variable;
             this is the value speciﬁed by the structure constructor LOCK_TYPE ( ). The locked state is represented by all
             other values. The value of a lock variable can be changed with the LOCK and UNLOCK statements (11.6.10).
             C1607 A named entity with declared type LOCK_TYPE, or which has a noncoarray potential subobject com-
                    ponent with declared type LOCK_TYPE, shall be a variable. A component that is of such a type shall
                    be a data component.
             C1608 A named variable with declared type LOCK_TYPE shall be a coarray. A named variable with a
                    noncoarray potential subobject component of type LOCK_TYPE shall be a coarray.
             C1609 Alock variable shall not appear in a variable deﬁnition context except as the lock-variable in a LOCK or
                    UNLOCKstatement, as an allocate-object, or as an actual argument in a reference to a procedure with
                    an explicit interface where the corresponding dummy argument has INTENT (INOUT).
             C1610 AvariablewithasubobjectoftypeLOCK_TYPEshallnotappearinavariabledeﬁnitioncontextexcept
                    as an allocate-object or as an actual argument in a reference to a procedure with an explicit interface
                    where the corresponding dummy argument has INTENT (INOUT).
                 NOTE16.39
                 The restrictions against changing a lock variable except via the LOCK and UNLOCK statements ensure
                 the integrity of its value and facilitate eﬃcient implementation, particularly when special synchronization
                 is needed for correct lock operation.
             16.10.2.20  LOGICAL_KINDS
          1 Thevalues of the elements of the default integer array constant LOGICAL_KINDS are the kind values supported
             by the processor for variables of type logical. The order of the values is processor dependent. The rank of the
             array is one, its lower bound is one, and its size is the number of logical kinds supported.
             16.10.2.21  NUMERIC_STORAGE_SIZE
          1 Thevalue of the default integer scalar constant NUMERIC_STORAGE_SIZE is the size expressed in bits of the
             numeric storage unit (19.5.3.2).
             16.10.2.22  OUTPUT_UNIT
          1 ThevalueofthedefaultintegerscalarconstantOUTPUT_UNITidentiﬁesthesameprocessor-dependentexternal
             unit preconnected for sequential formatted output as the one identiﬁed by an asterisk in a WRITE statement
             (12.6.4.3). The value shall not be −1.
             16.10.2.23  PARENT_TEAM
          1 The value of the default integer scalar constant PARENT_TEAM identiﬁes the parent team when it is used as
             the LEVEL argument to GET_TEAM.
             16.10.2.24  REAL_KINDS
          1 The values of the elements of the default integer array constant REAL_KINDS are the kind values supported by
             the processor for variables of type real. The order of the values is processor dependent. The rank of the array is
             one, its lower bound is one, and its size is the number of real kinds supported.
                                                                         c
             440                                                        ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
             16.10.2.25  REAL32, REAL64, and REAL128
          1 Thevalues of these default integer scalar named constants shall be those of the kind type parameters that specify
             a REAL type whose storage size expressed in bits is 32, 64, and 128 respectively. If, for any of these constants,
             the processor supports more than one kind of that size, it is processor dependent which kind value is provided. If
             the processor supports no kind of a particular size, that constant shall be equal to −2 if the processor supports
             kinds of a larger size and −1 otherwise.
             16.10.2.26  STAT_FAILED_IMAGE
          1 If the processor has the ability to detect that an image has failed, the value of the default integer scalar constant
             STAT_FAILED_IMAGE is positive; otherwise, the value of STAT_FAILED_IMAGE is negative. If an image
             involved in execution of an image control statement, a reference to a coindexed object, or execution of a collective
             or atomic subroutine has failed, and no other error condition occurs, the value of STAT_FAILED_IMAGE is
             assigned to the variable speciﬁed in a STAT= speciﬁer in the execution of an image control statement or reference
             to a coindexed object, or to the STAT argument in an invocation of a collective or atomic subroutine.
             16.10.2.27  STAT_LOCKED
          1 Thevalueofthedefault integer scalar constant STAT_LOCKED is assigned to the variable speciﬁed in a STAT=
             speciﬁer (11.6.11) of a LOCK statement if the lock variable is locked by the executing image.
             16.10.2.28  STAT_LOCKED_OTHER_IMAGE
          1 The value of the default integer scalar constant STAT_LOCKED_OTHER_IMAGE is assigned to the variable
             speciﬁed in a STAT= speciﬁer (11.6.11) of an UNLOCK statement if the lock variable is locked by another image.
             16.10.2.29  STAT_STOPPED_IMAGE
          1 The value of the default integer scalar constant STAT_STOPPED_IMAGE is assigned to the variable speciﬁed
             in a STAT= speciﬁer (9.7.4, 11.6.11), if execution of the statement with that speciﬁer requires synchronization
             with an image that has initiated normal termination. It is assigned to a STAT argument in a reference to a
             collective subroutine if any image of the current team has initiated normal termination. This value shall be
             positive.
             16.10.2.30  STAT_UNLOCKED
          1 The value of the default integer scalar constant STAT_UNLOCKED is assigned to the variable speciﬁed in a
             STAT=speciﬁer (11.6.11) of an UNLOCK statement if the lock variable is unlocked.
             16.10.2.31  STAT_UNLOCKED_FAILED_IMAGE
          1 The value of the default integer scalar constant STAT_UNLOCKED_FAILED_IMAGE is assigned to the vari-
             able speciﬁed in a STAT= speciﬁer (11.6.11) of a LOCK statement if the lock variable is unlocked because of the
             failure of the image that locked it.
             16.10.2.32  TEAM_TYPE
          1 TEAM_TYPE is a derived type with private components. It is an extensible type with no type parameters.
             Each nonallocatable component is fully default-initialized.
          2 Ascalar variable of type TEAM_TYPE is a team variable, and can identify a team. The default initial value of
             a team variable does not identify any team.
             c
             ISO/IEC 2017 – All rights reserved                                                                441
             ISO/IEC DIS 1539-1:2017 (E)
             16.10.2.33  Uniqueness of named constant values
          1 The values of these named constants shall be distinct:
                 IOSTAT_INQUIRE_INTERNAL_UNIT                 STAT_STOPPED_IMAGE
                 STAT_FAILED_IMAGE                            STAT_UNLOCKED
                 STAT_LOCKED                                  STAT_UNLOCKED_FAILED_IMAGE
                 STAT_LOCKED_OTHER_IMAGE
                                                                         c
             442                                                        ISO/IEC 2017 – All rights reserved
                                                                                      ISO/IEC DIS 1539-1:2017 (E)
             17 Exceptions and IEEE arithmetic
             17.1      Overview of IEEE arithmetic support
           1 The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES provide support
             for the facilities deﬁned by ISO/IEC/IEEE 60559:2011∗. Whether the modules are provided is processor depend-
             ent. If the module IEEE_FEATURES is provided, which of the named constants deﬁned in this document are
             included is processor dependent. The module IEEE_ARITHMETIC behaves as if it contained a USE statement
             for IEEE_EXCEPTIONS;everything that is public in IEEE_EXCEPTIONS is public in IEEE_ARITHMETIC.
                  NOTE17.1
                  The types and procedures deﬁned in these modules are not themselves intrinsic.
           2 If IEEE_EXCEPTIONS or IEEE_ARITHMETIC is accessible in a scoping unit, the exceptions IEEE_OVER-
             FLOW and IEEE_DIVIDE_BY_ZERO are supported in the scoping unit for all kinds of real and complex
             IEEE ﬂoating-point data. Which other exceptions are supported can be determined by the inquiry function
             IEEE_SUPPORT_FLAG (17.11.51); whether control of halting is supported can be determined by the inquiry
             function IEEE_SUPPORT_HALTING. The extent of support of the other exceptions may be inﬂuenced by
             the accessibility of the named constants IEEE_INEXACT_FLAG, IEEE_INVALID_FLAG, and IEEE_UN-
             DERFLOW_FLAGofthemoduleIEEE_FEATURES.If a scoping unit has access to IEEE_UNDERFLOW_-
             FLAGofIEEE_FEATURES,withinthescopingunittheprocessorshall support underﬂow and return true from
             IEEE_SUPPORT_FLAG (IEEE_UNDERFLOW, X) for at least one kind of real. Similarly, if IEEE_INEX-
             ACT_FLAG or IEEE_INVALID_FLAG is accessible, within the scoping unit the processor shall support the
             exception and return true from the corresponding inquiry function for at least one kind of real. If IEEE_HALT-
             ING is accessible, within the scoping unit the processor shall support control of halting and return true from
             IEEE_SUPPORT_HALTING(FLAG) for the ﬂag.
                  NOTE17.2
                  IEEE_INVALID is not required to be supported whenever IEEE_EXCEPTIONS is accessed. This is to
                  allow a processor whose arithmetic does not conform to ISO/IEC/IEEE 60559:2011 to provide support for
                  overﬂow and divide_by_zero. On a processor which does support ISO/IEC/IEEE 60559:2011, invalid is
                  an equally serious condition.
           3 If a scoping unit does not access IEEE_FEATURES, IEEE_EXCEPTIONS, or IEEE_ARITHMETIC, the level
             of support is processor dependent, and need not include support for any exceptions. If a ﬂag is signaling on entry
             to such a scoping unit, the processor ensures that it is signaling on exit. If a ﬂag is quiet on entry to such a
             scoping unit, whether it is signaling on exit is processor dependent.
           4 Additional ISO/IEC/IEEE 60559:2011 facilities are available from the module IEEE_ARITHMETIC. The extent
             of support may be inﬂuenced by the accessibility of the named constants of the module IEEE_FEATURES. If a
             scoping unit has access to IEEE_DATATYPE of IEEE_FEATURES, within the scoping unit the processor shall
             support IEEE arithmetic and return true from IEEE_SUPPORT_DATATYPE (X) (17.11.48) for at least one
             kind of real. Similarly, if IEEE_DENORMAL, IEEE_DIVIDE, IEEE_INF, IEEE_NAN, IEEE_ROUNDING,
             IEEE_SQRT, or IEEE_SUBNORMAL is accessible, within the scoping unit the processor shall support the
             feature and return true from the corresponding inquiry function for at least one kind of real. In the case of
             IEEE_ROUNDING,itshall return true for the rounding modes IEEE_NEAREST, IEEE_TO_ZERO, IEEE_-
             UP, and IEEE_DOWN; support for IEEE_AWAY is also required if there is at least one kind of real X for
                 ∗ Because ISO/IEC/IEEE 60559:2011 was originally an IEEE standard, its facilities are widely known as “IEEE arithmetic”,
             and this terminology is used by this document.
              c
             ISO/IEC 2017 – All rights reserved                                                                      443
            ISO/IEC DIS 1539-1:2017 (E)
            which IEEE_SUPPORT_DATATYPE (X) is true and RADIX (X) is equal to ten. Note that the eﬀect of
            IEEE_DENORMAListhe same as that of IEEE_SUBNORMAL.
         5 Execution might be slowed on some processors by the support of some features. If IEEE_EXCEPTIONS or
            IEEE_ARITHMETIC is accessed but IEEE_FEATURES is not accessed, the supported subset of features is
            processor dependent. The processor’s fullest support is provided when all of IEEE_FEATURES is accessed as in
                   USE, INTRINSIC :: IEEE_ARITHMETIC; USE, INTRINSIC :: IEEE_FEATURES
            but execution might then be slowed by the presence of a feature that is not needed. In all cases, the extent of
            support can be determined by the inquiry functions.
            17.2     Derived types, constants, and operators deﬁned in the modules
         1 The modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES deﬁne ﬁve derived types,
            whose components are all private. No direct component of any of these types is allocatable or a pointer.
         2 The module IEEE_EXCEPTIONS deﬁnes the following types.
               • IEEE_FLAG_TYPE is for identifying a particular exception ﬂag. Its only possible values are those of
                 named constants deﬁned in the module: IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_-
                 ZERO, IEEE_UNDERFLOW,andIEEE_INEXACT.Themodulealsodeﬁnes the array named constants
                 IEEE_USUAL = [ IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_INVALID ] and IEEE_-
                 ALL=[IEEE_USUAL,IEEE_UNDERFLOW,IEEE_INEXACT].
               • IEEE_MODES_TYPEis for representing the ﬂoating-point modes.
               • IEEE_STATUS_TYPE is for representing the ﬂoating-point status.
         3 The module IEEE_ARITHMETIC deﬁnes the following types, constants, and operators.
               • The type IEEE_CLASS_TYPE, for identifying a class of ﬂoating-point values.   Its only possible
                 values are those of named constants deﬁned in the module: IEEE_SIGNALING_NAN, IEEE_QUI-
                 ET_NAN,IEEE_NEGATIVE_INF,IEEE_NEGATIVE_NORMAL,IEEE_NEGATIVE_DENORMAL,
                 IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, IEEE_POSITIVE_SUBNORMAL, IEEE_POS-
                 ITIVE_NORMAL,IEEE_POSITIVE_INF,andIEEE_OTHER_VALUE.ThenamedconstantsIEEE_-
                 NEGATIVE_DENORMAL and IEEE_POSITIVE_DENORMAL are deﬁned with the same value as
                 IEEE_NEGATIVE_SUBNORMALandIEEE_POSITIVE_SUBNORMALrespectively.
               • The type IEEE_ROUND_TYPE, for identifying a particular rounding mode. Its only possible values
                 are those of named constants deﬁned in the module: IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP,
                 IEEE_DOWN,IEEE_AWAYandIEEE_OTHERfortherounding modes speciﬁed in this document.
               • The pure elemental operator == for two values of one of these types to return true if the values are the
                 same and false otherwise.
               • The pure elemental operator /= for two values of one of these types to return true if the values diﬀer and
                 false otherwise.
         4 ThemoduleIEEE_FEATURESdeﬁnesthetypeIEEE_FEATURES_TYPE,forexpressingtheneedforparticu-
            lar ISO/IEC/IEEE 60559:2011 features. Its only possible values are those of named constants deﬁned in the mod-
            ule: IEEE_DATATYPE, IEEE_DENORMAL, IEEE_DIVIDE, IEEE_HALTING, IEEE_INEXACT_FLAG,
            IEEE_INF, IEEE_INVALID_FLAG, IEEE_NAN, IEEE_ROUNDING, IEEE_SQRT, IEEE_SUBNORMAL,
            and IEEE_UNDERFLOW_FLAG.
            17.3     The exceptions
         1 The exceptions are the following.
                                                                    c
            444                                                    ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
              • IEEE_OVERFLOWoccursinanintrinsicrealaddition, subtraction, multiplication, division, or conversion
                by the intrinsic function REAL, as speciﬁed by ISO/IEC/IEEE 60559:2011 if IEEE_SUPPORT_DATA-
                TYPEistruefortheoperandsoftheoperationorconversion, and as determined by the processor otherwise.
                It occurs in an intrinsic real exponentiation as determined by the processor. It occurs in a complex op-
                eration, or conversion by the intrinsic function CMPLX, if it is caused by the calculation of the real or
                imaginary part of the result.
              • IEEE_DIVIDE_BY_ZEROoccursinarealdivision as speciﬁed by ISO/IEC/IEEE 60559:2011 if IEEE_-
                SUPPORT_DATATYPE is true for the operands of the division, and as determined by the processor
                otherwise. It is processor-dependent whether it occurs in a real exponentiation with a negative exponent.
                It occurs in a complex division if it is caused by the calculation of the real or imaginary part of the result.
              • IEEE_INVALID occurs when a real or complex operation or assignment is invalid; possible examples are
                SQRT (X) when X is real and has a nonzero negative value, and conversion to an integer (by assignment,
                an intrinsic procedure, or a procedure deﬁned in an intrinsic module) when the result is too large to be
                representable. IEEE_INVALID occurs for numeric relational intrinsic operations as speciﬁed below.
              • IEEE_UNDERFLOWoccurswhenthe result for an intrinsic real operation or assignment has an absolute
                value less than a processor-dependent limit, or the real or imaginary part of the result for an intrinsic
                complex operation or assignment has an absolute value less than a processor-dependent limit.
              • IEEE_INEXACT occurs when the result of a real or complex operation or assignment is not exact.
         2 Each exception has a ﬂag whose value is either quiet or signaling. The value can be determined by the subroutine
            IEEE_GET_FLAG. Its initial value is quiet. It is set to signaling when the associated exception occurs, except
            that the ﬂag for IEEE_UNDERFLOWisnotsetiftheresultoftheoperation that caused the exception was exact
            and default ISO/IEC/IEEE 60559:2011 exception handling is in eﬀect for IEEE_UNDERFLOW. Its status can
            also be changed by the subroutine IEEE_SET_FLAG or the subroutine IEEE_SET_STATUS. Once signaling
            within a procedure, it remains signaling unless set quiet by an invocation of the subroutine IEEE_SET_FLAG
            or the subroutine IEEE_SET_STATUS.
         3 If a ﬂag is signaling on entry to a procedure other than IEEE_GET_FLAG or IEEE_GET_STATUS, the
            processor will set it to quiet on entry and restore it to signaling on return. If a ﬂag signals during execution of a
            procedure, the processor shall not set it to quiet on return.
         4 Evaluation of a speciﬁcation expression might cause an exception to signal.
         5 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if an intrinsic procedure
            or a procedure deﬁned in an intrinsic module executes normally, the values of the ﬂags IEEE_OVERFLOW,
            IEEE_DIVIDE_BY_ZERO, and IEEE_INVALID shall be as on entry to the procedure, even if one or more of
            them signals during the calculation. If a real or complex result is too large for the procedure to handle, IEEE_-
            OVERFLOW may signal. If a real or complex result is a NaN because of an invalid operation (for example,
            LOG(−1.0)), IEEE_INVALID may signal. Similar rules apply to format processing and to intrinsic operations:
            no signaling ﬂag shall be set quiet and no quiet ﬂag shall be set signaling because of an intermediate calculation
            that does not aﬀect the result.
         6 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if x and x are numeric
                                                                                       1      2
            entities, the type of x + x is real, and IEEE_SUPPORT_NAN (x + x ) is true, the relational intrinsic
                               1   2                                   1     2
            operation x rel-op x shall signal IEEE_INVALID as speciﬁed for the conditional predicate of ISO/IEC/IEEE
                     1       2
            60559:2011 corresponding to rel-op indicated by Table 17.1. If the types or kind type parameters of x or x diﬀer,
                                                                                              1    2
            the conversions (10.1.5.5.1) might signal exceptions instead of or in addition to an IEEE_INVALID exception
            signaled by the comparison.
                NOTE17.3
                EachcomparisonpredicatedeﬁnedbyISO/IEC/IEEE60559:2011iseitherunorderedsignalingorunordered
                quiet. An unordered signaling predicate signals an invalid operation exception if and only if one of the values
                being compared is a NaN. An unordered quiet predicate signals an invalid operation exception if and only
                if one of the values being compared is a signaling NaN. The comparison predicates do not signal any other
                exceptions.
            c
            ISO/IEC 2017 – All rights reserved                                                      445
             ISO/IEC DIS 1539-1:2017 (E)
                                      Table 17.1: IEEE relational operator correspondence
                                     Operator     ISO/IEC/IEEE 60559:2011 comparison predicate
                                     .LT. or <                 compareSignalingLess
                                    .LE. or <=              compareSignalingLessEqual
                                     .GT. or >               compareSignalingGreater
                                    .GE. or >=             compareSignalingGreaterEqual
                                    .EQ. or ==                  compareQuietEqual
                                    .NE. or /=                compareQuietNotEqual
          7 In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if x1 or x2 are numeric
             entities, the type of x + x is complex, and IEEE_SUPPORT_NAN (REAL (x + x )) is true, the intrinsic
                                  1    2                                                    1    2
             equality or inequality operation between x  and x may signal IEEE_INVALID if the value of the real or
                                                       1       2
             imaginary part of either operand is a signaling NaN. If any conversions are done before the values are compared,
             those conversions might signal exceptions instead of or in addition to an IEEE_INVALID exception signaled by
             the comparison.
          8 In a sequence of statements that has no invocations of IEEE_GET_FLAG, IEEE_SET_FLAG, IEEE_GET_-
             STATUS, IEEE_SET_HALTING_MODE, or IEEE_SET_STATUS, if the execution of an operation would
             cause an exception to signal but after execution of the sequence no value of a variable depends on the operation,
             whether the exception is signaling is processor dependent. For example, when Y has the value zero, whether the
             code
                     X = 1.0/Y
                     X = 3.0
             signals IEEE_DIVIDE_BY_ZERO is processor dependent. Another example is the following:
                     REAL, PARAMETER :: X=0.0, Y=6.0
                     IF (1.0/X == Y) PRINT *,’Hello world’
             where the processor is permitted to discard the IF statement because the logical expression can never be true
             and no value of a variable depends on it.
          9 An exception shall not signal if this could arise only during execution of an operation beyond those required or
             permitted by the standard. For example, the statement
                     IF (F (X) > 0.0) Y = 1.0/Z
             shall not signal IEEE_DIVIDE_BY_ZERO when both F (X) and Z are zero and the statement
                     WHERE (A > 0.0) A = 1.0/A
             shall not signal IEEE_DIVIDE_BY_ZERO. On the other hand, when X has the value 1.0 and Y has the value
             0.0, the expression
                     X>0.00001 .OR. X/Y>0.00001
             is permitted to cause the signaling of IEEE_DIVIDE_BY_ZERO.
         10 Theprocessor need not support IEEE_INVALID, IEEE_UNDERFLOW, and IEEE_INEXACT. If an exception
             is not supported, its ﬂag is always quiet. The inquiry function IEEE_SUPPORT_FLAG can be used to inquire
             whether a particular ﬂag is supported.
                                                                           c
             446                                                          ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
         17.4  The rounding modes
       1 This document speciﬁes a binary rounding mode that aﬀects ﬂoating-point arithmetic with radix two, and a
         decimal rounding mode that aﬀects ﬂoating-point arithmetic with radix ten. Unqualiﬁed references to the round-
         ing mode with respect to a particular arithmetic operation or operands refers to the mode for the radix of the
         operation or operands, and other unqualiﬁed references to the rounding mode refers to both binary and decimal
         rounding modes.
       2 ISO/IEC/IEEE 60559:2011 speciﬁes ﬁve possible rounding-direction attributes: roundTiesToEven, roundTo-
         wardZero, roundTowardPositive, roundTowardNegative, and roundTiesToAway. These correspond to the round-
         ing modes IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, IEEE_DOWN, and IEEE_AWAY respectively.
         The rounding mode IEEE_OTHER does not correspond to any ISO/IEC/IEEE 60559:2011 rounding-direction
         attribute; if supported, the eﬀect of this rounding mode is processor dependent.
       3 Thesubroutine IEEE_GET_ROUNDING_MODEcanbeusedtogettheroundingmodes. Theinitial rounding
         modes are processor dependent.
       4 If the processor supports the alteration of the rounding modes during execution, the subroutine IEEE_SET_-
         ROUNDING_MODEcanbeused to alter them. The inquiry function IEEE_SUPPORT_ROUNDING can be
         used to inquire whether this facility is available for a particular mode. The inquiry function IEEE_SUPPORT_-
         IO can be used to inquire whether rounding for base conversion in formatted input/output (12.5.6.16, 12.6.2.13,
         13.7.2.3.8) is as speciﬁed in ISO/IEC/IEEE 60559:2011.
       5 In a procedure other than IEEE_SET_ROUNDING_MODE or IEEE_SET_STATUS, the processor shall not
         change the rounding modes on entry, and on return shall ensure that the rounding modes are the same as they
         were on entry.
            NOTE17.4
            ISO/IEC/IEEE 60559:2011 requires support for roundTiesToAway only for decimal ﬂoating-point.
            NOTE17.5
            ISO/IEC/IEEE 60559:2011 requires that there is a language-deﬁned means to specify a constant value
            for the rounding-direction attribute for all standard operations in a block. The means provided by this
            document are a CALL to IEEE_GET_ROUNDING_MODE at the beginning of the block followed by
            a CALL to IEEE_SET_ROUNDING_MODE with constant arguments, together with another CALL to
            IEEE_SET_ROUNDING_MODEattheendofthe block to restore the rounding mode.
            NOTE17.6
            Within a program, all literal constants that have the same form have the same value (7.1.4). Therefore, the
            value of a literal constant is not aﬀected by the rounding modes.
         17.5  Underﬂow mode
       1 Some processors allow control during program execution of whether underﬂow produces a subnormal number in
         conformance with ISO/IEC/IEEE 60559:2011 (gradual underﬂow) or produces zero instead (abrupt underﬂow).
         On some processors, ﬂoating-point performance is typically better in abrupt underﬂow mode than in gradual
         underﬂow mode.
       2 Control over the underﬂow mode is exercised by invocation of IEEE_SET_UNDERFLOW_MODE. The sub-
         routine IEEE_GET_UNDERFLOW_MODE can be used to get the underﬂow mode. The inquiry function
         IEEE_SUPPORT_UNDERFLOW_CONTROL can be used to inquire whether this facility is available. The
         initial underﬂow mode is processor dependent. In a procedure other than IEEE_SET_UNDERFLOW_MODE
         or IEEE_SET_STATUS,theprocessor shall not change the underﬂow mode on entry, and on return shall ensure
         that the underﬂow mode is the same as it was on entry.
         c
         ISO/IEC 2017 – All rights reserved                                447
         ISO/IEC DIS 1539-1:2017 (E)
       3 The underﬂow mode aﬀects only ﬂoating-point calculations whose type is that of an X for which IEEE_SUP-
         PORT_UNDERFLOW_CONTROLreturnstrue.
         17.6  Halting
       1 Some processors allow control during program execution of whether to abort or continue execution after an
         exception. Such control is exercised by invocation of the subroutine IEEE_SET_HALTING_MODE. Halting
         is not precise and may occur any time after the exception has occurred. The inquiry function IEEE_SUP-
         PORT_HALTINGcanbeusedtoinquire whether this facility is available. The initial halting mode is processor
         dependent. In a procedure other than IEEE_SET_HALTING_MODE or IEEE_SET_STATUS, the processor
         shall not change the halting mode on entry, and on return shall ensure that the halting mode is the same as it
         was on entry.
         17.7  The ﬂoating-point modes and status
       1 The values of the rounding modes, underﬂow mode, and halting mode are collectively called the ﬂoating-point
         modes. The values of all the supported ﬂags for exceptions and the ﬂoating-point modes are collectively called the
         ﬂoating-point status. The ﬂoating-point modes can be stored in a scalar variable of type IEEE_MODES_TYPE
         with the subroutine IEEE_GET_MODES and restored with the subroutine IEEE_SET_MODES. The ﬂoating-
         point status can be stored in a scalar variable of type IEEE_STATUS_TYPE with the subroutine IEEE_GET_-
         STATUSandrestored with the subroutine IEEE_SET_STATUS. There are no facilities for ﬁnding the values of
         particular ﬂags represented by such a variable.
            NOTE17.7
            Each image has its own ﬂoating-point status (5.3.4).
            NOTE17.8
            Some processors hold all these ﬂags and modes in one or two status registers that can be obtained and
            set as a whole faster than all individual ﬂags and modes can be obtained and set. These procedures are
            provided to exploit this feature.
            NOTE17.9
            The processor is required to ensure that a call to a Fortran procedure does not change the ﬂoating-point
            status other than by setting exception ﬂags to signaling.
         17.8  Exceptional values
       1 ISO/IEC/IEEE 60559:2011 speciﬁes the following exceptional ﬂoating-point values.
           • Subnormal values have very small absolute values and reduced precision.
           • Inﬁnite values (+inﬁnity and −inﬁnity) are created by overﬂow or division by zero.
           • Not-a-Number ( NaN) values are undeﬁned values or values created by an invalid operation.
       2 Avalue that does not fall into the above classes is called a normal number.
       3 The functions IEEE_IS_FINITE, IEEE_IS_NAN, IEEE_IS_NEGATIVE, and IEEE_IS_NORMAL are
         provided to test whether a value is ﬁnite, NaN, negative, or normal. The function IEEE_VALUE is provided to
         generate an IEEE number of any class, including an inﬁnity or a NaN. The inquiry functions IEEE_SUPPORT_-
         SUBNORMAL,IEEE_SUPPORT_INF,andIEEE_SUPPORT_NANareprovidedtodeterminewhether these
         facilities are available for a particular kind of real.
                                                  c
         448                                      ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
         17.9  IEEE arithmetic
       1 The inquiry function IEEE_SUPPORT_DATATYPE can be used to inquire whether IEEE arithmetic is sup-
         ported for a particular kind of real. Complete conformance with ISO/IEC/IEEE 60559:2011 is not required,
         but
           • the normal numbers shall be exactly those of an ISO/IEC/IEEE 60559:2011 ﬂoating-point format,
           • for at least one rounding mode, the intrinsic operations of addition, subtraction and multiplication shall
            conform whenever the operands and result speciﬁed by ISO/IEC/IEEE 60559:2011 are normal numbers,
           • the IEEE function abs shall be provided by the intrinsic function ABS,
           • the IEEE operation remainder shall be provided by the function IEEE_REM, and
           • the IEEE functions copySign, logB, and compareQuietUnordered shall be provided by the functions IEEE_-
            COPY_SIGN, IEEE_LOGB, and IEEE_UNORDERED, respectively,
         for that kind of real.
       2 Theinquiry function IEEE_SUPPORT_NANisprovidedtoinquire whether the processor supports IEEE NaNs.
         Where these are supported, the result of the intrinsic operations +, −, and *, and the functions IEEE_REM
         and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC/IEEE 60559:2011
         when the result is an IEEE NaN.
       3 Theinquiry function IEEE_SUPPORT_INF is provided to inquire whether the processor supports IEEE inﬁnit-
         ies. Where these are supported, the result of the intrinsic operations +, −, and *, and the functions IEEE_REM
         and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC/IEEE 60559:2011
         when exactly one operand or the result speciﬁed by ISO/IEC/IEEE 60559:2011 is an IEEE inﬁnity.
       4 The inquiry function IEEE_SUPPORT_SUBNORMAL is provided to inquire whether the processor supports
         subnormal numbers. Where these are supported, the result of the intrinsic operations +, −, and *, and the
         functions IEEE_REM and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to
         ISO/IEC/IEEE 60559:2011 when the result speciﬁed by ISO/IEC/IEEE 60559:2011 is subnormal, or any op-
         erand is subnormal and either the result is not an IEEE inﬁnity or IEEE_SUPPORT_INF is true.
       5 The inquiry function IEEE_SUPPORT_DIVIDE is provided to inquire whether, on kinds of real for which
         IEEE_SUPPORT_DATATYPE returns true, the intrinsic division operation conforms to ISO/IEC/IEEE
         60559:2011 when both operands and the result speciﬁed by ISO/IEC/IEEE 60559:2011 are normal numbers.
         If IEEE_SUPPORT_NAN is also true for a particular kind of real, the intrinsic division operation on that kind
         conforms to ISO/IEC/IEEE 60559:2011 when the result speciﬁed by ISO/IEC/IEEE 60559:2011 is a NaN. If
         IEEE_SUPPORT_INF is also true for a particular kind of real, the intrinsic division operation on that kind
         conforms to ISO/IEC/IEEE60559:2011whenoneoperandortheresultspeciﬁedbyISO/IEC/IEEE60559:2011is
         an IEEE inﬁnity. If IEEE_SUPPORT_SUBNORMAL is also true for a particular kind of real, the intrinsic divi-
         sion operation on that kind conforms to ISO/IEC/IEEE 60559:2011 when the result speciﬁed by ISO/IEC/IEEE
         60559:2011 is subnormal, or when any operand is subnormal and either the result speciﬁed by ISO/IEC/IEEE
         60559:2011 is not an inﬁnity or IEEE_SUPPORT_INF is true.
       6 ISO/IEC/IEEE 60559:2011 speciﬁes a square root function that returns negative real zero for the square root of
         negative real zero and has certain accuracy requirements. The inquiry function IEEE_SUPPORT_SQRT can
         be used to inquire whether the intrinsic function SQRT conforms to ISO/IEC/IEEE 60559:2011 for a particular
         kind of real. If IEEE_SUPPORT_NAN is also true for a particular kind of real, the intrinsic function SQRT
         on that kind conforms to ISO/IEC/IEEE 60559:2011 when the result speciﬁed by ISO/IEC/IEEE 60559:2011
         is a NaN. If IEEE_SUPPORT_INF is also true for a particular kind of real, the intrinsic function SQRT on
         that kind conforms to ISO/IEC/IEEE 60559:2011 when the result speciﬁed by ISO/IEC/IEEE 60559:2011 is an
         IEEEinﬁnity. If IEEE_SUPPORT_SUBNORMALisalsotrueforaparticularkindofreal, theintrinsic function
         SQRTonthat kind conforms to ISO/IEC/IEEE 60559:2011 when the argument is subnormal.
       7 The inquiry function IEEE_SUPPORT_STANDARD is provided to inquire whether the processor supports all
         the ISO/IEC/IEEE 60559:2011 facilities deﬁned in this document for a particular kind of real.
         c
         ISO/IEC 2017 – All rights reserved                                 449
            ISO/IEC DIS 1539-1:2017 (E)
            17.10    Summary of the procedures
         1 For all of the procedures deﬁned in the modules, the arguments shown are the names that shall be used for
            argument keywords if the keyword form is used for the actual arguments.
         2 Aprocedure classiﬁed in 17.10 as an inquiry function depends on the properties of one or more of its arguments
            instead of their values; in fact, these argument values may be undeﬁned. Unless the description of one of these
            inquiry functions states otherwise, these arguments are permitted to be unallocated allocatable variables or
            pointers that are undeﬁned or disassociated. A procedure that is classiﬁed as a transformational function is
            neither an inquiry function nor elemental.
         3 In the Class column of Tables 17.2 and 17.3,
              E indicates that the procedure is an elemental function,
             ES indicates that the procedure is an elemental subroutine,
               I indicates that the procedure is an inquiry function,
             PS indicates that the procedure is a pure subroutine,
              S indicates that the procedure is an impure subroutine, and
              T indicates that the procedure in a transformational function.
                             Table 17.2: IEEE_ARITHMETIC module procedure summary
             Procedure                       Arguments           Class Description
             IEEE_CLASS                      (X)                   E   Classify number.
             IEEE_COPY_SIGN                  (X, Y)                E   Copy sign.
             IEEE_FMA                        (A, B, C)             E   Fused multiply-add operation.
             IEEE_GET_ROUNDING_MODE (ROUND_VALUE                   S   Get rounding mode.
                                             [, RADIX])
             IEEE_GET_UNDERFLOW_-            (GRADUAL)             S   Get underﬂow mode.
             MODE
             IEEE_INT                        (A, ROUND [, KIND])   E   Conversion to integer type.
             IEEE_IS_FINITE                  (X)                   E   Whether a value is ﬁnite.
             IEEE_IS_NAN                     (X)                   E   Whether a value is an IEEE NaN.
             IEEE_IS_NEGATIVE                (X)                   E   Whether a value is negative.
             IEEE_IS_NORMAL                  (X)                   E   Whether a value is a normal number.
             IEEE_LOGB                       (X)                   E   Exponent.
             IEEE_MAX_NUM                    (X, Y)                E   Maximum numeric value.
             IEEE_MAX_NUM_MAG                (X, Y)                E   Maximum magnitude numeric value.
             IEEE_MIN_NUM                    (X, Y)                E   Minimum numeric value.
             IEEE_MIN_NUM_MAG                (X, Y)                E   Minimum magnitude numeric value.
             IEEE_NEXT_AFTER                 (X, Y)                E   Adjacent machine number.
             IEEE_NEXT_DOWN                  (X)                   E   Adjacent lower machine number.
             IEEE_NEXT_UP                    (X)                   E   Adjacent higher machine number.
             IEEE_QUIET_EQ                   (A, B)                E   Quiet compares equal.
             IEEE_QUIET_GE                   (A, B)                E   Quiet compares greater than or equal.
             IEEE_QUIET_GT                   (A, B)                E   Quiet compares greater than.
             IEEE_QUIET_LE                   (A, B)                E   Quiet compares less than or equal.
             IEEE_QUIET_LT                   (A, B)                E   Quiet compares less than.
             IEEE_QUIET_NE                   (A, B)                E   Quiet compares not equal.
             IEEE_REAL                       (A [, KIND])          E   Conversion to real type.
             IEEE_REM                        (X, Y)                E   Exact remainder.
             IEEE_RINT                       (X)                   E   Round to integer.
                                                                            I
             IEEE_SCALB                      (X, I)                E   X×2 .
             IEEE_SELECTED_REAL_KIND ([P, R, RADIX])               T   IEEE kind type parameter value.
             IEEE_SET_ROUNDING_MODE (ROUND_VALUE                   S   Set rounding mode.
                                             [, RADIX])
                                                                  c
            450                                                  ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
                     Table 17.2: IEEE_ARITHMETIC module procedure summary           (cont.)
           Procedure                  Arguments         Class Description
           IEEE_SET_UNDERFLOW_-       (GRADUAL)          S   Set underﬂow mode.
           MODE
           IEEE_SIGNALING_EQ          (A, B)             E   Signaling compares equal.
           IEEE_SIGNALING_GE          (A, B)             E   Signaling compares greater than or
                                                             equal.
           IEEE_SIGNALING_GT          (A, B)             E   Signaling compares greater than.
           IEEE_SIGNALING_LE          (A, B)             E   Signaling compares less than or equal.
           IEEE_SIGNALING_LT          (A, B)             E   Signaling compares less than.
           IEEE_SIGNALING_NE          (A, B)             E   Signaling compares not equal.
           IEEE_SIGNBIT               (X)                E   Test sign bit.
           IEEE_SUPPORT_DATATYPE      ([X])               I  Query IEEE arithmetic support.
           IEEE_SUPPORT_DENORMAL      ([X])               I  Query subnormal number support.
           IEEE_SUPPORT_DIVIDE        ([X])               I  Query IEEE division support.
           IEEE_SUPPORT_INF           ([X])               I  Query IEEE inﬁnity support.
           IEEE_SUPPORT_IO            ([X])               I  Query IEEE formatting support.
           IEEE_SUPPORT_NAN           ([X])               I  Query IEEE NaN support.
           IEEE_SUPPORT_ROUNDING      (ROUND_VALUE       T   Query IEEE rounding support.
                                      [, X])
           IEEE_SUPPORT_SQRT          ([X])               I  Query IEEE square root support.
           IEEE_SUPPORT_SUBNORMAL ([X])                   I  Query subnormal number support.
           IEEE_SUPPORT_STANDARD      ([X])               I  Query IEEE standard support.
           IEEE_SUPPORT_UNDER-        ([X])               I  Query underﬂow control support.
           FLOW_CONTROL
           IEEE_UNORDERED             (X, Y)             E   Whether two values are unordered.
           IEEE_VALUE                 (X, CLASS)         E   Return number in a class.
                         Table 17.3: IEEE_EXCEPTIONS module procedure summary
             Procedure                  Arguments           Class Description
             IEEE_GET_FLAG              (FLAG, FLAG_VALUE)  ES   Get an exception ﬂag.
             IEEE_GET_HALTING_MODE      (FLAG, HALTING)     ES   Get a halting mode.
             IEEE_GET_MODES             (MODES)              S   Get ﬂoating-point modes.
             IEEE_GET_STATUS            (STATUS_VALUE)       S   Get ﬂoating-point status.
             IEEE_SET_FLAG              (FLAG, FLAG_VALUE)  PS   Set an exception ﬂag.
             IEEE_SET_HALTING_MODE      (FLAG, HALTING)     PS   Set a halting mode.
             IEEE_SET_MODES             (MODES)              S   Set ﬂoating-point modes.
             IEEE_SET_STATUS            (STATUS_VALUE)       S   Restore ﬂoating-point status.
             IEEE_SUPPORT_FLAG          (FLAG [, X])         T   Query exception support.
             IEEE_SUPPORT_HALTING       (FLAG)               T   Query halting mode support.
        4 In the intrinsic module IEEE_ARITHMETIC, the elemental functions listed are provided for all reals X and Y.
          17.11    Speciﬁcations of the procedures
          17.11.1  General
        1 In the detailed descriptions in 17.11, procedure names are generic and are not speciﬁc. All the functions are pure
          and all the subroutines are impure unless otherwise stated. All dummy arguments have INTENT (IN) if the
          intent is not stated explicitly. In the examples, it is assumed that the processor supports IEEE arithmetic for
          default real.
           c
          ISO/IEC 2017 – All rights reserved                                          451
         ISO/IEC DIS 1539-1:2017 (E)
       2 For the elemental functions of IEEE_ARITHMETIC that return a ﬂoating-point result, if X or Y has a value
         that is an inﬁnity or a NaN, the result shall be consistent with the general rules in 6.1 and 6.2 of ISO/IEC/IEEE
         60559:2011. For example, the result for an inﬁnity shall be constructed as the limiting case of the result with a
         value of arbitrarily large magnitude, if such a limit exists.
       3 A program may contain statements that, if executed, would violate the requirements listed in a Restriction
         paragraph.
            NOTE17.10
            A program can avoid violating those requirements by using IF constructs to check whether particular
            features are supported. For example,
                 IF (IEEE_SUPPORT_DATATYPE (X)) THEN
                   C = IEEE_CLASS (X)
                 ELSE
                   ...
                 END IF
            avoids invoking IEEE_CLASS except on a processor which supports that facility.
         17.11.2 IEEE_CLASS (X)
       1 Description. Classify number.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_CLASS (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
       5 Result Characteristics. IEEE_CLASS_TYPE.
       6 Result Value. The result value shall be IEEE_SIGNALING_NAN or IEEE_QUIET_NAN if IEEE_SUP-
         PORT_NAN (X) has the value true and the value of X is a signaling or quiet NaN, respectively. The result
         value shall be IEEE_NEGATIVE_INF or IEEE_POSITIVE_INF if IEEE_SUPPORT_INF (X) has the value
         true and the value of X is negative or positive inﬁnity, respectively. The result value shall be IEEE_NEG-
         ATIVE_SUBNORMALorIEEE_POSITIVE_SUBNORMALifIEEE_SUPPORT_SUBNORMAL(X)hasthe
         value true and the value of X is a negative or positive subnormal value, respectively. The result value shall
         be IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, or IEEE_POSIT-
         IVE_NORMALifthevalueofXisnegativenormal, negative zero, positive zero, or positive normal, respectively.
         Otherwise, the result value shall be IEEE_OTHER_VALUE.
       7 Example. IEEE_CLASS (−1.0) has the value IEEE_NEGATIVE_NORMAL.
            NOTE17.11
            The result value IEEE_OTHER_VALUE is useful on systems that are almost IEEE-compatible, but do
            not implement all of it. For example, if a subnormal value is encountered on a system that does not support
            them.
         17.11.3 IEEE_COPY_SIGN (X, Y)
       1 Description. Copy sign.
       2 Class. Elemental function.
       3 Arguments. The arguments shall be of type real.
                                                  c
         452                                     ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        4 Restriction. IEEE_COPY_SIGN (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
           IEEE_SUPPORT_DATATYPE(Y)has the value false.
        5 Result Characteristics. Same as X.
        6 Result Value. The result has the absolute value of X with the sign of Y. This is true even for IEEE special
           values, such as a NaN or an inﬁnity (on processors supporting such values).
        7 Example. The value of IEEE_COPY_SIGN (X, 1.0) is ABS (X) even when X is a NaN.
           17.11.4   IEEE_FMA (A, B, C)
        1 Description. Fused multiply-add operation.
        2 Class. Elemental function.
        3 Arguments.
           A         shall be of type real.
           B         shall be of the same type and kind type parameter as A.
           C         shall be of the same type and kind type parameter as A.
        4 Restriction. IEEE_FMA (A, B, C) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the value
           false.
        5 Result Characteristics. Same as A.
        6 Result Value. The result has the value speciﬁed by ISO/IEC/IEEE 60559:2011 for the fusedMultiplyAdd
           operation; that is, when the result is in range, its value is equal to the mathematical value of (A×B)+C rounded
           to the representation method of A according to the rounding mode. IEEE_OVERFLOW, IEEE_UNDERFLOW,
           and IEEE_INEXACTshallbesignaled according to the ﬁnal step in the calculation and not by any intermediate
           calculation.
        7 Example. The value of IEEE_FMA (TINY (0.0), TINY (0.0), 1.0), when the rounding mode is IEEE_-
           NEAREST, is equal to 1.0; only the IEEE_INEXACT exception is signaled.
           17.11.5   IEEE_GET_FLAG (FLAG, FLAG_VALUE)
        1 Description. Get an exception ﬂag.
        2 Class. Elemental subroutine.
        3 Arguments.
           FLAG      shall be of type IEEE_FLAG_TYPE. It speciﬁes the exception ﬂag to be obtained.
           FLAG_VALUE shall be of type logical. It is an INTENT (OUT) argument. If the value of FLAG is IEEE_-
                     INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
                     INEXACT,FLAG_VALUEisassignedthevaluetrueifthecorrespondingexceptionﬂagissignaling
                     and is assigned the value false otherwise.
        4 Example. Following CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE), FLAG_VALUE is
           true if the IEEE_OVERFLOW ﬂag is signaling and is false if it is quiet.
           17.11.6   IEEE_GET_HALTING_MODE (FLAG, HALTING)
        1 Description. Get a halting mode.
        2 Class. Elemental subroutine.
           c
           ISO/IEC 2017 – All rights reserved                                               453
           ISO/IEC DIS 1539-1:2017 (E)
        3 Arguments.
           FLAG      shall be of type IEEE_FLAG_TYPE. It speciﬁes the exception ﬂag. It shall have one of the val-
                     ues IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW,
                     or IEEE_INEXACT.
           HALTING shall be of type logical. It is an INTENT (OUT) argument. It is assigned the value true if the
                     exception speciﬁed by FLAG will cause halting. Otherwise, it is assigned the value false.
        4 Example. To store the halting mode for IEEE_OVERFLOW, do a calculation without halting, and restore the
           halting mode later:
                 USE, INTRINSIC :: IEEE_ARITHMETIC
                 LOGICAL HALTING
                 ...
                 CALL IEEE_GET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Store halting mode
                 CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.) ! No halting
                 ... ! calculation without halting
                 CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Restore halting mode
           17.11.7   IEEE_GET_MODES (MODES)
        1 Description. Get ﬂoating-point modes.
        2 Class. Subroutine.
        3 Argument. MODES shall be a scalar of type IEEE_MODES_TYPE. It is an INTENT (OUT) argument that
           is assigned the value of the ﬂoating-point modes.
        4 Example. To save the ﬂoating-point modes, do a calculation with speciﬁc rounding and underﬂow modes, and
           restore them later:
                 USE, INTRINSIC :: IEEE_ARITHMETIC
                 TYPE (IEEE_MODES_TYPE) SAVE_MODES
                 ...
                 CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
                 CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO))
                 CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
                 ... ! calculation with abrupt round-to-zero.
                 CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
           17.11.8   IEEE_GET_ROUNDING_MODE (ROUND_VALUE [, RADIX])
        1 Description. Get rounding mode.
        2 Class. Subroutine.
        3 Arguments.
           ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It is an INTENT (OUT) argument. It is
                     assigned the value IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, IEEE_DOWN, or IEEE_-
                     AWAYif the corresponding rounding mode is in operation and IEEE_OTHER otherwise.
           RADIX(optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
                     the rounding mode queried is the decimal rounding mode, otherwise it is the binary rounding mode.
        4 Example. To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
           mode later:
                                                            c
           454                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
                 USE, INTRINSIC :: IEEE_ARITHMETIC
                 TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
                 ...
                 CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
                 CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
                 ... ! calculation with round to nearest
                 CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
           17.11.9   IEEE_GET_STATUS (STATUS_VALUE)
        1 Description. Get ﬂoating-point status.
        2 Class. Subroutine.
        3 Argument. STATUS_VALUE shall be a scalar of type IEEE_STATUS_TYPE. It is an INTENT (OUT)
           argument. It is assigned the value of the ﬂoating-point status.
        4 Example. To store all the exception ﬂags, do a calculation involving exception handling, and restore them later:
                 USE, INTRINSIC :: IEEE_ARITHMETIC
                 TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
                 ...
                 CALL IEEE_GET_STATUS (STATUS_VALUE) ! Get the flags
                 CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set the flags quiet.
                 ... ! calculation involving exception handling
                 CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
           17.11.10 IEEE_GET_UNDERFLOW_MODE (GRADUAL)
        1 Description. Get underﬂow mode.
        2 Class. Subroutine.
        3 Argument. GRADUAL shall be a logical scalar. It is an INTENT (OUT) argument. It is assigned the value
           true if the underﬂow mode is gradual underﬂow, and false if the underﬂow mode is abrupt underﬂow.
        4 Restriction. IEEE_GET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
           FLOW_CONTROL(X)istrue for some X.
        5 Example. After CALL IEEE_SET_UNDERFLOW_MODE (.FALSE.), a subsequent CALL IEEE_GET_-
           UNDERFLOW_MODE(GRADUAL)willsetGRADUALtofalse.
           17.11.11 IEEE_INT (A, ROUND [, KIND])
        1 Description. Conversion to integer type.
        2 Class. Elemental function.
        3 Arguments.
           A         shall be of type real.
           ROUND     shall be of type IEEE_ROUND_TYPE.
           KIND (optional) shall be a scalar integer constant expression.
        4 Restriction. IEEE_INT (A, ROUND, KIND) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
           the value false.
           c
           ISO/IEC 2017 – All rights reserved                                               455
         ISO/IEC DIS 1539-1:2017 (E)
       5 Result Characteristics. Integer. If KIND is present, the kind type parameter is that speciﬁed by the value of
         KIND; otherwise, the kind type parameter is that of default integer.
       6 Result Value. TheresulthasthevaluespeciﬁedbyISO/IEC/IEEE60559:2011fortheconvertToInteger{round}
         or the convertToIntegerExact{round} operation; the processor shall consistently choose which operation it
         provides. That is, the value of A is converted to an integer according to the rounding mode speciﬁed by ROUND;
         if this value is representable in the representation method of the result, the result has this value, otherwise IEEE_-
         INVALID is signaled and the result is processor dependent. If the processor provides the convertToIntegerExact
         operation, IEEE_INVALID did not signal, and the value of the result diﬀers from that of A, IEEE_INEXACT
         will be signaled.
       7 Example. The value of IEEE_INT (12.5, IEEE_UP) is 13; IEEE_INEXACT will be signaled if the processor
         provides the convertToIntegerExact operation.
         17.11.12 IEEE_IS_FINITE (X)
       1 Description. Whether a value is ﬁnite.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_IS_FINITE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
         false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value true if the value of X is ﬁnite, that is, IEEE_CLASS (X) has one
         of the values IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO,
         IEEE_POSITIVE_ZERO,IEEE_POSITIVE_SUBNORMAL,orIEEE_POSITIVE_NORMAL;otherwise,the
         result has the value false.
       7 Example. IEEE_IS_FINITE (1.0) has the value true.
         17.11.13 IEEE_IS_NAN (X)
       1 Description. Whether a value is an IEEE NaN.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_IS_NAN (X) shall not be invoked if IEEE_SUPPORT_NAN (X) has the value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value true if the value of X is an IEEE NaN; otherwise, it has the value false.
       7 Example. IEEE_IS_NAN (SQRT (−1.0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has the value
         true.
         17.11.14 IEEE_IS_NEGATIVE (X)
       1 Description. Whether a value is negative.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_IS_NEGATIVE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
         value false.
                                                  c
         456                                      ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
           5 Result Characteristics. Default logical.
           6 Result Value. The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
              NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO or IEEE_NEGATIVE_INF; oth-
              erwise, the result has the value false.
           7 Example. IEEE_IS_NEGATIVE (0.0) has the value false.
              17.11.15 IEEE_IS_NORMAL (X)
           1 Description. Whether a value is a normal number.
           2 Class. Elemental function.
           3 Argument. X shall be of type real.
           4 Restriction. IEEE_IS_NORMAL (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
              value false.
           5 Result Characteristics. Default logical.
           6 Result Value. The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
              NORMAL,IEEE_NEGATIVE_ZERO,IEEE_POSITIVE_ZEROorIEEE_POSITIVE_NORMAL;otherwise,
              the result has the value false.
           7 Example. IEEE_IS_NORMAL (SQRT (−1.0) has the value false if IEEE_SUPPORT_SQRT (1.0) has the
              value true.
              17.11.16 IEEE_LOGB (X)
           1 Description. Exponent.
           2 Class. Elemental function.
           3 Argument. X shall be of type real.
           4 Restriction. IEEE_LOGB (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
           5 Result Characteristics. Same as X.
           6 Result Value.
              Case (i):     If the value of X is neither zero, inﬁnity, nor NaN, the result has the value of the unbiased exponent
                            of X. Note: this value is equal to EXPONENT (X)− 1.
              Case (ii):    If X==0, the result is −inﬁnity if IEEE_SUPPORT_INF (X) is true and −HUGE (X) otherwise;
                            IEEE_DIVIDE_BY_ZERO signals.
              Case (iii):   If IEEE_SUPPORT_INF (X) is true and X is inﬁnite, the result is +inﬁnity.
              Case (iv):    If IEEE_SUPPORT_NAN (X) is true and X is a NaN, the result is a NaN.
           7 Example. IEEE_LOGB (−1.1) has the value 0.0.
              17.11.17 IEEE_MAX_NUM (X, Y)
           1 Description. Maximum numeric value.
           2 Class. Elemental function.
           3 Arguments.
              X             shall be of type real.
              Y             shall be of the same type and kind type parameter as X.
               c
              ISO/IEC 2017 – All rights reserved                                                                           457
           ISO/IEC DIS 1539-1:2017 (E)
         4 Restriction. IEEE_MAX_NUM shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
           false.
         5 Result Characteristics. Same as X.
         6 Result Value.  The result has the value speciﬁed for the maxNum operation in ISO/IEC/IEEE 60559:2011;
           that is,
              • if X < Y the result has the value of Y;
              • if Y < X the result has the value of X;
              • if exactly one of X and Y is a quiet NaN the result has the value of the other argument;
              • if one or both of X and Y are signaling NaNs, IEEE_INVALID signals and the result is a NaN;
              • otherwise, the result is either X or Y (processor dependent).
         7 Except when X or Y is a signaling NaN, no exception is signaled.
         8 Example. The value of IEEE_MAX_NUM (1.5, IEEE_VALUE (IEEE_QUIET_NAN)) is 1.5.
           17.11.18 IEEE_MAX_NUM_MAG (X, Y)
         1 Description. Maximum magnitude numeric value.
         2 Class. Elemental function.
         3 Arguments.
           X          shall be of type real.
           Y          shall be of the same type and kind type parameter as X.
         4 Restriction. IEEE_MAX_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
           value false.
         5 Result Characteristics. Same as X.
         6 Result Value. Theresult has the value speciﬁed for the maxNumMag operation in ISO/IEC/IEEE 60559:2011;
           that is,
              • if ABS (X) < ABS (Y) the result has the value of Y;
              • if ABS (Y) < ABS (X) the result has the value of X;
              • otherwise, the result has the value of IEEE_MAX_NUM (X, Y).
         7 Except when X or Y is a signaling NaN, no exception is signaled.
         8 Example. The value of IEEE_MAX_NUM_MAG (1.5, −2.5) is −2.5.
           17.11.19 IEEE_MIN_NUM (X, Y)
         1 Description. Minimum numeric value.
         2 Class. Elemental function.
         3 Arguments.
           X          shall be of type real.
           Y          shall be of the same type and kind type parameter as X.
         4 Restriction. IEEE_MIN_NUMshallnotbeinvokedifIEEE_SUPPORT_DATATYPE(X)hasthevaluefalse.
         5 Result Characteristics. Same as X.
                                                                c
           458                                                  ISO/IEC 2017 – All rights reserved
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
           6 Result Value.        The result has the value speciﬁed for the minNum operation in ISO/IEC/IEEE 60559:2011;
              that is,
                  • if X < Y the result has the value of X;
                  • if Y < X the result has the value of Y;
                  • if exactly one of X and Y is a quiet NaN the result has the value of the other argument;
                  • if one or both of X and Y are signaling NaNs, IEEE_INVALID signals and the result is a NaN;
                  • otherwise, the result is either X or Y (processor dependent).
           7 Except when X or Y is a signaling NaN, no exception is signaled.
           8 Example. The value of IEEE_MIN_NUM (1.5, IEEE_VALUE (IEEE_QUIET_NAN)) is 1.5.
              17.11.20 IEEE_MIN_NUM_MAG (X, Y)
           1 Description. Minimum magnitude numeric value.
           2 Class. Elemental function.
           3 Arguments.
              X              shall be of type real.
              Y              shall be of the same type and kind type parameter as X.
           4 Restriction. IEEE_MIN_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
              value false.
           5 Result Characteristics. Same as X.
           6 Result Value. The result has the value speciﬁed for the minNumMag operation in ISO/IEC/IEEE 60559:2011;
              that is,
                  • if ABS (X) < ABS (Y) the result has the value of X;
                  • if ABS (Y) < ABS (X) the result has the value of Y;
                  • otherwise, the result has the value of IEEE_MIN_NUM (X, Y).
           7 Except when X or Y is a signaling NaN, no exception is signaled.
           8 Example. The value of IEEE_MIN_NUM_MAG (1.5, −2.5) is 1.5.
              17.11.21 IEEE_NEXT_AFTER (X, Y)
           1 Description. Adjacent machine number.
           2 Class. Elemental function.
           3 Arguments. The arguments shall be of type real.
           4 Restriction. IEEE_NEXT_AFTER (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
              IEEE_SUPPORT_DATATYPE(Y)has the value false.
           5 Result Characteristics. Same as X.
           6 Result Value.
              Case (i):      If X == Y, the result is X and no exception is signaled.
              Case (ii):     If X 6= Y, the result has the value of the next representable neighbor of X in the direction of Y.
                             The neighbors of zero (of either sign) are both nonzero. IEEE_OVERFLOW is signaled when
                             X is ﬁnite but IEEE_NEXT_AFTER (X, Y) is inﬁnite; IEEE_UNDERFLOW is signaled when
                             IEEE_NEXT_AFTER(X,Y)is subnormal; in both cases, IEEE_INEXACT signals.
               c
              ISO/IEC 2017 – All rights reserved                                                                              459
         ISO/IEC DIS 1539-1:2017 (E)
       7 Example. The value of IEEE_NEXT_AFTER (1.0, 2.0) is 1.0 + EPSILON (X).
         17.11.22 IEEE_NEXT_DOWN (X)
       1 Description. Adjacent lower machine number.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_NEXT_DOWN (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
         value false. IEEE_NEXT_DOWN (−HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the
         value false.
       5 Result Characteristics. Same as X.
       6 Result Value. The result has the value speciﬁed for the nextDown operation in ISO/IEC/IEEE 60559:2011;
         that is, it is the greatest value in the representation method of X that compares less than X, except when X is
         equal to −∞ the result has the value −∞, and when X is a NaN the result is a NaN. If X is a signaling NaN,
         IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. If IEEE_SUPPORT_SUBNORMAL (0.0) is true, the value of IEEE_NEXT_DOWN (+0.0) is the
         negative subnormal number with least magnitude.
         17.11.23 IEEE_NEXT_UP (X)
       1 Description. Adjacent higher machine number.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
       4 Restriction. IEEE_NEXT_UP (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
         false. IEEE_NEXT_UP (HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the value false.
       5 Result Characteristics. Same as X.
       6 Result Value. The result has the value speciﬁed for the nextUp operation in ISO/IEC/IEEE 60559:2011; that
         is, it is the least value in the representation method of X that compares greater than X, except when X is
         equal to +∞ the result has the value +∞, and when X is a NaN the result is a NaN. If X is a signaling NaN,
         IEEE_INVALID_signals; otherwise, no exception is signaled.
       7 Example. If IEEE_SUPPORT_INF (X) is true, the value of IEEE_NEXT_UP (HUGE (X)) is +∞.
         17.11.24 IEEE_QUIET_EQ (A, B)
       1 Description. Quiet compares equal.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
                                                  c
         460                                      ISO/IEC 2017 – All rights reserved
                                                         ISO/IEC DIS 1539-1:2017 (E)
       6 Result Value. The result has the value speciﬁed for the compareQuietEqual operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be false. If
         Aor B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_EQ(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandnoexception
         is signaled.
         17.11.25 IEEE_QUIET_GE (A, B)
       1 Description. Quiet compares greater than or equal.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
       6 ResultValue. TheresulthasthevaluespeciﬁedforthecompareQuietGreaterEqualoperationinISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares greater than or equal to B. If A or B is a NaN, the result
         will be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_GE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandnoexception
         is signaled.
         17.11.26 IEEE_QUIET_GT (A, B)
       1 Description. Quiet compares greater than.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareQuietGreater operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will be
         false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_GT(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandnoexception
         is signaled.
         17.11.27 IEEE_QUIET_LE (A, B)
       1 Description. Quiet compares less than or equal.
       2 Class. Elemental function.
          c
         ISO/IEC 2017 – All rights reserved                                  461
         ISO/IEC DIS 1539-1:2017 (E)
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareQuietLessEqual operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the result will
         be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_LE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandnoexception
         is signaled.
         17.11.28 IEEE_QUIET_LT (A, B)
       1 Description. Quiet compares less than.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareQuietLess operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be
         false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_LT(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandnoexception
         is signaled.
         17.11.29 IEEE_QUIET_NE (A, B)
       1 Description. Quiet compares not equal.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall have the same type and kind type parameter as A.
       4 Restriction. IEEE_QUIET_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
         value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareQuietNotEqual operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will be true.
         If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_QUIET_NE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluetrueandnoexception
         is signaled.
                                                   c
         462                                      ISO/IEC 2017 – All rights reserved
                                                                       ISO/IEC DIS 1539-1:2017 (E)
           17.11.30 IEEE_REAL (A [, KIND])
         1 Description. Conversion to real type.
         2 Class. Elemental function.
         3 Arguments.
           A          shall be of type integer or real.
           KIND (optional) shall be a scalar integer constant expression.
         4 Restriction. IEEE_REAL shall not be invoked if A is of type real and IEEE_SUPPORT_DATATYPE (A)
           has the value false, or if IEEE_SUPPORT_DATATYPE (IEEE_REAL (A, KIND)) has the value false.
         5 Result Characteristics. Real. If KIND is present, the kind type parameter is that speciﬁed by the value of
           KIND; otherwise, the kind type parameter is that of default real.
         6 Result Value. The result has the same value as A if that value is representable in the representation method
           of the result, and is rounded according to the rounding mode otherwise. This shall be consistent with the
           speciﬁcation of ISO/IEC/IEEE 60559:2011 for the convertFromInt operation when A is of type integer, and with
           the convertFormat operation otherwise.
         7 Example. The value of IEEE_REAL (123) is 123.0.
           17.11.31 IEEE_REM (X, Y)
         1 Description. Exact remainder.
         2 Class. Elemental function.
         3 Arguments. The arguments shall be of type real and have the same radix.
         4 Restriction. IEEE_REM (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or IEEE_SUP-
           PORT_DATATYPE(Y)hasthe value false.
         5 Result Characteristics. Real with the kind type parameter of whichever argument has the greater precision.
         6 Result Value. This function computes the remainder operation speciﬁed in ISO/IEC/IEEE 60559:2011.
         7 The result value when X and Y are ﬁnite, and Y is nonzero, regardless of the rounding mode, shall be exactly X
           −Y*N,where N is the integer nearest to the exact value X/Y; whenever |N−X/Y| = 1, N shall be even. If the
           result value is zero, the sign shall be that of X.                     2
         8 When X is ﬁnite and Y is inﬁnite, the result value is X. If Y is zero or X is inﬁnite, and neither is a NaN, the
           IEEE_INVALID exception shall occur; if IEEE_SUPPORT_NAN(X+Y) is true, the result is a NaN. If X is
           subnormal and Y is inﬁnite, the IEEE_UNDERFLOW exception shall occur. No exception shall signal if X is
           ﬁnite and normal, and Y is inﬁnite.
         9 Examples. The value of IEEE_REM (4.0, 3.0) is 1.0, the value of IEEE_REM (3.0, 2.0) is −1.0, and the value
           of IEEE_REM (5.0, 2.0) is 1.0.
           17.11.32 IEEE_RINT (X [, ROUND])
         1 Description. Round to integer.
         2 Class. Elemental function.
         3 Arguments.
           X          shall be of type real.
           ROUND(optional) shall be of type IEEE_ROUND_TYPE.
            c
           ISO/IEC 2017 – All rights reserved                                                     463
               ISO/IEC DIS 1539-1:2017 (E)
            4 Restriction. IEEE_RINT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
            5 Result Characteristics. Same as X.
            6 Result Value. If ROUND is present, the value of the result is the value of X rounded to an integer according
               to the mode speciﬁed by ROUND; this is the ISO/IEC/IEEE 60559:2011 operation roundToInteger{rounding}.
               Otherwise, the value of the result is that speciﬁed for the operation roundIntegralToExact in ISO/IEC/IEEE
               60559:2011; this is the value of X rounded to an integer according to the rounding mode. If the result has the
               value zero, the sign is that of X.
            7 Examples. If the rounding mode is round to nearest, the value of IEEE_RINT (1.1) is 1.0. The value of
               IEEE_RINT (1.1, IEEE_UP) is 2.0.
               17.11.33 IEEE_SCALB (X, I)
                                     I
            1 Description. X ×2 .
            2 Class. Elemental function.
            3 Arguments.
               X             shall be of type real.
               I             shall be of type integer.
            4 Restriction. IEEE_SCALB(X)shallnotbeinvokedifIEEE_SUPPORT_DATATYPE(X)hasthevaluefalse.
            5 Result Characteristics. Same as X.
            6 Result Value.
                                      I
               Case (i):     If X ×2 is representable as a normal number, the result has this value.
                                                       I
               Case (ii):    If X is ﬁnite and X × 2 is too large, the IEEE_OVERFLOW exception shall occur. If IEEE_-
                             SUPPORT_INF (X) is true, the result value is inﬁnity with the sign of X; otherwise, the result
                             value is SIGN (HUGE (X), X).
                                      I
               Case (iii):   If X×2 is too small and there is loss of accuracy, the IEEE_UNDERFLOW exception shall occur.
                                                                                                           I
                             The result is the representable number having a magnitude nearest to |2 | and the same sign as X.
               Case (iv):    If X is inﬁnite, the result is the same as X; no exception signals.
            7 Example. The value of IEEE_SCALB (1.0, 2) is 4.0.
               17.11.34 IEEE_SELECTED_REAL_KIND ([P, R, RADIX])
            1 Description. IEEE kind type parameter value.
            2 Class. Transformational function.
            3 Arguments. At least one argument shall be present.
               P(optional) shall be an integer scalar.
               R(optional) shall be an integer scalar.
               RADIX(optional) shall be an integer scalar.
            4 Result Characteristics. Default integer scalar.
            5 Result Value. If P or R is absent, the result value is the same as if it were present with the value zero. If
               RADIX is absent, there is no requirement on the radix of the selected kind. The result has a value equal to a
               value of the kind type parameter of an ISO/IEC/IEEE 60559:2011 ﬂoating-point format with decimal precision,
               as returned by the intrinsic function PRECISION, of at least P digits, a decimal exponent range, as returned
               by the intrinsic function RANGE, of at least R, and a radix, as returned by the intrinsic function RADIX, of
               RADIX, if such a kind type parameter is available on the processor.
                                                                                     c
               464                                                                  ISO/IEC 2017 – All rights reserved
                                                      ISO/IEC DIS 1539-1:2017 (E)
       6 Otherwise, the result is −1 if the processor supports an IEEE real type with radix RADIX and exponent range
         of at least R but not with precision of at least P, −2 if the processor supports an IEEE real type with radix
         RADIX and precision of at least P but not with exponent range of at least R, −3 if the processor supports an
         IEEEreal type with radix RADIX but with neither precision of at least P nor exponent range of at least R, −4 if
         the processor supports an IEEE real type with radix RADIX and either precision of at least P or exponent range
         of at least R but not both together, and −5 if the processor supports no IEEE real type with radix RADIX.
       7 If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
         decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
       8 Example. IEEE_SELECTED_REAL_KIND (6, 30) has the value KIND (0.0) on a machine that supports
         ISO/IEC/IEEE 60559:2011 single precision arithmetic for its default real approximation method.
         17.11.35 IEEE_SET_FLAG (FLAG, FLAG_VALUE)
       1 Description. Set an exception ﬂag.
       2 Class. Pure subroutine.
       3 Arguments.
         FLAG    shall be a scalar or array of type IEEE_FLAG_TYPE. If a value of FLAG is IEEE_INVALID,
                 IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT,
                 the corresponding exception ﬂag is assigned a value. No two elements of FLAG shall have the same
                 value.
         FLAG_VALUE shallbealogicalscalar or array. It shall be conformable with FLAG. If an element has the value
                 true, the corresponding ﬂag is set to be signaling; otherwise, the ﬂag is set to be quiet.
       4 Example. CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .TRUE.) sets the IEEE_OVERFLOW ﬂag to be
         signaling.
         17.11.36 IEEE_SET_HALTING_MODE (FLAG, HALTING)
       1 Description. Set a halting mode.
       2 Class. Pure subroutine.
       3 Arguments.
         FLAG    shall be a scalar or array of type IEEE_FLAG_TYPE. It shall have only the values IEEE_-
                 INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
                 INEXACT. No two elements of FLAG shall have the same value.
         HALTING shall be a logical scalar or array. It shall be conformable with FLAG. If an element has the value
                 true, the corresponding exception speciﬁed by FLAG will cause halting. Otherwise, execution will
                 continue after this exception.
       4 Restriction. IEEE_SET_HALTING_MODE(FLAG,HALTING)shallnot be invoked if IEEE_SUPPORT_-
         HALTING(FLAG) has the value false.
       5 Example. CALL IEEE_SET_HALTING_MODE (IEEE_DIVIDE_BY_ZERO, .TRUE.) causes halting after
         a divide_by_zero exception.
         17.11.37 IEEE_SET_MODES (MODES)
       1 Description. Set ﬂoating-point modes.
       2 Class. Subroutine.
       3 Argument. MODES shall be a scalar of type IEEE_MODES_TYPE. Its value shall be one that was assigned
         c
         ISO/IEC 2017 – All rights reserved                               465
        ISO/IEC DIS 1539-1:2017 (E)
        by a previous invocation of IEEE_GET_MODES to its MODES argument. The ﬂoating-point modes (17.7) are
        restored to the state at that invocation.
       4 Example.
        To save the ﬂoating-point modes, do a calculation with speciﬁc rounding and underﬂow modes, and restore them
        later:
              USE, INTRINSIC :: IEEE_ARITHMETIC
              TYPE (IEEE_MODES_TYPE) SAVE_MODES
              ...
              CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
              CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO))
              CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
              ... ! calculation with abrupt round-to-zero.
              CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
        17.11.38 IEEE_SET_ROUNDING_MODE (ROUND_VALUE [, RADIX])
       1 Description. Set rounding mode.
       2 Class. Subroutine.
       3 Arguments.
        ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It speciﬁes the rounding mode to be set.
        RADIX(optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
                 the rounding mode set is the decimal rounding mode; otherwise it is the binary rounding mode.
       4 Restriction. IEEE_SET_ROUNDING_MODE (ROUND_VALUE) shall not be invoked unless IEEE_SUP-
        PORT_ROUNDING(ROUND_VALUE, X) is true for some X such that IEEE_SUPPORT_DATATYPE (X)
        is true. IEEE_SET_ROUNDING_MODE (ROUND_VALUE, RADIX) shall not be invoked unless IEEE_-
        SUPPORT_ROUNDING (ROUND_VALUE, X) is true for some X with radix RADIX such that IEEE_SUP-
        PORT_DATATYPE(X)is true.
       5 Example. To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
        mode later:
              USE, INTRINSIC :: IEEE_ARITHMETIC
              TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
              ...
              CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
              CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
              ... ! calculation with round to nearest
              CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
        17.11.39 IEEE_SET_STATUS (STATUS_VALUE)
       1 Description. Restore ﬂoating-point status.
       2 Class. Subroutine.
       3 Argument. STATUS_VALUEshallbeascalar of type IEEE_STATUS_TYPE. Its value shall be one that was
        assigned by a previous invocation of IEEE_GET_STATUS to its STATUS_VALUE argument. The ﬂoating-
        point status (17.7 is restored to the state at that invocation).
                                               c
        466                                    ISO/IEC 2017 – All rights reserved
                                                        ISO/IEC DIS 1539-1:2017 (E)
       4 Example. To store all the exceptions ﬂags, do a calculation involving exception handling, and restore them
         later:
              USE, INTRINSIC :: IEEE_EXCEPTIONS
              TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
              ...
              CALL IEEE_GET_STATUS (STATUS_VALUE) ! Store the flags
              CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set them quiet
              ... ! calculation involving exception handling
              CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
         17.11.40 IEEE_SET_UNDERFLOW_MODE (GRADUAL)
       1 Description. Set underﬂow mode.
       2 Class. Subroutine.
       3 Argument. GRADUAL shall be a logical scalar. If it is true, the underﬂow mode is set to gradual underﬂow.
         If it is false, the underﬂow mode is set to abrupt underﬂow.
       4 Restriction. IEEE_SET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
         FLOW_CONTROL(X)istrue for some X.
       5 Example. To perform some calculations with abrupt underﬂow and then restore the previous mode:
              USE, INTRINSIC :: IEEE_ARITHMETIC
              LOGICAL SAVE_UNDERFLOW_MODE
              ...
              CALL IEEE_GET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
              CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
              ... ! Perform some calculations with abrupt underflow
              CALL IEEE_SET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
         17.11.41 IEEE_SIGNALING_EQ (A, B)
       1 Description. Signaling compares equal.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall be of the same type and kind type parameter as A.
       4 Restriction. IEEE_SIGNALING_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
         the value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareSignalingEqual operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be false
         and IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_SIGNALING_EQ(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandsignals
         IEEE_INVALID.
         c
         ISO/IEC 2017 – All rights reserved                                  467
           ISO/IEC DIS 1539-1:2017 (E)
           17.11.42 IEEE_SIGNALING_GE (A, B)
         1 Description. Signaling compares greater than or equal.
         2 Class. Elemental function.
         3 Arguments.
           A          shall be of type real.
           B          shall be of the same type and kind type parameter as A.
         4 Restriction. IEEE_SIGNALING_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
           the value false.
         5 Result Characteristics. Default logical.
         6 Result Value.  The result has the value speciﬁed for the compareSignalingGreaterEqual operation in
           ISO/IEC/IEEE 60559:2011; that is, it is true if and only if A compares greater than or equal to B. If A or
           Bis a NaN, the result will be false and IEEE_INVALID signals; otherwise, no exception is signaled.
         7 Example. IEEE_SIGNALING_GE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandsignals
           IEEE_INVALID.
           17.11.43 IEEE_SIGNALING_GT (A, B)
         1 Description. Signaling compares greater than.
         2 Class. Elemental function.
         3 Arguments.
           A          shall be of type real.
           B          shall be of the same type and kind type parameter as A.
         4 Restriction. IEEE_SIGNALING_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
           the value false.
         5 Result Characteristics. Default logical.
         6 Result Value. The result has the value speciﬁed for the compareSignalingGreater operation in ISO/IEC/IEEE
           60559:2011; that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will be false
           and IEEE_INVALID signals; otherwise, no exception is signaled.
         7 Example. IEEE_SIGNALING_GT(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandsignals
           IEEE_INVALID.
           17.11.44 IEEE_SIGNALING_LE (A, B)
         1 Description. Signaling compares less than or equal.
         2 Class. Elemental function.
         3 Arguments.
           A          shall be of type real.
           B          shall be of the same type and kind type parameter as A.
         4 Restriction. IEEE_SIGNALING_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
           the value false.
         5 Result Characteristics. Default logical.
                                                              c
           468                                               ISO/IEC 2017 – All rights reserved
                                                         ISO/IEC DIS 1539-1:2017 (E)
       6 ResultValue. TheresulthasthevaluespeciﬁedforthecompareSignalingLessEqualoperationinISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the result will
         be false and IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_SIGNALING_LE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandsignals
         IEEE_INVALID.
         17.11.45 IEEE_SIGNALING_LT (A, B)
       1 Description. Signaling compares less than.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall be of the same type and kind type parameter as A.
       4 Restriction. IEEE_SIGNALING_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
         the value false.
       5 Result Characteristics. Default logical.
       6 Result Value. The result has the value speciﬁed for the compareSignalingLess operation in ISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be false
         and IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_SIGNALING_LT(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluefalseandsignals
         IEEE_INVALID.
         17.11.46 IEEE_SIGNALING_NE (A, B)
       1 Description. Signaling compares not equal.
       2 Class. Elemental function.
       3 Arguments.
         A        shall be of type real.
         B        shall be of the same type and kind type parameter as A.
       4 Restriction. IEEE_SIGNALING_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
         the value false.
       5 Result Characteristics. Default logical.
       6 Result Value. TheresulthasthevaluespeciﬁedforthecompareSignalingNotEqualoperationinISO/IEC/IEEE
         60559:2011; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will be true
         and IEEE_INVALID signals; otherwise, no exception is signaled.
       7 Example. IEEE_SIGNALING_NE(1.0,IEEE_VALUE(IEEE_QUIET_NAN))hasthevaluetrueandsignals
         IEEE_INVALID.
         17.11.47 IEEE_SIGNBIT (X)
       1 Description. Test sign bit.
       2 Class. Elemental function.
       3 Argument. X shall be of type real.
          c
         ISO/IEC 2017 – All rights reserved                                   469
              ISO/IEC DIS 1539-1:2017 (E)
           4 Restriction. IEEE_SIGNBIT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
              false.
           5 Result Characteristics. Default logical.
           6 Result Value. The result has the value speciﬁed for the isSignMinus operation in ISO/IEC/IEEE 60559:2011;
              that is, it is true if and only if the sign bit of X is nonzero. No exception is signaled even if X is a signaling NaN.
           7 Example. IEEE_SIGNBIT (−1.0) has the value true.
              17.11.48 IEEE_SUPPORT_DATATYPE () or
                            IEEE_SUPPORT_DATATYPE (X)
           1 Description. Query IEEE arithmetic support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value. The result has the value true if the processor supports IEEE arithmetic for all reals (X does
              not appear) or for real variables of the same kind type parameter as X; otherwise, it has the value false. Here,
              support is as deﬁned in the ﬁrst paragraph of 17.9.
           6 Example. If default real kind conforms to ISO/IEC/IEEE 60559:2011 except that underﬂow values ﬂush to zero
              instead of being subnormal, IEEE_SUPPORT_DATATYPE (1.0) has the value true.
              17.11.49 IEEE_SUPPORT_DENORMAL () or
                            IEEE_SUPPORT_DENORMAL (X)
           1 Description. Query subnormal number support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_DENORMAL(X)hasthevaluetrueifIEEE_SUPPORT_DATATYPE(X)has
                            the value true and the processor supports arithmetic operations and assignments with subnormal
                            numbers(biasedexponente = 0andfractionf 6= 0, seesubclause3.2ofISO/IEC/IEEE60559:2011)
                            for real variables of the same kind type parameter as X; otherwise, it has the value false.
              Case (ii):    IEEE_SUPPORT_DENORMAL()hasthevaluetrueifIEEE_SUPPORT_DENORMAL(X)has
                            the value true for all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_DENORMAL (X) has the value true if the processor supports subnormal values
              for X.
                   NOTE17.12
                   Areference to IEEE_SUPPORT_DENORMAL will have the same result value as a reference to IEEE_-
                   SUPPORT_SUBNORMALwiththesame argument list.
                                                                                c
              470                                                              ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              17.11.50 IEEE_SUPPORT_DIVIDE () or IEEE_SUPPORT_DIVIDE (X)
           1 Description. Query IEEE division support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_DIVIDE (X) has the value true if the processor supports division with the
                            accuracy speciﬁed by ISO/IEC/IEEE 60559:2011 for real variables of the same kind type parameter
                            as X; otherwise, it has the value false.
              Case (ii):    IEEE_SUPPORT_DIVIDE()has the value true if IEEE_SUPPORT_DIVIDE (X) has the value
                            true for all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_DIVIDE (X) has the value true if division of operands with the same kind as X
              conforms to ISO/IEC/IEEE 60559:2011.
              17.11.51 IEEE_SUPPORT_FLAG (FLAG) or IEEE_SUPPORT_FLAG (FLAG,
                            X)
           1 Description. Query exception support.
           2 Class. Transformational function.
           3 Arguments.
              FLAG          shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID, IEEE_-
                            OVERFLOW,IEEE_DIVIDE_BY_ZERO,IEEE_UNDERFLOW,orIEEE_INEXACT.
              X             shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_FLAG(FLAG,X)hasthevalue true if the processor supports detection of the
                            speciﬁed exception for real variables of the same kind type parameter as X; otherwise, it has the
                            value false.
              Case (ii):    IEEE_SUPPORT_FLAG(FLAG)hasthevaluetrueif IEEE_SUPPORT_FLAG(FLAG,X)has
                            the value true for all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_FLAG(IEEE_INEXACT)hasthevaluetrueiftheprocessorsupportstheinexact
              exception.
              17.11.52 IEEE_SUPPORT_HALTING (FLAG)
           1 Description. Query halting mode support.
           2 Class. Transformational function.
           3 Argument. FLAG shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID,
              IEEE_OVERFLOW,IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT.
           4 Result Characteristics. Default logical scalar.
           5 Result Value. The result has the value true if the processor supports the ability to control during program
              execution whether to abort or continue execution after the exception speciﬁed by FLAG; otherwise, it has the
              value false. Support includes the ability to change the mode by CALL IEEE_SET_HALTING_MODE (FLAG).
               c
              ISO/IEC 2017 – All rights reserved                                                                           471
              ISO/IEC DIS 1539-1:2017 (E)
           6 Example. IEEE_SUPPORT_HALTING (IEEE_OVERFLOW) has the value true if the processor supports
              control of halting after an overﬂow.
              17.11.53 IEEE_SUPPORT_INF () or IEEE_SUPPORT_INF (X)
           1 Description. Query IEEE inﬁnity support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE inﬁnities (positive
                            and negative) for real variables of the same kind type parameter as X; otherwise, it has the value
                            false.
              Case (ii):    IEEE_SUPPORT_INF () has the value true if IEEE_SUPPORT_INF (X) has the value true for
                            all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE inﬁnities for X.
              17.11.54 IEEE_SUPPORT_IO () or IEEE_SUPPORT_IO (X)
           1 Description. Query IEEE formatting support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_IO (X) has the value true if base conversion during formatted input/output
                            (12.5.6.16, 12.6.2.13, 13.7.2.3.8) conforms to ISO/IEC/IEEE 60559:2011 for the modes UP, DOWN,
                            ZERO, and NEAREST for real variables of the same kind type parameter as X; otherwise, it has
                            the value false.
              Case (ii):    IEEE_SUPPORT_IO() has the value true if IEEE_SUPPORT_IO (X) has the value true for all
                            real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_IO (X) has the value true if formatted input/output base conversions conform to
              ISO/IEC/IEEE 60559:2011.
              17.11.55 IEEE_SUPPORT_NAN () or IEEE_SUPPORT_NAN (X)
           1 Description. Query IEEE NaN support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for real
                            variables of the same kind type parameter as X; otherwise, it has the value false.
              Case (ii):    IEEE_SUPPORT_NAN () has the value true if IEEE_SUPPORT_NAN (X) has the value true
                            for all real X; otherwise, it has the value false.
                                                                                c
              472                                                              ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
           6 Example. IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for X.
              17.11.56 IEEE_SUPPORT_ROUNDING (ROUND_VALUE) or
                            IEEE_SUPPORT_ROUNDING (ROUND_VALUE, X)
           1 Description. Query IEEE rounding support.
           2 Class. Transformational function.
           3 Arguments.
              ROUND_VALUE shall be of type IEEE_ROUND_TYPE.
              X             shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_ROUNDING(ROUND_VALUE,X)hasthevaluetrueiftheprocessorsupports
                            the rounding mode deﬁned by ROUND_VALUE for real variables of the same kind type parameter
                            as X; otherwise, it has the value false. Support includes the ability to change the mode by CALL
                            IEEE_SET_ROUNDING_MODE(ROUND_VALUE).
              Case (ii):    IEEE_SUPPORT_ROUNDING (ROUND_VALUE) has the value true if IEEE_SUPPORT_-
                            ROUNDING (ROUND_VALUE, X) has the value true for all real X; otherwise, it has the value
                            false.
           6 Example. IEEE_SUPPORT_ROUNDING (IEEE_TO_ZERO) has the value true if the processor supports
              rounding to zero for all reals.
              17.11.57 IEEE_SUPPORT_SQRT () or IEEE_SUPPORT_SQRT (X)
           1 Description. Query IEEE square root support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_SQRT (X) has the value true if the intrinsic function SQRT conforms to
                            ISO/IEC/IEEE 60559:2011 for real variables of the same kind type parameter as X; otherwise,
                            it has the value false.
              Case (ii):    IEEE_SUPPORT_SQRT()hasthevaluetrue if IEEE_SUPPORT_SQRT (X) has the value true
                            for all real X; otherwise, it has the value false.
           6 Example. If IEEE_SUPPORT_SQRT (1.0) has the value true, SQRT (−0.0) will have the value −0.0.
              17.11.58 IEEE_SUPPORT_STANDARD () or
                            IEEE_SUPPORT_STANDARD (X)
           1 Description. Query IEEE standard support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
               c
              ISO/IEC 2017 – All rights reserved                                                                           473
              ISO/IEC DIS 1539-1:2017 (E)
           5 Result Value.
              Case (i):     IEEE_SUPPORT_STANDARD (X) has the value true if the results of all the func-
                            tions IEEE_SUPPORT_DATATYPE (X), IEEE_SUPPORT_DIVIDE (X), IEEE_SUPPORT_-
                            FLAG(FLAG,X)forvalidFLAG,IEEE_SUPPORT_HALTING(FLAG)forvalidFLAG,IEEE_-
                            SUPPORT_INF(X), IEEE_SUPPORT_NAN (X), IEEE_SUPPORT_ROUNDING (ROUND_-
                            VALUE, X) for valid ROUND_VALUE, IEEE_SUPPORT_SQRT (X), and IEEE_SUPPORT_-
                            SUBNORMAL(X)areall true; otherwise, it has the value false.
              Case (ii):    IEEE_SUPPORT_STANDARD () has the value true if IEEE_SUPPORT_STANDARD (X) has
                            the value true for all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_STANDARD () has the value false if some but not all kinds of reals conform to
              ISO/IEC/IEEE 60559:2011.
              17.11.59 IEEE_SUPPORT_SUBNORMAL () or
                            IEEE_SUPPORT_SUBNORMAL (X)
           1 Description. Query subnormal number support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_SUBNORMAL (X) has the value true if IEEE_SUPPORT_DATATYPE (X)
                            hasthevaluetrueandtheprocessorsupportsarithmeticoperationsandassignmentswithsubnormal
                            numbers(biasedexponente = 0andfractionf 6= 0, seesubclause3.2ofISO/IEC/IEEE60559:2011)
                            for real variables of the same kind type parameter as X; otherwise, it has the value false.
              Case (ii):    IEEE_SUPPORT_SUBNORMAL () has the value true if IEEE_SUPPORT_SUBNORMAL (X)
                            has the value true for all real X; otherwise, it has the value false.
           6 Example. IEEE_SUPPORT_SUBNORMAL(X)hasthevaluetrueiftheprocessor supports subnormal values
              for X.
                   NOTE17.13
                   The subnormal numbers are not included in the 16.4 model for real numbers; they satisfy the inequality
                   ABS (X) < TINY (X). They usually occur as a result of an arithmetic operation whose exact result is
                   less than TINY (X). Such an operation causes IEEE_UNDERFLOW to signal unless the result is exact.
                   IEEE_SUPPORT_SUBNORMAL (X) is false if the processor never returns a subnormal number as the
                   result of an arithmetic operation.
              17.11.60 IEEE_SUPPORT_UNDERFLOW_CONTROL () or
                            IEEE_SUPPORT_UNDERFLOW_CONTROL (X)
           1 Description. Query underﬂow control support.
           2 Class. Inquiry function.
           3 Argument. X shall be of type real. It may be a scalar or an array.
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     IEEE_SUPPORT_UNDERFLOW_CONTROL (X) has the value true if the processor supports
                            control of the underﬂow mode for ﬂoating-point calculations with the same type as X, and false
                            otherwise.
                                                                                c
              474                                                              ISO/IEC 2017 – All rights reserved
                                                                                            ISO/IEC DIS 1539-1:2017 (E)
              Case (ii):     IEEE_SUPPORT_UNDERFLOW_CONTROL () has the value true if the processor supports
                             control of the underﬂow mode for all ﬂoating-point calculations, and false otherwise.
           6 Example. IEEE_SUPPORT_UNDERFLOW_CONTROL (2.5) has the value true if the processor supports
              underﬂow mode control for default real calculations.
              17.11.61 IEEE_UNORDERED (X, Y)
           1 Description. Whether two values are unordered.
           2 Class. Elemental function.
           3 Arguments. The arguments shall be of type real.
           4 Restriction. IEEE_UNORDERED (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
              IEEE_SUPPORT_DATATYPE(Y)has the value false.
           5 Result Characteristics. Default logical.
           6 Result Value. The result has the value true if X or Y is a NaN or both are NaNs; otherwise, it has the value
              false. If X or Y is a signaling NaN, IEEE_INVALID may signal.
           7 Example. IEEE_UNORDERED (0.0, SQRT (−1.0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has
              the value true.
              17.11.62 IEEE_VALUE (X, CLASS)
           1 Description. Return number in a class.
           2 Class. Elemental function.
           3 Arguments.
              X              shall be of type real.
              CLASS          shall be of type IEEE_CLASS_TYPE. The value is permitted to be: IEEE_SIGNALING_NAN or
                             IEEE_QUIET_NANifIEEE_SUPPORT_NAN(X)hasthevaluetrue,IEEE_NEGATIVE_INF
                             or IEEE_POSITIVE_INFifIEEE_SUPPORT_INF(X)hasthevaluetrue,IEEE_NEGATIVE_-
                             SUBNORMALorIEEE_POSITIVE_SUBNORMALifIEEE_SUPPORT_SUBNORMAL(X)has
                             the value true, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_-
                             ZEROorIEEE_POSITIVE_NORMAL.
           4 Restriction. IEEE_VALUE (X, CLASS) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
              value false.
           5 Result Characteristics. Same as X.
           6 Result Value. The result value is an IEEE value as speciﬁed by CLASS. Although in most cases the value is
              processor dependent, the value shall not vary between invocations for any particular X kind type parameter and
              CLASS value.
           7 Example. IEEE_VALUE (1.0, IEEE_NEGATIVE_INF) has the value −inﬁnity.
           8 Whenever IEEE_VALUE returns a signaling NaN, it is processor dependent whether or not invalid is raised and
              processor dependent whether or not the signaling NaN is converted into a quiet NaN.
                    NOTE17.14
                    If the expr in an assignment statement is a reference to the IEEE_VALUE function that returns a signaling
                    NaN and the variable is of the same type and kind as the function result, it is recommended that the
                    signaling NaN be preserved.
               c
              ISO/IEC 2017 – All rights reserved                                                                              475
         ISO/IEC DIS 1539-1:2017 (E)
         17.12  Examples
            NOTE17.15
                 MODULE DOT
                   ! Module for dot product of two real arrays of rank 1.
                   ! The caller needs to ensure that exceptions do not cause halting.
                   USE, INTRINSIC :: IEEE_EXCEPTIONS
                   LOGICAL :: MATRIX_ERROR = .FALSE.
                   INTERFACE OPERATOR(.dot.)
                     MODULE PROCEDURE MULT
                   END INTERFACE
                 CONTAINS
                   REAL FUNCTION MULT (A, B)
                     REAL, INTENT (IN) :: A(:), B(:)
                     INTEGER I
                     LOGICAL OVERFLOW
                     IF (SIZE(A) /= SIZE(B)) THEN
                       MATRIX_ERROR = .TRUE.
                       RETURN
                     END IF
                     ! The processor ensures that IEEE_OVERFLOW is quiet.
                     MULT = 0.0
                     DO I = 1, SIZE (A)
                       MULT = MULT + A(I)*B(I)
                     END DO
                     CALL IEEE_GET_FLAG (IEEE_OVERFLOW, OVERFLOW)
                     IF (OVERFLOW) MATRIX_ERROR = .TRUE.
                   END FUNCTION MULT
                 END MODULE DOT
            This module provides a function that computes the dot product of two real arrays of rank 1. If the sizes
            of the arrays are diﬀerent, an immediate return occurs with MATRIX_ERROR true. If overﬂow occurs
            during the actual calculation, the IEEE_OVERFLOW ﬂag will signal and MATRIX_ERROR will be true.
            NOTE17.16
                 USE, INTRINSIC :: IEEE_EXCEPTIONS
                 USE, INTRINSIC :: IEEE_FEATURES, ONLY: IEEE_INVALID_FLAG
                 ! The other exceptions of IEEE_USUAL (IEEE_OVERFLOW and
                 ! IEEE_DIVIDE_BY_ZERO) are always available with IEEE_EXCEPTIONS
                 TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
                 LOGICAL, DIMENSION(3) :: FLAG_VALUE
                 ...
                 CALL IEEE_GET_STATUS (STATUS_VALUE)
                 CALL IEEE_SET_HALTING_MODE (IEEE_USUAL, .FALSE.) ! Needed in case the
                 !            default on the processor is to halt on exceptions
                 CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
                                                c
         476                                    ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
         NOTE17.16 (cont.)
            ! First try the "fast" algorithm for inverting a matrix:
            MATRIX1 = FAST_INV (MATRIX) ! This shall not alter MATRIX.
            CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
            IF (ANY(FLAG_VALUE)) THEN
              ! "Fast" algorithm failed; try "slow" one:
              CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
              MATRIX1 = SLOW_INV (MATRIX)
              CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
              IF (ANY (FLAG_VALUE)) THEN
               WRITE (*, *) ’Cannot invert matrix’
               STOP
              END IF
            END IF
            CALL IEEE_SET_STATUS (STATUS_VALUE)
        In this example, the function FAST_INV might cause a condition to signal. If it does, another try is made
        with SLOW_INV. If this still fails, a message is printed and the program stops. Note, also, that it is
        important to set the ﬂags quiet before the second try. The state of all the ﬂags is stored and restored.
         NOTE17.17
            USE, INTRINSIC :: IEEE_EXCEPTIONS
            LOGICAL FLAG_VALUE
            ...
            CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.)
            ! First try a fast algorithm for inverting a matrix.
            CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .FALSE.)
            DO K = 1, N
              ...
              CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE)
              IF (FLAG_VALUE) EXIT
            END DO
            IF (FLAG_VALUE) THEN
            ! Alternative code which knows that K-1 steps have executed normally.
            ...
            END IF
        Here the code for matrix inversion is in line and the transfer is made more precise by adding extra tests of
        the ﬂag.
       c
      ISO/IEC 2017 – All rights reserved             477
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      478                          ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           18 Interoperability with C
           18.1    General
         1 Fortran provides a means of referencing procedures that are deﬁned by means of the C programming language
           or procedures that can be described by C prototypes as deﬁned in 6.7.6.3 of ISO/IEC 9899:2011, even if they
           are not actually deﬁned by means of C. Conversely, there is a means of specifying that a procedure deﬁned by a
           Fortran subprogram can be referenced from a function deﬁned by means of C. In addition, there is a means of
           declaring global variables that are associated with C variables whose names have external linkage as deﬁned in
           6.2.2 of ISO/IEC 9899:2011.
         2 The ISO_C_BINDING module provides access to named constants that represent kind type parameters of data
           representations compatible with C types. Fortran also provides facilities for deﬁning derived types (7.5) and
           enumerations (7.6) that correspond to C types.
         3 ThesourceﬁleISO_Fortran_binding.hprovidesdeﬁnitionsandprototypestoenableaCfunctiontointeroperate
           withaFortranprocedurethathasadummydataobjectthatisallocatable,assumed-shape,assumed-rank,pointer,
           or is of type character with an assumed length.
           18.2    The ISO_C_BINDING intrinsic module
           18.2.1  Summary of contents
         1 The processor shall provide the intrinsic module ISO_C_BINDING. This module shall make accessible the
           following entities: the named constants C_NULL_PTR, C_NULL_FUNPTR, and those with names listed in
           the ﬁrst column of Table 18.1 and the second column of Table 18.2, the types C_PTR and C_FUNPTR, and the
           procedures in 18.2.3. A processor may provide other public entities in the ISO_C_BINDING intrinsic module
           in addition to those listed here.
           18.2.2  Named constants and derived types in the module
         1 The entities listed in the second column of Table 18.2 shall be default integer named constants.
         2 A Fortran intrinsic type whose kind type parameter is one of the values in the module shall have the same
           representation as the C type with which it interoperates, for each value that a variable of that type can have.
           For C_BOOL, the internal representation of .TRUE._C_BOOL and .FALSE._C_BOOL shall be the same as those of
           the C values (_Bool)1 and (_Bool)0 respectively.
         3 The value of C_INT shall be a valid value for an integer kind parameter on the processor. The values of
           C_SHORT, C_LONG, C_LONG_LONG, C_SIGNED_CHAR, C_SIZE_T, C_INT8_T, C_INT16_T, C_-
           INT32_T,C_INT64_T,C_INT_LEAST8_T,C_INT_LEAST16_T,C_INT_LEAST32_T,C_INT_LEAST-
           64_T, C_INT_FAST8_T, C_INT_FAST16_T, C_INT_FAST32_T, C_INT_FAST64_T, C_INTMAX_T,
           and C_INTPTR_T shall each be a valid value for an integer kind type parameter on the processor or shall be
           −1 if the companion processor (5.5.7) deﬁnes the corresponding C type and there is no interoperating Fortran
           processor kind, or −2 if the companion processor does not deﬁne the corresponding C type.
         4 The values of C_FLOAT, C_DOUBLE, and C_LONG_DOUBLE shall each be a valid value for a real kind
           type parameter on the processor or shall be −1 if the companion processor’s type does not have a precision equal
           to the precision of any of the Fortran processor’s real kinds, −2 if the companion processor’s type does not have
           a range equal to the range of any of the Fortran processor’s real kinds, −3 if the companion processor’s type
           c
           ISO/IEC 2017 – All rights reserved                                                 479
            ISO/IEC DIS 1539-1:2017 (E)
            has neither the precision nor range of any of the Fortran processor’s real kinds, and equal to −4 if there is no
            interoperating Fortran processor kind for other reasons. The values of C_FLOAT_COMPLEX, C_DOUBLE_-
            COMPLEX,andC_LONG_DOUBLE_COMPLEXshallbethesameasthoseofC_FLOAT,C_DOUBLE,and
            C_LONG_DOUBLE,respectively.
         5 The value of C_BOOL shall be a valid value for a logical kind parameter on the processor or shall be −1.
         6 Thevalue of C_CHAR shall be a valid value for a character kind type parameter on the processor or shall be −1.
            If the value of C_CHAR is nonnegative, the character kind speciﬁed is the C character kind; otherwise, there is
            no C character kind.
         7 The following entities shall be named constants of type character with a length parameter of one. The kind
            parameter value shall be equal to the value of C_CHAR unless C_CHAR = −1, in which case the kind parameter
            value shall be the same as for default kind. The values of these constants are speciﬁed in Table 18.1. In the case
            that C_CHAR 6= −1 the value is speciﬁed using C syntax. The semantics of these values are explained in 5.2.1
            and 5.2.2 of ISO/IEC 9899:2011.
                                Table 18.1: Names of C characters with special semantics
                                                                              Value
                        Name                      Cdeﬁnition     C_CHAR=−1 C_CHAR6=−1
                        C_NULL_CHAR               null character CHAR(0)              ’\0’
                        C_ALERT                   alert          ACHAR(7)             ’\a’
                        C_BACKSPACE               backspace      ACHAR(8)             ’\b’
                        C_FORM_FEED               form feed      ACHAR(12)            ’\f’
                        C_NEW_LINE                new line       ACHAR(10)            ’\n’
                        C_CARRIAGE_RETURN carriage return        ACHAR(13)            ’\r’
                        C_HORIZONTAL_TAB          horizontal tab ACHAR(9)             ’\t’
                        C_VERTICAL_TAB            vertical tab   ACHAR(11)            ’\v’
         8 The entities C_PTR and C_FUNPTR are described in 18.3.3.
         9 Theentity C_NULL_PTRshallbeanamedconstantoftypeC_PTR.ThevalueofC_NULL_PTRshallbethe
            same as the value NULL in C. The entity C_NULL_FUNPTR shall be a named constant of type C_FUNPTR.
            The value of C_NULL_FUNPTR shall be that of a null pointer to a function in C.
                NOTE18.1
                The value of NEW_LINE(C_NEW_LINE) is C_NEW_LINE (16.9.140).
            18.2.3   Procedures in the module
            18.2.3.1 General
         1 Inthedetaileddescriptionsbelow, procedurenamesaregenericandnotspeciﬁc. TheC_F_POINTERsubroutine
            is impure; all other procedures in the module are pure.
            18.2.3.2   C_ASSOCIATED (C_PTR_1 [, C_PTR_2])
         1 Description. Query C pointer status.
         2 Class. Transformational function.
         3 Arguments.
            C_PTR_1 shall be a scalar of type C_PTR or C_FUNPTR.
            C_PTR_2(optional) shall be a scalar of the same type as C_PTR_1.
                                                                   c
            480                                                   ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
           4 Result Characteristics. Default logical scalar.
           5 Result Value.
              Case (i):     If C_PTR_2 is absent, the result is false if C_PTR_1 is a C null pointer and true otherwise.
              Case (ii):    If C_PTR_2 is present, the result is false if C_PTR_1 is a C null pointer. If C_PTR_1 is not a
                            Cnull pointer, the result is true if C_PTR_1 compares equal to C_PTR_2 in the sense of 6.3.2.3
                            and 6.5.9 of ISO/IEC 9899:2011, and false otherwise.
                   NOTE18.2
                   The following example illustrates the use of C_LOC and C_ASSOCIATED.
                   USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_FLOAT, C_ASSOCIATED, C_LOC
                   INTERFACE
                     SUBROUTINE FOO(GAMMA) BIND(C)
                        IMPORT C_PTR
                        TYPE(C_PTR), VALUE :: GAMMA
                     END SUBROUTINE FOO
                   END INTERFACE
                   REAL(C_FLOAT), TARGET, DIMENSION(100) :: ALPHA
                   TYPE(C_PTR) :: BETA
                   ...
                   IF (.NOT. C_ASSOCIATED(BETA)) THEN
                     BETA = C_LOC(ALPHA)
                   ENDIF
                   CALL FOO(BETA)
              18.2.3.3     C_F_POINTER (CPTR, FPTR [, SHAPE])
           1 Description. Associate a data pointer with the target of a C pointer and specify its shape.
           2 Class. Subroutine.
           3 Arguments.
              CPTR          shall be a scalar of type C_PTR. It is an INTENT (IN) argument. Its value shall be
                               • the C address of an interoperable data entity,
                               • the result of a reference to C_LOC with a noninteroperable argument, or
                               • the C address of a storage sequence that is not in use by any other Fortran entity.
                            ThevalueofCPTRshallnotbetheCaddressofaFortranvariablethatdoesnothavetheTARGET
                            attribute.
              FPTR          shall be a pointer, shall not have a deferred type parameter, and shall not be a coindexed object.
                            It is an INTENT (OUT) argument. If FPTR is an array, its shape is speciﬁed by SHAPE and each
                            lower bound is equal to 1.
                                Case (i):     If the value of CPTR is the C address of an interoperable data entity, FPTR
                                              shall be a data pointer with type and type parameter values interoperable with
                                              the type of the entity. If the target T of CPTR is scalar, FPTR becomes pointer
                                              associated with T; if FPTR is an array, SHAPE shall specify a size of 1. If T is
                                              an array, and FPTR is scalar, FPTR becomes associated with the ﬁrst element of
                                              T. If both T and FPTR are arrays, SHAPE shall specify a size that is less than or
                                              equal to the size of T, and FPTR becomes associated with the ﬁrst PRODUCT
                                              (SHAPE) elements of T (this could be the entirety of T).
               c
              ISO/IEC 2017 – All rights reserved                                                                           481
              ISO/IEC DIS 1539-1:2017 (E)
                                 Case (ii):     If the value of CPTR is the result of a reference to C_LOC with a noninter-
                                                operable eﬀective argument X, FPTR shall be a nonpolymorphic pointer with
                                                the same type and type parameters as X. In this case, X shall not have been
                                                deallocated or have become undeﬁned due to execution of a RETURN or END
                                                statement since the reference. If X is scalar, FPTR becomes pointer associated
                                                with X; if FPTR is an array, SHAPE shall specify a size of 1. If X is an array and
                                                FPTRis scalar, FPTR becomes associated with the ﬁrst element of X. If both X
                                                and FPTR are arrays, SHAPE shall specify a size that is less than or equal to
                                                the size of X, and FPTR becomes associated with the ﬁrst PRODUCT (SHAPE)
                                                elements of X (this could be the entirety of X).
                                 Case (iii):    If the value of CPTR is the C address of a storage sequence that is not in use by
                                                any other Fortran entity, FPTR becomes associated with that storage sequence.
                                                If FPTR is an array, its shape is speciﬁed by SHAPE and each lower bound
                                                is 1. The storage sequence shall be large enough to contain the target object
                                                described by FPTR and shall satisfy any other processor-dependent requirement
                                                for association.
              SHAPE(optional) shall be a rank-one integer array. It is an INTENT (IN) argument. SHAPE shall be present
                             if and only if FPTR is an array; its size shall be equal to the rank of FPTR.
           4 Examples.
              Case (i):      extern double c_x;
                             void *address_of_x (void)
                             {
                               return &c_x;
                             }
                             ! Assume interface to "address_of_x" is available.
                             Real (C_double), Pointer :: xp
                             Call C_F_Pointer (address_of_x (), xp)
              Case (ii):     Type t
                               Real, Allocatable :: v(:,:)
                             End Type
                             Type(t), Target :: x
                             Type(C_ptr) :: xloc
                             xloc = C_Loc (x)
                             ...
                             Type(t), Pointer :: y
                             Call C_F_Pointer (xloc, y)
              Case (iii):    void *getmem (int nbits)
                             {
                                return malloc ((nbits+CHAR_BIT-1)/CHAR_BIT);
                             }
                             ! Assume interface to "getmem" is available,
                             ! and there is a derived type "mytype" accessible.
                             Type(mytype), Pointer :: x
                             Call C_F_Pointer (getmem (Storage_Size (x)), x)
                                                                                  c
              482                                                                 ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
             The following statements illustrate the use of C_F_POINTER when the pointer to be set has a deferred type
             parameter:
                           Character(42), Pointer :: C1
                           Character(:), Pointer :: C2
                           Call C_F_Pointer (CPTR, C1)
                           C2 => C1
             This will associate C2 with the entity at the C address speciﬁed by CPTR, and specify its length to be the same
             as that of C1.
                  NOTE18.3
                  In the case of associating FPTR with a storage sequence, there might be processor-dependent requirements
                  such as alignment of the memory address or placement in memory.
             18.2.3.4     C_F_PROCPOINTER (CPTR, FPTR)
          1 Description. Associate a procedure pointer with the target of a C function pointer.
          2 Class. Pure subroutine.
          3 Arguments.
             CPTR         shall be a scalar of type C_FUNPTR. It is an INTENT (IN) argument. Its value shall be the C
                          address of a procedure that is interoperable, or the result of a reference to the function C_FUNLOC
                          from the intrinsic module ISO_C_BINDING.
             FPTR         shall be a procedure pointer, and shall not be a component of a coindexed object. It is an INTENT
                          (OUT)argument. If the target of CPTR is interoperable, the interface for FPTR shall be interoper-
                          able with the prototype that describes the target of CPTR; otherwise, the interface for FPTR shall
                          have the same characteristics as that target. FPTR becomes pointer associated with the target of
                          CPTR.
                  NOTE18.4
                  The term “target” in the descriptions of C_F_POINTER and C_F_PROCPOINTER denotes the entity
                  referenced by a C pointer, as described in 6.2.5 of ISO/IEC 9899:2011.
             18.2.3.5     C_FUNLOC (X)
          1 Description. C address of the argument.
          2 Class. Transformational function.
          3 Argument. Xshall be a procedure; if it is a procedure pointer it shall be associated. It shall not be a coindexed
             object.
          4 Result Characteristics. Scalar of type C_FUNPTR.
          5 Result Value. The result value is described using the result name FUNPTR. The result is determined as if
             C_FUNPTR were a derived type containing a procedure pointer component PX with an implicit interface and
             the pointer assignment FUNPTR%PX => X were executed.
          6 The result is a value that can be used as an actual CPTR argument in a call to C_F_PROCPOINTER where
             the FPTR argument has attributes that would allow the pointer assignment FPTR => X. Such a call to C_F_-
             PROCPOINTERshall have the eﬀect of the pointer assignment FPTR => X.
              c
             ISO/IEC 2017 – All rights reserved                                                                     483
             ISO/IEC DIS 1539-1:2017 (E)
             18.2.3.6     C_LOC (X)
          1 Description. C address of the argument.
          2 Class. Transformational function.
          3 Argument. X shall have either the POINTER or TARGET attribute. It shall not be a coindexed object. It
             shall either be a variable with interoperable type and kind type parameters, or be a nonpolymorphic variable
             with no length type parameters. If it is allocatable, it shall be allocated. If it is a pointer, it shall be associated.
             If it is an array, it shall be contiguous and have nonzero size. It shall not be a zero-length string.
          4 Result Characteristics. Scalar of type C_PTR.
          5 Result Value. The result value is described using the result name CPTR.
          6 If X is a scalar data entity, the result is determined as if C_PTR were a derived type containing a scalar pointer
             componentPXofthetypeandtypeparametersofXandthepointerassignmentCPTR%PX=>Xwereexecuted.
          7 If X is an array data entity, the result is determined as if C_PTR were a derived type containing a scalar pointer
             component PX of the type and type parameters of X and the pointer assignment of CPTR%PX to the ﬁrst
             element of X were executed.
          8 If X is a data entity that is interoperable or has interoperable type and type parameters, the result is the value
             that the C processor returns as the result of applying the unary “&” operator (as deﬁned in ISO/IEC 9899:2011,
             6.5.3.2) to the target of CPTR%PX.
          9 The result is a value that can be used as an actual CPTR argument in a call to C_F_POINTER where FPTR
             has attributes that would allow the pointer assignment FPTR => X. Such a call to C_F_POINTER shall have
             the eﬀect of the pointer assignment FPTR => X.
                  NOTE18.5
                  Where the actual argument is of noninteroperable type or type parameters, the result of C_LOC provides
                  anopaque“handle”forit. In an actual implementation, this handle might be the C address of the argument;
                  however, only a C function that treats it as a void (generic) C pointer that cannot be dereferenced (6.5.3.2
                  in ISO/IEC 9899:2011) is likely to be portable.
             18.2.3.7     C_SIZEOF (X)
          1 Description. Size of X in bytes.
          2 Class. Inquiry function.
          3 Argument. X shall be an interoperable data entity that is not an assumed-size array or an assumed-rank array
             that is associated with an assumed-size array.
          4 Result Characteristics. Scalar integer of kind C_SIZE_T (18.3.2).
          5 Result Value. If X is scalar, the result value is the value that the companion processor returns as the result
             of applying the sizeof operator (ISO/IEC 9899:2011, subclause 6.5.3.4) to an object of a type that interoperates
             with the type and type parameters of X.
          6 If X is an array, the result value is the value that the companion processor returns as the result of applying the
             sizeof operator to an object of a type that interoperates with the type and type parameters of X, multiplied by
             the number of elements in X.
                                                                            c
             484                                                           ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           18.3    Interoperability between Fortran and C entities
           18.3.1  General
         1 Subclause 18.3 deﬁnes the conditions under which a Fortran entity is interoperable. If a Fortran entity is inter-
           operable, an equivalent entity could be deﬁned by means of C and the Fortran entity would interoperate with the
           Centity. There does not have to be such an interoperating C entity.
               NOTE18.6
               AFortran entity can be interoperable with more than one C entity.
           18.3.2  Interoperability of intrinsic types
         1 Table 18.2 shows the interoperability between Fortran intrinsic types and C types. A Fortran intrinsic type with
           particular type parameter values is interoperable with a C type if the type and kind type parameter value are listed
           in the table on the same row as that C type. If the type is character, the length type parameter is interoperable
           if and only if its value is one. A combination of Fortran type and type parameters that is interoperable with a
           Ctype listed in the table is also interoperable with any unqualiﬁed C type that is compatible with the listed C
           type.
         2 Thesecondcolumnofthetable refers to the named constants made accessible by the ISO_C_BINDING intrinsic
           module. If the value of any of these named constants is negative, there is no combination of Fortran type and
           type parameters interoperable with the C type shown in that row.
         3 Acombination of intrinsic type and type parameters is interoperable if it is interoperable with a C type. The C
           types mentioned in table 18.2 are deﬁned in subclauses 6.2.5, 7.19, and 7.20.1 of ISO/IEC 9899:2011.
                             Table 18.2: Interoperability between Fortran and C types
               Fortran type   Named constant from the ISO_C_BINDING module  Ctype
                              (kind type parameter if value is positive)
                              C_INT                                         int
                              C_SHORT                                       short int
                              C_LONG                                        long int
                              C_LONG_LONG                                   long long int
                              C_SIGNED_CHAR                                 signed char
                                                                            unsigned char
                              C_SIZE_T                                      size_t
                              C_INT8_T                                      int8_t
                              C_INT16_T                                     int16_t
                              C_INT32_T                                     int32_t
                              C_INT64_T                                     int64_t
                              C_INT_LEAST8_T                                int_least8_t
                              C_INT_LEAST16_T                               int_least16_t
                              C_INT_LEAST32_T                               int_least32_t
               INTEGER        C_INT_LEAST64_T                               int_least64_t
                              C_INT_FAST8_T                                 int_fast8_t
                              C_INT_FAST16_T                                int_fast16_t
                              C_INT_FAST32_T                                int_fast32_t
                              C_INT_FAST64_T                                int_fast64_t
                              C_INTMAX_T                                    intmax_t
           c
           ISO/IEC 2017 – All rights reserved                                                 485
            ISO/IEC DIS 1539-1:2017 (E)
                                 Interoperability between Fortran and C types                   (cont.)
                Fortran type    Named constant from the ISO_C_BINDING module     Ctype
                                (kind type parameter if value is positive)
                                C_INTPTR_T                                       intptr_t
                                C_PTRDIFF_T                                      ptrdiﬀ_t
                                C_FLOAT                                          ﬂoat
                REAL            C_DOUBLE                                         double
                                C_LONG_DOUBLE                                    long double
                                C_FLOAT_COMPLEX                                  ﬂoat _Complex
                COMPLEX         C_DOUBLE_COMPLEX                                 double _Complex
                                C_LONG_DOUBLE_COMPLEX                            long double _Complex
                LOGICAL         C_BOOL                                           _Bool
                CHARACTER       C_CHAR                                           char
                NOTE18.7
                ISO/IEC 9899:2011 speciﬁes that the representations for nonnegative signed integers are the same as the
                corresponding values of unsigned integers. Because Fortran does not provide direct support for unsigned
                kinds of integers, the ISO_C_BINDING module does not make accessible named constants for their kind
                type parameter values. A user can use the signed kinds of integers to interoperate with the unsigned types
                and all their qualiﬁed versions as well. This has the potentially surprising side eﬀect that the C type
                unsigned char is interoperable with the type integer with a kind type parameter of C_SIGNED_CHAR.
            18.3.3   Interoperability with C pointer types
         1 C_PTR and C_FUNPTR shall be derived types with only private components. No direct component of either
            of these types is allocatable or a pointer. C_PTR is interoperable with any C object pointer type. C_FUNPTR
            is interoperable with any C function pointer type.
                NOTE18.8
                This means that only a C processor with the same representation method for all C object pointer types,
                and the same representation method for all C function pointer types, can be the target of interoperability
                of a Fortran processor. ISO/IEC 9899:2011 does not require this to be the case.
                NOTE18.9
                The function C_LOC can be used to return a value of type C_PTR that is the C address of an allocated
                allocatable variable. The function C_FUNLOC can be used to return a value of type C_FUNPTR that is
                the C address of a procedure. For C_LOC and C_FUNLOC the returned value is of an interoperable type
                and thus can be used in contexts where the procedure or allocatable variable is not directly allowed. For
                example, it could be passed as an actual argument to a C function.
                Similarly, type C_FUNPTR or C_PTR can be used in a dummy argument or structure component and
                can have a value that is the C address of a procedure or allocatable variable, even in contexts where a
                procedure or allocatable variable is not directly allowed.
            18.3.4   Interoperability of derived types and C struct types
         1 Interoperability between a derived type in Fortran and a struct type in C is provided by the BIND attribute on
            the Fortran type.
            C1801 (R726) A derived type with the BIND attribute shall not have the SEQUENCE attribute.
                                                                  c
            486                                                  ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
         C1802 (R726) A derived type with the BIND attribute shall not have type parameters.
         C1803 (R726) A derived type with the BIND attribute shall not have the EXTENDS attribute.
         C1804 (R726) A derived-type-def that deﬁnes a derived type with the BIND attribute shall not have a type-
              bound-procedure-part.
         C1805 (R726) A derived type with the BIND attribute shall have at least one component.
         C1806 (R726) Each component of a derived type with the BIND attribute shall be a nonpointer, nonallocatable
              data component with interoperable type and type parameters.
            NOTE18.10
            The syntax rules and their constraints require that a derived type that is interoperable with a C struct
            type have components that are all data entities that are interoperable. No component is permitted to be
            allocatable or a pointer, but the value of a component of type C_FUNPTR or C_PTR can be the C address
            of such an entity.
       2 Aderivedtypeis interoperable with a C struct type if and only if the derived type has the BIND attribute (7.5.2),
         the derived type and the C struct type have the same number of components, and the components of the derived
         type would interoperate with corresponding components of the C struct type as described in 18.3.5 and 18.3.6 if
         the components were variables. A component of a derived type and a component of a C struct type correspond
         if they are declared in the same relative position in their respective type deﬁnitions.
            NOTE18.11
            The names of the corresponding components of the derived type and the C struct type need not be the
            same.
       3 There is no Fortran type that is interoperable with a C struct type that contains a bit ﬁeld or that contains a
         ﬂexible array member. There is no Fortran type that is interoperable with a C union type.
            NOTE18.12
            For example, the C type myctype, declared below, is interoperable with the Fortran type myftype, declared
            below.
            typedef struct {
             int m, n;
             float r;
            } myctype;
            USE, INTRINSIC :: ISO_C_BINDING
            TYPE, BIND(C) :: MYFTYPE
             INTEGER(C_INT) :: I, J
             REAL(C_FLOAT) :: S
            END TYPE MYFTYPE
            Thenamesofthetypesandthenamesofthecomponentsarenotsigniﬁcantforthepurposesof determining
            whether a Fortran derived type is interoperable with a C struct type.
            NOTE18.13
            ISO/IEC 9899:2011 requires the names and component names to be the same in order for the types to be
            compatible (ISO/IEC 9899:2011, subclause 6.2.7). This is similar to Fortran’s rule describing when diﬀerent
            derived type deﬁnitions describe the same sequence type. This rule was not extended to determine whether
         c
         ISO/IEC 2017 – All rights reserved                                 487
                         ISO/IEC DIS 1539-1:2017 (E)
                                   NOTE18.13 (cont.)
                                   a Fortran derived type is interoperable with a C struct type because the case of identiﬁers is signiﬁcant in
                                   Cbut not in Fortran.
                         18.3.5               Interoperability of scalar variables
                    1 Anamedscalar Fortran variable is interoperable if and only if its type and type parameters are interoperable, it
                         is not a coarray, it has neither the ALLOCATABLE nor the POINTER attribute, and if it is of type character
                         its length is not assumed or declared by an expression that is not a constant expression.
                    2 Aninteroperable scalar Fortran variable is interoperable with a scalar C entity if their types and type parameters
                         are interoperable.
                         18.3.6               Interoperability of array variables
                    1 AFortran variable that is a named array is interoperable if and only if its type and type parameters are interop-
                         erable, it is not a coarray, it is of explicit shape or assumed size, and if it is of type character its length is not
                         assumed or declared by an expression that is not a constant expression.
                    2 Anexplicit-shape or assumed-size array of rank r, with a shape of  e                                                                      . . .     e      is interoperable with a C array
                         if its size is nonzero and                                                                                                        1                 r
                                     (1)         either
                                                 (a)        the array is assumed-size, and the C array does not specify a size, or
                                                 (b)        the array is an explicit-shape array, and the extent of the last dimension (er) is the same as
                                                            the size of the C array, and
                                     (2)         either
                                                 (a)        r is equal to one, and an element of the array is interoperable with an element of the C array,
                                                            or                                                                                                                                                         
                                                 (b)        r is greater than one, and an explicit-shape array with shape of                                                                e1      . . .     er−1        , with the
                                                            same type and type parameters as the original array, is interoperable with a C array of a type
                                                            equal to the element type of the original C array.
                                   NOTE18.14
                                   An element of a multi-dimensional C array is an array type, so a Fortran array of rank one is not interop-
                                   erable with a multidimensional C array.
                                   NOTE18.15
                                   An allocatable array or array pointer is never interoperable. Such an array does not meet the requirement
                                   of being an explicit-shape or assumed-size array.
                                   NOTE18.16
                                   For example, a Fortran array declared as
                                   INTEGER(C_INT) :: A(18, 3:7, *)
                                   is interoperable with a C array declared as
                                   int b[][5][18];
                                                                                                                                                    c
                         488                                                                                                                      ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
               NOTE18.17
               The C programming language deﬁnes null-terminated strings, which are actually arrays of the C type char
               that have a C null character in them to indicate the last valid element. A Fortran array of type character
               with a kind type parameter equal to C_CHAR is interoperable with a C string.
               Fortran’s rules of sequence association (15.5.2.11) permit a character scalar actual argument to correspond
               to a dummy argument array. This makes it possible to argument associate a Fortran character string with
               a C string.
               NOTE18.21 has an example of interoperation between Fortran and C strings.
           18.3.7  Interoperability of procedures and procedure interfaces
         1 A Fortran procedure is interoperable if and only if it has the BIND attribute, that is, if its interface is speciﬁed
           with a proc-language-binding-spec.
         2 AFortran procedure interface is interoperable with a C function prototype if
                (1)  the interface has the BIND attribute,
                (2)  either
                     (a) the interface describes a function whose result is a scalar variable that is interoperable with
                         the result of the prototype or
                     (b) the interface describes a subroutine and the prototype has a result type of void,
                (3)  the number of dummy arguments of the interface is equal to the number of formal parameters of the
                     prototype,
                (4)  any scalar dummy argument with the VALUE attribute is interoperable with the corresponding
                     formal parameter of the prototype,
                (5)  any dummy argument without the VALUE attribute corresponds to a formal parameter of the pro-
                     totype that is of a pointer type, and either
                        • thedummyargumentisinteroperablewithanentityofthereferencedtype(ISO/IEC9899:2011,
                         6.2.5, 7.19, and 7.20.1) of the formal parameter,
                        • the dummy argument is a nonallocatable nonpointer variable of type CHARACTER with
                         assumed character length and the formal parameter is a pointer to CFI_cdesc_t,
                        • the dummy argument is allocatable, assumed-shape, assumed-rank, or a pointer without the
                         CONTIGUOUSattribute, and the formal parameter is a pointer to CFI_cdesc_t, or
                        • the dummy argument is assumed-type and not allocatable, assumed-shape, assumed-rank, or
                         a pointer, and the formal parameter is a pointer to void,
                (6)  each allocatable or pointer dummy argument of type CHARACTER has deferred character length,
                     and
                (7)  the prototype does not have variable arguments as denoted by the ellipsis (...).
               NOTE18.18
               The referenced type of a C pointer type is the C type of the object that the C pointer type points to.
               For example, the referenced type of the pointer type int * is int.
               NOTE18.19
               TheClanguageallowsspeciﬁcation of a C function that can take a variable number of arguments (ISO/IEC
               9899:2011, 7.16). This document does not provide a mechanism for Fortran procedures to interoperate with
               such C functions.
         3 A formal parameter of a C function prototype corresponds to a dummy argument of a Fortran interface if they
           are in the same relative positions in the C parameter list and the dummy argument list, respectively.
           c
           ISO/IEC 2017 – All rights reserved                                                 489
         ISO/IEC DIS 1539-1:2017 (E)
       4 In a reference from C to a Fortran procedure with an interoperable interface, a C actual argument shall be the
         address of a C descriptor for the intended eﬀective argument if the corresponding dummy argument interoperates
         with a C formal parameter that is a pointer to CFI_cdesc_t. In this C descriptor, the members other than
         attribute and type shall describe an object with the same characteristics as the intended eﬀective argument.
         ThevalueoftheattributememberoftheCdescriptorshallbecompatiblewiththecharacteristicsofthedummy
         argument. The type member shall have a value that depends on the intended eﬀective argument as follows:
           • if the dynamic type of the intended eﬀective argument is an interoperable type listed in Table 18.4, the
            corresponding value for that type;
           • if the dynamic type of the intended eﬀective argument is an intrinsic type for which the processor deﬁnes
            a nonnegative type speciﬁer value not listed in Table 18.4, that type speciﬁer value;
           • otherwise, CFI_type_other.
       5 Whenaninteroperable Fortran procedure with a simply contiguous dummy argument is invoked from C and the
         actual argument is the address of a C descriptor for a discontiguous object, the Fortran processor shall handle
         the diﬀerence in contiguity.
       6 Whenaninteroperable C procedure whose Fortran interface has a simply contiguous dummy argument is invoked
         from Fortran and the eﬀective argument is discontiguous, the Fortran processor shall ensure that the C procedure
         receives a descriptor for a contiguous object.
       7 Whenaninteroperable C procedure whose Fortran interface has a simply contiguous dummy argument is invoked
         from C, and the actual argument is the address of a C descriptor for a discontiguous object, the C code within
         the procedure shall be prepared to handle the discontiguous argument.
       8 If an interoperable procedure deﬁned by means other than Fortran has an optional dummy argument, and the
         corresponding actual argument in a reference from Fortran is absent, the procedure is invoked with a null pointer
         for that argument. If an interoperable procedure deﬁned by means of Fortran is invoked by a C function, an
         optional dummy argument is absent if and only if the corresponding argument in the invocation is a null pointer.
            NOTE18.20
            For example, a Fortran procedure interface described by
            INTERFACE
             FUNCTION FUNC(I, J, K, L, M) BIND(C)
               USE, INTRINSIC :: ISO_C_BINDING
               INTEGER(C_SHORT) :: FUNC
               INTEGER(C_INT), VALUE :: I
               REAL(C_DOUBLE) :: J
               INTEGER(C_INT) :: K, L(10)
               TYPE(C_PTR), VALUE :: M
             END FUNCTION FUNC
            END INTERFACE
            is interoperable with the C function prototype
            short func(int i, double *j, int *k, int l[10], void *m);
            ACpointer can correspond to a Fortran dummy argument of type C_PTR with the VALUE attribute or
            to a Fortran scalar that does not have the VALUE attribute. In the above example, the C pointers j and
            k correspond to the Fortran scalars J and K, respectively, and the C pointer m corresponds to the Fortran
            dummy argument M of type C_PTR.
                                                  c
         490                                     ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
            NOTE18.21
            Theinteroperability of Fortran procedure interfaces with C function prototypes is only one part of invocation
            of a C function from Fortran. There are four pieces to consider in such an invocation: the procedure
            reference, the Fortran procedure interface, the C function prototype, and the C function. Conversely,
            the invocation of a Fortran procedure from C involves the function reference, the C function prototype,
            the Fortran procedure interface, and the Fortran procedure. In order to determine whether a reference is
            allowed, it is necessary to consider all four pieces.
            For example, consider a C function that can be described by the C function prototype
            void copy(char in[], char out[]);
            Such a function can be invoked from Fortran as follows:
             USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR, C_NULL_CHAR
             INTERFACE
               SUBROUTINE COPY(IN, OUT) BIND(C)
                IMPORT C_CHAR
                CHARACTER(KIND=C_CHAR), DIMENSION(*) :: IN, OUT
               END SUBROUTINE COPY
             END INTERFACE
             CHARACTER(LEN=10, KIND=C_CHAR) :: &
             &   DIGIT_STRING = C_CHAR_’123456789’ // C_NULL_CHAR
             CHARACTER(KIND=C_CHAR) :: DIGIT_ARR(10)
             CALL COPY(DIGIT_STRING, DIGIT_ARR)
             PRINT ’(1X, A1)’, DIGIT_ARR(1:9)
             END
            Theprocedurereferencehascharacterstring actual arguments. These correspond to character array dummy
            arguments in the procedure interface body as allowed by Fortran’s rules of sequence association (15.5.2.11).
            Those array dummy arguments in the procedure interface are interoperable with the formal parameters of
            the C function prototype. The C function is not shown here, but is assumed to be compatible with the C
            function prototype.
            NOTE18.22
            The requirements on the Fortran processor when a discontiguous actual argument is being passed to a
            simply contiguous dummy argument are such that the C programmer has the same functionality (and
            safety) as the Fortran programmer, when either the calling or called procedure are Fortran procedures. The
            requirements on the C procedure, in the case when both the called and calling procedure are C procedures,
            eﬀectively require that the C procedure not access memory through the descriptor that is not described by
            the descriptor; otherwise the program will not conform to this document. A dummy argument is simply
            contiguous if it has the CONTIGUOUS attribute or is an array that is not assumed-shape, assumed-rank,
            or a pointer.
         18.4  C descriptors
       1 A C descriptor is a C structure of type CFI_cdesc_t. Together with library functions that have standard
         prototypes, it provides a means for describing and manipulating Fortran data objects from within a C function.
         This C structure is deﬁned in the source ﬁle ISO_Fortran_binding.h.
         c
         ISO/IEC 2017 – All rights reserved                                 491
           ISO/IEC DIS 1539-1:2017 (E)
           18.5    The source ﬁle ISO_Fortran_binding.h
           18.5.1  Summary of contents
         1 The source ﬁle ISO_Fortran_binding.h shall contain the C structure deﬁnitions, typedef declarations, macro
           deﬁnitions, and function prototypes speciﬁed in subclauses 18.5.2 to 18.5.5. The deﬁnitions and declarations in
           ISO_Fortran_binding.h can be used by a C function to interpret and manipulate a C descriptor. These provide
           a means to specify a C prototype that interoperates with a Fortran interface that has a non-interoperable dummy
           variable (18.3.7).
         2 The source ﬁle ISO_Fortran_binding.h may be included in any order relative to the standard C headers, and
           may be included more than once in a given scope, with no eﬀect diﬀerent from being included only once, other
           than the eﬀect on line numbers.
         3 A C source ﬁle that includes the ISO_Fortran_binding.h header ﬁle shall not use any names starting with
           CFI_ that are not deﬁned in the header, and shall not deﬁne any of the structure names deﬁned in the header
           as macro names. All names other than structure member names deﬁned in the header begin with CFI_ or an
           underscore character, or are deﬁned by a standard C header that it includes.
           18.5.2  The CFI_dim_t structure type
         1 CFI_dim_t is a typedef name for a C structure. It is used to represent lower bound, extent, and memory stride
           information for one dimension of an array. The type CFI_index_t is described in 18.5.4. CFI_dim_t contains
           at least the following members in any order.
           CFI_index_t lower_bound; The value is equal to the value of the lower bound for the dimension being
               described.
           CFI_index_t extent; The value is equal to the number of elements in the dimension being described, or −1
               for the ﬁnal dimension of an assumed-size array.
           CFI_index_t sm; The value is equal to the memory stride for a dimension; this is the diﬀerence in bytes
               between the addresses of successive elements in the dimension being described.
           18.5.3  The CFI_cdesc_t structure type
         1 CFI_cdesc_tisatypedefnameforaCstructure, whichcontains a ﬂexible array member. It shall contain at least
           the members described in this subclause. The values of these members of a structure of type CFI_cdesc_t that
           is produced by the functions and macros speciﬁed in this document, or received by a C function when invoked
           by a Fortran procedure, shall have the properties described in this subclause.
         2 The ﬁrst three members of the structure shall be base_addr, elem_len, and version in that order. The ﬁnal
           member shall be dim. All other members shall be between version and dim, in any order. The types CFI_-
           attribute_t, CFI_rank_t, and CFI_type_t are described in 18.5.4. The type CFI_dim_t is described in 18.5.2.
           void * base_addr; If the object is an unallocated allocatable variable or a pointer that is disassociated, the
               value is a null pointer. If the object has zero size, the value is not a null pointer but is otherwise processor-
               dependent. Otherwise, the value is the base address of the object being described. The base address of a
               scalar is its C address. The base address of an array is the C address of the ﬁrst element in Fortran array
               element order.
           size_t elem_len; If the object is scalar, the value is the storage size in bytes of the object; otherwise, the value
               is the storage size in bytes of an element of the object.
           int version; The value is equal to the value of CFI_VERSION in the source ﬁle ISO_Fortran_binding.h that
               deﬁned the format and meaning of this C descriptor when the descriptor was established.
                                                              c
           492                                               ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           CFI_rank_t rank; The value is equal to the number of dimensions of the Fortran object being described; if
               the object is scalar, the value is zero.
           CFI_type_t type; Thevalue is equal to the speciﬁer for the type of the object. Each interoperable intrinsic C
               type has a speciﬁer. Speciﬁers are also provided to indicate that the type of the object is an interoperable
               structure, or is unknown. The macros listed in Table 18.4 provide values that correspond to each speciﬁer.
           CFI_attribute_t attribute; The value is equal to the value of an attribute code that indicates whether the
               object described is allocatable, a data pointer, or a nonallocatable nonpointer data object. The macros
               listed in Table 18.3 provide values that correspond to each code.
           CFI_dim_t dim; Thenumberofelements in the dim array is equal to the rank of the object. Each element of
               the array contains the lower bound, extent, and memory stride information for the corresponding dimension
               of the Fortran object.
         3 For a C descriptor of an array pointer or allocatable array, the value of the lower_bound member of each element
           of the dim member of the descriptor is determined by argument association, allocation, or pointer association.
           For a C descriptor of a nonallocatable nonpointer object, the value of the lower_bound member of each element
           of the dim member of the descriptor is zero.
         4 There shall be an ordering of the dimensions such that the absolute value of the sm member of the ﬁrst dimension
           is not less than the elem_len member of the C descriptor and the absolute value of the sm member of each
           subsequent dimension is not less than the absolute value of the sm member of the previous dimension multiplied
           by the extent of the previous dimension.
         5 In a C descriptor of an assumed-size array, the extent member of the last element of the dim member has the
           value −1.
               NOTE18.23
               The reason for the restriction on the absolute values of the sm members is to ensure that there is no overlap
               between the elements of the array that is being described, while allowing for the reordering of subscripts.
               Within Fortran, such a reordering can be achieved with the intrinsic function TRANSPOSE or the intrinsic
               function RESHAPE with the optional argument ORDER, and an optimizing compiler can accommodate it
               without making a copy by constructing the appropriate descriptor whenever it can determine that a copy
               is not needed.
               NOTE18.24
               Thevalueofelem_lenforaFortranCHARACTERobjectisequaltothecharacterlengthtimesthenumber
               of bytes of a single character of that kind. If the kind is C_CHAR, this value will be equal to the character
               length.
           18.5.4  Macros and typedefs in ISO_Fortran_binding.h
         1 Except for CFI_CDESC_T, each macro deﬁned in ISO_Fortran_binding.h expands to an integer constant
           expression that is either a single token or a parenthesized expression that is suitable for use in #if preprocessing
           directives.
         2 CFI_CDESC_Tisafunction-likemacrothattakesoneargument, whichistherankoftheCdescriptor to create,
           and evaluates to an unqualiﬁed type of suitable size and alignment for deﬁning a variable to use as a C descriptor
           of that rank. The argument shall be an integer constant expression with a value that is greater than or equal to
           zero and less than or equal to CFI_MAX_RANK. A pointer to a variable declared using CFI_CDESC_T can
           be cast to CFI_cdesc_t *. A variable declared using CFI_CDESC_T shall not have an initializer.
           c
           ISO/IEC 2017 – All rights reserved                                                 493
            ISO/IEC DIS 1539-1:2017 (E)
                 NOTE18.25
                 The CFI_CDESC_T macro provides the memory for a C descriptor. The address of an entity declared
                 using the macro is not usable as an actual argument corresponding to a formal parameter of type CFI_-
                 cdesc_t * without an explicit cast. For example, the following code uses CFI_CDESC_T to declare a C
                 descriptor of rank 5 and pass it to CFI_deallocate (18.5.5.4).
                     CFI_CDESC_T(5) object;
                     int ind;
                     ... code to define and use C descriptor ...
                     ind = CFI_deallocate((CFI_cdesc_t *)&object);
          3 CFI_index_tisatypedefnameforastandardsignedintegertypecapableofrepresentingtheresultofsubtracting
            two pointers.
          4 The CFI_MAX_RANK macro has a processor-dependent value equal to the largest rank supported. The value
            shall be greater than or equal to 15. CFI_rank_t is a typedef name for a standard integer type capable of
            representing the largest supported rank.
          5 The CFI_VERSION macro has a processor-dependent value that encodes the version of the ISO_Fortran_-
            binding.h source ﬁle containing this macro. This value should be increased if a new version of the source ﬁle is
            incompatible with the previous version.
          6 The macros in Table 18.3 are for use as attribute codes. The values shall be nonnegative and distinct. CFI_-
            attribute_t is a typedef name for a standard integer type capable of representing the values of the attribute
            codes.
                               Table 18.3: ISO_Fortran_binding.h macros for attribute codes
                                            Macro name                  Attribute
                                      CFI_attribute_pointer      data pointer
                                      CFI_attribute_allocatable  allocatable
                                      CFI_attribute_other        nonallocatable nonpointer
          7 CFI_attribute_pointer speciﬁes a data object with the Fortran POINTER attribute. CFI_attribute_allocatable
            speciﬁes an object with the Fortran ALLOCATABLE attribute. CFI_attribute_other speciﬁes a nonallocatable
            nonpointer object.
          8 The macros in Table 18.4 are for use as type speciﬁers. The value for CFI_type_other shall be negative and
            distinct from all other type speciﬁers. CFI_type_struct speciﬁes a C structure that is interoperable with a
            Fortran derived type; its value shall be positive and distinct from all other type speciﬁers. If a C type is not
            interoperable with a Fortran type and kind supported by the Fortran processor, its macro shall evaluate to a
            negative value. Otherwise, the value for an intrinsic type shall be positive.
          9 If the processor supports interoperability of a Fortran intrinsic type with a C type not listed in Table 18.4,
            the processor shall deﬁne a type speciﬁer value for that type which is positive and distinct from all other type
            speciﬁers.
         10 CFI_type_t is a typedef name for a standard integer type capable of representing the values for the supported
            type speciﬁers.
                                 Table 18.4: ISO_Fortran_binding.h macros for type codes
                                             Macro name                      CType
                                   CFI_type_signed_char              signed char
                                   CFI_type_short                    short int
                                                                       c
            494                                                       ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                                ISO_Fortran_binding.h macros for type codes (cont.)
                                         Macro name                   CType
                                CFI_type_int                   int
                                CFI_type_long                  long int
                                CFI_type_long_long             long long int
                                CFI_type_size_t                size_t
                                CFI_type_int8_t                int8_t
                                CFI_type_int16_t               int16_t
                                CFI_type_int32_t               int32_t
                                CFI_type_int64_t               int64_t
                                CFI_type_int_least8_t          int_least8_t
                                CFI_type_int_least16_t         int_least16_t
                                CFI_type_int_least32_t         int_least32_t
                                CFI_type_int_least64_t         int_least64_t
                                CFI_type_int_fast8_t           int_fast8_t
                                CFI_type_int_fast16_t          int_fast16_t
                                CFI_type_int_fast32_t          int_fast32_t
                                CFI_type_int_fast64_t          int_fast64_t
                                CFI_type_intmax_t              intmax_t
                                CFI_type_intptr_t              intptr_t
                                CFI_type_ptrdiﬀ_t              ptrdiﬀ_t
                                CFI_type_ﬂoat                  ﬂoat
                                CFI_type_double                double
                                CFI_type_long_double           long double
                                CFI_type_ﬂoat_Complex          ﬂoat _Complex
                                CFI_type_double_Complex        double _Complex
                                CFI_type_long_double_Complex   long double _Complex
                                CFI_type_Bool                  _Bool
                                CFI_type_char                  char
                                CFI_type_cptr                  void *
                                CFI_type_struct                interoperable C structure
                                CFI_type_other                 Not otherwise speciﬁed
                NOTE18.26
                Thevalues for diﬀerent C types can be the same; for example, CFI_type_int and CFI_type_int32_t might
                have the same value.
        11 Themacros in Table 18.5 are for use as error codes. The macro CFI_SUCCESS shall be deﬁned to be the integer
           constant 0. The value of each macro other than CFI_SUCCESS shall be nonzero and shall be diﬀerent from the
           values of the other macros speciﬁed in this subclause. Error conditions other than those listed in this subclause
           should be indicated by error codes diﬀerent from the values of the macros named in this subclause.
        12 The values of the macros in Table 18.5 indicate the error condition described.
                              Table 18.5: ISO_Fortran_binding.h macros for error codes
             Macro name                              Error condition
             CFI_SUCCESS                             No error detected.
             CFI_ERROR_BASE_ADDR_NULL                The base address member of a C descriptor is a null pointer
                                                     in a context that requires a non-null pointer value.
             CFI_ERROR_BASE_ADDR_NOT_NULL Inacontextthat requires a null pointer value, the base
                                                     address member of a C descriptor is not a null pointer.
             CFI_INVALID_ELEM_LEN                    The value supplied for the element length member of a
                                                     Cdescriptor is not valid.
            c
           ISO/IEC 2017 – All rights reserved                                                       495
             ISO/IEC DIS 1539-1:2017 (E)
                                     ISO_Fortran_binding.h macros for error codes                                (cont.)
               Macro name                                    Error condition
               CFI_INVALID_RANK                              The value supplied for the rank member of a C descriptor is
                                                             not valid.
               CFI_INVALID_TYPE                              The value supplied for the type member of a C descriptor is
                                                             not valid.
               CFI_INVALID_ATTRIBUTE                         The value supplied for the attribute member of a
                                                             Cdescriptor is not valid.
               CFI_INVALID_EXTENT                            The value supplied for the extent member of a CFI_dim_t
                                                             structure is not valid.
               CFI_INVALID_DESCRIPTOR                        ACdescriptor is invalid in some way.
               CFI_ERROR_MEM_ALLOCATION                      Memory allocation failed.
               CFI_ERROR_OUT_OF_BOUNDS                       Areference is out of bounds.
             18.5.5     Functions declared in ISO_Fortran_binding.h
             18.5.5.1   Arguments and results of the functions
          1 Someofthe functions described in 18.5.5 return an error indicator; this is an integer value that indicates whether
             an error condition was detected. The value zero indicates that no error condition was detected, and a nonzero
             value indicates which error condition was detected. Table 18.5 lists standard error conditions and macro names
             for their corresponding error codes. A processor is permitted to detect other error conditions. If an invocation of
             a function deﬁned in 18.5.5 could detect more than one error condition and an error condition is detected, which
             error condition is detected is processor dependent.
          2 In function arguments representing subscripts, bounds, extents, or strides, the ordering of the elements is the
             same as the ordering of the elements of the dim member of a C descriptor.
          3 Prototypesforthesefunctions, or equivalent macros, are provided in the ISO_Fortran_binding.h ﬁle as described
             in 18.5.5. It is unspeciﬁed whether the functions deﬁned by this header are macros or identiﬁers declared with
             external linkage. If a macro deﬁnition is suppressed in order to access an actual function, the behavior is undeﬁned.
                  NOTE18.27
                  These functions are allowed to be macros to provide extra implementation ﬂexibility. For example, CFI_-
                  establish could include the value of CFI_VERSION in the header used to compile the call to CFI_establish
                  as an extra argument of the actual function used to establish the C descriptor.
             18.5.5.2     The CFI_address function
          1 Synopsis. C address of an object described by a C descriptor.
             void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);
          2 Formal Parameters.
             dv           shall be the address of a C descriptor describing the object. The object shall not be an unallocated
                          allocatable variable or a pointer that is not associated.
             subscripts shall be a null pointer or the address of an array of type CFI_index_t. If the object is an array,
                          subscripts shall be the address of an array of CFI_index_t with at least n elements, where n
                          is the rank of the object. The value of subscripts[i] shall be within the bounds of dimension i
                          speciﬁed by the dim member of the C descriptor except for the last dimension of a C descriptor for
                          an assumed-size array. For the C descriptor of an assumed-size array, the value of the subscript for
                          the last dimension shall not be less than the lower bound, and the subscript order value speciﬁed
                          by the subscripts shall not exceed the size of the array.
                                                                            c
             496                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          3 Result Value. If the object is an array of rank n, the result is the C address of the element of the object that
             the ﬁrst n elements of the subscripts argument would specify if used as subscripts. If the object is scalar, the
             result is its C address.
          4 Example. If dv is the address of a C descriptor for the Fortran array A declared as
                      REAL(C_FLOAT) :: A(100, 100)
             the following code calculates the C address of A(5, 10):
                      CFI_index_t subscripts[2];
                      float *address;
                      subscripts[0] = 4;
                      subscripts[1] = 9;
                      address = (float *) CFI_address(dv, subscripts );
             18.5.5.3     The CFI_allocate function
          1 Synopsis. Allocate memory for an object described by a C descriptor.
             int CFI_allocate(CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],
                                 const CFI_index_t upper_bounds[], size_t elem_len);
          2 Formal Parameters.
             dv           shall be the address of a C descriptor specifying the rank and type of the object. The base_-
                          addr member of the C descriptor shall be a null pointer. If the type is not a character type, the
                          elem_len member shall specify the element length. The attribute member shall have a value of
                          CFI_attribute_allocatable or CFI_attribute_pointer.
             lower_bounds shall be the address of an array with at least dv->rank elements, if dv->rank>0.
             upper_bounds shall be the address of an array with at least dv->rank elements, if dv->rank>0.
             elem_len     If the type speciﬁed in the C descriptor type is a Fortran character type, the value of elem_len
                          shall be the storage size in bytes of an element of the object; otherwise, elem_len is ignored.
          3 Description.       Successful execution of CFI_allocate allocates memory for the object described by the C
             descriptor with the address dv using the same mechanism as the Fortran ALLOCATE statement, and assigns the
             address of that memory to dv->base_addr. The ﬁrst dv->rank elements of the lower_bounds and upper_bounds
             arguments provide the lower and upper Fortran bounds, respectively, for each corresponding dimension of the
             object. The supplied lower and upper bounds override any current dimension information in the C descriptor.
             If the rank is zero, the lower_bounds and upper_bounds arguments are ignored. If the type speciﬁed in the C
             descriptor is a character type, the supplied element length overrides the current element-length information in
             the descriptor.
             If an error is detected, the C descriptor is not modiﬁed.
          4 Result Value. The result is an error indicator.
          5 Example. If dv is the address of a C descriptor for the Fortran array A declared as
                      REAL, ALLOCATABLE :: A(:, :)
             and the array is not allocated, the following code allocates it to be of shape [100, 500]:
                      CFI_index_t lower[2], upper[2];
                      int ind;
              c
             ISO/IEC 2017 – All rights reserved                                                                     497
             ISO/IEC DIS 1539-1:2017 (E)
                      lower[0] = 1; lower[1] = 1;
                      upper[0] = 100; upper[1] = 500;
                      ind = CFI_allocate(dv, lower, upper, 0);
             18.5.5.4     The CFI_deallocate function
          1 Synopsis. Deallocate memory for an object described by a C descriptor.
             int CFI_deallocate(CFI_cdesc_t *dv);
          2 Formal Parameter. dv shall be the address of a C descriptor describing the object. It shall have been allocated
             using the same mechanism as the Fortran ALLOCATE statement. If the object is a pointer, it shall be associated
             with a target satisfying the conditions for successful deallocation by the Fortran DEALLOCATE statement
             (9.7.3).
          3 Description. Successful execution of CFI_deallocate deallocates memory for the object using the same mech-
             anism as the Fortran DEALLOCATE statement, and the base_addr member of the C descriptor becomes a null
             pointer.
             If an error is detected, the C descriptor is not modiﬁed.
          4 Result Value. The result is an error indicator.
          5 Example. If dv is the address of a C descriptor for the Fortran array A declared as
                      REAL, ALLOCATABLE :: A(:, :)
             and the array is allocated, the following code deallocates it:
                      int ind;
                      ind = CFI_deallocate(dv);
             18.5.5.5     The CFI_establish function
          1 Synopsis. Establish a C descriptor.
             int CFI_establish(CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
                                  CFI_type_t type, size_t elem_len, CFI_rank_t rank,
                                  const CFI_index_t extents[]);
          2 Formal Parameters.
             dv           shall be the address of a data object large enough to hold a C descriptor of the rank speciﬁed by
                          rank. It shall not have the same value as either a C formal parameter that corresponds to a Fortran
                          actual argument or a C actual argument that corresponds to a Fortran dummy argument. It shall
                          not be the address of a C descriptor that describes an allocated allocatable object.
             base_addr    shall be a null pointer or the base address of the object to be described. If it is not a null pointer,
                          it shall be the address of a contiguous storage sequence that is appropriately aligned (ISO/IEC
                          9899:2011 3.2) for an object of the type speciﬁed by type.
             attribute    shall be one of the attribute codes in Table 18.3. If it is CFI_attribute_allocatable, base_addr
                          shall be a null pointer.
             type         shall be one of the type codes in Table 18.4.
                                                                            c
             498                                                           ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            elem_len   If the type is equal to CFI_type_struct, CFI_type_other, or a Fortran character type code, elem_-
                       len shall be greater than zero and equal to the storage size in bytes of an element of the object.
                       Otherwise, elem_len will be ignored.
            rank       shall have a value in the range 0 ≤ rank ≤ CFI_MAX_RANK. It speciﬁes the rank of the object.
            extents    is ignored if rank is equal to zero or if base_addr is a null pointer. Otherwise, it shall be the address
                       of an array with rank elements; the value of each element shall be nonnegative, and extents[i]
                       speciﬁes the extent of dimension i of the object.
         3 Description. Successful execution of CFI_establish updates the object with the address dv to be an established
            Cdescriptor for a nonallocatable nonpointer data object of known shape, an unallocated allocatable object, or a
            data pointer. If base_addr is not a null pointer, it is for a nonallocatable entity that is a scalar or a contiguous
            array; if the attribute argument has the value CFI_attribute_pointer, the lower bounds of the object described
            by dv are set to zero. If base_addr is a null pointer, the established C descriptor is for an unallocated allocatable,
            a disassociated pointer, or is a C descriptor that has the attribute CFI_attribute_other but does not describe
            a data object. If base_addr is the C address of a Fortran data object, the type and elem_len arguments shall be
            consistent with the type and type parameters of the Fortran data object. The remaining properties of the object
            are given by the other arguments.
            If an error is detected, the object with the address dv is not modiﬁed.
         4 Result Value. The result is an error indicator.
                NOTE18.28
                CFI_establish is used to initialize a C descriptor declared in C with CFI_CDESC_T before passing it to
                any other functions as an actual argument, in order to set the rank, attribute, type and element length.
                NOTE18.29
                A C descriptor with attribute CFI_attribute_other and base_addr a null pointer can be used as the
                argument result in calls to CFI_section or CFI_select_part, which will produce a C descriptor for a
                nonallocatable nonpointer data object.
         5 Examples.
            Case (i):  Thefollowing code fragment establishes a C descriptor for an unallocated rank-one allocatable array
                       that can be passed to Fortran for allocation there.
                          CFI_rank_t rank;
                          CFI_CDESC_T(1) field;
                          int ind;
                          rank = 1;
                          ind = CFI_establish((CFI_cdesc_t *)&field, NULL, CFI_attribute_allocatable,
                                              CFI_type_double, 0, rank, NULL);
            Case (ii): Given the Fortran type deﬁnition
                          TYPE, BIND(C) :: T
                            REAL(C_DOUBLE) :: X
                            COMPLEX(C_DOUBLE_COMPLEX) :: Y
                          END TYPE
                       and a Fortran subprogram that has an assumed-shape dummy argument of type T, the following
                       code fragment creates a descriptor a_fortran for an array of size 100 that can be used as the actual
                       argument in an invocation of the subprogram from C:
                          typedef struct {double x; double _Complex y;} t;
                          t a_c[100];
                          CFI_CDESC_T(1) a_fortran;
            c
            ISO/IEC 2017 – All rights reserved                                                      499
            ISO/IEC DIS 1539-1:2017 (E)
                          int ind;
                          CFI_index_t extent[1];
                          extent[0] = 100;
                          ind = CFI_establish((CFI_cdesc_t *)&a_fortran, a_c, CFI_attribute_other,
                                              CFI_type_struct, sizeof(t), 1, extent);
            18.5.5.6   The CFI_is_contiguous function
         1 Synopsis. Test contiguity of an array.
            int CFI_is_contiguous(const CFI_cdesc_t * dv);
         2 Formal Parameter. dv shall be the address of a C descriptor describing an array. The base_addr member of
            the C descriptor shall not be a null pointer.
         3 Result Value. The value of the result is 1 if the array described by dv is contiguous, and 0 otherwise.
                NOTE18.30
                Assumed-size and allocatable arrays are always contiguous, and therefore the result of CFI_is_contiguous
                on a C descriptor for such an array will be equal to 1.
            18.5.5.7   The CFI_section function
         1 Synopsis. Update a C descriptor for an array section for which each element is an element of a given array.
            int CFI_section(CFI_cdesc_t *result, const CFI_cdesc_t *source,
                            const CFI_index_t lower_bounds[], const CFI_index_t upper_bounds[],
                            const CFI_index_t strides[]);
         2 Formal Parameters.
            result     shall be the address of a C descriptor with rank equal to the rank of source minus the number of
                       zero strides. The attribute member shall have the value CFI_attribute_other or CFI_attribute_-
                       pointer. If the value of result is the same as either a C formal parameter that corresponds to a
                       Fortran actual argument or a C actual argument that corresponds to a Fortran dummy argument,
                       the attribute member shall have the value CFI_attribute_pointer.
            source     shall be the address of a C descriptor that describes a nonallocatable nonpointer array, an allocated
                       allocatable array, or an associated array pointer. The elem_len and type members of source shall
                       have the same values as the corresponding members of result.
            lower_bounds shall be a null pointer or the address of an array with at least source->rank elements. If it is not
                       a null pointer, and stride is zero or (upper − lower_bounds[i] + stride )/stride > 0, the value
                                            i               i                        i      i
                       of lower_bounds[i] shall be within the bounds of dimension i of SOURCE.
            upper_bounds shall be a null pointer or the address of an array with at least source->rank elements. If source
                       describes an assumed-size array, upper_bounds shall not be a null pointer. If it is not a null pointer
                       and stride is zero or (upper_bounds[i] − lower + stride )/stride > 0, the value of upper_-
                                i                                i       i       i
                       bounds[i] shall be within the bounds of dimension i of SOURCE.
            strides    shall be a null pointer or the address of an array with at least source->rank elements.
         3 Description. Successful execution of CFI_section updates the base_addr and dim members of the C descriptor
            with the address result to describe the array section determined by source, lower_bounds, upper_bounds, and
            strides, as follows.
                                                                  c
            500                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            The array section is equivalent to the Fortran array section SOURCE(sectsub , sectsub , ... sectsub ), where
                                                                              1       2          n
            SOURCE is the array described by source, n is the rank of that array, and sectsub is the subscript lower if
                                                                                   i                   i
            stride is zero, and the section subscript lower : upper : stride otherwise. The value of lower is the lower
                 i                                 i       i       i                          i
            bound of dimension i of SOURCE if lower_bounds is a null pointer and lower_bounds[i] otherwise. The value
            of upperi is the upper bound of dimension i of SOURCE if upper_bounds is a null pointer and upper_bounds[i]
            otherwise. The value of stride is 1 if strides is a null pointer and strides[i] otherwise. If stride has the
                                      i                                                           i
            value zero, lower shall have the same value as upper .
                          i                             i
            If an error is detected, the C descriptor with the address result is not modiﬁed.
         4 Result Value. The result is an error indicator.
         5 Examples.
            Case (i):  If source is already the address of a C descriptor for the rank-one Fortran array A, the lower
                       bounds of A are equal to 1, and the lower bounds in the C descriptor are equal to 0, the following
                       code fragment establishes a new C descriptor section and updates it to describe the array section
                       A(3::5):
                          CFI_index_t lower[1], strides[1];
                          CFI_CDESC_T(1) section;
                          int ind;
                          lower[0] = 2;
                          strides[0] = 5;
                          ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
                                              CFI_type_float, 0, 1, NULL);
                          ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);
            Case (ii): If source is already the address of a C descriptor for a rank-two Fortran assumed-shape array A
                       with lower bounds equal to 1, the following code fragment establishes a C descriptor and updates
                       it to describe the rank-one array section A(:, 42).
                           CFI_index_t lower[2], upper[2], strides[2];
                           CFI_CDESC_T(1) section;
                           int ind;
                           lower[0] = source->dim[0].lower_bound;
                           upper[0] = source->dim[0].lower_bound + source->dim[0].extent - 1;
                           strides[0] = 1;
                           lower[1] = upper[1] = source->dim[1].lower_bound + 41;
                           strides[1] = 0;
                           ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
                                               CFI_type_float, 0, 1, NULL);
                           ind = CFI_section((CFI_cdesc_t *)&section, source, lower, upper, strides);
            18.5.5.8   The CFI_select_part function
         1 Synopsis. Update a C descriptor for an array section for which each element is a part of the corresponding
            element of an array.
            int CFI_select_part(CFI_cdesc_t *result, const CFI_cdesc_t *source, size_t displacement,
                                size_t elem_len);
         2 Formal Parameters.
            result     shall be the address of a C descriptor; result->rank shall have the same value as source->rank
                       and result->attribute shall have the value CFI_attribute_other or CFI_attribute_pointer. If
            c
            ISO/IEC 2017 – All rights reserved                                                      501
            ISO/IEC DIS 1539-1:2017 (E)
                       the address speciﬁed by result is the value of a C formal parameter that corresponds to a For-
                       tran actual argument or of a C actual argument that corresponds to a Fortran dummy argument,
                       result->attribute shall have the value CFI_attribute_pointer. The value of result->type spe-
                       ciﬁes the type of the array section.
            source     shall be the address of a C descriptor for an allocated allocatable array, an associated array pointer,
                       or a nonallocatable nonpointer array that is not assumed-size.
            displacement shall have a value 0 ≤ displacement ≤ source->elem_len −1, and the sum of the displacement
                       andthesizeinbytesofanelementofthearraysectionshallbelessthanorequaltosource->elem_-
                       len. The address displacement bytes greater than the value of source->base_addr is the base of
                       the array section and shall be appropriately aligned (ISO/IEC 9899:2011, 3.2) for an object of the
                       type of the array section.
            elem_len   shall have a value equal to the storage size in bytes of an element of the array section if result->type
                       speciﬁes a Fortran character type; otherwise, elem_len is ignored.
         3 Description. Successful execution of CFI_select_part updates the base_addr, dim, and elem_len members of
            the C descriptor with the address result for an array section for which each element is a part of the corresponding
            element of the array described by the C descriptor with the address source. The part shall be a component of a
            structure, a substring, or the real or imaginary part of a complex value.
            If an error is detected, the C descriptor with the address result is not modiﬁed.
         4 Result Value. The result is an error indicator.
         5 Example. If source is already the address of a C descriptor for the Fortran array A declared with
              TYPE, BIND(C) :: T
                REAL(C_DOUBLE) :: X
                COMPLEX(C_DOUBLE_COMPLEX) :: Y
              END TYPE
              TYPE(T) A(100)
            the following code fragment establishes a C descriptor for the array A%Y:
               typedef struct {
                 double x; double _Complex y;
               } t;
               CFI_CDESC_T(1) component;
               CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;
               CFI_index_t extent[] = { 100 };
               (void)CFI_establish(comp_cdesc, NULL, CFI_attribute_other, CFI_type_double_Complex,
                                   sizeof(double _Complex), 1, extent);
               (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);
            18.5.5.9   The CFI_setpointer function
         1 Synopsis. Update a C descriptor for a Fortran pointer to be associated with the whole of a given object or to
            be disassociated.
            int CFI_setpointer(CFI_cdesc_t *result, CFI_cdesc_t *source,
                               const CFI_index_t lower_bounds[]);
                                                                  c
            502                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         2 Formal Parameters.
            result     shall be the address of a C descriptor for a Fortran pointer. It is updated using information from
                       the source and lower_bounds arguments.
            source     shall be a null pointer or the address of a C descriptor for an allocated allocatable object, a data
                       pointer object, or a nonallocatable nonpointer data object that is not an assumed-size array. If
                       source is not a null pointer, the corresponding values of the elem_len, rank, and type members
                       shall be the same in the C descriptors with the addresses source and result.
            lower_bounds If source is not a null pointer and source->rank is nonzero, lower_bounds shall be a null pointer
                       or the address of an array with at least source->rank elements.
         3 Description.   Successful execution of CFI_setpointer updates the base_addr and dim members of the C
            descriptor with the address result as follows:
              • if source is a null pointer or the address of a C descriptor for a disassociated pointer, the updated C
                descriptor describes a disassociated pointer;
              • otherwise, the C descriptor with the address result becomes a C descriptor for the object described by
                the C descriptor with the address source, except that if source->rank is nonzero and lower_bounds is
                not a null pointer, the lower bounds are replaced by the values of the ﬁrst source->rank elements of the
                lower_bounds array.
            If an error is detected, the C descriptor with the address result is not modiﬁed.
         4 Result Value. The result is an error indicator.
         5 Example.    If ptr is already the address of a C descriptor for an array pointer of rank 1, the following code
            updates it to be a C descriptor for a pointer to the same array with lower bound 0.
                CFI_index_t lower_bounds[1];
                int ind;
                lower_bounds[0] = 0;
                ind = CFI_setpointer(ptr, ptr, lower_bounds);
            18.6    Restrictions on C descriptors
         1 ACdescriptor shall not be initialized, updated, or copied other than by calling the functions speciﬁed in 18.5.5.
         2 If the address of a C descriptor is a formal parameter that corresponds to a Fortran actual argument or a C
            actual argument that corresponds to a Fortran dummy argument,
              • the C descriptor shall not be modiﬁed if either the corresponding dummy argument in the Fortran interface
                has the INTENT (IN) attribute or the C descriptor is for a nonallocatable nonpointer object, and
              • thebase_addrmemberoftheCdescriptorshallnotbeaccessedbeforeitisgivenavalueifthecorresponding
                dummy argument in the Fortran interface has the POINTER and INTENT (OUT) attributes.
                NOTE18.31
                In this context, modiﬁcation refers to any change to the location or contents of the C descriptor, including
                establishment and update. The intent of these restrictions is that C descriptors remain intact at all times
                they are accessible to an active Fortran procedure, so that the Fortran code is not required to copy them.
         3 If the address of a C descriptor is a C actual argument that corresponds to an assumed-shape Fortran dummy
            argument, that descriptor shall not be for an assumed-size array.
            c
            ISO/IEC 2017 – All rights reserved                                                      503
         ISO/IEC DIS 1539-1:2017 (E)
         18.7   Restrictions on formal parameters
       1 Within a C function, an allocatable object shall be allocated or deallocated only by execution of the CFI_-
         allocate and CFI_deallocate functions. A Fortran pointer can become associated with a target by execution of
         the CFI_allocate function.
       2 Calling CFI_allocate or CFI_deallocate for a C descriptor changes the allocation status of the Fortran variable
         it describes.
       3 If the address of an object is the value of a formal parameter that corresponds to a nonpointer dummy argument
         in an interface with the BIND attribute, then
           • if the dummyargumenthastheINTENT(IN)attribute,theobjectshallnotbedeﬁnedorbecomeundeﬁned,
             and
           • if the dummy argument has the INTENT (OUT) attribute, the object shall not be referenced before it is
             deﬁned.
       4 If a formal parameter that is a pointer to CFI_cdesc_t corresponds to a dummy argument in an interoperable
         procedure interface, a pointer based on the base_addr in that C descriptor shall not be used to access memory
         that is not part of the object described by the C descriptor.
         18.8   Restrictions on lifetimes
       1 A C descriptor of, or C pointer to, any part of a Fortran object becomes undeﬁned under the same conditions
         that the association status of a Fortran pointer associated with that object would become undeﬁned, and any
         further use of it is undeﬁned behavior (ISO/IEC 9899:2011, 3.4.3).
       2 A C descriptor whose address is a formal parameter that corresponds to a Fortran dummy argument becomes
         undeﬁned on return from a call to the function from Fortran. If the dummy argument does not have either the
         TARGETorASYNCHRONOUSattribute,allCpointers to any part of the object described by the C descriptor
         become undeﬁned on return from the call, and any further use of them is undeﬁned behavior.
       3 If the address of a C descriptor is passed as an actual argument to a Fortran procedure, the lifetime (ISO/IEC
         9899:2011, 6.2.4) of the C descriptor shall not end before the return from the procedure call. If an object is passed
         to a Fortran procedure as a nonallocatable, nonpointer dummy argument, its lifetime shall not end before the
         return from the procedure call.
       4 If the lifetime of a C descriptor for an allocatable object that was established by C ends before the program exits,
         the object shall be unallocated at that time.
       5 If a Fortran pointer becomes associated with a data object deﬁned by the companion processor, the association
         status of the Fortran pointer becomes undeﬁned when the lifetime of that data object ends.
            NOTE18.32
            The following example illustrates how a C descriptor becomes undeﬁned upon returning from a call to a C
            function.
                REAL, TARGET :: X(1000), B
                INTERFACE
                   REAL FUNCTION CFUN(ARRAY) BIND(C, NAME="Cfun")
                     REAL ARRAY(:)
                   END FUNCTION
                END INTERFACE
                B = CFUN(X)
                                                   c
         504                                       ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
              NOTE18.32 (cont.)
              Cfun is a C function. Before or during the invocation of Cfun, the processor will create a C descriptor
              for the array x. On return from Cfun, that C descriptor will become undeﬁned. In addition, because the
              dummyargumentARRAYdoesnothavetheTARGETorASYNCHRONOUSattribute,aCpointerwhose
              value was set during execution of Cfun to be the address of any part of X will become undeﬁned.
          18.9   Interoperation with C global variables
          18.9.1  General
        1 ACvariable whose name has external linkage may interoperate with a common block or with a variable declared in
          the scope of a module. The common block or variable shall be speciﬁed to have the BIND attribute.
        2 Atmostonevariable that is associated with a particular C variable whose name has external linkage is permitted
          to be declared within all the Fortran program units of a program. A variable shall not be initially deﬁned by
          more than one processor.
        3 If a common block is speciﬁed in a BIND statement, it shall be speciﬁed in a BIND statement with the same binding label in each
          scoping unit in which it is declared. A C variable whose name has external linkage interoperates with a common block that has been
          speciﬁed in a BIND statement if
             • the C variable is of a struct type and the variables that are members of the common block are interoperable with corresponding
              components of the struct type, or
             • the common block contains a single variable, and the variable is interoperable with the C variable.
        4 There does not have to be an associated C entity for a Fortran entity with the BIND attribute.
              NOTE18.33
              The following are examples of the usage of the BIND attribute for variables and for a common block. The
              Fortran variables, C_EXTERN and C2, interoperate with the C variables, c_extern and myVariable,
              respectively. TheFortrancommonblocks,COMandSINGLE,interoperatewiththeCvariables,comandsingle,respectively.
              MODULE LINK_TO_C_VARS
               USE, INTRINSIC :: ISO_C_BINDING
               INTEGER(C_INT), BIND(C) :: C_EXTERN
               INTEGER(C_LONG) :: C2
               BIND(C, NAME=’myVariable’) :: C2
               COMMON /COM/ R, S
               REAL(C_FLOAT) :: R, S, T
               BIND(C) :: /COM/, /SINGLE/
               COMMON /SINGLE/ T
              END MODULE LINK_TO_C_VARS
              /* Global variables. */
              int c_extern;
              long myVariable;
              struct { float r, s; } com;
              float single;
           c
          ISO/IEC 2017 – All rights reserved                                          505
           ISO/IEC DIS 1539-1:2017 (E)
           18.9.2  Binding labels for common blocks and variables
         1 The binding label of a variable or common block is a default character value that speciﬁes the name by which the
           variable or common block is known to the companion processor.
         2 If a variable or common block has the BIND attribute with the NAME= speciﬁer and the value of its expression,
           after discarding leading and trailing blanks, has nonzero length, the variable or common block has this as its binding
           label. The case of letters in the binding label is signiﬁcant. If a variable or common block has the BIND attribute
           speciﬁed without a NAME= speciﬁer, the binding label is the same as the name of the entity using lower case
           letters. Otherwise, the variable or common block has no binding label.
         3 The binding label of a C variable whose name has external linkage is the same as the name of the C variable. A
           Fortran variable or common block with the BIND attribute that has the same binding label as a C variable whose
           name has external linkage is linkage associated (19.5.1.5) with that variable.
           18.10    Interoperation with C functions
           18.10.1  Deﬁnition and reference of interoperable procedures
         1 A procedure that is interoperable may be deﬁned either by means other than Fortran or by means of a Fortran
           subprogram, but not both. A C function that has an inline deﬁnition and no external deﬁnition is not considered
           to be deﬁned in this sense.
         2 If the procedure is deﬁned by means other than Fortran,
              • it shall be describable by a C prototype that is interoperable with the interface, and
              • if it is accessed using its binding label, it shall
                 – have a name that has external linkage as deﬁned by 6.2.2 of ISO/IEC 9899:2011, and
                 – have the same binding label as the interface.
         3 A reference to such a procedure causes the function described by the C prototype to be called as speciﬁed in
           ISO/IEC 9899:2011.
         4 Areference in C to a procedure that has the BIND attribute, has the same binding label, and is deﬁned by means
           of Fortran, causes the Fortran procedure to be invoked. A C function shall not invoke a function pointer whose
           value is the result of a reference to C_FUNLOC with a noninteroperable argument.
         5 A procedure deﬁned by means of Fortran shall not invoke setjmp or longjmp (ISO/IEC 9899:2011, 7.13). If a
           procedure deﬁned by means other than Fortran invokes setjmp or longjmp, that procedure shall not cause any
           procedure deﬁned by means of Fortran to be invoked. A procedure deﬁned by means of Fortran shall not be
           invoked as a signal handler (ISO/IEC 9899:2011, 7.14.1).
         6 If a procedure deﬁned by means of Fortran and a procedure deﬁned by means other than Fortran perform
           input/output operations on the same external ﬁle, the results are processor dependent (12.5.4).
         7 If the value of a C function pointer will be the result of a reference to C_FUNLOC with a noninteroperable
           argument, it is recommended that the C function pointer be declared to have the type void (*)().
           18.10.2  Binding labels for procedures
         1 The binding label of a procedure is a default character value that speciﬁes the name by which a procedure with
           the BIND attribute is known to the companion processor.
         2 If a procedure has the BIND attribute with the NAME= speciﬁer and the value of its expression, after discarding
           leading and trailing blanks, has nonzero length, the procedure has this as its binding label. The case of letters
           in the binding label is signiﬁcant. If a procedure has the BIND attribute with no NAME= speciﬁer, and the
                                                              c
           506                                               ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
           procedure is not a dummy procedure, internal procedure, or procedure pointer, then the binding label of the
           procedure is the same as the name of the procedure using lower case letters. Otherwise, the procedure has no
           binding label.
           C1807 A procedure deﬁned in a submodule shall not have a binding label unless its interface is declared in the
                 ancestor module.
        3 The binding label for a C function whose name has external linkage is the same as the C function name.
              NOTE18.34
              In the following sample, the binding label of C_SUB is "c_sub", and the binding label of C_FUNC is
              "C_funC".
              SUBROUTINE C_SUB() BIND(C)
                ...
              END SUBROUTINE C_SUB
              INTEGER(C_INT) FUNCTION C_FUNC() BIND(C, NAME="C_funC")
                USE, INTRINSIC :: ISO_C_BINDING
                ...
              END FUNCTION C_FUNC
              ISO/IEC 9899:2011 permits functions to have names that are not permitted as Fortran names; it also
              distinguishes between names that would be considered as the same name in Fortran. For example, a C
              name can begin with an underscore, and C names that diﬀer in case are distinct names.
              The speciﬁcation of a binding label allows a program to use a Fortran name to refer to a procedure deﬁned
              by a companion processor.
           18.10.3  Exceptions and IEEE arithmetic procedures
        1 Aprocedure deﬁned by means other than Fortran shall not use signal (ISO/IEC 9899:2011, 7.14.1) to change the
           handling of any exception that is being handled by the Fortran processor.
        2 A procedure deﬁned by means other than Fortran shall not alter the ﬂoating-point status (17.7) other than by
           setting an exception ﬂag to signaling.
        3 The values of the ﬂoating-point exception ﬂags on entry to a procedure deﬁned by means other than Fortran are
           processor dependent.
           18.10.4  Asynchronous communication
        1 Asynchronous communication for a Fortran variable with the ASYNCHRONOUS attribute occurs through the
           action of procedures deﬁned by means other than Fortran. It is initiated by execution of an asynchronous
           communication initiation procedure and completed by execution of an asynchronous communication completion
           procedure. Between the execution of the initiation and completion procedures, any variable of which any part
           is associated with any part of the asynchronous communication variable is a pending communication aﬀector.
           Whether a procedure is an asynchronous communication initiation or completion procedure is processor depend-
           ent.
        2 Asynchronouscommunicationiseitherinputcommunicationoroutputcommunication. Forinputcommunication,
           a pending communication aﬀector shall not be referenced, become deﬁned, become undeﬁned, become associated
           with a dummy argument that has the VALUE attribute, or have its pointer association status changed. For
           output communication, a pending communication aﬀector shall not be redeﬁned, become undeﬁned, or have its
           pointer association status changed. The restrictions for asynchronous input communication are the same as for
           c
           ISO/IEC 2017 – All rights reserved                                               507
      ISO/IEC DIS 1539-1:2017 (E)
      asynchronous input data transfer. The restrictions for asynchronous output communication are the same as for
      asynchronous output data transfer.
         NOTE18.35
        Asynchronous communication can be used for nonblocking MPI calls such as MPI_IRECV and MPI_-
        ISEND. For example,
           REAL :: BUF(100,100)
           ... ! Code that involves BUF
           BLOCK
            ASYNCHRONOUS :: BUF
            CALL MPI_IRECV(BUF,...REQ,...)
             ... ! Code that does not involve BUF
            CALL MPI_WAIT(REQ,...)
           END BLOCK
           ... ! Code that involves BUF
        In this example, there is asynchronous input communication and BUF is a pending communication aﬀector
        between the two calls. MPI_IRECV can return while the communication (reading values into BUF) is still
        underway. The intent is that the code between MPI_IRECV and MPI_WAIT can execute without waiting
        for this communication to complete.
        Similar code with the call of MPI_IRECV replaced by a call of MPI_ISEND is asynchronous output
        communication.
                                   c
      508                          ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
          19 Scope, association, and deﬁnition
          19.1   Scopes, identiﬁers, and entities
        1 An entity is identiﬁed by an identiﬁer.
        2 The scope of
            • a global identiﬁer is a program (5.2.2),
            • a local identiﬁer is an inclusive scope,
            • an identiﬁer of a construct entity is that construct (10.2.4, 11.1), and
            • an identiﬁer of a statement entity is that statement or part of that statement (6.3),
          excluding any nested scope where the identiﬁer is treated as the identiﬁer of a diﬀerent entity (19.3, 19.4), or
          where an IMPORT statement (8.8) makes the identiﬁer inaccessible.
        3 An entity may be identiﬁed by
            • an image index (3.85),
            • a name (3.103),
            • a statement label (3.135),
            • an external input/output unit number (12.5),
            • an identiﬁer of a pending data transfer operation (12.6.2.9, 12.7),
            • a submodule identiﬁer (14.2.3),
            • a generic identiﬁer (3.79), or
            • a binding label (3.15).
        4 By means of association, an entity may be referred to by the same identiﬁer or a diﬀerent identiﬁer in a diﬀerent
          scope, or by a diﬀerent identiﬁer in the same scope.
          19.2   Global identiﬁers
        1 Program units, common blocks, external procedures, entities with binding labels, external input/output units,
          pending data transfer operations, and images are global entities of a program. The name of a common block with
          no binding label, external procedure with no binding label, or program unit that is not a submodule is a global
          identiﬁer. The submodule identiﬁer of a submodule is a global identiﬁer. A binding label of an entity of the
          program is a global identiﬁer. An entity of the program shall not be identiﬁed by more than one binding label.
        2 Theglobal identiﬁer of an entity shall not be the same as the global identiﬁer of any other entity. Furthermore, a
          binding label shall not be the same as the global identiﬁer of any other global entity, ignoring diﬀerences in case.
          A processor may assign a global identiﬁer to an entity that is not speciﬁed by this document to have a global
          identiﬁer (such as an intrinsic procedure); in such a case, the processor shall ensure that this assigned global
          identiﬁer diﬀers from all other global identiﬁers in the program.
             NOTE19.1
             Anintrinsic module is not a program unit, so a global identiﬁer can be the same as the name of an intrinsic
             module.
          c
          ISO/IEC 2017 – All rights reserved                                         509
          ISO/IEC DIS 1539-1:2017 (E)
             NOTE19.2
             Submodule identiﬁers are global identiﬁers, but because they consist of a module name and a descendant
             submodule name, the name of a submodule can be the same as the name of another submodule so long as
             they do not have the same ancestor module.
          19.3   Local identiﬁers
          19.3.1  Classes of local identiﬁers
        1 Identiﬁers of entities, other than statement or construct entities (19.4), in the classes
              (1)  named variables, named constants, named procedure pointers, named constructs, statement functions,
                   internal procedures, module procedures, dummyprocedures, intrinsic procedures, external procedures
                   that have binding labels, intrinsic modules, abstract interfaces, generic interfaces, derived types,
                   namelist groups, external procedures accessed via USE, and statement labels,
              (2)  type parameters, components, and type-bound procedure bindings, in a separate class for each type,
              (3)  argument keywords, in a separate class for each procedure with an explicit interface, and
              (4)  common blocks that have binding labels
          are local identiﬁers.
        2 Within its scope, a local identiﬁer of an entity of class (1) or class (4) shall not be the same as a global identiﬁer
          used in that scope unless the global identiﬁer
            • is used only as the use-name of a rename in a USE statement,
            • is a common block name (19.3.2),
            • is an external procedure name that is also a generic name, or
            • is an external function name and the inclusive scope is its deﬁning subprogram (19.3.3).
        3 Within its scope, a local identiﬁer of one class shall not be the same as another local identiﬁer of the same class,
          except that a generic name may be the same as the name of a procedure as explained in 15.4.3.4 or the same as
          the name of a derived type (7.5.10). A local identiﬁer of one class may be the same as a local identiﬁer of another
          class.
             NOTE19.3
             Anintrinsic procedure is inaccessible by its own name in a scoping unit that uses the same name as a local
             identiﬁer of class (1) for a diﬀerent entity. For example, in the program fragment
             SUBROUTINE SUB
                ...
                A = SIN (K)
                ...
             CONTAINS
                FUNCTION SIN (X)
                   ...
                END FUNCTION SIN
             END SUBROUTINE SUB
             any reference to function SIN in subroutine SUB refers to the internal function SIN, not to the intrinsic
             function of the same name.
        4 Alocal identiﬁer identiﬁes an entity in a scope and may be used to identify an entity in another scope except in
          the following cases.
                                                        c
          510                                           ISO/IEC 2017 – All rights reserved
                                                               ISO/IEC DIS 1539-1:2017 (E)
            • The name that appears as a subroutine-name in a subroutine-stmt has limited use within the scope estab-
              lished by the subroutine-stmt. It can be used to identify recursive references of the subroutine or to identify
              a common block (the latter is possible only for internal and module subroutines).
            • The name that appears as a function-name in a function-stmt has limited use within the scope established
              by that function-stmt. It can be used to identify the function result, to identify recursive references of the
              function, or to identify a common block (the latter is possible only for internal and module functions).
            • The name that appears as an entry-name in an entry-stmt has limited use within the scope of the subprogram in which
              the entry-stmt appears. It can be used to identify the function result if the subprogram is a function, to identify recursive
              references, or to identify a common block (the latter is possible only if the entry-stmt is in a module subprogram).
          19.3.2  Local identiﬁers that are the same as common block names
        1 Aname that identiﬁes a common block in a scoping unit shall not be used to identify a constant or an intrinsic procedure in that
          scoping unit. If a local identiﬁer of class (1) is also the name of a common block, the appearance of that name in any context other
          than as a common block name in a BIND, COMMON, or SAVE statement is an appearance of the local identiﬁer.
          19.3.3  Function results
        1 For each FUNCTION statement or ENTRY statement in a function subprogram, there is a function result. A function
          result is either a variable or a procedure pointer, and thus the name of a function result is a local identiﬁer of
          class (1).
          19.3.4  Components, type parameters, and bindings
        1 A component name has the scope of its derived-type deﬁnition. Outside the type deﬁnition, it may also appear
          within a designator of a component of a structure of that type or as a component keyword in a structure
          constructor for that type.
        2 A type parameter name has the scope of its derived-type deﬁnition. Outside the derived-type deﬁnition, it may
          also appear as a type parameter keyword in a derived-type-spec for the type or as the type-param-name of a
          type-param-inquiry.
        3 The binding name (7.5.5) of a type-bound procedure has the scope of its derived-type deﬁnition. Outside of the
          derived-type deﬁnition, it may also appear as the binding-name in a procedure reference.
        4 Ageneric binding for which the generic-spec is not a generic-name has a scope that consists of all scoping units
          in which an entity of the type is accessible.
        5 Acomponent name or binding name may appear only in a scope in which it is accessible.
        6 The accessibility of components and bindings is speciﬁed in 7.5.4.8 and 7.5.5.
          19.3.5  Argument keywords
        1 As an argument keyword, a dummy argument name in an internal procedure, module procedure, or an interface
          body has a scope of the scoping unit of the host of the procedure or interface body. As an argument keyword,
          the name of a dummy argument of a procedure declared by a procedure declaration statement that speciﬁes an
          explicit interface has a scope of the scoping unit containing the procedure declaration statement. It may appear
          only in a procedure reference for the procedure of which it is a dummy argument. If the procedure is accessible
          in another scoping unit by use or host association (19.5.1.3, 19.5.1.4), the argument keyword is accessible for
          procedure references for that procedure in that scoping unit.
          c
          ISO/IEC 2017 – All rights reserved                                         511
          ISO/IEC DIS 1539-1:2017 (E)
        2 A dummy argument name in an intrinsic procedure has a scope as an argument keyword of the scoping unit
          in which the reference to the procedure occurs. As an argument keyword, it may appear only in a procedure
          reference for the procedure of which it is a dummy argument.
          19.4   Statement and construct entities
        1 Avariable that appears as a data-i-do-variable in a DATA statement or an ac-do-variable in an array constructor,
          as a dummy argument in a statement function statement, or as an index-name in a FORALL statement is a statement entity. A
          variable that appears as an index-name in a FORALL or DO CONCURRENT, as an associate-name in a SELECT
          TYPEorASSOCIATEconstruct, or as a coarray-name in a codimension-decl in a CHANGE TEAM construct is
          a construct entity. A variable that has LOCAL or LOCAL_INIT locality in a DO CONCURRENT construct is a
          construct entity. An entity that is explicitly declared in the speciﬁcation part of a BLOCK construct, other than
          only in ASYNCHRONOUS and VOLATILE statements, is a construct entity. A USE statement in a BLOCK
          construct explicitly declares the entities accessed by use association to be construct entities. Two construct
          entities of the same construct shall not have the same identiﬁer.
        2 Even if the name of a statement entity is the same as another identiﬁer and the statement is in the scope of that
          identiﬁer, within the scope of the statement entity the name is interpreted as that of the statement entity.
        3 The name of a statement entity shall not be the same as an accessible global identiﬁer or local identiﬁer of class
          (1) (19.3.1), except for a common block name or a scalar variable name. Within the scope of a statement entity,
          another statement entity shall not have the same name.
        4 The name of a data-i-do-variable in a DATA statement or an ac-do-variable in an array constructor has a scope
          of its data-implied-do or ac-implied-do. It is a scalar variable. If integer-type-spec appears in data-implied-do or
          ac-implied-do-control it has the speciﬁed type and type parameters; otherwise it has the type and type parameters
          that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
          includes the DATA statement or array constructor, and this type shall be integer type. It has no other attributes.
          The appearance of a name as a data-i-do-variable of an implied DO in a DATA statement or an ac-do-variable
          in an array constructor is not an implicit declaration of a variable whose scope is the scoping unit that contains
          the statement.
        5 The name of a variable that appears as an index-name in a DO CONCURRENT construct, FORALL statement, or
          FORALLconstruct has a scope of the statement or construct. It is a scalar variable. If integer-type-spec appears in
          concurrent-header it has the speciﬁed type and type parameters; otherwise it has the type and type parameters
          that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
          includes the DO CONCURRENT or FORALL, and this type shall be integer type. It has no other attributes.
          The appearance of a name as an index-name in a DO CONCURRENT construct, FORALL statement, or FORALL
          construct is not an implicit declaration of a variable whose scope is the scoping unit that contains the statement or
          construct.
        6 Avariable that has LOCAL or LOCAL_INIT locality in a DO CONCURRENT construct has the scope of that
          construct. Its attributes are speciﬁed in 11.1.7.5.
        7 If integer-type-spec does not appear in a concurrent-header, an index-name shall not be the same as an accessible
          global identiﬁer, local identiﬁer, or identiﬁer of an outer construct entity, except for a common block name or
          a scalar variable name. An index-name of a contained DO CONCURRENT construct, FORALL statement, or
          FORALLconstruct shall not be the same as an index-name of any of its containing DO CONCURRENT or FORALL
          constructs.
                                                        c
          512                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          8 The associate name of a SELECT TYPE construct has a separate scope for each block of the construct. Within
             each block, it has the declared type, dynamic type, type parameters, rank, and bounds speciﬁed in 11.1.11.2.
          9 The associate names of an ASSOCIATE construct have the scope of the block. They have the declared type,
             dynamic type, type parameters, rank, and bounds speciﬁed in 11.1.3.2.
         10 The associate names of a CHANGE TEAM construct have the scope of the block. They have the declared type,
             dynamic type, type parameters, rank, corank, bounds, and cobounds speciﬁed in 11.1.5.
         11 The name of a variable that appears as a dummy argument in a statement function statement has a scope of the statement in which
             it appears. It is a scalar that has the type and type parameters that it would have if it were the name of a variable in the scoping
             unit that includes the statement function; it has no other attributes.
             19.5      Association
             19.5.1     Name association
             19.5.1.1   Forms of name association
          1 There are ﬁve forms of name association: argument association, use association, host association, linkage asso-
             ciation, and construct association. Argument, use, and host association provide mechanisms by which entities
             known in one scope may be accessed in another scope.
             19.5.1.2   Argument association
          1 The rules governing argument association are given in Clause 15. As explained in 15.5, execution of a procedure
             reference establishes a correspondence between each actual argument and a dummy argument and thus an associ-
             ation between each present dummy argument and its eﬀective argument. Argument association can be sequence
             association (15.5.2.11).
          2 Thenameofthedummyargumentmaybediﬀerentfromthename, if any, of its eﬀective argument. The dummy
             argument name is the name by which the eﬀective argument is known, and by which it may be accessed, in the
             referenced procedure.
                  NOTE19.4
                  An eﬀective argument can be a nameless data entity, such as the result of evaluating an expression that is
                  not simply a variable or constant.
          3 Upon termination of execution of a procedure reference, all argument associations established by that reference
             are terminated. A dummy argument of that procedure can be associated with an entirely diﬀerent eﬀective
             argument in a subsequent invocation of the procedure.
             19.5.1.3   Use association
          1 Use association is the association of names in diﬀerent scopes speciﬁed by a USE statement. The rules governing
             use association are given in 14.2.2. They allow for renaming of entities being accessed. Use association allows
             access in one scope to entities deﬁned or declared in another scope; it remains in eﬀect throughout the execution
             of the program.
              c
             ISO/IEC 2017 – All rights reserved                                                                     513
             ISO/IEC DIS 1539-1:2017 (E)
             19.5.1.4   Host association
          1 Anested scoping unit has access to named entities from its host as speciﬁed in 8.8. A host-associated variable is
             considered to have been previously declared; any other host-associated entity is considered to have been previously
             deﬁned. In the case of an internal subprogram, the access is to the entities in its host instance. The accessed
             entities are identiﬁed by the same identiﬁer and have the same attributes as in the host, except that a local entity
             may have the ASYNCHRONOUS attribute even if the host entity does not, and a noncoarray local entity may
             have the VOLATILE attribute even if the host entity does not. The accessed entities are named data objects,
             derived types, abstract interfaces, procedures, generic identiﬁers, and namelist groups.
          2 If an entity that is accessed by use association has the same nongeneric name as a host entity, the host entity is
             inaccessible by that name. The name of an external procedure that is given the EXTERNAL attribute (8.5.9)
             within the scoping unit, or a name that appears within the scoping unit as a module-name in a use-stmt is a
             global identiﬁer; any entity of the host that has this as its nongeneric name is inaccessible by that name. A name
             that appears in the scoping unit as
                   (1)   a function-name in a stmt-function-stmt or in an entity-decl in a type-declaration-stmt, unless it is a
                         global identiﬁer,
                   (2)   an object-name in an entity-decl in a type-declaration-stmt, in a pointer-stmt, in a save-stmt, in an
                         allocatable-stmt, or in a target-stmt,
                   (3)   a type-param-name in a derived-type-stmt,
                   (4)   a named-constant in a named-constant-def in a parameter-stmt,
                   (5)   a coarray-name in a codimension-stmt,
                   (6)   an array-name in a dimension-stmt,
                   (7)   a variable-name in a common-block-object in a common-stmt,
                   (8)   a procedure pointer given the EXTERNAL attribute in the scoping unit,
                   (9)   the name of a variable that is wholly or partially initialized in a data-stmt,
                   (10)  the name of an object that is wholly or partially equivalenced in an equivalence-stmt,
                   (11)  a dummy-arg-name in a function-stmt, in a subroutine-stmt, in an entry-stmt, or in a stmt-function-stmt,
                   (12)  a result-name in a function-stmt or in an entry-stmt,
                   (13)  the name of an entity declared by an interface body, unless it is a global identiﬁer,
                   (14)  an intrinsic-procedure-name in an intrinsic-stmt,
                   (15)  a namelist-group-name in a namelist-stmt,
                   (16)  a generic-name in a generic-spec in an interface-stmt, or
                   (17)  the name of a named construct
             is a local identiﬁer in the scoping unit and any entity of the host that has this as its nongeneric name is inaccessible
             by that name by host association. If a scoping unit is the host of a derived-type deﬁnition or a subprogram that
             does not deﬁne a separate module procedure, the name of the derived type or of any procedure deﬁned by the
             subprogram is a local identiﬁer in the scoping unit; any entity of the host that has this as its nongeneric name is
             inaccessible by that name. Local identiﬁers of a subprogram are not accessible to its host.
                  NOTE19.5
                  Aname that appears in an ASYNCHRONOUS or VOLATILE statement is not necessarily the name of a
                  local variable. In an internal or module procedure, if a variable that is accessible via host association is spe-
                  ciﬁed in an ASYNCHRONOUSorVOLATILEstatement,thathostvariableisgiventheASYNCHRONOUS
                  or VOLATILE attribute in the local scope.
                                                                            c
             514                                                           ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         3 If a host entity is inaccessible only because a local variable with the same name is wholly or partially initialized
            in a DATA statement, the local variable shall not be referenced or deﬁned prior to the DATA statement.
         4 If a derived-type name of a host is inaccessible, data entities of that type or subobjects of such data entities still
            can be accessible.
                NOTE19.6
                An interface body that is not a module procedure interface body accesses by host association only those
                entities made accessible by IMPORT statements.
         5 If an external or dummy procedure with an implicit interface is accessed via host association, then it shall have
            the EXTERNALattribute in the host scoping unit; if it is invoked as a function in the inner scoping unit, its type
            and type parameters shall be established in the host scoping unit. The type and type parameters of a function
            with the EXTERNAL attribute are established in a scoping unit if that scoping unit explicitly declares them,
            invokes the function, accesses the function from a module, or accesses the function from its host where its type
            and type parameters are established.
         6 If an intrinsic procedure is accessed via host association, then it shall be established to be intrinsic in the host
            scoping unit. An intrinsic procedure is established to be intrinsic in a scoping unit if that scoping unit explicitly
            gives it the INTRINSIC attribute, invokes it as an intrinsic procedure, accesses it from a module, or accesses it
            from its host where it is established to be intrinsic.
                NOTE19.7
                Ahost subprogram and an internal subprogram can contain the same and diﬀering use-associated entities,
                as illustrated in the following example.
                MODULE B; REAL BX, Q; INTEGER IX, JX; END MODULE B
                MODULE C; REAL CX; END MODULE C
                MODULE D; REAL DX, DY, DZ; END MODULE D
                MODULE E; REAL EX, EY, EZ; END MODULE E
                MODULE F; REAL FX; END MODULE F
                MODULE G; USE F; REAL GX; END MODULE G
                PROGRAM A
                USE B; USE C; USE D
                   ...
                CONTAINS
                   SUBROUTINE INNER_PROC (Q)
                      USE C            ! Not needed
                      USE B, ONLY: BX  ! Entities accessible are BX, IX, and JX
                                       ! if no other IX or JX
                                       ! is accessible to INNER_PROC
                                       ! Q is local to INNER_PROC,
                                       ! because Q is a dummy argument
                      USE D, X => DX   ! Entities accessible are DX, DY, and DZ
                                       ! X is local name for DX in INNER_PROC
                                       ! X and DX denote same entity if no other
                                       ! entity DX is local to INNER_PROC
                      USE E, ONLY: EX  ! EX is accessible in INNER_PROC, not in program A
            c
            ISO/IEC 2017 – All rights reserved                                                      515
             ISO/IEC DIS 1539-1:2017 (E)
                  NOTE19.7 (cont.)
                                            ! EY and EZ are not accessible in INNER_PROC
                                            ! or in program A
                         USE G              ! FX and GX are accessible in INNER_PROC
                         ...
                     END SUBROUTINE INNER_PROC
                  END PROGRAM A
                  Because program A contains the statement
                  USE B
                  all of the entities in module B, except for Q, are accessible in INNER_PROC, even though INNER_PROC
                  contains the statement
                  USE B, ONLY: BX
                  The USE statement with the ONLY option means that this particular statement brings in only the entity
                  named, not that this is the only variable from the module accessible in this scoping unit.
                  NOTE19.8
                  For more examples of host association, see subclause C.13.
             19.5.1.5   Linkage association
          1 Linkage association occurs between a module variable that has the BIND attribute and the C variable with which
             it interoperates, or between a Fortran common block and the C variable with which it interoperates (18.9). Such association
             remains in eﬀect throughout the execution of the program.
             19.5.1.6   Construct association
          1 Execution of a SELECT RANK or SELECT TYPEstatement establishes an association between the selector and
             the associate name of the construct. Execution of an ASSOCIATE or CHANGE TEAM statement statement
             establishes an association between each selector and the corresponding associate name of the construct.
          2 In an ASSOCIATE or SELECT TYPE construct, the following rules apply.
                 • If a selector is allocatable, it shall be allocated; the associate name is associated with the data object and
                   does not have the ALLOCATABLE attribute.
                 • If a selector has the POINTER attribute, it shall be associated; the associate name is associated with the
                   target of the pointer and does not have the POINTER attribute.
          3 If the selector is a variable other than an array section having a vector subscript, the association is with the data
             object speciﬁed by the selector; otherwise, the association is with the value of the selector expression, which is
             evaluated prior to execution of the block.
          4 Eachassociate name remains associated with the corresponding selector throughout the execution of the executed
             block. Within the block, each selector is known by and may be accessed by the corresponding associate name.
             Oncompletion of execution of the construct, the association is terminated.
                                                                            c
             516                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
                  NOTE19.9
                  The association between the associate name and a data object is established prior to execution of the block
                  and is not aﬀected by subsequent changes to variables that were used in subscripts or substring ranges in
                  the selector.
             19.5.2     Pointer association
             19.5.2.1   General
          1 Pointer association between a pointer and a target allows the target to be referenced by a reference to the pointer.
             Atdiﬀerent times during the execution of a program, a pointer may be undeﬁned, associated with diﬀerent targets
             on its own image, or be disassociated. If a pointer is associated with a target, the deﬁnition status of the pointer
             is either deﬁned or undeﬁned, depending on the deﬁnition status of the target. If the pointer has deferred type
             parameters or shape, their values are assumed from the target. If the pointer is polymorphic, its dynamic type
             is assumed from the dynamic type of the target.
             19.5.2.2   Pointer association status
          1 Apointer may have a pointer association status of associated, disassociated, or undeﬁned. Its association status
             may change during execution of a program. Unless a pointer is initialized (explicitly or by default), it has an
             initial association status of undeﬁned. A pointer may be initialized to have an association status of disassociated
             or associated.
                  NOTE19.10
                  A pointer from a module program unit might be accessible in a subprogram via use association. Such
                  pointers have a lifetime that is greater than targets that are declared in the subprogram, unless such targets
                  are saved. Therefore, if such a pointer is associated with a local target, there is the possibility that when
                  a procedure deﬁned by the subprogram completes execution, the target will cease to exist, leaving the
                  pointer “dangling”. This document considers such pointers to have an undeﬁned association status. They
                  are neither associated nor disassociated. They cannot be used again in the program until their status has
                  been reestablished. A processor is not required to detect when a pointer target ceases to exist.
             19.5.2.3   Events that cause pointers to become associated
          1 Apointer becomes associated when any of the following events occur.
                   (1)   The pointer is allocated (9.7.1) as the result of the successful execution of an ALLOCATE statement
                         referencing the pointer.
                   (2)   Thepointerispointer-assigned to a target (10.2.2) that is associated or is speciﬁed with the TARGET
                         attribute and, if allocatable, is allocated.
                   (3)   The pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
                         SOURCE=appears and the corresponding subobject of source-expr is associated.
                   (4)   The pointer is a dummy argument and its corresponding actual argument is not a pointer.
                   (5)   The pointer is a default-initialized subcomponent of an object, the corresponding initializer is not a
                         reference to the intrinsic function NULL, and
                         (a)   a procedure is invoked with this object as an actual argument corresponding to a nonpointer
                               nonallocatable dummy argument with INTENT (OUT),
              c
             ISO/IEC 2017 – All rights reserved                                                                     517
              ISO/IEC DIS 1539-1:2017 (E)
                          (b)   a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
                          (c)   a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
                                local variable of the BLOCK construct,
                                or
                          (d)   this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
              19.5.2.4  Events that cause pointers to become disassociated
           1 Apointer becomes disassociated when
                    (1)   the pointer is nulliﬁed (9.7.2),
                    (2)   the pointer is deallocated (9.7.3),
                    (3)   the pointer is pointer-assigned (10.2.2) to a disassociated pointer,
                    (4)   the pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
                          SOURCE=appears and the corresponding subobject of source-expr is disassociated,
                          or
                    (5)   the pointer is a default-initialized subcomponent of an object, the corresponding initializer is a
                          reference to the intrinsic function NULL, and
                          (a)   a procedure is invoked with this object as an actual argument corresponding to a nonpointer
                                nonallocatable dummy argument with INTENT (OUT),
                          (b)   a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
                          (c)   a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
                                local variable of the BLOCK construct,
                                or
                          (d)   this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
              19.5.2.5  Events that cause the association status of pointers to become undeﬁned
           1 The association status of a pointer becomes undeﬁned when
                    (1)   the pointer is pointer-assigned to a target that has an undeﬁned association status,
                    (2)   the pointer is pointer-assigned to a target on a diﬀerent image,
                    (3)   the target of the pointer is deallocated other than through the pointer,
                    (4)   the target of the pointer is a data object deﬁned by the companion processor and the lifetime of that
                          data object ends,
                    (5)   the allocation transfer procedure (16.9.137) is executed, the pointer is associated with the argument
                          FROM, and the argument TO does not have the TARGET attribute,
                    (6)   completion of execution of an instance of a subprogram causes the pointer’s target to become un-
                          deﬁned (item (3) of 19.6.6),
                    (7)   completion of execution of a BLOCK construct causes the pointer’s target to become undeﬁned (item
                          (23) of 19.6.6),
                    (8)   execution of the host instance of a procedure pointer is completed,
                    (9)   execution of an instance of a subprogram completes and the pointer is declared or accessed in the
                          subprogram that deﬁnes the procedure if the pointer
                          (a)   does not have the SAVE attribute,
                                                                              c
              518                                                            ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
                          (b)   is not in blank common,
                          (c)   is not in a named common block that is declared in any other scoping unit that is in execution,
                          (d)   is not accessed by host association, and
                          (e)   is not the result of a function declared to have the POINTER attribute,
                    (10)  execution of an instance of a subprogram completes, the pointer is associated with a dummy argument
                          of the procedure, and
                          (a)   the eﬀective argument does not have the TARGET attribute or is an array section with a
                                vector subscript, or
                          (b)   the dummy argument has the VALUE attribute,
                    (11)  a BLOCK construct completes execution and the pointer is an unsaved construct entity of that
                          BLOCKconstruct,
                    (12)  a DO CONCURRENT construct is terminated and the pointer’s association status was changed in
                          more than one iteration of the construct,
                    (13)  an iteration of a DO CONCURRENT construct completes and the pointer is associated with a
                          variable of that construct that has LOCAL or LOCAL_INIT locality,
                    (14)  the pointer is a subcomponent of an object that is allocated and either
                          (a)   the pointer is not default-initialized and SOURCE= does not appear, or
                          (b)   SOURCE=appears and the association status of the corresponding subcomponent of source-
                                expr is undeﬁned,
                    (15)  the pointer is a subcomponent of an object, the pointer is not default-initialized, and a procedure is
                          invoked with this object as an actual argument corresponding to a dummy argument with INTENT
                          (OUT),
                    (16)  a procedure is invoked with the pointer as an actual argument corresponding to a pointer dummy
                          argument with INTENT (OUT), or
                    (17)  evaluation of an expression containing a function reference that need not be evaluated completes, if
                          execution of that function would change the association status of the pointer.
              19.5.2.6  Other events that change the association status of pointers
           1 Whenapointer becomes associated with another pointer by argument association, construct association, or host
              association, the eﬀects on its association status are speciﬁed in 19.5.5.
           2 While two pointers are name associated, storage associated, or inheritance associated, if the association status of
              one pointer changes, the association status of the other changes accordingly.
           3 The association status of a pointer object with the VOLATILE attribute might change by means not speciﬁed
              by the program.
              19.5.2.7  Pointer deﬁnition status
           1 The deﬁnition status of an associated pointer is that of its target. If a pointer is associated with a deﬁnable
              target, it may be deﬁned or become undeﬁned according to the rules for a variable (19.6). The deﬁnition status
              of a pointer that is not associated is undeﬁned.
              c
              ISO/IEC 2017 – All rights reserved                                                                       519
             ISO/IEC DIS 1539-1:2017 (E)
             19.5.2.8   Relationship between association status and deﬁnition status
          1 If the association status of a pointer is disassociated or undeﬁned, the pointer shall not be referenced or dealloc-
             ated. Whatever its association status, a pointer always may be nulliﬁed, allocated, or pointer-assigned. A nulliﬁed
             pointer is disassociated. When a pointer is allocated, it becomes associated but undeﬁned. When a pointer is
             pointer-assigned, its association and deﬁnition status become those of the speciﬁed data-target or proc-target.
             19.5.3     Storage association
             19.5.3.1   General
          1 Storage sequences are used to describe relationships that exist among variables and common blocks. Storage asso-
             ciation is the association of two or more data objects that occurs when two or more storage sequences share or
             are aligned with one or more storage units.
             19.5.3.2   Storage sequence
          1 A storage sequence is a sequence of storage units. The size of a storage sequence is the number of storage units
             in the storage sequence. A storage unit is a character storage unit, a numeric storage unit, a ﬁle storage unit
             (12.3.5), or an unspeciﬁed storage unit. The sizes of the numeric storage unit, the character storage unit and the
             ﬁle storage unit are the values of constants in the ISO_FORTRAN_ENV intrinsic module (16.10.2).
          2 In a storage association context
                   (1)   a nonpointer scalar object that is default integer, default real, or default logical occupies a single
                         numeric storage unit,
                   (2)   a nonpointer scalar object that is double precision real or default complex occupies two contiguous
                         numeric storage units,
                   (3)   a default character nonpointer scalar object of character length len occupies len contiguous character
                         storage units,
                   (4)   if C character kind is not the same as default character kind a nonpointer scalar object of type char-
                         acter with the C character kind (18.2.2) and character length len occupies len contiguous unspeciﬁed
                         storage units,
                   (5)   a nonpointer scalar object of sequence type occupies a sequence of storage sequences corresponding
                         to the sequence of its ultimate components,
                   (6)   a nonpointer scalar object of any type not speciﬁed in items (1)-(5) occupies a single unspeciﬁed
                         storage unit that is diﬀerent for each case and each set of type parameter values, and that is diﬀerent
                         from the unspeciﬁed storage units of item (4),
                   (7)   a nonpointer array occupies a sequence of contiguous storage sequences, one for each array element,
                         in array element order (9.5.3.2), and
                   (8)   a data pointer occupies a single unspeciﬁed storage unit that is diﬀerent from that of any nonpointer
                         object and is diﬀerent for each combination of type, type parameters, and rank. A data pointer that
                         has the CONTIGUOUSattribute occupies a storage unit that is diﬀerent from that of a data pointer
                         that does not have the CONTIGUOUS attribute.
          3 A sequence of storage sequences forms a storage sequence. The order of the storage units in such a composite
             storage sequence is that of the individual storage units in each of the constituent storage sequences taken in
             succession, ignoring any zero-sized constituent sequences.
                                                                            c
             520                                                           ISO/IEC 2017 – All rights reserved
                                                                                    ISO/IEC DIS 1539-1:2017 (E)
          4 Each common block has a storage sequence (8.10.2.2).
             19.5.3.3   Association of storage sequences
          1 Two nonzero-sized storage sequences s and s are storage associated if the ith storage unit of s is the same as
                                                  1      2                                                1
             the jth storage unit of s . This causes the (i + k)th storage unit of s to be the same as the (j + k)th storage
                                     2                                           1
             unit of s , for each integer k such that 1 ≤ i + k ≤ size of s and 1 ≤ j + k ≤ size of s where size of measures
                     2                                                 1                         2
             the number of storage units.
          2 Storage association also is deﬁned between two zero-sized storage sequences, and between a zero-sized storage
             sequence and a storage unit. A zero-sized storage sequence in a sequence of storage sequences is storage associated
             with its successor, if any. If the successor is another zero-sized storage sequence, the two sequences are storage
             associated. If the successor is a nonzero-sized storage sequence, the zero-sized sequence is storage associated with
             the ﬁrst storage unit of the successor. Two storage units that are each storage associated with the same zero-sized
             storage sequence are the same storage unit.
             19.5.3.4   Association of scalar data objects
          1 Twoscalardataobjectsarestorageassociated if their storage sequences are storage associated. Two scalar entities
             are totally associated if they have the same storage sequence. Two scalar entities are partially associated if they
             are associated without being totally associated.
          2 The deﬁnition status and value of a data object aﬀects the deﬁnition status and value of any storage associated
             entity. An EQUIVALENCE statement, a COMMON statement, or an ENTRY statement can cause storage association of storage
             sequences.
          3 AnEQUIVALENCEstatementcausesstorageassociation of data objects only within one scoping unit, unless one of the equivalenced
             entities is also in a common block (8.10.1.2, 8.10.2.2).
          4 COMMONstatementscausedataobjectsinonescoping unit to become storage associated with data objects in another scoping unit.
          5 Acommon block is permitted to contain a sequence of diﬀering storage units. All scoping units that access named common blocks
             with the same name shall specify an identical sequence of storage units. Blank common blocks may be declared with diﬀering sizes
             in diﬀerent scoping units. For any two blank common blocks, the initial sequence of storage units of the longer blank common block
             shall be identical to the sequence of storage units of the shorter common block. If two blank common blocks are the same length,
             they shall have the same sequence of storage units.
          6 AnENTRYstatement in a function subprogram causes storage association of the function results that are variables.
          7 Partial association shall exist only between
                 • an object that is default character or of character sequence type and an object that is default character or
                   of character sequence type, or
                 • an object that is default complex, double precision real, or of numeric sequence type and an object that is
                   default integer, default real, default logical, double precision real, default complex, or of numeric sequence
                   type.
          8 Fornoncharacter entities, partial association may occur only through the use of COMMON, EQUIVALENCE, or ENTRY statements.
             For character entities, partial association may occur only through argument association or the use of COMMON or
             EQUIVALENCEstatements.
              c
             ISO/IEC 2017 – All rights reserved                                                                     521
           ISO/IEC DIS 1539-1:2017 (E)
         9 Partial association of character entities occurs when some, but not all, of the storage units of the entities are the
           same.
        10 A storage unit shall not be explicitly initialized more than once in a program. Explicit initialization overrides
           default initialization, and default initialization for an object of derived type overrides default initialization for
           a component of the object (7.5.4.6). Default initialization may be speciﬁed for a storage unit that is storage
           associated provided the objects supplying the default initialization are of the same type and type parameters,
           and supply the same value for the storage unit.
           19.5.4  Inheritance association
         1 Inheritance association occurs between components of the parent component and components inherited by type
           extension into an extended type (7.5.7.2). This association is persistent; it is not aﬀected by the accessibility of
           the inherited components.
           19.5.5  Establishing associations
         1 When an association is established between two entities by argument association, host association, or construct
           association, certain properties of the associating entity become those of the pre-existing entity.
         2 Forargumentassociation, the pre-existing entity is the eﬀective argument and the associating entity is the dummy
           argument.
         3 For host association, the associating entity is the entity in the contained scoping unit. When a procedure is
           invoked, the pre-existing entity that participates in the association is the one from its host instance (15.6.2.4).
           Otherwise the pre-existing entity that participates in the association is the entity in the host scoping unit.
         4 For construct association, the associating entity is identiﬁed by the associate name and the pre-existing entity is
           the selector.
         5 When an association is established by argument association, host association, or construct association, the fol-
           lowing applies.
              • If the entities have the POINTER attribute, the pointer association status of the associating entity becomes
               the same as that of the pre-existing entity. If the pre-existing entity has a pointer association status of
               associated, the associating entity becomes pointer associated with the same target and, if they are arrays,
               the bounds of the associating entity become the same as those of the pre-existing entity.
              • If the associating entity has the ALLOCATABLE attribute, its allocation status becomes the same as that
               of the pre-existing entity. If the pre-existing entity is allocated, the bounds (if it is an array), values of
               deferred type parameters, deﬁnition status, and value (if it is deﬁned) become the same as those of the
               pre-existing entity. If the associating entity is polymorphic and the pre-existing entity is allocated, the
               dynamic type of the associating entity becomes the same as that of the pre-existing entity.
              • If the associating entity is neither a pointer nor allocatable, its deﬁnition status, value (if it is deﬁned), and
               dynamic type (if it is polymorphic) become the same as those of the pre-existing entity. If the entities are
               arrays and the association is not argument association, the bounds of the associating entity become the
               same as those of the pre-existing entity.
              • If the associating entity is a pointer dummy argument and the pre-existing entity is a nonpointer actual
               argument the associating entity becomes pointer associated with the pre-existing entity and, if the entities
               are arrays, the bounds of the associating entity become the same as those of the pre-existing entity.
                                                              c
           522                                               ISO/IEC 2017 – All rights reserved
                                                                     ISO/IEC DIS 1539-1:2017 (E)
           19.6    Deﬁnition and undeﬁnition of variables
           19.6.1  Deﬁnition of objects and subobjects
         1 A variable may be deﬁned or may be undeﬁned and its deﬁnition status may change during execution of a
           program. An action that causes a variable to become undeﬁned does not imply that the variable was previously
           deﬁned. An action that causes a variable to become deﬁned does not imply that the variable was previously
           undeﬁned.
         2 Arrays, including sections, and variables of derived, character, or complex type are objects that consist of zero
           or more subobjects. Associations may be established between variables and subobjects and between subobjects
           of diﬀerent variables. These subobjects may become deﬁned or undeﬁned.
         3 An array is deﬁned if and only if all of its elements are deﬁned.
         4 Aderived-type scalar object is deﬁned if and only if all of its nonpointer components are deﬁned.
         5 Acomplex or character scalar object is deﬁned if and only if all of its subobjects are deﬁned.
         6 If an object is undeﬁned, at least one (but not necessarily all) of its subobjects are undeﬁned.
           19.6.2  Variables that are always deﬁned
         1 Zero-sized arrays and zero-length strings are always deﬁned.
           19.6.3  Variables that are initially deﬁned
         1 The following variables are initially deﬁned:
                (1)  variables speciﬁed to have initial values by DATA statements;
                (2)  variables speciﬁed to have initial values by type declaration statements;
                (3)  nonpointer default-initialized subcomponents of saved variables that do not have the ALLOCAT-
                     ABLEor POINTER attribute;
                (4)  pointers speciﬁed to be initially associated with a variable that is initially deﬁned;
                (5)  variables that are always deﬁned;
                (6)  variables with the BIND attribute that are initialized by means other than Fortran.
               NOTE19.11
               Fortran code:
               module mod
                 integer, bind(c,name="blivet") :: foo
               end module mod
               Ccode:
               int blivet = 123;
               In the above example, the Fortran variable foo is initially deﬁned to have the value 123 by means other
               than Fortran.
           c
           ISO/IEC 2017 – All rights reserved                                                 523
              ISO/IEC DIS 1539-1:2017 (E)
              19.6.4    Variables that are initially undeﬁned
           1 Variables that are not initially deﬁned are initially undeﬁned.
              19.6.5    Events that cause variables to become deﬁned
           1 Variables become deﬁned by the following events.
                    (1)   Execution of an intrinsic assignment statement other than a masked array assignment or FORALL
                          assignment statement causes the variable that precedes the equals to become deﬁned.
                    (2)   Execution of a masked array assignment or FORALL assignment statement might cause some or all of
                          the array elements in the assignment statement to become deﬁned (10.2.3).
                    (3)   As execution of an input statement proceeds, each variable that is assigned a value from the input
                          ﬁle becomes deﬁned at the time that data are transferred to it. (See (4) in 19.6.6.) Execution of a
                          WRITE statement whose unit speciﬁer identiﬁes an internal ﬁle causes each record that is written
                          to become deﬁned.
                    (4)   Execution of a DO statement causes the DO variable, if any, to become deﬁned.
                    (5)   Beginning of execution of the action speciﬁed by an io-implied-do in a synchronous data transfer
                          statement causes the do-variable to become deﬁned.
                    (6)   Areference to a procedure causes an entire dummy data object to become deﬁned if the dummy data
                          object does not have INTENT (OUT) and the entire eﬀective argument is deﬁned.
                          Areference to a procedure causes a subobject of a dummy argument to become deﬁned if the dummy
                          argument does not have INTENT (OUT) and the corresponding subobject of the eﬀective argument
                          is deﬁned.
                    (7)   Execution of an input/output statement containing an IOSTAT= speciﬁer causes the speciﬁed integer
                          variable to become deﬁned.
                    (8)   Execution of a synchronous input statement containing a SIZE= speciﬁer causes the speciﬁed integer
                          variable to become deﬁned.
                    (9)   Execution of a wait operation (12.7.1) corresponding to an asynchronous input statement containing
                          a SIZE= speciﬁer causes the speciﬁed integer variable to become deﬁned.
                    (10)  Execution of an INQUIRE statement causes any variable that is assigned a value during the execution
                          of the statement to become deﬁned if no error condition exists.
                    (11)  If an error, end-of-ﬁle, or end-of-record condition occurs during execution of an input/output state-
                          ment that has an IOMSG= speciﬁer, the iomsg-variable becomes deﬁned.
                    (12)  Whenacharacterstorageunitbecomesdeﬁned,allassociatedcharacterstorageunitsbecomedeﬁned.
                          Whenanumeric storage unit becomes deﬁned, all associated numeric storage units of the same type
                          become deﬁned. When an entity of double precision real type becomes deﬁned, all totally associated
                          entities of double precision real type become deﬁned.
                          When an unspeciﬁed storage unit becomes deﬁned, all associated unspeciﬁed storage units become
                          deﬁned.
                    (13)  Whenadefault complex entity becomes deﬁned, all partially associated default real entities become
                          deﬁned.
                    (14)  Whenbothpartsofadefaultcomplexentitybecomedeﬁnedasaresultofpartially associated default
                          real or default complex entities becoming deﬁned, the default complex entity becomes deﬁned.
                                                                              c
              524                                                            ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
                    (15)  When all components of a structure of a numeric sequence type or character sequence type become
                          deﬁned as a result of partially associated objects becoming deﬁned, the structure becomes deﬁned.
                    (16)  Execution of a statement with a STAT= speciﬁer causes the variable speciﬁed by the STAT= speciﬁer
                          to become deﬁned.
                    (17)  If an error condition occurs during execution of a statement that has an ERRMSG= speciﬁer, the
                          variable speciﬁed by the ERRMSG= speciﬁer becomes deﬁned.
                    (18)  Allocation of a zero-sized array or zero-length character variable causes the array or variable to
                          become deﬁned.
                    (19)  Allocation of an object that has a nonpointer default-initialized subcomponent, except by an AL-
                          LOCATEstatement with a SOURCE= speciﬁer, causes that subcomponent to become deﬁned.
                    (20)  Successful execution of an ALLOCATE statement with a SOURCE= speciﬁer causes a subobject of
                          the allocated object to become deﬁned if the corresponding subobject of the SOURCE= expression
                          is deﬁned.
                    (21)  Invocation of a procedure causes any automatic data object of zero size or zero character length in
                          that procedure to become deﬁned.
                    (22)  When a pointer becomes associated with a target that is deﬁned, the pointer becomes deﬁned.
                    (23)  Invocation of a procedure that contains an unsaved nonpointer nonallocatable local variable causes
                          all nonpointer default-initialized subcomponents of the object to become deﬁned.
                    (24)  Invocation of a procedure that has a nonpointer nonallocatable INTENT (OUT) dummy argument
                          causes all nonpointer default-initialized subcomponents of the dummy argument to become deﬁned.
                    (25)  In a DO CONCURRENT or FORALL construct, the index-name becomes deﬁned when the index-
                          name value set is evaluated.
                    (26)  In a DO CONCURRENT construct, a variable with LOCAL_INIT locality becomes deﬁned at the
                          beginning of each iteration.
                    (27)  An object with the VOLATILE attribute that is changed by a means not speciﬁed by the program
                          might become deﬁned (see 8.5.19).
                    (28)  Execution of the BLOCK statement of a BLOCK construct that has an unsaved nonpointer non-
                          allocatable local variable causes all nonpointer default-initialized subcomponents of the variable to
                          become deﬁned.
                    (29)  Execution of an OPEN statement containing a NEWUNIT= speciﬁer causes the speciﬁed integer
                          variable to become deﬁned.
                    (30)  Execution of a LOCK statement containing an ACQUIRED_LOCK= speciﬁer causes the speciﬁed
                          logical variable to become deﬁned. If the logical variable becomes deﬁned with the value true, the
                          lock variable in the LOCK statement also becomes deﬁned.
                    (31)  Successful execution of a LOCK statement that does not contain an ACQUIRED_LOCK= speciﬁer
                          causes the lock variable to become deﬁned.
                    (32)  Successful execution of an UNLOCK statement causes the lock variable to become deﬁned.
                    (33)  Failure of an image that locked a lock variable without unlocking it causes the lock variable to become
                          deﬁned.
                    (34)  Successful execution of an EVENT POST or EVENT WAIT statement causes the event variable to
                          become deﬁned.
                    (35)  Successful execution of a FORM TEAM statement causes the team variable to become deﬁned.
              c
              ISO/IEC 2017 – All rights reserved                                                                       525
              ISO/IEC DIS 1539-1:2017 (E)
              19.6.6     Events that cause variables to become undeﬁned
           1 Variables become undeﬁned by the following events.
                   (1)   When a scalar variable of intrinsic type becomess deﬁned, all totally associated variables of diﬀerent type become
                         undeﬁned.  When a double precision scalar variable becomes deﬁned, all partially associated scalar
                         variables become undeﬁned. When a scalar variable becomes undeﬁned, all partially associated double
                         precision scalar variables become undeﬁned.
                   (2)   If the evaluation of a function would cause a variable to become deﬁned and if a reference to the
                         function appears in an expression in which the value of the function is not needed to determine the
                         value of the expression, the variable becomes undeﬁned when the expression is evaluated.
                   (3)   When execution of an instance of a subprogram completes,
                         (a)   its unsaved local variables become undeﬁned,
                         (b)   unsaved variables in a named common block that appears in the subprogram become undeﬁned if they have been
                               deﬁned or redeﬁned, unless another active scoping unit is referencing the common block, and
                         (c)   a variable of type C_PTR from the intrinsic module ISO_C_BINDING whose value is the C
                               address of an unsaved local variable of the subprogram becomes undeﬁned.
                   (4)   When an error condition or end-of-ﬁle condition occurs during execution of an input statement, all of
                         the variables speciﬁed by the input list or namelist group of the statement become undeﬁned.
                   (5)   Whenanerrorconditionoccursduringexecutionofanoutputstatementinwhichtheunitisaninternal
                         ﬁle, the internal ﬁle becomes undeﬁned.
                   (6)   When an error condition, end-of-ﬁle condition, or end-of-record condition occurs during execution of
                         an input/output statement and the statement contains any io-implied-dos, all of the do-variables in
                         the statement become undeﬁned (12.11).
                   (7)   Execution of a direct access input statement that speciﬁes a record that has not been written previously
                         causes all of the variables speciﬁed by the input list of the statement to become undeﬁned.
                   (8)   Execution of an INQUIRE statement might cause the NAME=, RECL=, and NEXTREC= variables
                         to become undeﬁned (12.10).
                   (9)   When a character storage unit becomes undeﬁned, all associated character storage units become un-
                         deﬁned.
                         Whenanumericstorageunitbecomesundeﬁned,allassociatednumericstorageunitsbecomeundeﬁned
                         unless the undeﬁnition is a result of deﬁning an associated numeric storage unit of diﬀerent type (see
                         (1) above).
                         Whenanentityofdoubleprecision real type becomes undeﬁned, all totally associated entities of double
                         precision real type become undeﬁned.
                         When an unspeciﬁed storage unit becomes undeﬁned, all associated unspeciﬁed storage units become
                         undeﬁned.
                   (10) When an allocatable entity is deallocated, it becomes undeﬁned.
                   (11) When the allocation transfer procedure (16.9.137) causes the allocation status of an allocatable entity
                         to become unallocated, the entity becomes undeﬁned.
                   (12) Successful execution of an ALLOCATE statement with no SOURCE= speciﬁer causes a subcomponent
                         of an allocated object to become undeﬁned if default initialization has not been speciﬁed for that
                         subcomponent.
                                                                                 c
              526                                                                ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                   (13) Successful execution of an ALLOCATE statement with a SOURCE= speciﬁer causes a subobject of
                         the allocated object to become undeﬁned if the corresponding subobject of the SOURCE= expression
                         is undeﬁned.
                   (14) Execution of an INQUIRE statement causes all inquiry speciﬁer variables to become undeﬁned if an
                         error condition exists, except for any variable in an IOSTAT= or IOMSG= speciﬁer.
                   (15) When a procedure is invoked
                         (a)   an optional dummy argument that has no corresponding actual argument becomes undeﬁned,
                         (b)   a dummyargument with INTENT (OUT) becomes undeﬁned except for any nonpointer default-
                               initialized subcomponents of the argument,
                         (c)   an actual argument corresponding to a dummy argument with INTENT (OUT) becomes un-
                               deﬁned except for any nonpointer default-initialized subcomponents of the argument,
                         (d)   a subobject of a dummy argument that does not have INTENT (OUT) becomes undeﬁned if the
                               corresponding subobject of the eﬀective argument is undeﬁned, and
                         (e)   a variable that is the function result of that procedure becomes undeﬁned except for any of its
                               nonpointer default-initialized subcomponents.
                   (16) When the association status of a pointer becomes undeﬁned or disassociated (19.5.2.4, 19.5.2.5), the
                         pointer becomes undeﬁned.
                   (17) When a DO CONCURRENT construct terminates, a variable that is deﬁned or becomes undeﬁned
                         during more than one iteration of the construct becomes undeﬁned.
                   (18) When execution of an iteration of a DO CONCURRENT construct completes, a construct entity of
                         that construct which has LOCAL or LOCAL_INIT locality becomes undeﬁned.
                   (19) Execution of an asynchronous READ statement causes all of the variables speciﬁed by the input list or
                         SIZE=speciﬁer to become undeﬁned. Execution of an asynchronous namelist READ statement causes
                         any variable in the namelist group to become undeﬁned if that variable will subsequently be deﬁned
                         during the execution of the READ statement or the corresponding wait operation (12.7.1).
                   (20) When a variable with the TARGET attribute is deallocated, a variable of type C_PTR from the
                         intrinsic module ISO_C_BINDING becomes undeﬁned if its value is the C address of any part of the
                         variable that is deallocated.
                   (21) Whenapointerisdeallocated, a variable of type C_PTR from the intrinsic module ISO_C_BINDING
                         becomes undeﬁned if its value is the C address of any part of the target that is deallocated.
                   (22) Execution of the allocation transfer procedure (16.9.137) where the argument TO does not have the
                         TARGETattribute causes a variable of type C_PTR from the intrinsic module ISO_C_BINDING to
                         become undeﬁned if its value is the C address of any part of the argument FROM.
                   (23) When a BLOCK construct completes execution,
                          •    its unsaved local variables become undeﬁned, and
                          •    a variable of type C_PTR from the intrinsic module ISO_C_BINDING, whose value is the C
                               address of an unsaved local variable of the BLOCK construct, becomes undeﬁned.
                   (24) When execution of the host instance of the target of a variable of type C_FUNPTR from the intrinsic
                         module ISO_C_BINDING is completed by execution of a RETURN or END statement, the variable
                         becomes undeﬁned.
                   (25) Execution of an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module
                         ISO_C_BINDING, or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
                         in which the variable and expr are not on the same image, causes the variable to become undeﬁned.
               c
              ISO/IEC 2017 – All rights reserved                                                                            527
              ISO/IEC DIS 1539-1:2017 (E)
                  (26) An object with the VOLATILE attribute (8.5.19) might become undeﬁned by means not speciﬁed by
                        the program.
                  (27) When a pointer becomes associated with a target that is undeﬁned, the pointer becomes undeﬁned.
                  (28) When an image fails during execution of a segment, a data object on a nonfailed image becomes
                        undeﬁned if it is not a lock variable and it might become undeﬁned by execution of a statement of
                        the segment other than an invocation of an atomic subroutine with the object as an actual argument
                        corresponding to the ATOM dummy argument.
                   NOTE19.12
                  Execution of a deﬁned assignment statement could leave all or part of the variable undeﬁned.
              19.6.7    Variable deﬁnition context
           1 Some variables are prohibited from appearing in a syntactic context that would imply deﬁnition or undeﬁnition
              of the variable (8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a variable implies
              such deﬁnition or undeﬁnition of the variable:
                    (1)   the variable of an assignment-stmt;
                    (2)   a do-variable in a do-stmt or io-implied-do;
                    (3)   an input-item in a read-stmt;
                    (4)   a variable-name in a namelist-stmt if the namelist-group-name appears in a NML= speciﬁer in a
                          read-stmt;
                    (5)   an internal-ﬁle-variable in a write-stmt;
                    (6)   a SIZE= or IOMSG= speciﬁer in an input/output statement;
                    (7)   a speciﬁer in an INQUIRE statement other than FILE=, ID=, and UNIT=;
                    (8)   a NEWUNIT= speciﬁer in an OPEN statement;
                    (9)   a stat-variable, allocate-object, or errmsg-variable;
                    (10)  an actual argument in a reference to a procedure with an explicit interface if the corresponding
                          dummy argument is not a pointer and has INTENT (OUT) or INTENT (INOUT);
                    (11)  a variable that is a selector in an ASSOCIATE, CHANGE TEAM, SELECT RANK, or SELECT
                          TYPEconstruct if the corresponding associate name or any subobject thereof appears in a variable
                          deﬁnition context;
                    (12)  an event-variable in an EVENT POST or EVENT WAIT statement;
                    (13)  a lock-variable in a LOCK or UNLOCK statement;
                    (14)  a scalar-logical-variable in an ACQUIRED_LOCK= speciﬁer;
                    (15)  a team-variable in a FORM TEAM statement.
           2 If a reference to a function appears in a variable deﬁnition context the result of the function reference shall be a
              pointer that is associated with a deﬁnable target. That target is the variable that becomes deﬁned or undeﬁned.
              19.6.8    Pointer association context
           1 Some pointers are prohibited from appearing in a syntactic context that would imply alteration of the pointer
              association status (19.5.2.2, 8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a
              pointer implies such alteration of its pointer association status:
                                                                              c
              528                                                            ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
        • a pointer-object in a nullify-stmt;
        • a data-pointer-object or proc-pointer-object in a pointer-assignment-stmt;
        • an allocate-object in an allocate-stmt or deallocate-stmt;
        • an actual argument in a reference to a procedure if the corresponding dummy argument is a pointer with
         the INTENT (OUT) or INTENT (INOUT) attribute.
       c
      ISO/IEC 2017 – All rights reserved             529
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      530                          ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
                                       Annex A
                                        (Informative)
                              Processor dependencies
         A.1  Unspeciﬁed items
       1 This document does not specify the following:
           • the properties excluded in 1;
           • a processor’s error detection capabilities beyond those listed in 4.2;
           • which additional intrinsic procedures or modules a processor provides (4.2);
           • the number and kind of companion processors (5.5.7);
           • the number of representation methods and associated kind type parameter values of the intrinsic types
            (7.4), except that there shall be at least two representation methods for type real, and a representation
            method of type complex that corresponds to each representation method for type real.
         A.2  Processor dependencies
       1 According to this document, the following are processor dependent:
           • the order of evaluation of the speciﬁcation expressions within the speciﬁcation part of an invoked Fortran
            procedure (5.3.5);
           • how soon an image terminates if another image initiates error termination (5.3.5);
           • the value of a reference to to a coindexed object on a failed image (5.3.6);
           • the conditions that cause an image to fail (5.3.6);
           • whether the processor supports a concept of process exit status, and if so, the process exit status on program
            termination (5.3.7);
           • the mechanismofacompanionprocessor, andthemeansofselectingbetweenmultiplecompanionprocessors
            (5.5.7);
           • the processor character set (6.1);
           • the means for specifying the source form of a program unit (6.3);
           • the maximum number of characters allowed on a source line containing characters not of default kind (6.3.2,
            6.3.3);
           • the maximum depth of nesting of include lines (6.4);
           • the interpretation of the char-literal-constant in the include line (6.4);
           • the set of values supported by an intrinsic type, other than logical (7.1.3);
           • the kind type parameter value of a complex literal constant, if both the real part and imaginary part are of
            type real with the same precision, but have diﬀerent kind type parameter values (7.4.3.3);
           • the kind of a character length type parameter (7.4.4.1);
           • the blank padding character for nondefault character kind (7.4.4.2)
         c
         ISO/IEC 2017 – All rights reserved                                531
      ISO/IEC DIS 1539-1:2017 (E)
        • whether particular control characters can appear within a character literal constant in ﬁxed source form
         (7.4.4.3);
        • the collating sequence for each character set (7.4.4.4);
        • the order of ﬁnalization of components of objects of derived type (7.5.6.2);
        • the order of ﬁnalization when several objects are ﬁnalized as the consequence of a single event (7.5.6.2);
        • whether and when an object is ﬁnalized if it is allocated by pointer allocation and it later becomes un-
         reachable due to all pointers associated with the object having their pointer association status changed
         (7.5.6.3);
        • whether an object is ﬁnalized by a deallocation in which an error condition occurs (7.5.6.3);
        • the kind type parameter of each enumeration and its enumerators (7.6);
        • whether an array is contiguous, except as speciﬁed in 8.5.7;
        • the set of error conditions that can occur in ALLOCATE and DEALLOCATE statements (9.7.1, 9.7.3);
        • the allocation status of a variable after evaluation of an expression if the evaluation of a function would
         change the allocation status of the variable and if a reference to the function appears in the expression in
         which the value of the function is not needed to determine the value of the expression (9.7.1.3);
        • the order of deallocation when several objects are deallocated by a DEALLOCATE statement (9.7.3);
        • the order of deallocation when several objects are deallocated due to the occurence of an event described
         in 9.7.3.2;
        • whether an allocated allocatable subobject is deallocated when an error condition occurs in the deallocation
         of an object (9.7.3.2);
        • the positive integer values assigned to the stat-variable in a STAT= speciﬁer as the result of an error
         condition (9.7.4, 11.6.11);
        • the allocation status or pointer association status of an allocate-object if an error condition occurs during
         execution of an ALLOCATE or DEALLOCATE statement (9.7.4);
        • the value assigned to the errmsg-variable in an ERRMSG= speciﬁer as the result of an error condition
         (9.7.5, 11.6.11);
        • the kind type parameter value of the result of a numeric intrinsic binary operation where
          – both operands are of type integer but with diﬀerent kind type parameters, and the decimal exponent
           ranges are the same,
          – one operand is of type real or complex and the other is of type real or complex with a diﬀerent kind
           type parameter, and the decimal precisions are the same,
         andforalogicalintrinsic binary operation where the operands have diﬀerent kind type parameters (10.1.9.3);
        • the character assigned to the variable in an intrinsic assignment statement if the kind of the expression is
         diﬀerent and the character is not representable in the kind of the variable (10.2.1.3);
        • the order of evaluation of the speciﬁcation expressions within the speciﬁcation part of a BLOCK construct
         when the construct is executed (11.1.4);
        • the pointer association status of a pointer that has its pointer association changed in more than one iteration
         of a DO CONCURRENT construct, on termination of the construct (11.1.7);
        • the ordering between records written by diﬀerent iterations of a DO CONCURRENT construct if the records
         are written to a ﬁle connected for sequential access by more than one iteration (11.1.7);
        • the manner in which the stop code of a STOP or ERROR STOP statement is made available (11.4);
        • the mechanisms available for creating dependencies for cooperative synchronization (11.6.5);
                                   c
      532                          ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
        • the value of the count of the event variable in an EVENT POST or EVENT WAIT statement if an error
         condition occurs (11.6.7, 11.6.8);
        • the image index value established for each image in a team by a FORM TEAM statement without a
         NEW_INDEX=speciﬁer (11.6.9);
        • the set of error conditions that can occur in image control statements (11.6.11);
        • the relationship between the ﬁle storage units when viewing a ﬁle as a stream ﬁle, and the records when
         viewing that ﬁle as a record ﬁle (12);
        • whether particular control characters can appear in a formatted record or a formatted stream ﬁle (12.2.2);
        • the form of values in an unformatted record (12.2.3);
        • at any time, the set of allowed access methods, set of allowed forms, set of allowed actions, and set of
         allowed record lengths for a ﬁle (12.3);
        • the set of allowable names for a ﬁle (12.3);
        • whether a named ﬁle on one image is the same as a ﬁle with the same name on another image (12.3.1);
        • the set of external ﬁles that exist for a program (12.3.2);
        • the relationship between positions of successive ﬁle storage units in an external ﬁle that is connected for
         formatted stream access (12.3.3.4);
        • the external unit preconnected for sequential formatted input and identiﬁed by an asterisk or the named
         constant INPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
        • the external unit preconnected for sequential formatted output and identiﬁed by an asterisk or the named
         constant OUTPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
        • the external unit preconnected for sequential formatted output and identiﬁed by the named constant ER-
         ROR_UNIT of the ISO_FORTRAN_ENV intrinsic module, and whether this unit is the same as OUT-
         PUT_UNIT(12.5);
        • at any time, the set of external units that exist for an image (12.5.3);
        • whether a unit can be connected to a ﬁle that is also connected to a C stream (12.5.4);
        • whether a ﬁle can be connected to more than one unit at the same time (12.5.4);
        • the eﬀect of performing input/output operations on multiple units while they are connected to the same
         external ﬁle (12.5.4);
        • the result of performing input/output operations on a unit connected to a ﬁle that is also connected to a C
         stream (12.5.4);
        • whether the ﬁles connected to the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond
         to the predeﬁned C text streams standard input, standard output, and standard error, respectively (12.5.4);
        • theresults of performing input/output operations on an external ﬁle both from Fortran and from a procedure
         deﬁned by means other than Fortran (12.5.4);
        • the default value for the ACTION= speciﬁer in an OPEN statement (12.5.6.4);
        • the encoding of a ﬁle opened with ENCODING=’DEFAULT’ (12.5.6.9);
        • the ﬁle connected by an OPEN statement with STATUS=’SCRATCH’ (12.5.6.10);
        • the interpretation of case in a ﬁle name (12.5.6.10, 12.10.2.2);
        • the position of a ﬁle after executing an OPEN statement with a POSITION= speciﬁer of ASIS, when the
         ﬁle previously existed but was not connected (12.5.6.14);
        • the default value for the RECL= speciﬁer in an OPEN statement (12.5.6.15);
        • the eﬀect of RECL= on a record containing any nondefault characters (12.5.6.15);
       c
      ISO/IEC 2017 – All rights reserved             533
      ISO/IEC DIS 1539-1:2017 (E)
        • the default input/output rounding mode (12.5.6.16);
        • the default sign mode (12.5.6.17);
        • the ﬁle status when STATUS=’UNKNOWN’ is speciﬁed in an OPEN statement (12.5.6.18);
        • the value assigned to the variable in the ID= speciﬁer in an asynchronous data transfer statement when
         execution of the statement is successfully completed (12.6.2.9);
        • whether POS= is permitted with particular ﬁles, and whether POS= can position a particular ﬁle to a
         position prior to its current position (12.6.2.11);
        • the form in which a single value of derived type is treated in an unformatted input/output statement if the
         eﬀective item is not processed by a deﬁned input/output procedure (12.6.3);
        • the result of unformatted input when the value stored in the ﬁle has a diﬀerent type or type parameters
         from that of the input list item (12.6.4.5.2);
        • the negative value of the unit argument to a deﬁned input/output procedure if the parent data transfer
         statement accesses an internal ﬁle (12.6.4.8.2);
        • the manner in which the processor makes the value of the iomsg argument of a deﬁned input/output
         procedure available if the procedure assigns a nonzero value to the iostat argument and the processor
         therefore terminates execution of the program (12.6.4.8.2);
        • the action caused by the ﬂush operation, whether the processor supports the ﬂush operation for the speciﬁed
         unit, and the negative value assigned to the IOSTAT= variable if the processor does not support the ﬂush
         operation for the speciﬁed unit (12.9);
        • the case of characters assigned to the variable in a NAME= speciﬁer in an INQUIRE statement (12.10.2.15);
        • which of the connected external unit numbers is assigned to the scalar-int-variable in the NUMBER=
         speciﬁer in an INQUIRE by ﬁle statement, if more than one unit on an image is connected to the ﬁle
         (12.10.2.18);
        • thevalueofthevariableinaPOSITION=speciﬁerinanINQUIREstatementiftheﬁlehasbeenrepositioned
         since connection (12.10.2.23);
        • the relationship between ﬁle size and the data stored in records in a sequential or direct access ﬁle
         (12.10.2.30);
        • the number of ﬁle storage units needed to store data in an unformatted ﬁle (12.10.3);
        • the set of error conditions that can occur in input/output statements (12.11.1);
        • when an input/output error condition occurs or is detected (12.11.1);
        • the positive integer value assigned to the variable in an IOSTAT= speciﬁer as the result of an error condition
         (12.11.5);
        • the value assigned to the variable in an IOMSG= speciﬁer as the result of an error condition (12.11.6);
        • the result of output of non-representable characters to a Unicode ﬁle (13.7.1);
        • the interpretation of the optional non-blank characters within the parentheses of a real NaN input ﬁeld
         (13.7.2.3.2);
        • the interpretation of a sign in a NaN input ﬁeld (13.7.2.3.2);
        • for output of an IEEE NaN, whether after the letters ’NaN’, the processor produces additional alphanumeric
         characters enclosed in parentheses (13.7.2.3.2);
        • the choice of binary exponent in EX output editing (13.7.2.3.6);
        • the eﬀect of the input/output rounding mode PROCESSOR_DEFINED (13.7.2.3.8);
        • which value is chosen if the input/output rounding mode is NEAREST and the value to be converted is
         exactly halfway between the two nearest representable values in the result format (13.7.2.3.8);
                                   c
      534                          ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
        • the ﬁeld width, decimal part width, and exponent width used for the G0 edit descriptor (13.7.5);
        • the ﬁle position when position editing skips a character of nondefault kind in an internal ﬁle of default
         character kind or an external unit that is not connected to a Unicode ﬁle (13.8.1.1);
        • when the sign mode is PROCESSOR_DEFINED, whether a plus sign appears in a numeric output ﬁeld
         for a nonnegative value (13.8.4);
        • the results of list-directed output (13.10.4);
        • the results of namelist output (13.11.4);
        • the interaction between argument association and pointer association, (15.5.2.4);
        • the values returned by some intrinsic functions (16);
        • how the sequences of atomic actions in unordered segments interleave (16.5);
        • the value assigned to a STAT argument in a reference to an atomic subroutine when an error condition
         occurs (16.5);
        • the eﬀect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team
         (16.7);
        • whether each image uses a separate random number generator, or if some or all images use common random
         number generators (16.7);
        • whether the results returned from CPU_TIME, DATE_AND_TIME and SYSTEM_CLOCK are depend-
         ent on which image calls them (16.7);
        • the set of error conditions that can occur in some intrinsic subroutines (16.9);
        • the value assigned to a CMDSTAT, ERRMSG, EXITSTAT, STAT, or STATUS argument to indicate a
         processor-dependent error condition (16.9);
        • the computed value of the the intrinsic subroutine CO_REDUCE (16.9.49) and the intrinsic subroutine
         CO_SUM(16.9.50);
        • the value assigned to the TIME argument by the intrinsic subroutine CPU_TIME (16.9.57);
        • whether date, clock, and time zone information is available (16.9.59);
        • whether date, clock, and time zone information on one image is the same as that on another image (16.9.59);
        • the value of command argument zero, if the processor does not support the concept of a command name
         (16.9.83);
        • the order of command arguments (16.9.83);
        • whether the signiﬁcant length of a command argument includes trailing blanks (16.9.83);
        • the interpretation of case for the NAME argument of the intrinsic subroutine GET_ENVIRONMENT_-
         VARIABLE (16.9.84);
        • whether an environment variable that exists on an image also exists on another image, and if it does exist
         on both images, whether the values are the same or diﬀerent (16.9.84);
        • the value assigned to the pseudorandom number generator by the intrinsic subroutine RANDOM_INIT
         (16.9.155);
        • the computation of the seed value used by the pseudorandom number generator (16.9.157);
        • onimagesthatuseacommonrandomnumbergenerator,theinterleavingofvaluesassignedbyRANDOM_-
         NUMBERinunordered segments(16.7);
        • the value assigned to the seed by the intrinsic subroutine RANDOM_SEED when no argument is present
         (16.9.157);
        • the values assigned to its arguments by the intrinsic subroutine SYSTEM_CLOCK (16.9.186);
       c
      ISO/IEC 2017 – All rights reserved             535
      ISO/IEC DIS 1539-1:2017 (E)
        • the values of the named constants in the intrinsic module ISO_FORTRAN_ENV (16.10.2);
        • the values returned by the functions COMPILER_OPTIONS and COMPILER_VERSION in the intrinsic
         module ISO_FORTRAN_ENV (16.10.2);
        • the extent to which a processor supports IEEE arithmetic (17);
        • whether a ﬂag that is quiet on entry to a scoping unit that does not access IEEE_FEATURES, IEEE_-
         EXCEPTIONS, or IEEE_ARITHMETIC is signaling on exit (17.1);
        • the conditions under which IEEE_OVERFLOW is raised in a calculation involving non-ISO/IEC/IEEE
         60559:2011 ﬂoating-point data (17.3);
        • the conditions under which IEEE_OVERFLOW and IEEE_DIVIDE_BY_ZERO are raised in a ﬂoating-
         point exponentiation operation (17.3);
        • the conditions under which IEEE_DIVIDE_BY_ZERO is raised in a calculation involving ﬂoating-point
         data that do not conform to ISO/IEC/IEEE 60559:2011 (17.3);
        • whetheranexceptionsignalsattheendofasequenceofstatementsthathasnoinvocationsofIEEE_GET_-
         FLAG, IEEE_SET_FLAG, IEEE_GET_STATUS, IEEE_SET_STATUS, or IEEE_SET_HALTING_-
         MODE,inwhich execution of an operation would cause it to signal, if no value of a variable depends upon
         the result of the operation (17.3);
        • the initial rounding modes (17.4);
        • whether the processor supports a particular rounding mode (17.4);
        • the eﬀect of the rounding mode IEEE_OTHER, if supported (17.4);
        • the initial underﬂow mode (17.5);
        • the initial halting mode (17.6);
        • whether IEEE_INT implements the convertToInteger{round} or convertToIntegerExact{round} operation
         speciﬁed by ISO/IEC/IEEE 60559:2011 (17.11.11);
        • which argument is the result value of IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_NUM,
         or IEEE_MIN_NUM_MAGwhenbothargumentsarequietNaNsorarezeros(17.11.17,17.11.18,17.11.19,
         17.11.20);
        • the requirements on the storage sequence to be associated with the pointer FPTR by the C_F_POINTER
         subroutine (18.2.3.4);
        • the order of the members of the CFI_dim_t structure deﬁned in the source ﬁle CFI_Fortran_binding.h
         (18.5.2);
        • members of the CFI_cdesc_t structure deﬁned in the source ﬁle CFI_Fortran_binding.h beyond the re-
         quirements of 18.5.3;
        • the value of CFI_MAX_RANK in the source ﬁle CFI_Fortran_binding.h (18.5.4);
        • the value of CFI_VERSION in the source ﬁle CFI_Fortran_binding.h (18.5.4);
        • which error condition is detected if more than one error condition could be detected for an invocation of
         one of the functions declared in the source ﬁle CFI_Fortran_binding.h (18.5.5.1);
        • the values of the attribute speciﬁer macros deﬁned in the source ﬁle CFI_Fortran_binding.h (18.5.4);
        • the values of the type speciﬁer macros deﬁned in the source ﬁle CFI_Fortran_binding.h;
        • which additional type speciﬁer values are deﬁned in the source ﬁle CFI_Fortran_binding.h (18.5.4);
        • the values of the error code macros other than CFI_SUCCESS that are deﬁned in the source ﬁle CFI_-
         Fortran_binding.h (18.5.4);
        • the base address of a zero-sized array (18.5.3);
        • the values of the ﬂoating-point exception ﬂags on entry to a procedure deﬁned by means other than Fortran
                                   c
      536                          ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
         (18.10.3);
        • whether a procedure deﬁned by means other than Fortran is an asynchronous communication initiation or
         completion procedure (18.10.4).
       c
      ISO/IEC 2017 – All rights reserved             537
      ISO/IEC DIS 1539-1:2017 (E)
                            (Blank page)
                                   c
      538                          ISO/IEC 2017 – All rights reserved
                                                                                           ISO/IEC DIS 1539-1:2017 (E)
                                                                Annex B
                                                                 (Informative)
                                        Deleted and obsolescent features
              B.1      Deleted features from Fortran 90
           1 These deleted features are those features of Fortran 90 that were redundant and considered largely unused.
           2 The following Fortran 90 features are not required.
                     (1)   Real and double precision DO variables.
                           In Fortran 77 and Fortran 90, a DO variable was allowed to be of type real or double precision
                           in addition to type integer; this has been deleted. A similar result can be achieved by using a DO
                           construct with no loop control and the appropriate exit test.
                     (2)   Branching to an END IF statement from outside its block.
                           In Fortran 77 and Fortran 90, it was possible to branch to an END IF statement from outside the
                           IF construct; this has been deleted. A similar result can be achieved by branching to a CONTINUE
                           statement that is immediately after the END IF statement.
                     (3)   PAUSE statement.
                           The PAUSE statement, provided in Fortran 66, Fortran 77, and Fortran 90, has been deleted.
                           Asimilar result can be achieved by writing a message to the appropriate unit, followed by reading
                           from the appropriate unit.
                     (4)   ASSIGN and assigned GO TO statements, and assigned format speciﬁers.
                           The ASSIGN statement and the related assigned GO TO statement, provided in Fortran 66,
                           Fortran 77, and Fortran 90, have been deleted. Further, the ability to use an assigned integer as a
                           format, provided in Fortran 77 and Fortran 90, has been deleted. A similar result can be achieved
                           by using other control constructs instead of the assigned GO TO statement and by using a default
                           character variable to hold a format speciﬁcation instead of using an assigned integer.
                     (5)   Hedit descriptor.
                           In Fortran 77 and Fortran 90, there was an alternative form of character string edit descriptor,
                           which had been the only such form in Fortran 66; this has been deleted. A similar result can be
                           achieved by using a character string edit descriptor.
                     (6)   Vertical format control.
                           In Fortran 66, Fortran 77, Fortran 90, and Fortran 95 formatted output to certain units resulted
                           in the ﬁrst character of each record being interpreted as controlling vertical spacing. There was no
                           standard way to detect whether output to a unit resulted in this vertical format control, and no
                           way to specify that it should be applied; this has been deleted. The eﬀect can be achieved by
                           post-processing a formatted ﬁle.
           3 See ISO/IEC 1539:1991 for detailed rules of how these deleted features worked.
               c
              ISO/IEC 2017 – All rights reserved                                                                            539
              ISO/IEC DIS 1539-1:2017 (E)
              B.2      Deleted features from Fortran 2008
           1 These deleted features are those features of Fortran 2008 that were redundant and considered largely unused.
           2 The following Fortran 2008 features are not required.
                     (1)   Arithmetic IF statement.
                           ThearithmeticIFstatementisincompatiblewithISO/IEC/IEEE60559:2011andnecessarilyinvolves
                           the use of statement labels; statement labels can hinder optimization, and make code hard to read
                           and maintain. Similar logic can be more clearly encoded using other conditional statements.
                     (2)   Nonblock DO construct
                           The nonblock forms of the DO loop were confusing and hard to maintain. Shared termination and
                           dual use of labeled action statements as do termination and branch targets were especially error-
                           prone.
              B.3      Obsolescent features
              B.3.1     General
           1 Theobsolescent features are those features of Fortran 90 that were redundant and for which better methods were
              available in Fortran 90. Subclause 4.4.3 describes the nature of the obsolescent features. The obsolescent features
              in this document are the following.
                     (1)   Alternate return — see B.3.2.
                     (2)   Computed GO TO — see B.3.3.
                     (3)   Statement functions — see B.3.4.
                     (4)   DATAstatements amongst executable statements — see B.3.5.
                     (5)   Assumed length character functions — see B.3.6.
                     (6)   Fixed form source — see B.3.7.
                     (7)   CHARACTER*formof CHARACTERdeclaration — see B.3.8.
                     (8)   ENTRYstatements — see B.3.9.
                     (9)   Label form of DO statement – see B.3.10.
                     (10)  COMMONandEQUIVALENCEstatements, and the block data program unit – see B.3.11.
                     (11)  Speciﬁc names for intrinsic functions – see B.3.12.
                     (12)  FORALLconstruct and statement – see B.3.13
              B.3.2     Alternate return
           1 An alternate return introduces labels into an argument list to allow the called procedure to direct the execution
              of the caller upon return. The same eﬀect can be achieved with a return code that is used in a SELECT CASE
              construct on return. This avoids an irregularity in the syntax and semantics of argument association. For example,
                  CALL SUBR_NAME (X, Y, Z, *100, *200, *300)
              can be replaced by
                  CALL SUBR_NAME (X, Y, Z, RETURN_CODE)
                  SELECT CASE (RETURN_CODE)
                                                                                 c
              540                                                                ISO/IEC 2017 – All rights reserved
                                                                  ISO/IEC DIS 1539-1:2017 (E)
                CASE (1)
                  ...
                CASE (2)
                  ...
                CASE (3)
                  ...
                CASE DEFAULT
                  ...
             END SELECT
          B.3.3   Computed GO TO statement
        1 The computed GO TO statement has been superseded by the SELECT CASE construct, which is a generalized,
          easier to use, and clearer means of expressing the same computation.
          B.3.4   Statement functions
        1 Statementfunctionsaresubjecttoanumberofnonintuitiverestrictions and are a potential source of error because
          their syntax is easily confused with that of an assignment statement.
        2 The internal function is a more generalized form of the statement function and completely supersedes it.
          B.3.5   DATA statements among executables
        1 The statement ordering rules allow DATA statements to appear anywhere in a program unit after the speciﬁc-
          ation statements. The ability to position DATA statements amongst executable statements is very rarely used,
          unnecessary, and a potential source of error.
          B.3.6   Assumed character length functions
        1 Assumed character length for functions is an irregularity in the language in that elsewhere in Fortran the philo-
          sophy is that the attributes of a function result depend only on the actual arguments of the invocation and on
          any data accessible by the function through host or use association. Some uses of this facility can be replaced
          with an automatic character length function, where the length of the function result is declared in a speciﬁcation
          expression. Other uses can be replaced by the use of a subroutine whose arguments correspond to the function
          result and the function arguments.
        2 Note that dummy arguments of a function can have assumed character length.
          B.3.7   Fixed form source
        1 Fixedformsourcewasdesignedwhentheprincipalmachine-readableinputmediumfornewprogramswaspunched
          cards. Now that new and amended programs are generally entered via keyboards with screen displays, it is an
          unnecessary overhead, and is potentially error-prone, to have to locate positions 6, 7, or 72 on a line. Free form
          source was designed expressly for this more modern technology.
        2 It is a simple matter for a software tool to convert from ﬁxed to free form source.
           c
          ISO/IEC 2017 – All rights reserved                                              541
          ISO/IEC DIS 1539-1:2017 (E)
          B.3.8   CHARACTER* form of CHARACTER declaration
        1 In addition to the CHARACTER*char-length form introduced in Fortran 77, Fortran 90 provided the CHAR-
          ACTER([ LEN = ] type-param-value) form. The older form (CHARACTER*char-length) is redundant.
          B.3.9   ENTRY statements
        1 ENTRY statements allow more than one entry point to a subprogram, facilitating sharing of data items and
          executable statements local to that subprogram.
        2 This can be replaced by a module containing the (private) data items, with a module procedure for each entry
          point and the shared code in a private module procedure.
          B.3.10   Label DO statement
        1 The label in the DO statement is redundant with the construct name. Furthermore, the label allows unrestricted
          branches and, for its main purpose (the target of a conditional branch to skip the rest of the current iteration),
          is redundant with the CYCLE statement, which is clearer.
          B.3.11   COMMONandEQUIVALENCEstatements and the block data program unit
        1 Common blocks are error-prone and have largely been superseded by modules. EQUIVALENCE similarly is
          error-prone. Whilst use of these statements was invaluable prior to Fortran 90 they are now redundant and
          can inhibit performance. The block data program unit exists only to serve common blocks and hence is also
          redundant.
          B.3.12   Speciﬁc names for intrinsic functions
        1 The speciﬁc names of the intrinsic functions are often obscure and hinder portability. They have been redundant
          since Fortran 90. Use generic names for references to intrinsic procedures.
          B.3.13   FORALL construct and statement
        1 The FORALL construct and statement were added to the language in the expectation that they would enable
          highly eﬃcient execution, especially on parallel processors. However, experience indicates that they are too
          complex and have too many restrictions for compilers to take advantage of them. They are redundant with the
          DOCONCURRENTconstruct, and many of the manipulations for which they might be used can be done more
          eﬀectively using pointers, especially using pointer rank remapping.
                                                           c
          542                                             ISO/IEC 2017 – All rights reserved
                                                        ISO/IEC DIS 1539-1:2017 (E)
                                        Annex C
                                        (Informative)
                                   Extended notes
         C.1   Fortran 2008 features not mentioned in its Introduction
       1 Thefollowing features were new in Fortran 2008 but not originally listed in its Introduction as being new features:
           • An array or object with a nonconstant length type parameter can have the VALUE attribute.
           • Multiple allocations are permitted in a single ALLOCATE statement with the SOURCE= speciﬁer.
           • A PROCEDURE statement can have a double colon before the ﬁrst procedure name.
           • An argument to a pure procedure can have default INTENT if it has the VALUE attribute.
           • The PROTECTED attribute can be speciﬁed by the procedure declaration statement.
           • A deﬁned-operator can be used in a speciﬁcation expression.
           • All transformational functions from the intrinsic modules IEEE_ARITHMETIC and IEEE_EXCEPTIONS
             can be used in constant expressions. All transformational functions from the intrinsic modules IEEE_-
             ARITHMETIC, IEEE_EXCEPTIONS, and ISO_C_BINDING can be used in speciﬁcation expressions.
           • A contiguous array variable that is not interoperable but which has interoperable type and kind type
             parameter (if any), and a scalar character variable with length greater than 1 and kind C_CHAR in the
             intrinsic module ISO_C_BINDING, can be used as the argument of the function C_LOC in the intrinsic
             module ISO_C_BINDING, provided the variable has the POINTER or TARGET attribute.
           • The name of an external procedure that has a binding label is a local identiﬁer and not a global identiﬁer.
           • A procedure that is not a procedure pointer can be an actual argument that corresponds to a procedure
             pointer dummy argument with the INTENT (IN) attribute.
           • An interface body for an external procedure that does not exist in a program can be used to specify an
             explicit speciﬁc interface.
       2 All but the last two of the above list were subsequently added to the Introduction by Technical Corrigenda.
         C.2   Clause 7 notes
         C.2.1 Selection of the approximation methods (7.4.3.2)
       1 One can select the real approximation method for an entire program through the use of a module and the
         parameterized real type. This is accomplished by deﬁning a named integer constant to have a particular kind
         type parameter value and using that named constant in all real, complex, and derived-type declarations. For
         example, the speciﬁcation statements
              INTEGER, PARAMETER :: LONG_FLOAT = 8
              REAL (LONG_FLOAT) X, Y
              COMPLEX (LONG_FLOAT) Z
         c
         ISO/IEC 2017 – All rights reserved                                  543
            ISO/IEC DIS 1539-1:2017 (E)
            specify that the approximation method corresponding to a kind type parameter value of 8 is supplied for the data
            objects X, Y, and Z in the program unit. The kind type parameter value LONG_FLOAT can be made available
            to an entire program by placing the INTEGER speciﬁcation statement in a module and accessing the named
            constant LONG_FLOAT with a USE statement. Note that by changing 8 to 4 once in the module, a diﬀerent
            approximation method is selected.
         2 To avoid the use of the processor-dependent values 4 or 8, replace 8 by KIND (0.0) or KIND (0.0D0). Another
            way to avoid these processor-dependent values is to select the kind value using the intrinsic function SELEC-
            TED_REAL_KIND (16.9.170). In the above speciﬁcation statement, the 8 might be replaced by, for instance,
            SELECTED_REAL_KIND (10, 50), which requires an approximation method to be selected with at least 10
            decimal digits of precision and a range from 10−50 to 1050. There are no magnitude or ordering constraints placed
            on kind values, in order that implementers have ﬂexibility in assigning such values and can add new kinds without
            changing previously assigned kind values.
         3 As kind values have no portable meaning, a good practice is to use them in programs only through named
            constants as described above (for example, SINGLE, IEEE_SINGLE, DOUBLE, and QUAD), rather than using
            the kind values directly.
            C.2.2   Type extension and component accessibility (7.5.2.2, 7.5.4)
         1 The default accessibility of the components of an extended type can be speciﬁed in the type deﬁnition. The
            accessibility of its components can be speciﬁed individually. For example:
                   module types
                     type base_type
                       private                !-- Sets default accessibility
                       integer :: i           !-- a private component
                       integer, private :: j  !-- another private component
                       integer, public :: k   !-- a public component
                     end type base_type
                     type, extends(base_type) :: my_type
                       private               !-- Sets default for components declared in my_type
                       integer :: l          !-- A private component.
                       integer, public :: m  !-- A public component.
                     end type my_type
                   end module types
                   subroutine sub
                     use types
                     type (my_type) :: x
                     ...
                     call another_sub( &
                       x%base_type,    &  !-- ok because base_type is a public subobject of x
                       x%base_type%k,  &  !-- ok because x%base_type is ok and has k as a
                                                                  c
            544                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                                          !-- public component.
                       x%k,            &  !-- ok because it is shorthand for x%base_type%k
                       x%base_type%i,  &  !-- Invalid because i is private.
                       x%i)               !-- Invalid because it is shorthand for x%base_type%i
                   end subroutine sub
            C.2.3   Generic type-bound procedures (7.5.5)
            Example of a derived type with generic type-bound procedures:
         1 The only diﬀerence between this example and the same thing rewritten to use generic interface blocks is that
            with type-bound procedures,
                   USE rational_numbers, ONLY: rational
            does not block the type-bound procedures; the user still gets access to the deﬁned assignment and extended
            operations.
                   MODULE rational_numbers
                     IMPLICIT NONE
                     PRIVATE
                     TYPE,PUBLIC :: rational
                       PRIVATE
                       INTEGER n,d
                     CONTAINS
                       ! ordinary type-bound procedure
                       PROCEDURE :: real => rat_to_real
                       ! specific type-bound procedures for generic support
                       PROCEDURE,PRIVATE :: rat_asgn_i, rat_plus_i, rat_plus_rat => rat_plus
                       PROCEDURE,PRIVATE,PASS(b) :: i_plus_rat
                       ! generic type-bound procedures
                       GENERIC :: ASSIGNMENT(=) => rat_asgn_i
                       GENERIC :: OPERATOR(+) => rat_plus_rat, rat_plus_i, i_plus_rat
                     END TYPE
                   CONTAINS
                     ELEMENTAL REAL FUNCTION rat_to_real(this) RESULT(r)
                       CLASS(rational),INTENT(IN) :: this
                       r = REAL(this%n)/this%d
                     END FUNCTION
                     ELEMENTAL SUBROUTINE rat_asgn_i(a,b)
                       CLASS(rational),INTENT(OUT) :: a
                       INTEGER,INTENT(IN) :: b
                       a%n = b
                       a%d = 1
                     END SUBROUTINE
                     ELEMENTAL TYPE(rational) FUNCTION rat_plus_i(a,b) RESULT(r)
                       CLASS(rational),INTENT(IN) :: a
                       INTEGER,INTENT(IN) :: b
            c
            ISO/IEC 2017 – All rights reserved                                                      545
           ISO/IEC DIS 1539-1:2017 (E)
                     r%n = a%n + b*a%d
                     r%d = a%d
                   END FUNCTION
                   ELEMENTAL TYPE(rational) FUNCTION i_plus_rat(a,b) RESULT(r)
                     INTEGER,INTENT(IN) :: a
                     CLASS(rational),INTENT(IN) :: b
                     r%n = b%n + a*b%d
                     r%d = b%d
                   END FUNCTION
                   ELEMENTAL TYPE(rational) FUNCTION rat_plus(a,b) RESULT(r)
                     CLASS(rational),INTENT(IN) :: a,b
                     r%n = a%n*b%d + b%n*a%d
                     r%d = a%d*b%d
                   END FUNCTION
                 END
           C.2.4  Abstract types (7.5.7.1)
        1 The following illustrates how an abstract type can be used as the basis for a collection of related types, and how
           a non-abstract member of that collection can be created by type extension.
                 TYPE, ABSTRACT :: DRAWABLE_OBJECT
                    REAL, DIMENSION(3) :: RGB_COLOR = (/1.0,1.0,1.0/) ! White
                    REAL, DIMENSION(2) :: POSITION = (/0.0,0.0/) ! Centroid
                 CONTAINS
                    PROCEDURE(RENDER_X), PASS(OBJECT), DEFERRED :: RENDER
                 END TYPE DRAWABLE_OBJECT
                 ABSTRACT INTERFACE
                    SUBROUTINE RENDER_X(OBJECT, WINDOW)
                      IMPORT DRAWABLE_OBJECT, X_WINDOW
                      CLASS(DRAWABLE_OBJECT), INTENT(IN) :: OBJECT
                      CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
                    END SUBROUTINE RENDER_X
                 END INTERFACE
                 ...
                 TYPE, EXTENDS(DRAWABLE_OBJECT) :: DRAWABLE_TRIANGLE ! Not ABSTRACT
                    REAL, DIMENSION(2,3) :: VERTICES ! In relation to centroid
                 CONTAINS
                    PROCEDURE, PASS(OBJECT) :: RENDER=>RENDER_TRIANGLE_X
                 END TYPE DRAWABLE_TRIANGLE
        2 The actual drawing procedure will draw a triangle in WINDOW with vertices at x and y coordinates at
           OBJECT%POSITION(1)+OBJECT%VERTICES(1,1:3) and OBJECT%POSITION(2)+OBJECT%VERTICES(2,1:3):
                                                            c
           546                                              ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
                 SUBROUTINE RENDER_TRIANGLE_X(OBJECT, WINDOW)
                    CLASS(DRAWABLE_TRIANGLE), INTENT(IN) :: OBJECT
                    CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
                    ...
                 END SUBROUTINE RENDER_TRIANGLE_X
           C.2.5  Structure constructors and generic names (7.5.10)
        1 Ageneric name can be the same as a type name. This can be used to emulate user-deﬁned structure constructors
           for that type, even if the type has private components. For example:
                 MODULE mytype_module
                   TYPE mytype
                     PRIVATE
                     COMPLEX value
                     LOGICAL exact
                   END TYPE
                   INTERFACE mytype
                     MODULE PROCEDURE int_to_mytype
                   END INTERFACE
                   ! Operator definitions etc.
                   ...
                 CONTAINS
                   TYPE(mytype) FUNCTION int_to_mytype(i)
                     INTEGER,INTENT(IN) :: i
                     int_to_mytype%value = i
                     int_to_mytype%exact = .TRUE.
                   END FUNCTION
                   ! Procedures to support operators etc.
                   ...
                 END
                 PROGRAM example
                   USE mytype_module
                   TYPE(mytype) x
                   x = mytype(17)
                 END
        2 The type name can still be used as a generic name if the type has type parameters. For example:
                 MODULE m
                   TYPE t(kind)
                     INTEGER, KIND :: kind
                     COMPLEX(kind) value
                   END TYPE
                   INTEGER,PARAMETER :: single = KIND(0.0), double = KIND(0d0)
                   INTERFACE t
           c
           ISO/IEC 2017 – All rights reserved                                               547
            ISO/IEC DIS 1539-1:2017 (E)
                       MODULE PROCEDURE real_to_t1, dble_to_t2, int_to_t1, int_to_t2
                     END INTERFACE
                     ...
                   CONTAINS
                     TYPE(t(single)) FUNCTION real_to_t1(x)
                       REAL(single) x
                       real_to_t1%value = x
                     END FUNCTION
                     TYPE(t(double)) FUNCTION dble_to_t2(x)
                       REAL(double) x
                       dble_to_t2%value = x
                     END FUNCTION
                     TYPE(t(single)) FUNCTION int_to_t1(x,mold)
                       INTEGER x
                       TYPE(t(single)) mold
                       int_to_t1%value = x
                     END FUNCTION
                     TYPE(t(double)) FUNCTION int_to_t2(x,mold)
                       INTEGER x
                       TYPE(t(double)) mold
                       int_to_t2%value = x
                     END FUNCTION
                     ...
                   END
                   PROGRAM example
                     USE m
                     TYPE(t(single)) x
                     TYPE(t(double)) y
                     x = t(1.5)                ! References real_to_t1
                     x = t(17,mold=x)          ! References int_to_t1
                     y = t(1.5d0)              ! References dble_to_t2
                     y = t(42,mold=y)          ! References int_to_t2
                     y = t(kind(0d0)) ((0,1))  ! Uses the structure constructor for type t
                   END
            C.2.6   Final subroutines (7.5.6, 7.5.6.2, 7.5.6.3, 7.5.6.4)
            Example of a parameterized derived type with ﬁnal subroutines:
                   MODULE m
                     TYPE t(k)
                       INTEGER, KIND :: k
                       REAL(k),POINTER :: vector(:) => NULL()
                     CONTAINS
                       FINAL :: finalize_t1s, finalize_t1v, finalize_t2e
                     END TYPE
                                                                  c
            548                                                  ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
          CONTAINS
           SUBROUTINE finalize_t1s(x)
            TYPE(t(KIND(0.0))) x
            IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
           END SUBROUTINE
           SUBROUTINE finalize_t1v(x)
            TYPE(t(KIND(0.0))) x(:)
            DO i=LBOUND(x,1),UBOUND(x,1)
             IF (ASSOCIATED(x(i)%vector)) DEALLOCATE(x(i)%vector)
            END DO
           END SUBROUTINE
           ELEMENTAL SUBROUTINE finalize_t2e(x)
            TYPE(t(KIND(0.0d0))),INTENT(INOUT) :: x
            IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
           END SUBROUTINE
          END MODULE
          SUBROUTINE example(n)
           USE m
           TYPE(t(KIND(0.0))) a,b(10),c(n,2)
           TYPE(t(KIND(0.0d0))) d(n,n)
           ...
           ! Returning from this subroutine will effectively do
           !  CALL finalize_t1s(a)
           !  CALL finalize_t1v(b)
           !  CALL finalize_t2e(d)
           ! No final subroutine will be called for variable C because the user
           ! omitted to define a suitable specific procedure for it.
          END SUBROUTINE
      Example of extended types with ﬁnal subroutines:
          MODULE m
           TYPE t1
            REAL a,b
           END TYPE
           TYPE,EXTENDS(t1) :: t2
            REAL,POINTER :: c(:),d(:)
           CONTAINS
            FINAL :: t2f
           END TYPE
           TYPE,EXTENDS(t2) :: t3
            REAL,POINTER :: e
           CONTAINS
            FINAL :: t3f
           END TYPE
           ...
       c
      ISO/IEC 2017 – All rights reserved             549
            ISO/IEC DIS 1539-1:2017 (E)
                   CONTAINS
                     SUBROUTINE t2f(x) ! Finalizer for TYPE(t2)’s extra components
                       TYPE(t2) :: x
                       IF (ASSOCIATED(x%c)) DEALLOCATE(x%c)
                       IF (ASSOCIATED(x%d)) DEALLOCATE(x%d)
                     END SUBROUTINE
                     SUBROUTINE t3f(y) ! Finalizer for TYPE(t3)’s extra components
                       TYPE(t3) :: y
                       IF (ASSOCIATED(y%e)) DEALLOCATE(y%e)
                     END SUBROUTINE
                   END MODULE
                   SUBROUTINE example
                     USE m
                     TYPE(t1) x1
                     TYPE(t2) x2
                     TYPE(t3) x3
                     ...
                     ! Returning from this subroutine will effectively do
                     !    ! Nothing to x1; it is not finalizable
                     !    CALL t2f(x2)
                     !    CALL t3f(x3)
                     !    CALL t2f(x3%t2)
                   END SUBROUTINE
            C.3    Clause 8 notes: The VOLATILE attribute (8.5.19)
         1 The following example shows the use of a variable with the VOLATILE attribute to communicate with an
            asynchronous process, in this case the operating system. The program detects a user keystroke on the terminal
            and reacts at a convenient point in its processing.
         2 TheVOLATILEattributeisnecessarytopreventanoptimizingcompilerfromstoringthecommunicationvariable
            in a register or from doing ﬂow analysis and deciding that the EXIT statement can never be executed.
                   SUBROUTINE TERMINATE_ITERATIONS
                     LOGICAL, VOLATILE  ::   USER_HIT_ANY_KEY
                     ! Have the OS start to look for a user keystroke and set the variable
                     ! "USER_HIT_ANY_KEY" to TRUE as soon as it detects a keystroke.
                     ! This call is operating system dependent.
                     CALL OS_BEGIN_DETECT_USER_KEYSTROKE( USER_HIT_ANY_KEY )
                     USER_HIT_ANY_KEY = .FALSE.     ! This will ignore any recent keystrokes.
                     PRINT *, " Hit any key to terminate iterations!"
                     DO I = 1,100
                        ...                         ! Compute a value for R.
                                                                  c
            550                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                        PRINT *, I, R
                        IF (USER_HIT_ANY_KEY)      EXIT
                     ENDDO
                     ! Have the OS stop looking for user keystrokes.
                     CALL OS_STOP_DETECT_USER_KEYSTROKE
                   END SUBROUTINE TERMINATE_ITERATIONS
            C.4    Clause 9 notes
            C.4.1   Structure components (9.4.2)
         1 Componentsofastructure are referenced by writing the components of successive levels of the structure hierarchy
            until the desired component is described. For example,
                   TYPE ID_NUMBERS
                      INTEGER SSN
                      INTEGER EMPLOYEE_NUMBER
                   END TYPE ID_NUMBERS
                   TYPE PERSON_ID
                      CHARACTER (LEN=30) LAST_NAME
                      CHARACTER (LEN=1) MIDDLE_INITIAL
                      CHARACTER (LEN=30) FIRST_NAME
                      TYPE (ID_NUMBERS) NUMBER
                   END TYPE PERSON_ID
                   TYPE PERSON
                      INTEGER AGE
                      TYPE (PERSON_ID) ID
                   END TYPE PERSON
                   TYPE (PERSON) GEORGE, MARY
                   PRINT *, GEORGE % AGE             ! Print the AGE component
                   PRINT *, MARY % ID % LAST_NAME    ! Print LAST_NAME of MARY
                   PRINT *, MARY % ID % NUMBER % SSN ! Print SSN of MARY
                   PRINT *, GEORGE % ID % NUMBER  ! Print SSN and EMPLOYEE_NUMBER of GEORGE
         2 A structure component can be a data object of intrinsic type as in the case of GEORGE % AGE or it can be
            of derived type as in the case of GEORGE % ID % NUMBER. The resultant component can be a scalar or an
            array of intrinsic or derived type.
                   TYPE LARGE
                      INTEGER ELT (10)
                      INTEGER VAL
            c
            ISO/IEC 2017 – All rights reserved                                                      551
            ISO/IEC DIS 1539-1:2017 (E)
                   END TYPE LARGE
                   TYPE (LARGE) A (5)       ! 5 element array, each of whose elements
                                            ! includes a 10 element array ELT and
                                            ! a scalar VAL.
                   PRINT *, A (1)           ! Prints 10 element array ELT and scalar VAL.
                   PRINT *, A (1) % ELT (3) ! Prints scalar element 3
                                            ! of array element 1 of A.
                   PRINT *, A (2:4) % VAL   ! Prints scalar VAL for array elements
                                            ! 2 to 4 of A.
         3 Components of an object of extensible type that are inherited from the parent type can be accessed as a whole
            by using the parent component name, or individually, either with or without qualifying them by the parent
            component name. For example:
                   TYPE POINT            ! A base type
                     REAL :: X, Y
                   END TYPE POINT
                   TYPE, EXTENDS(POINT) :: COLOR_POINT  ! An extension of TYPE(POINT)
                     ! Components X and Y, and component name POINT, inherited from parent
                     INTEGER :: COLOR
                   END TYPE COLOR_POINT
                   TYPE(POINT) :: PV = POINT(1.0, 2.0)
                   TYPE(COLOR_POINT) :: CPV = COLOR_POINT(POINT=PV, COLOR=3)
                   PRINT *, CPV%POINT                   ! Prints 1.0 and 2.0
                   PRINT *, CPV%POINT%X, CPV%POINT%Y    ! And this does, too
                   PRINT *, CPV%X, CPV%Y                ! And this does, too
            C.4.2   Allocation with dynamic type (9.7.1)
         1 The following example illustrates the use of allocation with the value and dynamic type of the allocated object
            given by another object. The example copies a list of objects of any type. It copies the list starting at IN_LIST.
            After copying, each element of the list starting at LIST_COPY has a polymorphic component, ITEM, for which
            both the value and type are taken from the ITEM component of the corresponding element of the list starting at
            IN_LIST.
                   TYPE :: LIST ! A list of anything
                     TYPE(LIST), POINTER :: NEXT => NULL()
                     CLASS(*), ALLOCATABLE :: ITEM
                   END TYPE LIST
                   ...
                   TYPE(LIST), POINTER :: IN_LIST, LIST_COPY => NULL()
                   TYPE(LIST), POINTER :: IN_WALK, NEW_TAIL
                   ! Copy IN_LIST to LIST_COPY
                   IF (ASSOCIATED(IN_LIST)) THEN
                                                                  c
            552                                                  ISO/IEC 2017 – All rights reserved
                                                       ISO/IEC DIS 1539-1:2017 (E)
                IN_WALK => IN_LIST
                ALLOCATE(LIST_COPY)
                NEW_TAIL => LIST_COPY
                DO
                 ALLOCATE(NEW_TAIL%ITEM, SOURCE=IN_WALK%ITEM)
                 IN_WALK => IN_WALK%NEXT
                 IF (.NOT. ASSOCIATED(IN_WALK)) EXIT
                 ALLOCATE(NEW_TAIL%NEXT)
                 NEW_TAIL => NEW_TAIL%NEXT
                END DO
              END IF
         C.5  Clause 10 notes
         C.5.1 Evaluation of function references (10.1.7)
       1 If more than one function reference appears in a statement, they can be executed in any order (subject to a
         function result being evaluated after the evaluation of its arguments) and their values cannot depend on the order
         of execution. This lack of dependence on order of evaluation enables parallel execution of the function references.
         C.5.2 Pointers in expressions (10.1.9.2)
       1 A pointer is considered to be like any other variable when it is used as a primary in an expression. If a pointer
         is used as an operand to an operator that expects a value, the pointer will automatically deliver the value stored
         in the space described by the pointer, that is, the value of the target object associated with the pointer.
         C.5.3 Pointers in variable deﬁnition contexts (10.2.1.3, 19.6.7)
       1 The appearance of a pointer in a context that requires its value is a reference to its target. Similarly, where a
         pointer appears in a variable deﬁnition context the variable that is deﬁned is the target of the pointer.
       2 Executing the program fragment
              REAL, POINTER :: A
              REAL, TARGET :: B = 10.0
              A => B
              A = 42.0
              PRINT ’(F4.1)’, B
         produces “42.0” as output.
         C.6  Clause 11 notes
         C.6.1 The SELECT CASE construct (11.1.9)
       1 At most one case block is selected for execution within a SELECT CASE construct, and there is no fall-through
         from one block into another block within a SELECT CASE construct. Thus there is no requirement for the user
         to exit explicitly from a block.
         c
         ISO/IEC 2017 – All rights reserved                                 553
            ISO/IEC DIS 1539-1:2017 (E)
            C.6.2   Loop control (11.1.7)
         1 Fortran provides several forms of loop control:
                 (1)  With an iteration count and a DO variable. This is the classic Fortran DO loop.
                 (2)  Test a logical condition before each execution of the loop (DO WHILE).
                 (3)  DO“forever”.
            C.6.3   Examples of DO constructs (11.1.7)
         1 The following are all valid examples of DO constructs.
            Example 1:
                   SUM = 0.0
                   READ (IUN) N
                   OUTER: DO L = 1, N           ! A DO with a construct name
                      READ (IUN) IQUAL, M, ARRAY (1:M)
                      IF (IQUAL < IQUAL_MIN) CYCLE OUTER    ! Skip inner loop
                      INNER: DO 40 I = 1, M     ! A DO with a label and a name
                         CALL CALCULATE (ARRAY (I), RESULT)
                         IF (RESULT < 0.0) CYCLE
                         SUM = SUM + RESULT
                         IF (SUM > SUM_MAX) EXIT OUTER
               40     END DO INNER
                   END DO OUTER
         2 Theouterloophasaniteration count of MAX (N, 0), and will execute that number of times or until SUM exceeds
            SUM_MAX, in which case the EXIT OUTER statement terminates both loops. The inner loop is skipped by
            the ﬁrst CYCLE statement if the quality ﬂag, IQUAL, is too low. If CALCULATE returns a negative RESULT,
            the second CYCLE statement prevents it from being summed. Both loops have construct names and the inner
            loop also has a label. A construct name is required in the EXIT statement in order to terminate both loops, but
            is optional in the CYCLE statements because each belongs to its innermost loop.
            Example 2:
                   N = 0
                   DO 50, I = 1, 10
                      J = I
                      DO K = 1, 5
                         L = K
                         N = N + 1  ! This statement executes 50 times
                      END DO        ! Nonlabeled DO inside a labeled DO
               50  CONTINUE
         3 After execution of the above program fragment, I = 11, J = 10, K = 6, L = 5, and N = 50.
                                                                  c
            554                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            Example 3:
                   N = 0
                   DO I = 1, 10
                      J = I
                      DO 60, K = 5, 1  ! This inner loop is never executed
                         L = K
                         N = N + 1
               60     CONTINUE         ! Labeled DO inside a nonlabeled DO
                   END DO
         4 After execution of the above program fragment, I = 11, J = 10, K = 5, N = 0, and L is not deﬁned by these
            statements.
            C.6.4   Examples of invalid DO constructs (11.1.7)
         1 The following are all examples of invalid skeleton DO constructs:
            Example 1:
                   DO I = 1, 10
                      ...
                   END DO LOOP   ! No matching construct name
            Example 2:
                   LOOP: DO 1000 I = 1, 10   ! No matching construct name
                      ...
                   1000  CONTINUE
            Example 3:
                   LOOP1: DO
                      ...
                   END DO LOOP2   ! Construct names don’t match
            Example 4:
                   DO I = 1, 10   ! Label required or ...
                      ...
                   1010 CONTINUE  ! ... END DO required
            Example 5:
                   DO 1020 I = 1, 10
                      ...
                   1021 END DO        ! Labels don’t match
            c
            ISO/IEC 2017 – All rights reserved                                                      555
            ISO/IEC DIS 1539-1:2017 (E)
            Example 6:
                   FIRST: DO I = 1, 10
                      SECOND: DO J = 1, 5
                         ...
                      END DO FIRST   ! Improperly nested DOs
                   END DO SECOND
            C.6.5   Simple example using events
         1 Atree is a graph in which every node except one has a single “parent” node to which it is connected by an edge.
            The node without a parent is the “root” of the tree. The nodes that have a particular node as their parent are
            the “children” of that node. The root is at level 1, its children are at level 2, and so on.
         2 Amultifrontal code to solve a sparse set of linear equations involves a tree. Work at a node can start after all of
            its children’s work is complete and their data have been passed to it.
         3 Here we assume that each node has been assigned to an image. Each image has a list of its nodes and these
            are ordered in decreasing tree level (all those at level L preceding those at level L − 1). For each node, array
            elements hold the number of children, details about the parent, and an event variable. This allows the processing
            to proceed asynchronously subject to the rule that a parent has to wait for all its children.
            Outline of example code:
                   PROGRAM TREE
                     USE, INTRINSIC :: ISO_FORTRAN_ENV
                     INTEGER, ALLOCATABLE :: NODE (:) ! Tree nodes that this image handles.
                     INTEGER, ALLOCATABLE :: NC (:)   ! NODE(I) has NC(I) children.
                     INTEGER, ALLOCATABLE :: PARENT (:), SUB (:)
                         ! The parent of NODE (I) is NODE (SUB (I)) [PARENT (I)].
                     TYPE (EVENT_TYPE), ALLOCATABLE :: DONE (:) [:]
                     INTEGER :: I, J, STATUS
                     ! Set up the tree, including allocation of all arrays.
                     DO I = 1, SIZE (NODE)
                       ! Wait for children to complete
                       IF (NC (I) > 0) THEN
                         EVENT WAIT (DONE (I), UNTIL_COUNT=NC (I), STAT=STATUS)
                         IF (STATUS/=0) EXIT
                       END IF
                       ! Process node, using data from children.
                       IF (PARENT (I)>0) THEN
                         ! Node is not the root.
                         ! Place result on image PARENT (I) for node NODE (SUB) [PARENT (I)]
                         ! Tell PARENT (I) that this has been done.
                         EVENT POST (DONE (SUB (I)) [PARENT (I)], STAT=STATUS)
                         IF (STATUS/=0) EXIT
                       END IF
                     END DO
                   END PROGRAM TREE
                                                                  c
            556                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            C.6.6   Example using three teams
         1 The following example illustrates the structure of a routine that will compute ﬂuxes based on surface properties
            over land, sea, and ice, each in a diﬀerent team. Each image will deal with areas containing exactly one of the
            three surface types.
                   SUBROUTINE COMPUTE_FLUXES (FLUX_MOM, FLUX_SENS, FLUX_LAT)
                   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
                   REAL, INTENT (OUT)  :: FLUX_MOM (:,:), FLUX_SENS (:,:), FLUX_LAT (:,:)
                   INTEGER, PARAMETER  :: LAND = 1, SEA = 2, ICE = 3
                   CHARACTER (LEN=10)  :: SURFACE_TYPE
                   INTEGER             :: MY_SURFACE_TYPE, N_IMAGE
                   TYPE (TEAM_TYPE)    :: TEAM_SURFACE_TYPE
                      CALL GET_SURFACE_TYPE(THIS_IMAGE (), SURFACE_TYPE)
                      SELECT CASE (SURFACE_TYPE)
                      CASE ("LAND")
                         MY_SURFACE_TYPE = LAND
                      CASE ("SEA")
                         MY_SURFACE_TYPE = SEA
                      CASE ("ICE")
                         MY_SURFACE_TYPE = ICE
                      CASE DEFAULT
                         ERROR STOP
                      END SELECT
                      FORM TEAM (MY_SURFACE_TYPE, TEAM_SURFACE_TYPE)
                      CHANGE TEAM (TEAM_SURFACE_TYPE)
                         SELECT CASE (TEAM_NUMBER ( ))
                         CASE (LAND)   ! Compute fluxes over land surface
                            CALL COMPUTE_FLUXES_LAND (FLUX_MOM, FLUX_SENS, FLUX_LAT)
                         CASE (SEA)    ! Compute fluxes over sea surface
                            CALL COMPUTE_FLUXES_SEA (FLUX_MOM, FLUX_SENS, FLUX_LAT)
                         CASE (ICE)    ! Compute fluxes over ice surface
                            CALL COMPUTE_FLUXES_ICE (FLUX_MOM, FLUX_SENS, FLUX_LAT)
                         CASE DEFAULT
                            ERROR STOP
                         END SELECT
                      END TEAM
                   END SUBROUTINE COMPUTE_FLUXES
            C.6.7   Accessing coarrays in sibling teams
         1 The following program illustrates subdividing a 4×4 grid into 2×2 teams, and the denotation of sibling teams.
                   PROGRAM DEMO
                     ! Initial team : 16 images. Algorithm design is a 4 by 4 grid.
                     ! Desire 4 teams, for the upper left (UL), upper right (UR),
            c
            ISO/IEC 2017 – All rights reserved                                                      557
            ISO/IEC DIS 1539-1:2017 (E)
                     !                         lower left (LL), lower right (LR)
                     USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
                     TYPE (TEAM_TYPE) :: T
                     INTEGER, PARAMETER :: UL=11, UR=22, LL=33, LR=44
                     REAL    :: A(10,10)[4,*]
                     INTEGER :: MYPE, TEAMNUM, NEWPE
                     TYPE TRANS_T
                       INTEGER :: NEW_TEAM (16), NEW_INDEX (16)
                     END TYPE
                     TYPE (TRANS_T) :: TRANS
                     TRANS = TRANS_T ([UL, UL, LL, LL, UL, UL, LL, LL, UR, UR, LR, LR, UR, UR, LR, LR], &
                                      [1,  2,  1,  2,  3,  4,  3,  4,  1,  2,  1,  2,  3,  4,  3,  4])
                     MYPE = THIS_IMAGE ()
                     FORM TEAM (TRANS%NEW_TEAM(MYPE), T, NEW_INDEX=TRANS%NEW_INDEX(MYPE))
                     A = 3.14
                     CHANGE TEAM (T, B[2,*] => A)
                       ! Inside change team, image pattern for B is a 2 by 2 grid.
                       B (5, 5) = B (1, 1)[2, 1]
                       ! Outside the team addressing:
                       NEWPE = THIS_IMAGE ()
                       SELECT CASE (TEAM_NUMBER ())
                       CASE (UL)
                          IF (NEWPE==3) THEN
                             ! Right column of UL gets left column of UR.
                              B (:, 10) = B (:, 1)[1, 1, TEAM_NUMBER=UR]
                          ELSE IF (NEWPE==4) THEN
                              B (:, 10) = B (:, 1)[2, 1, TEAM_NUMBER=UR]
                          END IF
                       CASE (LL)
                          ! Similar to complete column exchange across middle of the original grid.
                          ...
                       END SELECT
                      END TEAM
                   END PROGRAM DEMO
            C.6.8   Example involving failed images
         1 Parallel algorithms often use work sharing schemes based on a speciﬁc mapping between image indices and global
            data addressing. To allow such programs to continue when one or more images fail, spare images can be used
            to re-establish execution of the algorithm with the failed images replaced by spare images, while retaining the
            previous image mapping for nonfailed images.
                                                                  c
            558                                                  ISO/IEC 2017 – All rights reserved
                                           ISO/IEC DIS 1539-1:2017 (E)
      2 The following example illustrates how this might be done. In this example, failure cannot be tolerated for image
       1 in the initial team.
           PROGRAM possibly_recoverable_simulation
            USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE, STAT_FAILED_IMAGE
            IMPLICIT NONE
            INTEGER, ALLOCATABLE :: failures (:)
            INTEGER :: images_used, i, images_spare, status
            INTEGER :: id [*], me [*]
            TYPE (TEAM_TYPE) :: simulation_team
            LOGICAL :: read_checkpoint, done [*]
            ! Keep 1% spare images if we have a lot, just 1 if 10-199 images, 0 if <10.
            images_spare = MAX (INT (0.01*NUM_IMAGES ()), 0, MIN (NUM_IMAGES () - 10, 1)
            images_used = NUM_IMAGES () - images_spare
            read_checkpoint = THIS_IMAGE () > images_used
            setup : DO
             me = THIS_IMAGE ()
             id = MERGE (1, 2, me<=images_used)
             !
             ! Set up spare images as replacement for failed ones.
             !
             IF (IMAGE_STATUS (1) == STAT_FAILED_IMAGE) &
                ERROR STOP "cannot recover"
             IF (me == 1) THEN
               failures = FAILED_IMAGES ()
               k = images_used
               DO i = 1, SIZE (failures)
                 DO k = k+1, NUM_IMAGES ()
                  IF (IMAGE_STATUS (k) == 0) EXIT
                 END DO
                 IF (k > NUM_IMAGES ()) ERROR STOP "cannot recover"
                 me [k] = failures (i)
                 id [k] = 1
               END DO
               images_used = k
             END IF
             !
             ! Set up a simulation team of constant size.
             ! Team 2 is the set of spares, so does not participate in the simulation.
             !
             FORM TEAM (id, simulation_team, NEW_INDEX=me, STAT=status)
             simulation : CHANGE TEAM (simulation_team, STAT=status)
               IF (status == STAT_FAILED_IMAGE) EXIT simulation
               IF (TEAM_NUMBER () == 1) THEN
                iter : DO
       c
       ISO/IEC 2017 – All rights reserved                  559
            ISO/IEC DIS 1539-1:2017 (E)
                             CALL simulation_procedure (read_checkpoint, status, done)
                             ! The simulation_procedure:
                             !  - sets up and performs some part of the simulation;
                             !  - resets to the last checkpoint if requested;
                             !  - sets status from its internal synchronizations;
                             !  - sets done to .TRUE. when the simulation has completed.
                             IF (status == STAT_FAILED_IMAGE) THEN
                                read_checkpoint = .TRUE.
                                EXIT simulation
                             ELSE IF (done)
                                EXIT iter
                             END IF
                             read_checkpoint = .FALSE.
                           END DO iter
                         END IF
                       END TEAM simulation (STAT=status)
                       SYNC ALL (STAT=status)
                       IF (THIS_IMAGE () > images_used) done = done[1]
                       IF (done) EXIT setup
                     END DO setup
                   END PROGRAM possibly_recoverable_simulation
         3 Supporting fault-tolerant execution imposes obligations on library writers who use the parallel language facilities.
            Every synchronization statement, allocation or deallocation of coarrays, or invocation of a collective procedure
            will need to be prepared to handle error conditions, and implicit deallocation of coarrays will need to be avoided.
            Also, coarray module variables that are allocated inside the team execution context are not persistent.
            C.6.9   EVENT_QUERY example that tolerates image failure
         1 This example is an adaptation of the later EVENT_QUERY example of C.11.2 to make it able to execute in
            the presence of the failure of one or more of the worker images. The function create_work_item now accepts an
            integer argument to indicate which work item is required. It is assumed that the work items are indexed 1, 2,
            ... . It is also assumed that if an image fails while processing a work item, that work item can subsequently be
            processed by another image.
                   PROGRAM work_share
                      USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: EVENT_TYPE
                      USE :: mod_work, ONLY:   & ! Module that creates work items
                             work,             & ! Type for holding a work item
                             create_work_item, & ! Function that creates work item
                             process_item,     & ! Function that processes an item
                             work_done           ! Logical function that returns true
                                                 !  if all work done
                      TYPE :: worker_type
                         TYPE (EVENT_TYPE), ALLOCATABLE :: free (:)
                      END TYPE
                                                                  c
            560                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                      TYPE (EVENT_TYPE)  :: submit [*]     ! Whether work ready for a worker
                      TYPE (worker_type) :: worker [*]     ! Whether worker is free
                      TYPE (work)        :: work_item [*]  ! Holds the data for a work item
                      INTEGER :: count, i, k, kk, nbusy [*], np, status
                      INTEGER, ALLOCATABLE :: working (:) ! Items being worked on
                      INTEGER, ALLOCATABLE :: pending (:) ! Items pending after image failure
                       IF (THIS_IMAGE () == 1) THEN
                         ! Get started
                         ALLOCATE (worker%free (2:NUM_IMAGES ()))
                         ALLOCATE (working (2: NUM_IMAGES ()), pending(NUM_IMAGES ()-1))
                         nbusy = 0              ! This holds the number of workers working
                         k = 1                  ! Index of next work item
                         np = 0                 ! Number of work items in array pending
                         DO i = 2, NUM_IMAGES () ! Start the workers working
                            IF (work_done ()) EXIT
                            working (i) = 0
                            IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) CYCLE
                            work_item [i] = create_work_item (k)
                            working (i) = k
                            k = k + 1
                            nbusy = nbusy + 1
                            EVENT POST (submit [i], STAT=status)
                         END DO
                         ! Main work distribution loop
                         master : DO
                            image : DO i = 2, NUM_IMAGES ()
                               IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) THEN
                                  IF (working (i)>0) THEN           ! It failed while working
                                     np = np + 1
                                     pending (np) = working (i)
                                     working (i) = 0
                                  END IF
                                  CYCLE image
                               END IF
                               CALL EVENT_QUERY (worker%free (i), count)
                               IF (count == 0) CYCLE image        ! Worker is not free
                               EVENT WAIT (worker%free (i))
                               nbusy = nbusy - 1
                               IF (np>0) THEN
                                  kk = pending (np)
                                  np = np - 1
                               ELSE
                                  IF (work_done ()) CYCLE image
                                  kk = k
                                  k = k + 1
            c
            ISO/IEC 2017 – All rights reserved                                                      561
             ISO/IEC DIS 1539-1:2017 (E)
                                  END IF
                                  nbusy = nbusy + 1
                                  working (i) = kk
                                  work_item [i] = create_work_item (kk)
                                  EVENT POST (submit [i], STAT=status)
                                  ! If image i has failed, the failure will be handled on
                                  ! the next iteration of the master loop.
                               END DO image
                               IF ( nbusy==0 ) THEN ! All done. Exit on all images.
                                  DO i = 2, NUM_IMAGES ()
                                      EVENT POST (submit [i], STAT=status)
                                      IF (status == STAT_FAILED_IMAGE) CYCLE
                                  END DO
                                  EXIT master
                               END IF
                            END DO master
                        ELSE
                            ! Work processing loop
                            worker : DO
                               EVENT WAIT (submit)
                               IF (nbusy [1] == 0) EXIT worker
                               CALL process_item(work_item)
                               EVENT POST (worker[1]%free (THIS_IMAGE ()))
                            END DO worker
                        END IF
                     END PROGRAM work_share
             C.7     Clause 12 notes
             C.7.1    External ﬁles (12.3)
          1 This document accommodates, but does not require, ﬁle cataloging. To do this, several concepts are introduced.
             C.7.1.1  File existence (12.3.2)
          1 Totally independent of the connection state is the property of existence, this being a ﬁle property. The processor
             “knows” of a set of ﬁles that exist at a given time for a given program. This set would include tapes ready to
             read, ﬁles in a catalog, a keyboard, a printer, etc. The set might exclude ﬁles inaccessible to the program because
             of security, because they are already in use by another program, etc. This document does not specify which
             ﬁles exist, hence wide latitude is available to a processor to implement security, locks, privilege techniques, etc.
             Existence is a convenient concept to designate all of the ﬁles that a program can potentially process.
                                                                          c
             562                                                         ISO/IEC 2017 – All rights reserved
                                                                           ISO/IEC DIS 1539-1:2017 (E)
         2 All four combinations of connection and existence can occur:
                              Connect  Exist  Examples
                              Yes      Yes    Acard reader loaded and ready to be read
                              Yes      No     Aprinter before the ﬁrst line is written
                              No       Yes    Aﬁle named ’JOAN’ in the catalog
                              No       No     Aﬁle on a reel of tape, not known to the processor
         3 Means are provided to create, delete, connect, and disconnect ﬁles.
            C.7.1.2 File access (12.3.3)
         1 This document does not address problems of security, protection, locking, and many other concepts that might
            be part of the concept of “right of access”. Such concepts are considered to be in the province of an operating
            system.
         2 The OPEN and INQUIRE statements can be extended naturally to consider these things.
         3 Possible access methods for a ﬁle are: sequential, stream and direct. The processor might implement three
            diﬀerent types of ﬁles, each with its own access method. It might instead implement one type of ﬁle with three
            diﬀerent access methods.
         4 Direct access to ﬁles is of a simple and commonly available type, that is, ﬁxed-length records. The key is a
            positive integer.
            C.7.1.3 File connection (12.5)
         1 Before any input/output can be performed on a ﬁle, it needs to be connected to a unit. The unit then serves as a
            designator for that ﬁle as long as it is connected. To be connected does not imply that “buﬀers” have or have not
            been allocated, that “ﬁle-control tables” have or have not been ﬁlled, or that any other method of implementation
            has been used. Connection means that (barring some other fault) a READ or WRITE statement can be executed
            on the unit, hence on the ﬁle. Without a connection, a READ or WRITE statement cannot be executed.
            C.7.1.4 File names (12.5.6.10)
         1 Aﬁlecanhaveaname. Theformofaﬁlenameisnotspeciﬁed. Ifasystemdoesnothavesomeformofcataloging
            or tape labeling for at least some of its ﬁles, all ﬁle names disappear at the termination of execution. This is a
            valid implementation. Nowhere does this document require names to survive for any period of time longer than
            the execution time span of a program. Therefore, this document does not impose cataloging as a prerequisite.
            The naming feature is intended to enable use of a cataloging system where one exists.
            C.7.2   Nonadvancing input/output (12.3.4.2)
         1 Data transfer statements aﬀect the positioning of an external ﬁle. In Fortran 77, if no error or end-of-ﬁle
            condition exists, the ﬁle is positioned after the record just read or written and that record becomes the preceding
            record. This document contains the ADVANCE= speciﬁer in a data transfer statement that provides the capab-
            ility of maintaining a position within the current record from one formatted data transfer statement to the next
            data transfer statement. The value NO provides this capability. The value YES positions the ﬁle after the record
            just read or written. The default is YES.
            c
            ISO/IEC 2017 – All rights reserved                                                        563
       ISO/IEC DIS 1539-1:2017 (E)
      2 The tab edit descriptor and the slash are still appropriate for use with this type of record access but the tab
       cannot reposition before the left tab limit.
      3 A BACKSPACE of a ﬁle that is positioned within a record causes the speciﬁed unit to be positioned before the
       current record.
      4 If the next input/output operation on a ﬁle after a nonadvancing write is a rewind, backspace, end ﬁle or close
       operation, the ﬁle is positioned implicitly after the current record before an ENDFILE record is written to the
       ﬁle, that is, a REWIND, BACKSPACE, or ENDFILE statement following a nonadvancing WRITE statement
       causes the ﬁle to be positioned at the end of the current output record before the endﬁle record is written to the
       ﬁle.
      5 This document provides a SIZE= speciﬁer to be used with formatted data transfer statements. The variable in
       the SIZE= speciﬁer is assigned the count of the number of characters that make up the sequence of values read
       by the data edit descriptors in the input statement.
      6 Thecount is especially helpful if there is only one list item in the input list because it is the number of characters
       that appeared for the item.
      7 The EOR= speciﬁer is provided to indicate when an EOR condition is encountered during a nonadvancing data
       transfer statement. The EOR condition is not an error condition. If this speciﬁer appears, an input list item that
       requires more characters than the record contained is padded with blanks if PAD= ’YES’ is in eﬀect. This means
       that the input list item completed successfully. The ﬁle is positioned after the current record. If the IOSTAT=
       speciﬁer appears, the speciﬁed variable is deﬁned with the value of the named constant IOSTAT_EOR from
       the intrinsic module ISO_FORTRAN_ENV and the data transfer statement is terminated. Program execution
       continues with the statement speciﬁed in the EOR= speciﬁer. The EOR= speciﬁer gives the capability of taking
       control of execution when the EOR condition is encountered. The do-variables in io-implied-dos retain their last
       deﬁned value and any remaining items in the input-item-list retain their deﬁnition status when an EOR condition
       occurs. If the SIZE= speciﬁer appears, the speciﬁed variable is assigned the number of characters read with the
       data edit descriptors during the READ statement.
      8 For nonadvancing input, the processor is not required to read partial records. The processor could read the entire
       record into an internal buﬀer and make successive portions of the record available to successive input statements.
      9 In an implementation of nonadvancing input/output in which a nonadvancing write to a terminal device causes
       immediate display of the output, such a write can be used as a mechanism to output a prompt. In this case, the
       statement
           WRITE (*, FMT=’(A)’, ADVANCE=’NO’) ’CONTINUE?(Y/N): ’
       would result in the prompt
           CONTINUE?(Y/N):
       being displayed with no subsequent line feed.
     10 The response, which might be read by a statement of the form
           READ (*, FMT=’(A)’) ANSWER
       can then be entered on the same line as the prompt as in
           CONTINUE?(Y/N): Y
                                       c
       564                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
        11 This document does not require that an implementation of nonadvancing input/output operate in this manner.
            For example, an implementation of nonadvancing output in which the display of the output is deferred until
            the current record is complete is also standard-conforming. Such an implementation will not, however, allow a
            prompting mechanism of this kind to operate.
            C.7.3   OPEN statement (12.5.6)
         1 A ﬁle can become connected to a unit either by preconnection or by execution of an OPEN statement. Precon-
            nection is performed prior to the beginning of execution of a program by means external to Fortran. For example,
            it could be done by job control action or by processor-established defaults. Execution of an OPEN statement is
            not required in order to access preconnected ﬁles (12.5.5).
         2 The OPEN statement provides a means to access existing ﬁles that are not preconnected. An OPEN statement
            can be used in either of two ways: with a ﬁle name (open-by-name) and without a ﬁle name (open-by-unit). A
            unit is given in either case. Open-by-name connects the speciﬁed ﬁle to the speciﬁed unit. Open-by-unit connects
            a processor-dependent default ﬁle to the speciﬁed unit. (The default ﬁle might or might not have a name.)
         3 Therefore, there are three ways a ﬁle can become connected and hence processed: preconnection, open-by-name,
            and open-by-unit. Once a ﬁle is connected, there is no means in standard Fortran to determine how it became
            connected.
         4 AnOPENstatementcanalsobeusedtocreate a new ﬁle. In fact, any of the foregoing three connection methods
            can be performed on a ﬁle that does not exist. When a unit is preconnected, writing the ﬁrst record creates the
            ﬁle. With the other two methods, execution of the OPEN statement creates the ﬁle.
         5 WhenanOPENstatementis executed, the unit speciﬁed in the OPEN statement might or might not already be
            connected to a ﬁle. If it is already connected to a ﬁle (either through preconnection or by prior execution of an
            OPENstatement), then omitting the FILE= speciﬁer in the OPEN statement implies that the ﬁle is to remain
            connected to the unit. Such an OPEN statement can be used to change the values of the blank interpretation
            mode, decimal edit mode, pad mode, input/output rounding mode, delimiter mode, and sign mode.
         6 If the value of the ACTION= speciﬁer is WRITE, then a READ statement cannot refer to the connection.
            ACTION=’WRITE’does not restrict positioning by a BACKSPACE statement or positioning speciﬁed by the
            POSITION= speciﬁer with the value APPEND. However, a BACKSPACE statement or an OPEN statement
            containing POSITION = ’APPEND’ might fail if the processor needs to read the ﬁle to achieve the positioning.
         7 The following examples illustrate these rules. In the ﬁrst example, unit 10 is preconnected to a SCRATCH ﬁle;
            the OPEN statement changes the value of PAD= to YES.
                   CHARACTER (LEN = 20) CH1
                   WRITE (10, ’(A)’) ’THIS IS RECORD 1’
                   OPEN (UNIT = 10, STATUS = ’OLD’, PAD = ’YES’)
                   REWIND 10
                   READ (10, ’(A20)’) CH1   ! CH1 now has the value
                                            ! ’THIS IS RECORD 1    ’
         8 In the next example, unit 12 is ﬁrst connected to a ﬁle named FRED, with a status of OLD. The second OPEN
            statement then opens unit 12 again, retaining the connection to the ﬁle FRED, but changing the value of the
            DELIM=speciﬁer to QUOTE.
            c
            ISO/IEC 2017 – All rights reserved                                                      565
            ISO/IEC DIS 1539-1:2017 (E)
                   CHARACTER (LEN = 25) CH2, CH3
                   OPEN (12, FILE = ’FRED’, STATUS = ’OLD’, DELIM = ’NONE’)
                   CH2 = ’"THIS STRING HAS QUOTES."’
                                ! Quotes in string CH2
                   WRITE (12, *) CH2           ! Written with no delimiters
                   OPEN (12, DELIM = ’QUOTE’)  ! Now quote is the delimiter
                   REWIND 12
                   READ (12, *) CH3  ! CH3 now has the value
                                     ! ’THIS STRING HAS QUOTES.  ’
         9 The next example is invalid because it attempts to change the value of the STATUS= speciﬁer.
                   OPEN (10, FILE = ’FRED’, STATUS = ’OLD’)
                   WRITE (10, *) A, B, C
                   OPEN (10, STATUS = ’SCRATCH’)   ! Attempts to make FRED a SCRATCH file
        10 The previous example could be made valid by closing the unit ﬁrst, as in the next example.
                   OPEN (10, FILE = ’FRED’, STATUS = ’OLD’)
                   WRITE (10, *) A, B, C
                   CLOSE (10)
                   OPEN (10, STATUS = ’SCRATCH’)   ! Opens a different SCRATCH file
            C.7.4   Connection properties (12.5.4)
         1 When a unit becomes connected to a ﬁle, either by execution of an OPEN statement or by preconnection, the
            following connection properties, among others, are established.
                 (1)  Anaccess method, which is sequential, direct, or stream, is established for the connection (12.5.6.3).
                 (2)  A form, which is formatted or unformatted, is established for a connection to a ﬁle that exists or
                      is created by the connection. For a connection that results from execution of an OPEN statement,
                      a default form (which depends on the access method, as described in 12.3.3) is established if no
                      form is speciﬁed. For a preconnected ﬁle that exists, a form is established by preconnection. For a
                      preconnected ﬁle that does not exist, a form might be established, or the establishment of a form
                      might be delayed until the ﬁle is created (for example, by execution of a formatted or unformatted
                      WRITEstatement) (12.5.6.11).
                 (3)  A record length might be established. If the access method is direct, the connection establishes a
                      record length that speciﬁes the length of each record of the ﬁle. A direct access ﬁle can only contain
                      records that are all of equal length.
                 (4)  Asequential ﬁle can contain records of varying lengths. In this case, the record length established
                      speciﬁes the maximum length of a record in the ﬁle (12.5.6.15).
         2 A processor has wide latitude in adapting these concepts and actions to its own cataloging and job control
            conventions. Some processors might need job control action to specify the set of ﬁles that exist or that will
            be created by a program. Some processors might not need any job control action prior to execution. This
            document enables processors to perform dynamic open, close, or ﬁle creation operations, but it does not require
            such capabilities of the processor.
                                                                  c
            566                                                  ISO/IEC 2017 – All rights reserved
                                                                   ISO/IEC DIS 1539-1:2017 (E)
        3 The meaning of “open” in contexts other than Fortran might include such things as mounting a tape, console
           messages, spooling, label checking, security checking, etc. These actions might occur upon job control action
           external to Fortran, upon execution of an OPEN statement, or upon execution of the ﬁrst read or write of the
           ﬁle. The OPEN statement describes properties of the connection to the ﬁle and might or might not cause physical
           activities to take place.
           C.7.5  Asynchronous input/output (12.6.2.5)
        1 Rather than limit support for asynchronous input/output to what has been traditionally provided by facilities
           such as BUFFERIN/BUFFEROUT,thisdocumentbuildsuponexistingFortransyntax. Thispermitsalternative
           approaches for implementing asynchronous input/output, and simpliﬁes the task of adapting existing standard-
           conforming programs to use asynchronous input/output.
        2 Not all processors actually perform input/output asynchronously, nor will every processor that does be able to
           handle data transfer statements with complicated input/output item lists in an asynchronous manner. Such
           processors can still be standard-conforming.
        3 This document allows for at least two diﬀerent conceptual models for asynchronous input/output.
        4 Model1: the processor performs asynchronous input/output when the item list is simple (perhaps one contiguous
           named array) and the input/output is unformatted. The implementation cost is reduced, and this is the scenario
           most likely to be beneﬁcial on traditional “big-iron” machines.
        5 Model 2: The processor is free to do any of the following:
               (1)  on output, create a buﬀer inside the input/output library, completely formatted, and then start an
                    asynchronous write of the buﬀer, and immediately return to the next statement in the program. The
                    processor is free to wait for previously issued WRITEs, or not, or
               (2)  pass the input/output list addresses to another processor/process, which processes the list items
                    independently of the processor that executes the user’s code. The addresses of the list items will
                    need to be computed before the asynchronous READ/WRITE statement completes. There is still
                    an ordering requirement on list item processing to handle things like READ (...) N,(a(i),i=1,N).
        6 Aprogram can issue a large number of asynchronous input/output requests, without waiting for any of them to
           complete, and then wait for any or all of them. That does not constitute a requirement for the processor to keep
           track of each individual request separately.
        7 It is not necessary for all requests to be tracked by the runtime library. If an ID= speciﬁer does not appear in on a
           READorWRITEstatement,theruntime library can forget about this particular request once it has successfully
           completed. If an error or end-of-ﬁle condition occurs for a request, the processor can report this during any
           input/output operation to that unit. If an ID= speciﬁer appears, the processor’s runtime input/output library
           will need to keep track of any end-of-ﬁle or error conditions for that particular input/output request. However, if
           the input/output request succeeds without any exceptional conditions occurring, then the runtime can forget that
           ID=value. A runtime library might only keep track of the last request made, or perhaps a very few. Then, when
           a user WAITs for a particular request, either the library will know about it (and does the right thing with respect
           to error handling, etc.), or can assume it is a request that successfully completed and was forgotten about (and
           will just return without signaling any end-of-ﬁle or error condition). A standard-conforming program can only
           pass valid ID= values, but there is no requirement on the processor to detect invalid ID= values. There might
           be a processor dependent limit on how many outstanding input/output requests that generate an end-of-ﬁle or
           c
           ISO/IEC 2017 – All rights reserved                                               567
         ISO/IEC DIS 1539-1:2017 (E)
         error condition can be handled before the processor runs out of memory to keep track of such conditions. The
         restrictions on the SIZE= variables are designed to enable the processor to update such variables at any time
         (after the request has been processed, but before the wait operation), and then forget about them. Only error and
         end-of-ﬁle conditions are expected to be tracked by individual request by the runtime, and then only if an ID=
         speciﬁer appears. The END= and EOR= speciﬁers have not been added to all statements that can perform wait
         operations. Instead, the IOSTAT variable can be queried after a wait operation to handle this situation. This
         choice was made because the WAIT statement is expected to be the usual method of waiting for input/output
         to complete (and WAIT does support the END= and EOR= speciﬁers). This particular choice is philosophical,
         and was not based on signiﬁcant technical diﬃculties.
       8 The requirement to set the IOSTAT variable correctly means that a processor will need to remember which
         input/output requests encountered an end-of-record condition, so that a subsequent wait operation can return
         the correct IOSTAT value. Therefor there might be a processor deﬁned limit on the number of outstanding
         nonadvancing input/output requests that have encountered an end-of-record condition (constrained by available
         memory to keep track of this information, similar to end-of-ﬁle and error conditions).
         C.8  Clause 13 notes
         C.8.1 Number of records (13.4, 13.5, 13.8.2)
       1 The number of records read by an explicitly formatted advancing input statement can be determined from the
         following rule: a record is read at the beginning of the format scan (even if the input list is empty unless the most
         recently previous operation on the unit was not a nonadvancing read operation), at each slash edit descriptor
         encountered in the format, and when a format rescan occurs at the end of the format.
       2 The number of records written by an explicitly formatted advancing output statement can be determined from
         the following rule: a record is written when a slash edit descriptor is encountered in the format, when a format
         rescan occurs at the end of the format, and at completion of execution of an advancing output statement (even if
         the output list is empty). Thus, the occurrence of n successive slashes between two other edit descriptors causes
         n−1blank lines if the records are printed. The occurrence of n slashes at the beginning or end of a complete
         format speciﬁcation causes n blank lines if the records are printed. However, a complete format speciﬁcation
         containing n slashes (n > 0) and no other edit descriptors causes n+1 blank lines if the records are printed. For
         example, the statements
             PRINT 3
           3 FORMAT (/)
         will write two records that cause two blank lines if the records are printed.
         C.8.2 List-directed input (13.10.3)
       1 The following examples illustrate list-directed input. A blank character is represented by b.
       2 Example 1:
         Program:
              J = 3
              READ *, I
              READ *, J
                                                  c
         568                                     ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            Sequential input ﬁle:
                   record 1:  b1b,4bbbbb
                   record 2:  ,2bbbbbbbb
         3 Result: I = 1, J = 3.
         4 Explanation: The second READ statement reads the second record. The initial comma in the record designates
            a null value; therefore, J is not redeﬁned.
         5 Example 2:
            Program:
                CHARACTER A *8, B *1
                READ *, A, B
            Sequential input ﬁle:
                record 1:  ’bbbbbbbb’
                record 2:  ’QXY’b’Z’
         6 Result: A = ’bbbbbbbb’, B = ’Q’
         7 Explanation: In the ﬁrst record, the rightmost apostrophe is interpreted as delimiting the constant (it cannot
            be the ﬁrst of a pair of embedded apostrophes representing a single apostrophe because this would involve
            the prohibited “splitting” of the pair by the end of a record); therefore, A is assigned the character constant
            ’bbbbbbbb’. The end of a record acts as a blank, which in this case is a value separator because it occurs between
            two constants.
            C.9    Clause 14 notes
            C.9.1   Main program and block data program unit (14.1, 14.3)
         1 The name of the main program or of a block data program unit has no explicit use within the Fortran language.
            It is available for documentation and for possible use by a processor.
         2 A processor might implement an unnamed program unit by assigning it a global identiﬁer that is not used
            elsewhere in the program. This could be done by using a default name that does not satisfy the rules for Fortran
            names.
            C.9.2   Dependent compilation (14.2)
         1 This document, like its predecessors, is intended to enable the implementation of conforming processors in which
            a program can be broken into multiple units, each of which can be separately translated in preparation for
            execution. Such processors are commonly described as supporting separate compilation. There is an important
            diﬀerence between the way separate compilation can be implemented under this document and the way it could be
            implemented under the Fortran 77 International Standard. Under the Fortran 77 standard, any information
            c
            ISO/IEC 2017 – All rights reserved                                                      569
              ISO/IEC DIS 1539-1:2017 (E)
              required to translate a program unit was speciﬁed in that program unit. Each translation was thus totally
              independent of all others. Under this document, a program unit can use information that was speciﬁed in a
              separate module and thus can be dependent on that module. The implementation of this dependency in a
              processor might be that the translation of a program unit depends on the results of translating one or more
              modules. Processors implementing the dependency this way are commonly described as supporting dependent
              compilation.
           2 The dependencies involved here are new only in the sense that the Fortran processor is now aware of them. The
              same information dependencies existed under the Fortran 77 International Standard, but it was the program-
              mer’s responsibility to transport the information necessary to resolve them by making redundant speciﬁcations of
              the information in multiple program units. The availability of separate but dependent compilation oﬀers several
              potential advantages over the redundant textual speciﬁcation of information.
                     (1)   Specifying information at a single place in the program ensures that diﬀerent program units using that
                           information are translated consistently. Redundant speciﬁcation leaves the possibility that diﬀerent
                           information can be erroneously be speciﬁed. Even if an INCLUDE line is used to ensure that the
                           text of the speciﬁcations is identical in all involved program units, the presence of other speciﬁcations
                           (for example, an IMPLICIT statement) could change the interpretation of that text.
                     (2)   During the revision of a program, it is possible for a processor to assist in determining whether diﬀer-
                           ent program units have been translated using diﬀerent (incompatible) versions of a module, although
                           there is no requirement that a processor provide such assistance. Inconsistencies in redundant textual
                           speciﬁcation of information, on the other hand, tend to be much more diﬃcult to detect.
                     (3)   Putting information in a module provides a way of packaging it. Without modules, redundant spe-
                           ciﬁcations frequently are interleaved with other speciﬁcations in a program unit, making convenient
                           packaging of such information diﬃcult.
                     (4)   Because a processor can be implemented such that the speciﬁcations in a module are translated once
                           and then repeatedly referenced, there is the potential for greater eﬃciency than when the processor
                           translates redundant speciﬁcations of information in multiple program units.
           3 The exact meaning of the requirement that the public portions of a module be available at the time of reference
              is processor dependent. For example, a processor could consider a module to be available only after it has been
              compiled and require that if the module has been compiled separately, the result of that compilation be identiﬁed
              to the compiler when compiling program units that use it.
              C.9.2.1    USE statement and dependent compilation (14.2.2)
           1 Another beneﬁt of the USE statement is its enhanced facilities for name management. If one needs to use only
              selected entities in a module, one can do so without having to worry about the names of all the other entities
              in that module. If one needs to use two diﬀerent modules that happen to contain entities with the same name,
              there are several ways to deal with the conﬂict. If none of the entities with the same name are to be used, they
              can simply be ignored. If the name happens to refer to the same entity in both modules (for example, if both
              modules obtained it from a third module), then there is no confusion about what the name denotes and the name
              can be freely used. If the entities are diﬀerent and one or both is to be used, the local renaming facility in the
              USE statement makes it possible to give those entities diﬀerent names in the program unit containing the USE
              statements.
           2 Abeneﬁt of using the ONLY option consistently, as compared to USE without it, is that the module from which
              each accessed entity is accessed is explicitly speciﬁed in each program unit. This means that one need not search
              other program units to ﬁnd where each one is deﬁned. This reduces maintenance costs.
                                                                                 c
              570                                                                ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
          3 Atypical implementation of dependent but separate compilation might involve storing the result of translating a
             module in a ﬁle whose name is derived from the name of the module. Note, however, that the name of a module
             is limited only by the Fortran rules and not by the names allowed in the ﬁle system. Thus the processor might
             have to provide a mapping between Fortran names and ﬁle system names.
          4 The result of translating a module could reasonably either contain only the information textually speciﬁed in the
             module (with “pointers” to information originally textually speciﬁed in other modules) or contain all information
             speciﬁedinthemodule(includingcopiesofinformationoriginallyspeciﬁedinothermodules). Althoughtheformer
             approach would appear to save on storage space, the latter approach can greatly simplify the logic necessary to
             process a USE statement and can avoid the necessity of imposing a limit on the logical “nesting” of modules via
             the USE statement.
          5 There is an increased potential for undetected errors in a scoping unit that uses both implicit typing and the
             USE statement. For example, in the program fragment
                     SUBROUTINE SUB
                        USE MY_MODULE
                        IMPLICIT INTEGER (I-N), REAL (A-H, O-Z)
                        X = F (B)
                        A = G (X) + H (X + 1)
                     END SUBROUTINE SUB
             Xcould be either an implicitly typed real variable or a variable obtained from the module MY_MODULE and
             might change from one to the other because of changes in MY_MODULE unrelated to the action performed by
             SUB. Logic errors resulting from this kind of situation can be extremely diﬃcult to locate. Thus, the use of these
             features together is discouraged.
             C.9.2.2  Accessibility attributes (8.5.2)
          1 The PUBLIC and PRIVATE attributes, which can be declared only in modules, divide the entities in a module
             into those that are actually relevant to a scoping unit referencing the module and those that are not. This
             information might be used to improve the performance of a Fortran processor. For example, it might be possible
             to discard much of the information about the private entities once a module has been translated, thus saving on
             both storage and the time to search it. Similarly, it might be possible to recognize that two versions of a module
             diﬀer only in the private entities they contain and avoid retranslating program units that use that module when
             switching from one version of the module to the other.
             C.9.3    Examples of the use of modules (14.2.1)
             C.9.3.1  Global data (14.2.1)
          1 Amodule could contain only data objects, for example:
                     MODULE DATA_MODULE
                        SAVE
                        REAL A (10), B, C (20,20)
                        INTEGER :: I=0
                        INTEGER, PARAMETER :: J=10
                        COMPLEX D (J,J)
                     END MODULE DATA_MODULE
              c
             ISO/IEC 2017 – All rights reserved                                                                  571
             ISO/IEC DIS 1539-1:2017 (E)
          2 Data objects made global in this manner can have any combination of data types.
          3 Access to some of these can be made by a USE statement with the ONLY option, such as:
                     USE DATA_MODULE, ONLY: A, B, D
             and access to all of them can be made by the following USE statement:
                     USE DATA_MODULE
          4 Access to all of them with some renaming to avoid name conﬂicts can be made by, for example:
                USE DATA_MODULE, AMODULE => A, DMODULE => D
             C.9.3.2  Derived types (14.2.1)
          1 Aderived type can be deﬁned in a module and accessed in a number of program units. For example,
                     MODULE SPARSE
                        TYPE NONZERO
                            REAL A
                            INTEGER   I, J
                        END TYPE NONZERO
                     END MODULE SPARSE
             deﬁnes a type consisting of a real component and two integer components for holding the numerical value of a
             nonzero matrix element and its row and column indices.
             C.9.3.3  Global allocatable arrays (14.2.1)
          1 Many programs need large global allocatable arrays whose sizes are not known before program execution. A
             simple form for such a program is:
                     PROGRAM GLOBAL_WORK
                        CALL CONFIGURE_ARRAYS          ! Perform the appropriate allocations
                        CALL COMPUTE                   ! Use the arrays in computations
                     END PROGRAM GLOBAL_WORK
                     MODULE WORK_ARRAYS                ! An example set of work arrays
                        INTEGER   N
                        REAL, ALLOCATABLE :: A (:), B (:, :), C (:, :, :)
                     END MODULE WORK_ARRAYS
                     SUBROUTINE CONFIGURE_ARRAYS       ! Process to set up work arrays
                        USE WORK_ARRAYS
                        READ (*, *)    N
                        ALLOCATE (A (N), B (N, N), C (N, N, 2 * N))
                     END SUBROUTINE CONFIGURE_ARRAYS
                     SUBROUTINE COMPUTE
                        USE WORK_ARRAYS
                        ...   !  Computations involving arrays A, B, and C
                     END SUBROUTINE COMPUTE
                                                                          c
             572                                                         ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
          2 Typically, many subprograms need access to the work arrays, and all such subprograms would contain the
             statement
                     USE WORK_ARRAYS
             C.9.3.4  Procedure libraries (14.2.2)
          1 Interface bodies for external procedures in a library can be gathered into a module. An interface body speciﬁes
             an explicit interface (15.4.2.2).
          2 An example is the following library module:
                     MODULE LIBRARY_LLS
                        INTERFACE
                            SUBROUTINE LLS (X, A, F, FLAG)
                               REAL X (:, :)
                               ! The SIZE in the next statement is an intrinsic function
                               REAL, DIMENSION (SIZE (X, 2)) :: A, F
                               INTEGER FLAG
                            END SUBROUTINE LLS
                               ...
                        END INTERFACE
                            ...
                     END MODULE LIBRARY_LLS
          3 This module provides an explicit interface that is necessary for the subroutine LLS to be invoked. for example:
                     USE LIBRARY_LLS
                        ...
                     CALL LLS (X = ABC, A = D, F = XX, FLAG = IFLAG)
                        ...
          4 Because dummy argument names in an interface body for an external procedure are not required to be the same
             as in the procedure deﬁnition, diﬀerent versions can be constructed for diﬀerent applications using argument
             keywords appropriate to each application.
             C.9.3.5  Operator extensions (14.2.2)
          1 In order to extend an intrinsic operator symbol to have an additional meaning, an interface block specifying that
             operator symbol in the OPERATOR option of the INTERFACE statement could be placed in a module.
          2 For example, // can be extended to perform concatenation of two derived-type objects serving as varying length
             character strings and + can be extended to specify matrix addition for type MATRIX or interval arithmetic
             addition for type INTERVAL.
          3 Amodulemightcontain several such interface blocks. An operator can be deﬁned by an external function (either
             in Fortran or some other language) and its procedure interface placed in the module.
              c
             ISO/IEC 2017 – All rights reserved                                                                  573
             ISO/IEC DIS 1539-1:2017 (E)
             C.9.3.6  Data abstraction (14.2.2)
          1 In addition to providing a portable means of avoiding the redundant speciﬁcation of information in multiple
             program units, a module provides a convenient means of “packaging” related entities, such as the deﬁnitions of
             the representation and operations of an abstract data type. The following example of a module deﬁnes a data
             abstraction for a SET type where the elements of each set are of type integer. The usual set operations of UNION,
             INTERSECTION, and DIFFERENCE are provided. The CARDINALITY function returns the cardinality of
             (number of elements in) its set argument. Two functions returning logical values are included, ELEMENT and
             SUBSET. ELEMENT deﬁnes the operator .IN. and SUBSET extends the operator <=. ELEMENT determines
             if a given scalar integer value is an element of a given set, and SUBSET determines if a given set is a subset of
             another given set. (Two sets can be checked for equality by comparing cardinality and checking that one is a
             subset of the other, or checking to see if each is a subset of the other.)
          2 The transfer function SETF converts a vector of integer values to the corresponding set, with duplicate values
             removed. Thus, a vector of constant values can be used as set constants. An inverse transfer function VECTOR
             returns the elements of a set as a vector of values in ascending order. In this SET implementation, set data
             objects have a maximum cardinality of 200.
          3 Here is the example module:
                     MODULE INTEGER_SETS
                     ! This module is intended to illustrate use of the module facility
                     ! to define a new type, along with suitable operators.
                     INTEGER, PARAMETER :: MAX_SET_CARD = 200
                     TYPE SET                                    ! Define SET type
                        PRIVATE
                        INTEGER CARD
                        INTEGER ELEMENT (MAX_SET_CARD)
                     END TYPE SET
                     INTERFACE OPERATOR (.IN.)
                        MODULE PROCEDURE ELEMENT
                     END INTERFACE OPERATOR (.IN.)
                     INTERFACE OPERATOR (<=)
                        MODULE PROCEDURE SUBSET
                     END INTERFACE OPERATOR (<=)
                     INTERFACE OPERATOR (+)
                        MODULE PROCEDURE UNION
                     END INTERFACE OPERATOR (+)
                     INTERFACE OPERATOR (-)
                        MODULE PROCEDURE DIFFERENCE
                     END INTERFACE OPERATOR (-)
                                                                          c
             574                                                         ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                   INTERFACE OPERATOR (*)
                      MODULE PROCEDURE INTERSECTION
                   END INTERFACE OPERATOR (*)
                   CONTAINS
                   INTEGER FUNCTION CARDINALITY (A)   ! Returns cardinality of set A
                      TYPE (SET), INTENT (IN) :: A
                      CARDINALITY = A % CARD
                   END FUNCTION CARDINALITY
                   LOGICAL FUNCTION ELEMENT (X, A)           ! Determines if
                      INTEGER, INTENT(IN) :: X               ! element X is in set A
                      TYPE (SET), INTENT(IN) :: A
                      ELEMENT = ANY (A % ELEMENT (1 : A % CARD) == X)
                   END FUNCTION ELEMENT
                   FUNCTION UNION (A, B)                     ! Union of sets A and B
                      TYPE (SET) UNION
                      TYPE (SET), INTENT(IN) :: A, B
                      INTEGER J
                      UNION = A
                      DO J = 1, B % CARD
                         IF (.NOT. (B % ELEMENT (J) .IN. A)) THEN
                            IF (UNION % CARD < MAX_SET_CARD) THEN
                               UNION % CARD = UNION % CARD + 1
                               UNION % ELEMENT (UNION % CARD) = B % ELEMENT (J)
                            ELSE
                               ! Maximum set size exceeded . . .
                            END IF
                         END IF
                      END DO
                   END FUNCTION UNION
                   FUNCTION DIFFERENCE (A, B)           ! Difference of sets A and B
                      TYPE (SET) DIFFERENCE
                      TYPE (SET), INTENT(IN) :: A, B
                      INTEGER J, X
                      DIFFERENCE % CARD = 0             ! The empty set
                      DO J = 1, A % CARD
                         X = A % ELEMENT (J)
                         IF (.NOT. (X .IN. B)) DIFFERENCE = DIFFERENCE + SET (1, X)
                      END DO
                   END FUNCTION DIFFERENCE
                   FUNCTION INTERSECTION (A, B)       ! Intersection of sets A and B
            c
            ISO/IEC 2017 – All rights reserved                                                      575
            ISO/IEC DIS 1539-1:2017 (E)
                      TYPE (SET) INTERSECTION
                      TYPE (SET), INTENT(IN) :: A, B
                      INTERSECTION = A - (A - B)
                   END FUNCTION INTERSECTION
                   LOGICAL FUNCTION SUBSET (A, B)          ! Determines if set A is
                      TYPE (SET), INTENT(IN) :: A, B       ! a subset of set B
                      INTEGER I
                      SUBSET = A % CARD <= B % CARD
                      IF (.NOT. SUBSET) RETURN             ! For efficiency
                      DO I = 1, A % CARD
                         SUBSET = SUBSET .AND. (A % ELEMENT (I) .IN. B)
                      END DO
                   END FUNCTION SUBSET
                   TYPE (SET) FUNCTION SETF (V)     ! Transfer function between a vector
                      INTEGER V (:)                 ! of elements and a set of elements
                      INTEGER J                     ! removing duplicate elements
                      SETF % CARD = 0
                      DO J = 1, SIZE (V)
                         IF (.NOT. (V (J) .IN. SETF)) THEN
                            IF (SETF % CARD < MAX_SET_CARD) THEN
                               SETF % CARD = SETF % CARD + 1
                               SETF % ELEMENT (SETF % CARD) = V (J)
                            ELSE
                               ! Maximum set size exceeded . . .
                            END IF
                         END IF
                      END DO
                   END FUNCTION SETF
                   FUNCTION VECTOR (A)              ! Transfer the values of set A
                      TYPE (SET), INTENT (IN) :: A  ! into a vector in ascending order
                      INTEGER, POINTER :: VECTOR (:)
                      INTEGER I, J, K
                      ALLOCATE (VECTOR (A % CARD))
                      VECTOR = A % ELEMENT (1 : A % CARD)
                      DO I = 1, A % CARD - 1         ! Use a better sort if
                         DO J = I + 1, A % CARD      ! A % CARD is large
                            IF (VECTOR (I) > VECTOR (J)) THEN
                               K = VECTOR (J); VECTOR (J) = VECTOR (I); VECTOR (I) = K
                            END IF
                         END DO
                      END DO
                   END FUNCTION VECTOR
                   END MODULE INTEGER_SETS
                                                                  c
            576                                                  ISO/IEC 2017 – All rights reserved
                                                                                  ISO/IEC DIS 1539-1:2017 (E)
          4 Examples of using INTEGER_SETS (A, B, and C are variables of type SET; X is an integer variable):
                     ! Check to see if A has more than 10 elements
                     IF (CARDINALITY (A) > 10) ...
                     ! Check for X an element of A but not of B
                     IF (X .IN. (A - B)) ...
                     ! C is the union of A and the result of B intersected
                     ! with the integers 1 to 100
                     C = A + B * SETF ([(I, I = 1, 100)])
                     ! Does A have any even numbers in the range 1:100?
                     IF (CARDINALITY (A * SETF ([(I, I = 2, 100, 2)])) > 0) ...
                     PRINT *, VECTOR (B) ! Print out the elements of set B, in ascending order
             C.9.3.7  Public entities renamed (14.2.2)
          1 At times it might be necessary to rename entities that are accessed with USE statements.
          2 The following example illustrates renaming features of the USE statement.
                     MODULE J; REAL JX, JY, JZ; END MODULE J
                     MODULE K
                        USE J, ONLY : KX => JX, KY => JY
                        ! KX and KY are local names to module K
                        REAL KZ         ! KZ is local name to module K
                        REAL JZ         ! JZ is local name to module K
                     END MODULE K
                     PROGRAM RENAME
                        USE J; USE K
                        ! Module J’s entity JX is accessible under names JX and KX
                        ! Module J’s entity JY is accessible under names JY and KY
                        ! Module K’s entity KZ is accessible under name KZ
                        ! Module J’s entity JZ and K’s entity JZ are different entities
                        ! and cannot be referenced
                        ...
                     END PROGRAM RENAME
             C.9.4    Modules with submodules (14.2.3)
          1 Each submodule speciﬁes that it is the child of exactly one parent module or submodule. Therefore, a module
             and all of its descendant submodules stand in a tree-like relationship one to another.
          2 A separate module procedure that is declared in a module to have public accessibility can be accessed by use
             association even if it is deﬁned in a submodule. No other entity in a submodule can be accessed by use association.
             Each program unit that references a module by use association depends on it, and each submodule depends on
             its ancestor module. Therefore, if one changes a separate module procedure body in a submodule but does not
              c
             ISO/IEC 2017 – All rights reserved                                                                  577
       ISO/IEC DIS 1539-1:2017 (E)
       change its corresponding module procedure interface, a tool for automatic program translation would not need
       to reprocess program units that reference the module by use association. This is so even if the tool exploits the
       relative modiﬁcation times of ﬁles as opposed to comparing the result of translating the module to the result of
       a previous translation.
      3 By constructing taller trees, one can put entities at intermediate levels that are shared by submodules at lower
       levels; changing these entities cannot change the interpretation of anything that is accessible from the module
       by use association. Developers of modules that embody large complicated concepts can exploit this possibility
       to organize components of the concept into submodules, while preserving the privacy of entities that are shared
       by the submodules and that ought not to be exposed to users of the module. Putting these shared entities at an
       intermediate level also prevents cascades of reprocessing and testing if some of them are changed.
      4 Thefollowing example illustrates a module, color_points, with a submodule, color_points_a, that in turn has
       a submodule, color_points_b. Public entities declared within color_points can be accessed by use association.
       Thesubmodulescolor_points_aandcolor_points_bcanbechangedwithoutcausingretranslation of program
       units that reference the module color_points.
      5 The module color_points does not have a module-subprogram-part, but a module-subprogram-part is not pro-
       hibited. The module could be published as deﬁnitive speciﬁcation of the interface, without revealing trade secrets
       contained within color_points_a or color_points_b. Of course, a similar module without the module preﬁx in
       the interface bodies would serve equally well as documentation – but the procedures would be external procedures.
       It would make little diﬀerence to the consumer, but the developer would forfeit all of the advantages of modules.
           module color_points
            type color_point
             private
             real :: x, y
             integer :: color
            end type color_point
            interface     ! Interfaces for procedures with separate
                          ! bodies in the submodule color_points_a
             module subroutine color_point_del ( p ) ! Destroy a color_point object
               type(color_point), allocatable :: p
             end subroutine color_point_del
             ! Distance between two color_point objects
             real module function color_point_dist ( a, b )
               type(color_point), intent(in) :: a, b
             end function color_point_dist
             module subroutine color_point_draw ( p ) ! Draw a color_point object
               type(color_point), intent(in) :: p
             end subroutine color_point_draw
             module subroutine color_point_new ( p ) ! Create a color_point object
               type(color_point), allocatable :: p
             end subroutine color_point_new
            end interface
           end module color_points
                                       c
       578                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         6 The only entities within color_points_a that can be accessed by use association are the separate module
            procedures that were declared in color_points. If the procedures are changed but their interfaces are not, the
            interface from program units that access them by use association is unchanged. If the module and submodule are
            in separate ﬁles, utilities that examine the time of modiﬁcation of a ﬁle would notice that changes in the module
            could aﬀect the translation of its submodules or of program units that reference the module by use association,
            but that changes in submodules could not aﬀect the translation of the parent module or program units that
            reference it by use association.
         7 The variable instance_count in the following example is not accessible by use association of color_points, but
            is accessible within color_points_a, and its submodules.
                   submodule ( color_points ) color_points_a ! Submodule of color_points
                     integer :: instance_count = 0
                     interface                   ! Interface for a procedure with a separate
                                                 ! body in submodule color_points_b
                       module subroutine inquire_palette ( pt, pal )
                         use palette_stuff       ! palette_stuff, especially submodules thereof,
                                                 ! can reference color_points by use association
                                                 ! without causing a circular dependence during
                                                 ! translation because this use is not in the module.
                                                 ! Furthermore, changes in the module palette_stuff
                                                 ! do not affect the translation of color_points.
                         type(color_point), intent(in) :: pt
                         type(palette), intent(out) :: pal
                       end subroutine inquire_palette
                     end interface
                   contains ! Invisible bodies for public separate module procedures
                            ! declared in the module
                     module subroutine color_point_del ( p )
                       type(color_point), allocatable :: p
                       instance_count = instance_count - 1
                       deallocate ( p )
                     end subroutine color_point_del
                     real module function color_point_dist ( a, b ) result ( dist )
                       type(color_point), intent(in) :: a, b
                       dist = SQRT ( (b%x - a%x)**2 + (b%y - a%y)**2 )
                     end function color_point_dist
                     module subroutine color_point_new ( p )
                       type(color_point), allocatable :: p
                       instance_count = instance_count + 1
                       allocate ( p )
                     end subroutine color_point_new
                   end submodule color_points_a
            c
            ISO/IEC 2017 – All rights reserved                                                      579
       ISO/IEC DIS 1539-1:2017 (E)
      8 The subroutine inquire_palette is accessible within color_points_a because its interface is declared therein.
       It is not, however, accessible by use association, because its interface is not declared in the module, color_points.
       Since the interface is not declared in the module, changes in the interface cannot aﬀect the translation of program
       units that reference the module by use association.
           module palette_stuff
            type :: palette ; ... ; end type palette
           contains
            subroutine test_palette ( p )
            ! Draw a color wheel using procedures from the color_points module
             use color_points ! This does not cause a circular dependency because
                        ! the "use palette_stuff" that is logically within
                        ! color_points is in the color_points_a submodule.
             type(palette), intent(in) :: p
             ...
            end subroutine test_palette
           end module palette_stuff
           submodule ( color_points:color_points_a ) color_points_b ! Subsidiary**2 submodule
           contains
            ! Invisible body for interface declared in the ancestor module
            module subroutine color_point_draw ( p )
             use palette_stuff, only: palette
             type(color_point), intent(in) :: p
             type(palette) :: MyPalette
             ...; call inquire_palette ( p, MyPalette ); ...
            end subroutine color_point_draw
            ! Invisible body for interface declared in the parent submodule
            module procedure inquire_palette
             ... implementation of inquire_palette
            end procedure inquire_palette
            subroutine private_stuff ! not accessible from color_points_a
             ...
            end subroutine private_stuff
           end submodule color_points_b
      9 There is a use palette_stuff in color_points_a, and a use color_points in palette_stuff. The use
       palette_stuff would cause a circular reference if it appeared in color_points. In this case, it does not cause
       a circular dependence because it is in a submodule. Submodules cannot be referenced by use association, and
       therefore what would be a circular appearance of use palette_stuff is not accessed.
                                       c
       580                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                   program main
                     use color_points
                     ! "instance_count" and "inquire_palette" are not accessible here
                     ! because they are not declared in the "color_points" module.
                     ! "color_points_a" and "color_points_b" cannot be referenced by
                     ! use association.
                     interface draw                   ! just to demonstrate it’s possible
                       module procedure color_point_draw
                     end interface
                     type(color_point) :: C_1, C_2
                     real :: RC
                     ...
                     call color_point_new (c_1)       ! body in color_points_a, interface in color_points
                     ...
                     call draw (c_1)                  ! body in color_points_b, specific interface
                                                      ! in color_points, generic interface here.
                     ...
                     rc = color_point_dist (c_1, c_2) ! body in color_points_a, interface in color_points
                     ...
                     call color_point_del (c_1)       ! body in color_points_a, interface in color_points
                     ...
                   end program main
        10 A multilevel submodule system can be used to package and organize a large and interconnected concept without
            exposing entities of one subsystem to other subsystems.
        11 Consider a Plasma module from a Tokomak simulator. A plasma simulation requires attention at least to ﬂuid
            ﬂow, thermodynamics, and electromagnetism. Fluid ﬂow simulation requires simulation of subsonic, supersonic,
            and hypersonic ﬂow. This problem decomposition can be reﬂected in the submodule structure of the Plasma
            module:
                                                    Plasma module
                             Flow submodule           Thermal submodule  Electromagnetics submodule
                     Subsonic  Supersonic Hypersonic
                    submodule  submodule   submodule
        12 Entities can be shared among the Subsonic, Supersonic, and Hypersonic submodules by putting them within
            the Flow submodule. One then need not worry about accidental use of these entities by use association or by the
            Thermal or Electromagnetics submodules, or the development of a dependency of correct operation of those
            subsystems upon the representation of entities of the Flow subsystem as a consequence of maintenance. Since
            these entities are not accessible by use association, if any of them are changed, the new values cannot be accessed
            in program units that reference the Plasma module by use association; the answer to the question “where are
            these entities used” is therefore conﬁned to the set of descendant submodules of the Flow submodule.
            c
            ISO/IEC 2017 – All rights reserved                                                      581
          ISO/IEC DIS 1539-1:2017 (E)
          C.10    Clause 15 notes
          C.10.1   Portability problems with external procedures (15.4.3.5)
        1 There is a potential portability problem in a scoping unit that references an external procedure without explicitly
          declaring it to have the EXTERNAL attribute (8.5.9). On a diﬀerent processor, the name of that procedure
          might be the name of a nonstandard intrinsic procedure and in such a case the processor would interpret those
          procedure references as references to that intrinsic procedure. (On that processor, the program would also be
          viewed as not conforming to this document because of the references to the nonstandard intrinsic procedure.)
          Declaration of the EXTERNAL attribute causes the references to be to the external procedure regardless of the
          availability of an intrinsic procedure with the same name. Note that declaration of the type of a procedure is not
          enough to make it external, even if the type is inconsistent with the type of the result of an intrinsic procedure
          of the same name.
          C.10.2   Procedures deﬁned by means other than Fortran (15.6.3)
        1 Aprocessor is not required to provide any means other than Fortran for deﬁning external procedures. Among the
          means that might be supported are the machine assembly language, other high level languages, the Fortran lan-
          guage extended with nonstandard features, and the Fortran language as supported by another Fortran processor
          (for example, a previously existing Fortran 77 processor). The means other than Fortran for deﬁning external
          procedures, including any restrictions on the structure or organization of those procedures, are not speciﬁed by
          this document.
        2 A Fortran processor might limit its support of procedures deﬁned by means other than Fortran such that these
          procedures can aﬀect entities in the Fortran environment only on the same basis as procedures written in Fortran.
          For example, it might not support the value of a local variable from being changed by a procedure reference unless
          that variable were one of the arguments to the procedure.
          C.10.3   Abstract interfaces and procedure pointer components (15.4, 7.5)
        1 This is an example of a library module providing lists of callbacks that the user can register and invoke.
                 MODULE callback_list_module
                  !
                  ! Type for users to extend with their own data, if they so desire
                  !
                  TYPE callback_data
                  END TYPE
                  !
                  ! Abstract interface for the callback procedures
                  !
                  ABSTRACT INTERFACE
                    SUBROUTINE callback_procedure(data)
                      IMPORT callback_data
                      CLASS(callback_data),OPTIONAL :: data
                    END SUBROUTINE
                  END INTERFACE
                  !
                                                          c
          582                                             ISO/IEC 2017 – All rights reserved
                                       ISO/IEC DIS 1539-1:2017 (E)
           ! The callback list type.
           !
           TYPE callback_list
            PRIVATE
            CLASS(callback_record),POINTER :: first => NULL()
           END TYPE
           !
           ! Internal: each callback registration creates one of these
           !
           TYPE,PRIVATE :: callback_record
            PROCEDURE(callback_procedure),POINTER,NOPASS :: proc
            CLASS(callback_record),POINTER :: next
            CLASS(callback_data),POINTER :: data => NULL();
           END TYPE
           PRIVATE invoke,forward_invoke
          CONTAINS
           !
           ! Register a callback procedure with optional data
           !
           SUBROUTINE register_callback(list, entry, data)
            TYPE(callback_list),INTENT(INOUT) :: list
            PROCEDURE(callback_procedure) :: entry
            CLASS(callback_data),OPTIONAL :: data
            TYPE(callback_record),POINTER :: new,last
            ALLOCATE(new)
            new%proc => entry
            IF (PRESENT(data)) ALLOCATE(new%data,SOURCE=data)
            new%next => list%first
            list%first => new
           END SUBROUTINE
           !
           ! Internal: Invoke a single callback and destroy its record
           !
           SUBROUTINE invoke(callback)
            TYPE(callback_record),POINTER :: callback
            IF (ASSOCIATED(callback%data) THEN
             CALL callback%proc(list%first%data)
             DEALLOCATE(callback%data)
            ELSE
             CALL callback%proc
            END IF
            DEALLOCATE(callback)
           END SUBROUTINE
           !
           ! Call the procedures in reverse order of registration
           !
       c
      ISO/IEC 2017 – All rights reserved             583
              ISO/IEC DIS 1539-1:2017 (E)
                         SUBROUTINE invoke_callback_reverse(list)
                           TYPE(callback_list),INTENT(INOUT) :: list
                           TYPE(callback_record),POINTER :: next,current
                           current => list%first
                           NULLIFY(list%first)
                           DO WHILE (ASSOCIATED(current))
                              next => current%next
                              CALL invoke(current)
                              current => next
                           END DO
                         END SUBROUTINE
                         !
                         ! Internal: Forward mode invocation
                         !
                         SUBROUTINE forward_invoke(callback)
                           IF (ASSOCIATED(callback%next)) CALL forward_invoke(callback%next)
                           CALL invoke(callback)
                         END SUBROUTINE
                         !
                         ! Call the procedures in forward order of registration
                         !
                         SUBROUTINE invoke_callback_forward(list)
                           TYPE(callback_list),INTENT(INOUT) :: list
                           IF (ASSOCIATED(list%first)) CALL forward_invoke(list%first)
                         END SUBROUTINE
                       END
              C.10.4     Pointers and targets as arguments (15.5.2.4, 15.5.2.6, 15.5.2.7)
           1 If a dummy argument is declared to be a pointer, the corresponding actual argument could be a pointer or could
              be a nonpointer variable or procedure. Consider the two cases separately.
              Case (i):     The actual argument is a pointer. When procedure execution commences the pointer association
                            status of the dummy argument becomes the same as that of the actual argument. If the pointer
                            association status of the dummy argument is changed, the pointer association status of the actual
                            argument changes in the same way.
              Case (ii):    Theactual argument is not a pointer. This only occurs when the actual argument has the TARGET
                            attribute or is a procedure, and the dummy argument has the INTENT (IN) attribute. The dummy
                            argument becomes pointer associated with the actual argument.
           2 Whenexecution of a procedure completes, any pointer that remains deﬁned and that is associated with a dummy
              argument that has the TARGET attribute and is either a scalar or an assumed-shape array, remains associated
              with the corresponding actual argument if the actual argument has the TARGET attribute and is not an array
              section with a vector subscript.
                                                                                c
              584                                                              ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         3 For example, consider:
                   REAL, POINTER      :: PBEST
                   REAL, TARGET       :: B (10000)
                   CALL BEST (PBEST, B)            ! Upon return PBEST is associated
                      ...                          ! with the ‘‘best’’ element of B
                   CONTAINS
                     SUBROUTINE BEST (P, A)
                       REAL, POINTER, INTENT (OUT)  :: P
                       REAL, TARGET, INTENT (IN)    :: A (:)
                          ...                      ! Find the ‘‘best’’ element A(I)
                       P => A (I)
                     RETURN
                     END SUBROUTINE BEST
                   END
            When procedure BEST completes, the pointer PBEST is associated with an element of B.
         4 An actual argument without the TARGET attribute can become associated with a dummy argument with the
            TARGETattribute. This enables a pointer to become associated with the dummy argument during execution of
            the procedure that contains the dummy argument. For example:
                   INTEGER LARGE(100,100)
                   CALL SUB (LARGE)
                      ...
                   CALL SUB ()
                   CONTAINS
                     SUBROUTINE SUB(ARG)
                       INTEGER, TARGET, OPTIONAL :: ARG(100,100)
                       INTEGER, POINTER, DIMENSION(:,:) :: PARG
                       IF (PRESENT(ARG)) THEN
                         PARG => ARG
                       ELSE
                         ALLOCATE (PARG(100,100))
                         PARG = 0
                       ENDIF
                          ...  ! Code with lots of references to PARG
                       IF (.NOT. PRESENT(ARG)) DEALLOCATE(PARG)
                     END SUBROUTINE SUB
                   END
            Within subroutine SUB the pointer PARG is either associated with the dummy argument ARG or it is associated
            with an allocated target. The bulk of the code can reference PARG without further calls to the intrinsic function
            PRESENT.
         5 If a nonpointer dummy argument has the TARGET attribute and the corresponding actual argument does not,
            any pointers that become associated with the dummy argument, and therefore with the actual argument, during
            execution of the procedure, become undeﬁned when execution of the procedure completes.
            c
            ISO/IEC 2017 – All rights reserved                                                      585
          ISO/IEC DIS 1539-1:2017 (E)
          C.10.5   Polymorphic Argument Association (15.5.2.9)
        1 The following example illustrates the polymorphic argument association rules using the derived types deﬁned in
          NOTE7.55.
                 TYPE(POINT) :: T2
                 TYPE(COLOR_POINT) :: T3
                 CLASS(POINT) :: P2
                 CLASS(COLOR_POINT) :: P3
                 ! Dummy argument is polymorphic and actual argument is of fixed type
                 SUBROUTINE SUB2 ( X2 ); CLASS(POINT) :: X2; ...
                 SUBROUTINE SUB3 ( X3 ); CLASS(COLOR_POINT) :: X3; ...
                 CALL SUB2 ( T2 ) ! Valid -- The declared type of T2 is the same as the
                                !        declared type of X2.
                 CALL SUB2 ( T3 ) ! Valid -- The declared type of T3 is extended from
                                !        the declared type of X2.
                 CALL SUB3 ( T2 ) ! Invalid -- The declared type of T2 is neither the
                                !        same as nor extended from the declared type
                                !        type of X3.
                 CALL SUB3 ( T3 ) ! Valid -- The declared type of T3 is the same as the
                                !        declared type of X3.
                 ! Actual argument is polymorphic and dummy argument is of fixed type
                 SUBROUTINE TUB2 ( D2 ); TYPE(POINT) :: D2; ...
                 SUBROUTINE TUB3 ( D3 ); TYPE(COLOR_POINT) :: D3; ...
                 CALL TUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
                                !        declared type of D2.
                 CALL TUB2 ( P3 ) ! Invalid -- The declared type of P3 differs from the
                                !        declared type of D2.
                 CALL TUB2 ( P3%POINT ) ! Valid alternative to the above
                 CALL TUB3 ( P2 ) ! Invalid -- The declared type of P2 differs from the
                                !        declared type of D3.
                 SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
                 CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the same
                  CALL TUB3 ( P2 )     ! as the declared type of D3, or a type
                                       ! extended therefrom.
                 CLASS DEFAULT
                                       ! Cannot work if not.
                 END SELECT
                 CALL TUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
                                !        declared type of D3.
                 ! Both the actual and dummy arguments are of polymorphic type.
                 CALL SUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
                                !        declared type of X2.
                 CALL SUB2 ( P3 ) ! Valid -- The declared type of P3 is extended from
                                !        the declared type of X2.
                                                          c
          586                                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                   CALL SUB3 ( P2 ) ! Invalid -- The declared type of P2 is neither the
                                    !          same as nor extended from the declared
                                    !          type of X3.
                   SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
                   CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the
                     CALL SUB3 ( P2 )       ! same as the declared type of X3, or a
                                            ! type extended therefrom.
                   CLASS DEFAULT
                                            ! Cannot work if not.
                   END SELECT
                   CALL SUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
                                    !          declared type of X3.
            C.10.6   Rules ensuring unambiguous generics (15.4.3.4.5)
         1 The rules in 15.4.3.4.5 are intended to ensure
              • that it is possible to reference each speciﬁc procedure or binding in the generic collection,
              • that for any valid generic procedure reference, the determination of the speciﬁc procedure referenced is
                unambiguous, and
              • that the determination of the speciﬁc procedure or binding referenced can be made before execution of the
                program begins (during compilation).
         2 Interfaces of speciﬁc procedures or bindings are distinguished by ﬁxed properties of their arguments, speciﬁcally
            type, kind type parameters, rank, and whether the dummy argument has the POINTER or ALLOCATABLE
            attribute. A valid reference to one procedure in a generic collection will diﬀer from another because it has an
            argument that the other cannot accept, because it is missing an argument that the other requires, or because one
            of these ﬁxed properties is diﬀerent.
         3 Although the declared type of a data entity is a ﬁxed property, polymorphic variables allow for a limited degree
            of type mismatch between dummy arguments and actual arguments, so the requirement for distinguishing two
            dummy arguments is type incompatibility, not merely diﬀerent types. (This is illustrated in the BAD6 example
            later in this note.)
         4 That same limited type mismatch means that two dummy arguments that are not type incompatible can be
            distinguished on the basis of the values of the kind type parameters they have in common; if one of them has a
            kind type parameter that the other does not, that is irrelevant in distinguishing them.
         5 Rank is a ﬁxed property, but some forms of array dummy arguments allow rank mismatches when a procedure is
            referenced by its speciﬁc name. In order to allow rank to always be usable in distinguishing generics, such rank
            mismatchesaredisallowed for those arguments when the procedure is referenced as part of a generic. Additionally,
            the fact that elemental procedures can accept array arguments is not taken into account when applying these rules,
            so apparent ambiguity between elemental and nonelemental procedures is possible; in such cases, the reference is
            interpreted as being to the nonelemental procedure.
         6 For procedures referenced as operators or deﬁned-assignment, syntactically distinguished arguments are mapped
            to speciﬁc positions in the argument list, so the rule for distinguishing such procedures is that it be possible to
            distinguish the arguments at one of the argument positions.
            c
            ISO/IEC 2017 – All rights reserved                                                      587
       ISO/IEC DIS 1539-1:2017 (E)
      7 For deﬁned input/output procedures, only the dtv argument corresponds to something explicitly written in the
       program, so it is the dtv that is required to be distinguished. Because dtv arguments are required to be scalar,
       they cannot diﬀer in rank. Thus this rule eﬀectively involves only type and kind type parameters.
      8 For generic procedure names, the rules are more complicated because optional arguments can be omitted and
       because arguments can be speciﬁed either positionally or by name.
      9 In the special case of type-bound procedures with passed-object dummy arguments, the passed-object argument
       is syntactically distinguished in the reference, so rule (3) in 15.4.3.4.5 can be applied. The type of passed-object
       arguments is constrained in ways that prevent passed-object arguments in the same scoping unit from being type
       incompatible. Thus this rule eﬀectively involves only kind type parameters and rank.
     10 The primary means of distinguishing named generics is rule (4). The most common application of that rule is a
       single argument satisfying both (4a) and (4b):
           INTERFACE GOOD1
            FUNCTION F1A(X)
             REAL :: F1A,X
            END FUNCTION F1A
            FUNCTION F1B(X)
             INTEGER :: F1B,X
            END FUNCTION F1B
           END INTERFACE GOOD1
     11 Whether one writes GOOD1(1.0) or GOOD1(X=1.0), the reference is to F1A because F1B would require an integer
       argument whereas these references provide the real constant 1.0.
     12 This example and those that follow are expressed using interface bodies, with type as the distinguishing property.
       This was done to make it easier to write and describe the examples. The principles being illustrated are equally
       applicable when the procedures get their explicit interfaces in some other way or when kind type parameters or
       rank are the distinguishing property.
     13 Another common variant is the argument that satisﬁes (4a) and (4b) by being required in one speciﬁc and
       completely missing in the other:
           INTERFACE GOOD2
            FUNCTION F2A(X)
             REAL :: F2A,X
            END FUNCTION F2A
            FUNCTION F2B(X,Y)
             COMPLEX :: F2B
             REAL :: X,Y
            END FUNCTION F2B
           END INTERFACE GOOD2
     14 Whether one writes GOOD2(0.0,1.0), GOOD2(0.0,Y=1.0), or GOOD2(Y=1.0,X=0.0), the reference is to F2B,
       because F2A has no argument in the second position or with the name Y. This approach is used as an alternative
       to optional arguments when one wants a function to have diﬀerent result type, kind type parameters, or rank,
       depending on whether the argument is present. In many of the intrinsic functions, the DIM argument works this
       way.
                                       c
       588                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
        15 It is possible to construct cases where diﬀerent arguments are used to distinguish positionally and by name:
                   INTERFACE GOOD3
                     SUBROUTINE S3A(W,X,Y,Z)
                       REAL :: W,Y
                       INTEGER :: X,Z
                     END SUBROUTINE S3A
                     SUBROUTINE S3B(X,W,Z,Y)
                       REAL :: W,Z
                       INTEGER :: X,Y
                     END SUBROUTINE S3B
                   END INTERFACE GOOD3
        16 If one writes GOOD3(1.0,2,3.0,4) to reference S3A, then the third and fourth arguments are consistent with a
            reference to S3B, but the ﬁrst and second are not. If one switches to writing the ﬁrst two arguments as keyword
            arguments in order for them to be consistent with a reference to S3B, the latter two arguments will also need
            to be written as keyword arguments, GOOD3(X=2,W=1.0,Z=4,Y=3.0), and the named arguments Y and Z are
            distinguished.
        17 The ordering requirement in rule (4) is critical:
                   INTERFACE BAD4  ! this interface is invalid !
                     SUBROUTINE S4A(W,X,Y,Z)
                       REAL :: W,Y
                       INTEGER :: X,Z
                     END SUBROUTINE S4A
                     SUBROUTINE S4B(X,W,Z,Y)
                       REAL :: X,Y
                       INTEGER :: W,Z
                     END SUBROUTINE S4B
                   END INTERFACE BAD4
        18 In this example, the positionally distinguished arguments are Y and Z, and it is W and X that are distinguished by
            name. In this order it is possible to write BAD4(1.0,2,Y=3.0,Z=4), which is a valid reference for both S4A and
            S4B.
        19 Rule (1) can be used to distinguish some cases that are not covered by rule (4):
                   INTERFACE GOOD5
                     SUBROUTINE S5A(X)
                       REAL :: X
                     END SUBROUTINE S5A
                     SUBROUTINE S5B(Y,X)
                       REAL :: Y,X
                     END SUBROUTINE S5B
                   END INTERFACE GOOD5
        20 In attempting to apply rule (4), position 2 and name Y are distinguished, but they are in the wrong order, just like
            the BAD4 example. However, when we try to construct a similarly ambiguous reference, we get GOOD5(1.0,X=2.0),
            c
            ISO/IEC 2017 – All rights reserved                                                      589
            ISO/IEC DIS 1539-1:2017 (E)
            which can’t be a reference to S5A because it would be attempting to associate two diﬀerent actual arguments
            with the dummy argument X. Rule (4) catches this case by recognizing that S5B requires two real arguments, and
            S5A cannot possibly accept more than one.
        21 Theapplicationofrule(1)becomesmorecomplicatedwhenextensibletypesareinvolved. IfFRUITisanextensible
            type, PEAR and APPLE are extensions of FRUIT, and BOSC is an extension of PEAR, then
                   INTERFACE BAD6  ! this interface is invalid !
                     SUBROUTINE S6A(X,Y)
                       CLASS(PEAR) :: X,Y
                     END SUBROUTINE S6A
                     SUBROUTINE S6B(X,Y)
                       CLASS(FRUIT) :: X
                       CLASS(BOSC) :: Y
                     END SUBROUTINE S6B
                   END INTERFACE BAD6
            might, at ﬁrst glance, seem distinguishable this way, but because of the limited type mismatching allowed,
            BAD6(A_PEAR,A_BOSC) is a valid reference to both S6A and S6B.
        22 It is important to try rule (1) for each type that appears:
                   INTERFACE GOOD7
                     SUBROUTINE S7A(X,Y,Z)
                       CLASS(PEAR) :: X,Y,Z
                     END SUBROUTINE S7A
                     SUBROUTINE S7B(X,Z,W)
                       CLASS(FRUIT) :: X
                       CLASS(BOSC) :: Z
                       CLASS(APPLE),OPTIONAL :: W
                     END SUBROUTINE S7B
                   END INTERFACE GOOD7
        23 Looking at the most general type, S7A has a minimum and maximum of 3 FRUIT arguments, while S7B has a
            minimum of 2 and a maximum of three. Looking at the most speciﬁc, S7A has a minimum of 0 and a maximum
            of 3 BOSC arguments, while S7B has a minimum of 1 and a maximum of 2. However, when we look at the
            intermediate, S7A has a minimum and maximum of 3 PEAR arguments, while S7B has a minimum of 1 and a
            maximum of 2. Because S7A’s minimum exceeds S7B’s maximum, they can be distinguished.
        24 In identifying the minimum number of arguments with a particular set of properties, we exclude optional argu-
            ments and test TKR compatibility, so the corresponding actual arguments are required to have those properties.
            In identifying the maximum number of arguments with those properties, we include the optional arguments and
            test not distinguishable, so we include actual arguments which could have those properties but are not required
            to have them.
        25 These rules are suﬃcient to ensure that references to procedures that meet them are unambiguous, but there
            remain examples that fail to meet these rules but which can be shown to be unambiguous:
                   INTERFACE BAD8  ! this interface is invalid !
                     ! despite the fact that it is unambiguous !
                                                                  c
            590                                                  ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
                       SUBROUTINE S8A(X,Y,Z)
                         REAL,OPTIONAL :: X
                         INTEGER :: Y
                         REAL :: Z
                       END SUBROUTINE S8A
                       SUBROUTINE S8B(X,Z,Y)
                         INTEGER,OPTIONAL :: X
                         INTEGER :: Z
                         REAL :: Y
                       END SUBROUTINE S8B
                    END INTERFACE BAD8
         26 Thisinterfacefails rule (4) because there are no required arguments that can be distinguished from the positionally
             corresponding argument, but in order for the mismatch of the optional arguments not to be relevant, the later
             arguments need to be speciﬁed as keyword arguments, so distinguishing by name does the trick. This interface is
             nevertheless invalid so a standard-conforming Fortran processor is not required to do such reasoning. The rules
             to cover all cases are too complicated to be useful.
         27 If one dummy argument has the POINTER attribute and a corresponding argument in the other interface body
             has the ALLOCATABLEattribute the generic interface is not ambiguous. If one dummy argument has either the
             POINTER or ALLOCATABLE attribute and a corresponding argument in the other interface body has neither
             attribute, the generic interface might be ambiguous.
             C.11     Clause 16 notes
             C.11.1    Atomic memory consistency
             C.11.1.1  Relaxed memory model
          1 Parallel programs sometimes have apparently impossible behavior because data transfers and other messages can
             be delayed, reordered and even repeated, by hardware, communication software, and caching and other forms
             of optimization. Requiring processors to deliver globally consistent behavior is incompatible with performance
             on many systems. This document speciﬁes that all ordered actions will be consistent (5.3.5 and 11.6), but all
             consistency between unordered segments is deliberately left processor dependent. Depending on the hardware,
             this can be observed even when only two images and one mechanism are involved.
             C.11.1.2  Examples with atomic operations
          1 When variables are being referenced (atomically) from segments that are unordered with respect to the segment
             that is atomically deﬁning or redeﬁning the variables, the results are processor dependent. This supports use
             of so-called “relaxed memory model” architectures, which can enable more eﬃcient execution on some hardware
             implementations.
          2 The following examples assume these declarations:
                    MODULE EXAMPLE
                       USE,INTRINSIC :: ISO_FORTRAN_ENV
                       INTEGER(ATOMIC_INT_KIND) :: X [*] = 0, Y [*] = 0, TMP
             c
             ISO/IEC 2017 – All rights reserved                                                                591
       ISO/IEC DIS 1539-1:2017 (E)
      3 Example 1
       With X [j] and Y [j] still in their initial state (both zero), image j executes the following sequence of statements:
           CALL ATOMIC_DEFINE (X, 1)
           CALL ATOMIC_DEFINE (Y, 1)
       and a diﬀerent image, k, executes the following sequence of statements:
           DO
            CALL ATOMIC_REF (TMP, Y [j])
            IF (TMP==1) EXIT
           END DO
           CALL ATOMIC_REF (TMP, X [j])
           PRINT *, TMP
      4 The ﬁnal value of TMP on image k could be either 0 or 1. That is, even though image j thinks that it deﬁned X
       [j] before it deﬁned Y [j], this ordering is not guaranteed to be observed on image k. There are many aspects of
       hardware and software implementation that can cause this eﬀect, but conceptually this example can be thought
       of as the change in the value of Y propagating faster through the inter-image connections than the change in the
       value of X.
      5 Even if image j executed the sequence
           CALL ATOMIC_DEFINE (X, 1)
           SYNC MEMORY
           CALL ATOMIC_DEFINE (Y, 1)
       the same eﬀect could be seen. That is because even though X and Y are deﬁned in ordered segments, the
       references from image k are both from a segment that is unordered with respect to image j.
      6 Only if the reference on image k to Y [j] is in a segment that is ordered after the segment on image j that deﬁned
       Y, will TMP be guaranteed to have the value 1.
      7 Example 2:
       With the initial state of X and Y on image j (i.e. X [j] and Y [j]) still being zero, execution of
           CALL ATOMIC_REF (TMP, X [j])
           CALL ATOMIC_DEFINE (Y [j], 1)
           PRINT *, TMP
       on image k1, and execution of
           CALL ATOMIC_REF (TMP, Y [j])
           CALL ATOMIC_DEFINE (X [j], 1)
           PRINT *, TMP
       on image k2, in unordered segments, might print the value 1 both times.
      8 This can happen by such mechanisms as “load buﬀering”; one might imagine that what is happening is that
       the deﬁnitions (ATOMIC_DEFINE) are overtaking the references (ATOMIC_REF). On some processors it is
                                       c
       592                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
            possible that insertion of SYNC MEMORY statements between the calls to ATOMIC_REF and ATOMIC_-
            DEFINE might be suﬃcient to make the output print the value 1 at most one time (or even exactly one time),
            butthis is still processor dependent unless the SYNC MEMORY statement executions cause the relevant segments
            on images k1 and k2 to be ordered.
         9 Example 3:
            Because there are no segment boundaries implied by collective subroutines, with the initial state as before,
            execution of
                   IF (THIS_IMAGE ()==1) THEN
                     CALL ATOMIC_DEFINE (X [3], 23)
                     Y = 42
                   END IF
                   CALL CO_BROADCAST (Y, 1)
                   IF (THIS_IMAGE ()==2) THEN
                     CALL ATOMIC_REF (TMP, X [3])
                     PRINT *, Y, TMP
                   END IF
            could print the values 42 and 0.
        10 Example 4:
            Assuming the declarations
                   INTEGER (ATOMIC_INT_KIND) :: X [*] = 0, Z = 0
            the statements
                   CALL ATOMIC_ADD (X [1], 1)         ! (A)
                   IF (THIS_IMAGE() == 2) THEN
                     wait: DO
                        CALL ATOMIC_REF (Z, X [1])    ! (B)
                        IF (Z == NUM_IMAGES ()) EXIT wait
                     END DO wait                      ! (C)
                   END IF
            will execute the “wait” loop on image 2 until all images have completed statement (A). The updates of X [1] are
            performed by each image in the same manner, but in an arbitrary order. Because the result from the complete
            set of updates will eventually become visible by execution of statement (B) for some loop iteration on image 2,
            the termination condition is guaranteed to be eventually fulﬁlled, provided that no image failure occurs, every
            image executes the above code, and no other code is executed in an unordered segment that performs an update
            to X [1]. Furthermore, if two SYNC MEMORY statements are inserted in the above code before statement (A)
            and after statement (C), respectively, the segment started by the second SYNC MEMORY on image 2 is ordered
            after the segments on all images that end with the ﬁrst SYNC MEMORY.
            C.11.2   EVENT_QUERY example
         1 The following example illustrates the use of events via a program in which image 1 acts as the master image,
            distributing work items to the other images. Only one work item at a time can be active on a worker image, and
            each deals with the result (e.g. via input/output) without directly feeding data back to the master image.
            c
            ISO/IEC 2017 – All rights reserved                                                      593
            ISO/IEC DIS 1539-1:2017 (E)
         2 Because the work items are not expected to be balanced, the master keeps cycling through all images to ﬁnd one
            that is waiting for work.
         3 An event is posted by each worker to indicate that it has completed its work item. Since the corresponding
            variables are needed only on the master, we place them in an allocatable array component of a coarray. An event
            on each worker is needed for the master to post the fact that it has made a work item available for it.
            Example code:
                   PROGRAM work_share
                     USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: EVENT_TYPE
                     USE :: mod_work, ONLY:             & ! Module that creates work items
                                      work,             & ! Type for holding a work item
                                      create_work_item, & ! Function that creates work item
                                      process_item,     & ! Function that processes an item
                                      work_done           ! Logical function that returns true
                                                          ! if all work has been done.
                     TYPE :: worker_type
                       TYPE (EVENT_TYPE), ALLOCATABLE :: free (:)
                     END TYPE
                     TYPE (EVENT_TYPE)  :: submit [*]    ! Post when work ready for a worker
                     TYPE (worker_type) :: worker [*]    ! Post when worker is free
                     TYPE (work)        :: work_item [*] ! Holds the data for a work item
                     INTEGER :: count, i, nbusy [*]
                     IF (THIS_IMAGE ()==1) THEN
                       ! Get started
                       ALLOCATE (worker%free (2:NUM_IMAGES ()))
                       nbusy = 0 ! This holds the number of workers working
                       DO i = 2, NUM_IMAGES () ! Start the workers working
                         IF (work_done ()) EXIT
                         nbusy = nbusy + 1
                         work_item [i] = create_work_item ()
                         EVENT POST (submit [i])
                       END DO
                       ! Main work distribution loop
               master: DO
                  image: DO i = 2, NUM_IMAGES ()
                           CALL EVENT_QUERY (worker%free (i), count)
                           IF (count==0) CYCLE image ! Worker is not free
                           EVENT WAIT (worker%free (i))
                           nbusy = nbusy - 1
                           IF (work_done ()) CYCLE
                           nbusy = nbusy + 1
                           work_item [i] = create_work_item ()
                           EVENT POST (submit [i])
                         END DO image
                                                                  c
            594                                                  ISO/IEC 2017 – All rights reserved
                                                                 ISO/IEC DIS 1539-1:2017 (E)
                      IF (nbusy==0) THEN
                        ! All done. Exit on all images.
                        DO i = 2, NUM_IMAGES ()
                         EVENT POST (submit [i])
                        END DO
                        EXIT master
                      END IF
                    END DO master
                  ELSE
                    ! Work processing loop
             worker: DO
                      EVENT WAIT (submit)
                      IF (nbusy[1] == 0) EXIT
                      CALL process_item (work_item)
                      EVENT POST (worker [1]%free (THIS_IMAGE ()))
                    END DO worker
                  END IF
                 END PROGRAM work_share
          C.11.3   Collective subroutine examples
        1 The following example computes a dot product of two scalar coarrays using CO_SUM to store the result in a
          noncoarray scalar variable.
                 SUBROUTINE codot (x, y, x_dot_y)
                   REAL :: x [*], y [*], x_dot_y
                   x_dot_y = x*y
                   CALL CO_SUM (x_dot_y)
                 END SUBROUTINE codot
        2 Thefunction below demonstrates passing a noncoarray dummy argument to CO_MAX. The function uses CO_-
          MAXtoﬁndthe maximum value of the dummy argument across all images. Then the function ﬂags all images
          that hold values matching the maximum. The function then returns the maximum image index for an image that
          holds the maximum value.
                 FUNCTION find_max (j) RESULT (j_max_location)
                  INTEGER, INTENT (IN) :: j
                  INTEGER j_max, j_max_location
                  j_max = j
                  CALL CO_MAX (j_max)
                  ! Flag images that hold the maximum j.
                  IF (j==j_max) THEN
                     j_max_location = THIS_IMAGE ()
                  ELSE
                     j_max_location = 0
                  END IF
                  ! Return highest image index associated with a maximal j.
                  CALL CO_MAX(j_max_location)
                 END FUNCTION find_max
           c
          ISO/IEC 2017 – All rights reserved                                             595
          ISO/IEC DIS 1539-1:2017 (E)
          C.12    Clause 18 notes
          C.12.1   Runtime environments (18.1)
        1 This document allows programs to contain procedures deﬁned by means other than Fortran. That raises the
          issues of initialization of and interaction between the runtime environments involved.
        2 Implementations are free to solve these issues as they see ﬁt, provided that
             • heap allocation/deallocation (e.g., (DE)ALLOCATE in a Fortran subprogram and malloc/free in a C func-
               tion) can be performed without interference,
             • input/output to and from external ﬁles can be performed without interference, as long as procedures deﬁned
               by diﬀerent means do not do input/output with the same external ﬁle,
             • input/output preconnections exist as required by the respective standards, and
             • initialized data are initialized according to the respective standards.
          C.12.2   Example of Fortran calling C (18.3)
          CFunction Prototype:
                 int C_Library_Function(void* sendbuf, int sendcount, int *recvcounts);
          Fortran Module:
                 MODULE CLIBFUN_INTERFACE
                   INTERFACE
                      INTEGER (C_INT) FUNCTION C_LIBRARY_FUNCTION (SENDBUF, SENDCOUNT, RECVCOUNTS) &
                                    BIND(C, NAME=’C_Library_Function’)
                         USE, INTRINSIC :: ISO_C_BINDING
                         IMPLICIT NONE
                         TYPE (C_PTR), VALUE :: SENDBUF
                         INTEGER (C_INT), VALUE :: SENDCOUNT
                         INTEGER (C_INT) :: RECVCOUNTS(*)
                      END FUNCTION C_LIBRARY_FUNCTION
                   END INTERFACE
                 END MODULE CLIBFUN_INTERFACE
        1 The module CLIBFUN_INTERFACE contains the declaration of the Fortran dummy arguments, which corres-
          pondtotheCformalparameters. TheNAME=isusedintheBINDattributeinordertohandlethecase-sensitive
          name change between Fortran and C from “c_library_function” to “C_Library_Function”.
        2 The ﬁrst C formal parameter is the pointer to void sendbuf, which corresponds to the Fortran dummy argument
          SENDBUF, which has the type C_PTR and the VALUE attribute.
        3 The second C formal parameter is the int sendcount, which corresponds to the Fortran dummy argument
          SENDCOUNT,which has the type INTEGER (C_INT) and the VALUE attribute.
        4 The third C formal parameter is the pointer to int recvcounts, which corresponds to the Fortran dummy
          argument RECVCOUNTS, which is an assumed-size array of type INTEGER (C_INT).
                                                          c
          596                                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         5 This example shows how C_Library_Function might be referenced in a Fortran program unit:
                   USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT, C_FLOAT, C_LOC
                   USE CLIBFUN_INTERFACE
                   ...
                   REAL (C_FLOAT), TARGET  :: SEND(100)
                   INTEGER (C_INT)         :: SENDCOUNT, RET
                   INTEGER (C_INT), ALLOCATABLE :: RECVCOUNTS(:)
                   ...
                   ALLOCATE( RECVCOUNTS(100) )
                   ...
                   RET = C_LIBRARY_FUNCTION(C_LOC(SEND), SENDCOUNT, RECVCOUNTS)
                   ...
         6 Theﬁrst Fortran actual argument is a reference to the function C_LOC which returns the value of the C address
            of its argument, SEND. This value becomes the value of the ﬁrst formal parameter, the pointer sendbuf, in
            C_Library_Function.
         7 Thesecond Fortran actual argument is SENDCOUNT of type INTEGER (C_INT). Its value becomes the initial
            value of the second formal parameter, the int sendcount, in C_Library_Function.
         8 The third Fortran actual argument is the allocatable array RECVCOUNTS of type INTEGER (C_INT). The
            base C address of this array becomes the value of the third formal parameter, the pointer recvcounts, in
            C_Library_Function. Note that interoperability is based on the characteristics of the dummy arguments in
            the speciﬁed interface and not on those of the actual arguments. Thus, the fact that the actual argument is
            allocatable is not relevant here.
            C.12.3   Example of C calling Fortran (18.3)
            Fortran Code:
                   SUBROUTINE SIMULATION(ALPHA, BETA, GAMMA, DELTA, ARRAYS) BIND(C)
                      USE, INTRINSIC :: ISO_C_BINDING
                      IMPLICIT NONE
                      INTEGER (C_LONG), VALUE                 :: ALPHA
                      REAL (C_DOUBLE), INTENT(INOUT)          :: BETA
                      INTEGER (C_LONG), INTENT(OUT)           :: GAMMA
                      REAL (C_DOUBLE),DIMENSION(*),INTENT(IN) :: DELTA
                      TYPE, BIND(C) :: PASS
                        INTEGER (C_INT) :: LENC, LENF
                        TYPE (C_PTR)    :: C, F
                      END TYPE PASS
                      TYPE (PASS), INTENT(INOUT) :: ARRAYS
                      REAL (C_FLOAT), ALLOCATABLE, TARGET, SAVE :: ETA(:)
                      REAL (C_FLOAT), POINTER :: C_ARRAY(:)
                      ...
                      ! Associate C_ARRAY with an array allocated in C
                      CALL C_F_POINTER (ARRAYS%C, C_ARRAY, [ ARRAYS%LENC ])
            c
            ISO/IEC 2017 – All rights reserved                                                      597
       ISO/IEC DIS 1539-1:2017 (E)
             ...
             ! Allocate an array and make it available in C
             ARRAYS%LENF = 100
             ALLOCATE (ETA(ARRAYS%LENF))
             ARRAYS%F = C_LOC(ETA)
             ...
           END SUBROUTINE SIMULATION
       CStruct Declaration:
           struct pass {
            int lenc, lenf;
            float *c, *f;
           };
       CFunction Prototype:
           void simulation(long alpha, double *beta, long *gamma, double delta[],
                     struct pass *arrays);
       CCalling Sequence:
           simulation(alpha, beta, gamma, delta, arrays);
      1 The above-listed Fortran code speciﬁes a subroutine SIMULATION. This subroutine corresponds to the C void
       function simulation.
      2 The Fortran subroutine references the intrinsic module ISO_C_BINDING.
      3 The ﬁrst Fortran dummy argument of the subroutine is ALPHA, which has the type INTEGER(C_LONG) and
       the VALUE attribute. This dummy argument corresponds to the C formal parameter alpha, which is a long.
       The C actual argument is also a long.
      4 The second Fortran dummy argument of the subroutine is BETA, which has the type REAL(C_DOUBLE) and
       the INTENT (INOUT) attribute. This dummy argument corresponds to the C formal parameter beta, which is
       a pointer to double. An address is passed as the C actual argument.
      5 The third Fortran dummy argument of the subroutine is GAMMA, which has the type INTEGER(C_LONG)
       and the INTENT (OUT) attribute. This dummy argument corresponds to the C formal parameter gamma, which
       is a pointer to long. An address is passed as the C actual argument.
      6 ThefourthFortrandummyargumentistheassumed-sizearrayDELTA,whichhasthetypeREAL(C_DOUBLE)
       and the INTENT (IN) attribute. This dummy argument corresponds to the C formal parameter delta, which is
       a double array. The C actual argument is also a double array.
      7 The ﬁfth Fortran dummy argument is ARRAYS, which is a structure for accessing an array allocated in C and
       an array allocated in Fortran. The lengths of these arrays are held in the components LENC and LENF; their C
       addresses are held in components C and F.
                                       c
       598                             ISO/IEC 2017 – All rights reserved
                                                                 ISO/IEC DIS 1539-1:2017 (E)
          C.12.4   Example of calling C functions with noninteroperable data (18.10)
        1 Many Fortran processors support 16-byte real numbers, which might not be supported by the C processor.
          Assume a Fortran programmer wants to use a C procedure from a message passing library for an array of these
          reals. The C prototype of this procedure is
                 void ProcessBuffer(void *buffer, int n_bytes);
          with the corresponding Fortran interface
                 USE, INTRINSIC :: ISO_C_BINDING
                 INTERFACE
                   SUBROUTINE PROCESS_BUFFER(BUFFER,N_BYTES) BIND(C,NAME="ProcessBuffer")
                      IMPORT :: C_PTR, C_INT
                      TYPE(C_PTR), VALUE :: BUFFER ! The ‘‘C address’’ of the array buffer
                      INTEGER (C_INT), VALUE :: N_BYTES ! Number of bytes in buffer
                   END SUBROUTINE PROCESS_BUFFER
                 END INTERFACE
        2 This can be done using C_LOC if the particular Fortran processor speciﬁes that C_LOC returns an appropriate
          address:
                 REAL(R_QUAD), DIMENSION(:), ALLOCATABLE, TARGET :: QUAD_ARRAY
                 ...
                 CALL PROCESS_BUFFER(C_LOC(QUAD_ARRAY), INT(16*SIZE(QUAD_ARRAY),C_INT))
                 ! One quad real takes 16 bytes on this processor
          C.12.5   Example of opaque communication between C and Fortran (18.3)
        1 Thefollowing example demonstrates how a Fortran processor can make a modern object-oriented random number
          generator written in Fortran available to a C program.
                 USE, INTRINSIC :: ISO_C_BINDING
                   ! Assume this code is inside a module
                 TYPE RANDOM_STREAM
                   ! A (uniform) random number generator (URNG)
                 CONTAINS
                   PROCEDURE(RANDOM_UNIFORM), DEFERRED, PASS(STREAM) :: NEXT
                   ! Generates the next number from the stream
                 END TYPE RANDOM_STREAM
                 ABSTRACT INTERFACE
                   ! Abstract interface of Fortran URNG
                   SUBROUTINE RANDOM_UNIFORM(STREAM, NUMBER)
                      IMPORT :: RANDOM_STREAM, C_DOUBLE
                      CLASS(RANDOM_STREAM), INTENT(INOUT) :: STREAM
                      REAL(C_DOUBLE), INTENT(OUT) :: NUMBER
                   END SUBROUTINE RANDOM_UNIFORM
                 END INTERFACE
           c
          ISO/IEC 2017 – All rights reserved                                             599
       ISO/IEC DIS 1539-1:2017 (E)
      2 A polymorphic object with declared type RANDOM_STREAM is not interoperable with C. However, we can
       make such a random number generator available to C by packaging it inside another nonpolymorphic, nonpara-
       meterized derived type:
           TYPE :: URNG_STATE ! No BIND(C), as this type is not interoperable
             CLASS(RANDOM_STREAM), ALLOCATABLE :: STREAM
           END TYPE URNG_STATE
      3 The following two procedures will enable a C program to use our Fortran uniform random number generator:
           ! Initialize a uniform random number generator:
           SUBROUTINE INITIALIZE_URNG(STATE_HANDLE, METHOD) &
                   BIND(C, NAME="InitializeURNG")
             TYPE(C_PTR), INTENT(OUT) :: STATE_HANDLE
               ! An opaque handle for the URNG
             CHARACTER(C_CHAR), DIMENSION(*), INTENT(IN) :: METHOD
               ! The algorithm to be used
             TYPE(URNG_STATE), POINTER :: STATE
               ! An actual URNG object
             ALLOCATE(STATE)
               ! There needs to be a corresponding finalization
               ! procedure to avoid memory leaks, not shown in this example
             ! Allocate STATE%STREAM with a dynamic type depending on METHOD
             ...
             STATE_HANDLE=C_LOC(STATE)
               ! Obtain an opaque handle to return to C
           END SUBROUTINE INITIALIZE_URNG
           ! Generate a random number:
           SUBROUTINE GENERATE_UNIFORM(STATE_HANDLE, NUMBER) &
                  BIND(C, NAME="GenerateUniform")
             TYPE(C_PTR), INTENT(IN), VALUE :: STATE_HANDLE
               ! An opaque handle: Obtained via a call to INITIALIZE_URNG
             REAL(C_DOUBLE), INTENT(OUT) :: NUMBER
             TYPE(URNG_STATE), POINTER :: STATE
               ! A pointer to the actual URNG
             CALL C_F_POINTER(CPTR=STATE_HANDLE, FPTR=STATE)
               ! Convert the opaque handle into a usable pointer
             CALL STATE%STREAM%NEXT(NUMBER)
               ! Use the type-bound procedure NEXT to generate NUMBER
           END SUBROUTINE GENERATE_UNIFORM
                                       c
       600                             ISO/IEC 2017 – All rights reserved
                                                                                 ISO/IEC DIS 1539-1:2017 (E)
             C.12.6    Using assumed type to interoperate with C
             C.12.6.1  Overview
          1 The mechanism for handling unlimited polymorphic entities whose dynamic type is interoperable with C is
             designed to handle the following two situations:
                  (1)   A formal parameter that is a C pointer to void. This is an address, and no further information
                        about the entity is provided. The formal parameter corresponds to a dummy argument that is a
                        nonallocatable nonpointer scalar or is an assumed-size array.
                  (2)   Aformal parameter that is the address of a C descriptor. Additional information on the status, type,
                        size, and shape is implicitly provided. The formal parameter corresponds to a dummy argument that
                        is assumed-shape or assumed-rank.
          2 In the ﬁrst situation, it is the programmer’s responsibility to explicitly provide any information needed on the
             status, type, size, and shape of the entity.
             C.12.6.2  Mapping of interfaces with void * C parameters to Fortran
          1 ACinterface for message passing or input/output functionality could be provided in the form
                    int EXAMPLE_send(const void *buffer, size_t buffer_size, const HANDLE_t *handle);
             where the buffer_size argument is given in units of bytes, and the handle argument (which is of a type aliased
             to int) provides information about the target the buﬀer is to be transferred to. In this example, type resolution
             is not required.
          2 The ﬁrst method provides a thin binding; a call to EXAMPLE_send from Fortran directly invokes the C function.
                    INTERFACE
                        INTEGER (C_INT) FUNCTION example_send(buffer, buffer_size, handle) &
                        BIND(C, NAME=’EXAMPLE_send’)
                           USE, INTRINSIC :: ISO_C_BINDING
                           TYPE(*), INTENT (IN) :: buffer(*)
                           INTEGER (C_SIZE_T), VALUE :: buffer_size
                           INTEGER (C_INT), INTENT (IN) :: handle
                        END FUNCTION
                    END INTERFACE
          3 It is assumed that this interface is declared in the speciﬁcation part of the module MOD_EXAMPLE_OLD. An
             example of its use follows:
                    USE, INTRINSIC :: ISO_C_BINDING
                    USE MOD_EXAMPLE_OLD
                    REAL(C_FLOAT) :: x(100)
                    INTEGER(C_INT) :: y(10,10)
                    REAL(C_DOUBLE) :: z
                    INTEGER(C_INT) :: status, handle
                    ...
             c
             ISO/IEC 2017 – All rights reserved                                                                601
            ISO/IEC DIS 1539-1:2017 (E)
                   ! Assign values to x, y, z and initialize handle.
                   ...
                   ! Send values in x, y, and z using EXAMPLE_send.
                   status = example_send(x, C_SIZEOF(x), handle)
                   status = example_send(y, C_SIZEOF(y), handle)
                   status = example_send([ z ], C_SIZEOF(z), handle)
         4 In those invocations, x and y are passed directly with sequence association, but it is necessary to make an array
            expression containing the value of z to pass it.
         5 Thesecond method provides a Fortran interface which is easier to use, but requires writing a separate C wrapper
            routine. With this method, a C descriptor is created because the buﬀer is assumed-rank in the Fortran interface;
            the use of an optional argument is also demonstrated.
                   INTERFACE
                      SUBROUTINE example_send(buffer, handle, status) BIND(C, NAME="EG_send_fortran")
                         USE, INTRINSIC :: ISO_C_BINDING
                         TYPE(*), CONTIGUOUS, INTENT (IN) :: buffer(..)
                         INTEGER (C_INT), INTENT (IN) :: handle
                         INTEGER (C_INT), INTENT(OUT), OPTIONAL :: status
                      END SUBROUTINE
                   END INTERFACE
         6 It is assumed that this interface is declared in the speciﬁcation part of a module MOD_EXAMPLE_NEW.
            Example invocations from Fortran are then
                   USE, INTRINSIC :: iso_c_binding
                   USE mod_example_new
                   TYPE, BIND(C) :: my_derived
                      INTEGER(C_INT) :: len_used
                      REAL(C_FLOAT) ::  stuff(100)
                   END TYPE
                   TYPE(my_derived) :: w(3)
                   REAL(C_FLOAT) :: x(100)
                   INTEGER(C_INT) :: y(10,10)
                   REAL(C_DOUBLE) :: z
                   INTEGER(C_INT) :: status, handle
                   ...
                   ! Assign values to w, x, y, z and initialize handle.
                   ...
                   ! Send values in w, x, y, and z using example_send.
                   CALL example_send(w, handle, status)
                   CALL example_send(x, handle)
                   CALL example_send(y, handle)
                   CALL example_send(z, handle)
                   CALL example_send(y(:,5), handle) ! Fifth column of y.
                   CALL example_send(y(1,5), handle) ! Scalar y(1,5) passed by descriptor.
                                                                  c
            602                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         7 The wrapper routine can be written in C as follows.
                   #include "ISO_Fortran_binding.h"
                   void EXAMPLE_send_fortran(const CFI_cdesc_t *buffer, const HANDLE_t *handle,
                                            int *status)
                   {
                     int status_local;
                     size_t buffer_size;
                     int i;
                     buffer_size = buffer->elem_len;
                     for (i=0; i<buffer->rank; i++) {
                       buffer_size *= buffer->dim[i].extent;
                     }
                     status_local = EXAMPLE_send(buffer->base_addr,buffer_size, handle);
                     if (status != NULL) *status = status_local;
                   }
            C.12.7   Using assumed-type variables in Fortran
         1 Anassumed-typedummyargumentinaFortranprocedurecanbeusedasanactualargumentcorrespondingtoan
            assumed-type dummyinacalltoanotherprocedure. Inthefollowingexample, the Fortran subroutine SIMPLE_-
            SENDserves as a wrapper to hide the complications associated with calls to a C function named ACTUAL_Send.
            Module COMM_INFO contains node and address information for the current data transfer operations.
                   SUBROUTINE SIMPLE_SEND(buffer, nbytes)
                     USE comm_info, ONLY: my_node, r_node, r_addr
                     USE, INTRINSIC :: ISO_C_BINDING
                     IMPLICIT NONE
                     TYPE(*), INTENT (IN) :: buffer(*)
                     INTEGER              :: nbytes, ierr
                     INTERFACE
                        SUBROUTINE actual_Send(buffer, nbytes, node, addr, ierr) &
                        BIND(C, NAME="ACTUAL_Send")
                           IMPORT :: C_SIZE_T, C_INT, C_INTPTR_T
                           TYPE(*), INTENT (IN)        :: buffer(*)
                           INTEGER(C_SIZE_T), VALUE    :: nbytes
                           INTEGER(C_INT), VALUE       :: node
                           INTEGER(C_INTPTR_T), VALUE  :: addr
                           INTEGER(C_INT), INTENT(OUT) :: ierr
                        END SUBROUTINE actual_Send
                     END INTERFACE
                     CALL actual_Send(buffer, INT(nbytes, C_SIZE_T), r_node, r_addr, ierr)
            c
            ISO/IEC 2017 – All rights reserved                                                      603
            ISO/IEC DIS 1539-1:2017 (E)
                     IF (ierr /= 0) THEN
                        PRINT *, "Error sending from node", my_node, "to node", r_node
                        PRINT *, "Program Aborting"  ! Or call a recovery procedure
                        ERROR STOP                   ! Omit in the recovery case
                     END IF
                   END SUBROUTINE simple_Send
            C.12.8   Simplifying interfaces for arbitrary rank procedures
         1 There are situations where an assumed-rank dummy argument can be useful in Fortran, although a Fortran
            procedure cannot itself access its value. For example, the IEEE inquiry functions in Clause 14 could be written
            using an assumed-rank dummy argument instead of writing 16 separate speciﬁc routines, one for each possible
            rank.
         2 In particular, the speciﬁc procedures for the IEEE_SUPPORT_DIVIDE function could possibly be implemented
            in Fortran as follows:
                   INTERFACE ieee_support_divide
                      MODULE PROCEDURE ieee_support_divide_noarg, ieee_support_divide_onearg_r, &
                                       ieee_support_divide_onearg_d
                   END INTERFACE ieee_support_divide
                   ...
                   LOGICAL FUNCTION ieee_support_divide_noarg ()
                      ieee_support_divide_noarg = .TRUE.
                   END FUNCTION ieee_support_divide_noarg
                   LOGICAL FUNCTION ieee_support_divide_onearg_r (x)
                      REAL, INTENT (IN) :: x(..)
                      ieee_support_divide_onearg_r4 = .TRUE.
                   END FUNCTION ieee_support_divide_onearg_r
                   LOGICAL FUNCTION ieee_support_divide_onearg_d (x)
                      DOUBLE PRECISION, INTENT (IN) :: x(..)
                      ieee_support_divide_onearg_r8 = .TRUE.
                   END FUNCTION ieee_support_divide_onearg_d
            C.12.9   Processing assumed-shape arrays in C
         1 The example shown below calculates the product of individual elements of arrays A and B and returns the result
            in array C. The Fortran interface of elemental_mult will accept arguments of any type and rank. However, the
            Cfunction will return an error code if any argument is not a two-dimensional int array. Note that the arguments
            are permitted to be array sections, so the C function does not assume that any argument is contiguous.
                                                                  c
            604                                                  ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         2 The Fortran interface is:
                   INTERFACE
                      FUNCTION elemental_mult(a, b, c) BIND(C, NAME="elemental_mult_c") RESULT(err)
                         USE, INTRINSIC :: ISO_C_BINDING
                         INTEGER(C_INT) :: err
                         TYPE(*), DIMENSION(..) :: a, b, c
                      END FUNCTION elemental_mult
                   END INTERFACE
         3 The deﬁnition of the C function is:
                   #include "ISO_Fortran_binding.h"
                   int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc, CFI_cdesc_t * c_desc)
                   {
                     size_t i, j, ni, nj;
                     int err = 1;  /* this error code represents all errors */
                     char * a_col = (char*) a_desc->base_addr;
                     char * b_col = (char*) b_desc->base_addr;
                     char * c_col = (char*) c_desc->base_addr;
                     char *a_elt, *b_elt, *c_elt;
                     /* Only support int. */
                     if (a_desc->type != CFI_type_int || b_desc->type != CFI_type_int ||
                         c_desc->type != CFI_type_int) {
                        return err;
                     }
                     /* Only support two dimensions. */
                     if (a_desc->rank != 2 || b_desc->rank != 2 || c_desc->rank != 2) {
                        return err;
                     }
                     ni = a_desc->dim[0].extent;
                     nj = a_desc->dim[1].extent;
                     /* Ensure the shapes conform. */
                     if (ni != b_desc->dim[0].extent || ni != c_desc->dim[0].extent) return err;
                     if (nj != b_desc->dim[1].extent || nj != c_desc->dim[1].extent) return err;
                     /* Multiply the elements of the two arrays. */
                     for (j = 0; j < nj; j++) {
                       a_elt = a_col;
                       b_elt = b_col;
                       c_elt = c_col;
            c
            ISO/IEC 2017 – All rights reserved                                                      605
          ISO/IEC DIS 1539-1:2017 (E)
                    for (i = 0; i < ni; i++) {
                      *(int*)a_elt = *(int*)b_elt * *(int*)c_elt;
                      a_elt += a_desc->dim[0].sm;
                      b_elt += b_desc->dim[0].sm;
                      c_elt += c_desc->dim[0].sm;
                    }
                    a_col += a_desc->dim[1].sm;
                    b_col += b_desc->dim[1].sm;
                    c_col += c_desc->dim[1].sm;
                  }
                  return 0;
                }
          C.12.10  Creating a contiguous copy of an array
        1 A C function might need to create a contiguous copy of an array section, for example, to pass the array section
          as an actual argument corresponding to a dummy argument with the CONTIGUOUS attribute. The following
          example provides functions that can be used to copy an array described by a CFI_cdesc_t descriptor to a
          contiguous buﬀer. The input array need not be contiguous.
        2 The C functions are:
                #include "ISO_Fortran_binding.h"
                /* Other necessary includes omitted. */
                /*
                 * Returns the number of elements in the object described by desc.
                 * If it is an array, it need not be contiguous.
                 * (The number of elements could be zero).
                 */
                size_t numElements(const CFI_cdesc_t * desc)
                {
                   CFI_rank_t r;
                   size_t num = 1;
                   for (r = 0; r < desc->rank; r++) {
                      num *= desc->dim[r].extent;
                   }
                   return num;
                }
                /*
                 * Auxiliary recursive function to copy an array of a given rank.
                 * Recursion is useful because an array of rank n is composed of an
                 * ordered set of arrays of rank n-1.
                 */
                static void *_copyToContiguous (const CFI_cdesc_t *vald, void *output,
                                             const void *input, CFI_rank_t rank)
                                                          c
          606                                            ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
                   {
                      CFI_index_t e;
                      if (rank == 0) {
                         /* Copy scalar element. */
                         memcpy (output, input, vald->elem_len);
                         output = (void *)((char *)output + vald->elem_len);
                      }
                      else {
                         for (e = 0; e < vald->dim[rank-1].extent; e++) {
                            /* Recurse on subarrays of lesser rank. */
                            output = _copyToContiguous (vald, output, input, rank-1);
                            input = (void *) ((char *)input + vald->dim[rank].sm);
                         }
                      }
                      return output;
                   }
                   /*
                    * General routine to copy the elements in the array described by vald
                    * to buffer, as done by sequence association.  The array itself can
                    * be non-contiguous.  This is not the most efficient approach.
                    */
                   void copyToContiguous (void * buffer, const CFI_cdesc_t * vald) {
                      _copyToContiguous (vald, buffer, vald->base_addr, vald->rank);
                   }
            C.12.11   Changing the attributes of an array
         1 A C programmer might want to call more than one Fortran procedure and the attributes of an array involved
            might diﬀer between the procedures. In this case, it is necessary to set up more than one C descriptor for the
            array. For example, this code fragment initializes the ﬁrst C descriptor for an allocatable entity of rank 2, calls
            a procedure that allocates the array described by the ﬁrst C descriptor, constructs the second C descriptor by
            invoking CFI_section with the value CFI_attribute_other for the attribute parameter, then calls a procedure
            that expects an assumed-shape array.
                   CFI_CDESC_T(2) loc_alloc, loc_assum;
                   CFI_cdesc_t * desc_alloc = (CFI_cdesc_t *)&loc_alloc,
                               * desc_assum = (CFI_cdesc_t *)&loc_assum;
                   CFI_index_t extents[2];
                   CFI_rank_t rank = 2;
                   int flag;
                   flag = CFI_establish(desc_alloc,
                                        NULL,
                                        CFI_attribute_allocatable,
                                        CFI_type_double,
            c
            ISO/IEC 2017 – All rights reserved                                                      607
          ISO/IEC DIS 1539-1:2017 (E)
                                   sizeof(double),
                                   rank,
                                   NULL);
                Fortran_factor (desc_alloc, ...); /* Allocates array described by desc_alloc. */
                /* Extract extents from descriptor. */
                extents[0] = desc_alloc->dim[0].extent;
                extents[1] = desc_alloc->dim[1].extent;
                flag = CFI_establish(desc_assum,
                                   desc_alloc->base_addr,
                                   CFI_attribute_other,
                                   CFI_type_double,
                                   sizeof(double),
                                   rank,
                                   extents);
                Fortran_solve (desc_assum, ...); /* Uses array allocated in Fortran_factor. */
        2 After invocation of the second CFI_establish, the lower bounds stored in the dim member of desc_assum will
          have the value 0 even if the corresponding entries in desc_alloc have diﬀerent values.
          C.12.12  Creating an array section in C using CFI_section
        1 TheCfunctionset_oddsetseverysecondelementofanarraytoaspeciﬁcvalue, beginning with the ﬁrst element.
          If does this by making an array section descriptor for the elements to be set, and calling a Fortran subroutine
          SET_ALLthatsets every element of an assumed-shape array to a speciﬁc value. An interface block for set_odd
          permits it to be also called from Fortran.
                SUBROUTINE set_all(int_array, val) BIND(C)
                  INTEGER(C_INT) :: int_array(:)
                  INTEGER(C_INT), VALUE :: val
                  int_array = val
                END SUBROUTINE
                INTERFACE
                  SUBROUTINE set_odd(int_array, val) BIND(C)
                    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT
                    INTEGER(C_INT) :: int_array(:)
                    INTEGER(C_INT), VALUE :: val
                  END SUBROUTINE
                END INTERFACE
                #include "ISO_Fortran_binding.h"
                void set_odd(CFI_cdesc_t *int_array, int val)
                                                          c
          608                                            ISO/IEC 2017 – All rights reserved
                                           ISO/IEC DIS 1539-1:2017 (E)
           {
             CFI_index_t lower_bound[1], upper_bound[1], stride[1];
             CFI_CDESC_T(1) array;
             int status;
             /* Create a new descriptor which will contain the section. */
             status = CFI_establish((CFI_cdesc_t *)&array,
                          NULL,
                          CFI_attribute_other,
                          int_array->type,
                          int_array->elem_len,
                          /* rank */ 1,
                          /* extents is ignored */NULL);
             lower_bound[0] = int_array->dim[0].lower_bound;
             upper_bound[0] = lower_bound[0] + (int_array->dim[0].extent - 1);
             stride[0] = 2;
             status = CFI_section((CFI_cdesc_t *)&array,
                         int_array,
                         lower_bound,
                         upper_bound,
                         stride);
             set_all( (CFI_cdesc_t *) &array, val);
             /* Here one could make use of int_array and access all its data. */
           }
      2 The set_odd procedure can be called from Fortran as follows:
           INTEGER(C_INT) :: d(5)
           d = (/ 1, 2, 3, 4, 5 /)
           CALL set_odd(d, -1)
           PRINT *, d
      3 This program will print something like:
            -1  2 -1  4 -1
      4 During execution of the subroutine SET_ALL, its dummy argument INT_ARRAY would have size (and upper
       bound) 3.
      5 It is also possible to invoke set_odd() from C. However, it would be the C programmer’s responsibility to make
       sure that all members of the C descriptor have the correct value on entry to the function. Inserting additional
       checking into the function could alleviate this problem.
      6 Following is an example C function that dynamically generates a C descriptor for an assumed-shape array and
       calls set_odd.
       c
       ISO/IEC 2017 – All rights reserved                  609
          ISO/IEC DIS 1539-1:2017 (E)
                #include <stdio.h>
                #include <stdlib.h>
                #include "ISO_Fortran_binding.h"
                #define ARRAY_SIZE 5
                void example_of_calling_set_odd(void)
                {
                  CFI_CDESC_T(1) d;
                  CFI_index_t extent[1];
                  CFI_index_t subscripts[1];
                  void *base;
                  int i, status;
                  base = malloc(ARRAY_SIZE*sizeof(int));
                  extent[0] = ARRAY_SIZE;
                  status = CFI_establish((CFI_cdesc_t *)&d,
                                      base,
                                      CFI_attribute_other,
                                      CFI_type_int,
                                      /* element length is ignored */ 0,
                                      /* rank */ 1,
                                      extent);
                  set_odd((CFI_cdesc_t *)&d, -1);
                  for (i=0; i<ARRAY_SIZE; i++) {
                    subscripts[0] = i;
                    printf(" %d",*((int *)CFI_address((CFI_cdesc_t *)&d, subscripts)));
                  }
                  putc(10, stdout);
                  free(base);
                }
          The above C function will print similar output to that of the preceding Fortran program.
          C.12.13  Use of CFI_setpointer
        1 The C function change_target modiﬁes a pointer to an integer variable to become associated with a global
          variable deﬁned inside C:
                #include "ISO_Fortran_binding.h"
                int y = 2;
                void change_target(CFI_cdesc_t *ip) {
                   CFI_CDESC_T(0) yp;
                   int status;
                                                          c
          610                                            ISO/IEC 2017 – All rights reserved
                                                                ISO/IEC DIS 1539-1:2017 (E)
                   /* Make local yp point at y. */
                   status = CFI_establish((CFI_cdesc_t *)&yp,
                                       &y,
                                       CFI_attribute_pointer,
                                       CFI_type_int,
                                       /* elem_len is ignored */ sizeof(int),
                                       /* rank */ 0,
                                       /* extents are ignored */ NULL);
                   /* Pointer-associate ip with (the target of) yp. */
                   status = CFI_setpointer(ip, (CFI_cdesc_t *)&yp, NULL);
                   if (status != CFI_SUCCESS) {
                     ... report run time error...
                   }
                }
        2 The restrictions on the use of CFI_establish prohibit direct modiﬁcation of the incoming pointer entity ip by
          invoking that function on it.
        3 The following program illustrates the usage of change_target from Fortran.
                PROGRAM change_target_example
                  USE, INTRINSIC :: ISO_C_BINDING
                  INTERFACE
                    SUBROUTINE change_target(ip) BIND(C)
                      IMPORT :: C_INT
                      INTEGER(C_INT), POINTER :: ip
                    END SUBROUTINE
                  END INTERFACE
                  INTEGER(C_INT), TARGET :: it = 1
                  INTEGER(C_INT), POINTER :: it_ptr
                  it_ptr => it
                  WRITE (*,*) it_ptr
                  CALL change_target(it_ptr)
                  WRITE (*,*) it_ptr
        4 This will print something similar to
                 1
                 2
          C.12.14  Mapping of MPI interfaces to Fortran
        1 The Message Passing Interface (MPI) speciﬁes procedures for exchanging data between MPI processes. This
          example shows the usage of MPI_Send and is similar to the second variant of EXAMPLE_Send in C.12.6.2. It also
          shows the usage of assumed-length character dummy arguments and optional dummy arguments.
        2 MPI_Send has the C prototype:
                int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag,
                            MPI_Comm comm);
           c
          ISO/IEC 2017 – All rights reserved                                            611
       ISO/IEC DIS 1539-1:2017 (E)
       where MPI_Datatype and MPI_Comm are opaque handles. Most MPI C functions return an error code, which in
       Fortran is the last dummy argument to the corresponding subroutine and can be made optional. Thus, the use
       of a Fortran subroutine requires a wrapper function, declared as
           void MPI_Send_f(CFI_cdesc_t *buf, int count, MPI_Datatype_f datatype, int dest,
                     int tag, MPI_Datatype_f comm, int *ierror);
      3 This wrapper function will convert MPI_Datatype_f and MPI_Comm_f to MPI_Datatype and MPI_Comm, and pro-
       duce a contiguous void * buﬀer from CFI_cdesc_t *buf (if necessary).
      4 Similarly, the wrapper function for MPI_Comm_set_name could have the C prototype:
           void MPI_Comm_set_name_f(MPI_Comm comm, CFI_cdesc_t *comm_name, int *ierror);
      5 The Fortran handle types and interfaces are deﬁned in the module MPI_F08. For example,
           MODULE mpi_f08
            ...
            TYPE, BIND(C) :: mpi_comm
             PRIVATE
             INTEGER(C_INT) :: mpi_val
            END TYPE mpi_comm
            INTERFACE
             SUBROUTINE MPI_SEND(buf,count,datatype,dest,tag,comm,ierror) &
             BIND(C, NAME=’MPI_Send_f’)
               USE, INTRINSIC :: ISO_C_BINDING
               IMPORT :: MPI_Datatype, MPI_Comm
               TYPE(*), DIMENSION(..), INTENT (IN) :: buf
               INTEGER(C_INT), VALUE, INTENT (IN) :: count, dest, tag
               TYPE(mpi_datatype), INTENT (IN) :: datatype
               TYPE(mpi_comm), INTENT (IN) :: comm
               INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
             END SUBROUTINE mpi_send
             SUBROUTINE mpi_comm_set_name(comm,comm_name,ierror) &
             BIND(C, NAME=’MPI_Comm_set_name_f’)
               USE, INTRINSIC :: ISO_C_BINDING
               IMPORT :: mpi_comm
               TYPE(mpi_comm), INTENT (IN) :: comm
               CHARACTER(KIND=C_CHAR, LEN=*), INTENT (IN) :: comm_name
               INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
             END SUBROUTINE mpi_comm_set_name
            END INTERFACE
            ...
           END MODULE mpi_f08
                                       c
       612                             ISO/IEC 2017 – All rights reserved
                                                                         ISO/IEC DIS 1539-1:2017 (E)
         6 Some examples of invocation from Fortran are:
                   USE, INTRINSIC :: ISO_C_BINDING
                   USE :: MPI_f08
                   TYPE(mpi_comm) :: comm
                   REAL :: x(100)
                   INTEGER :: y(10,10)
                   REAL(KIND(1.0d0)) :: z
                   INTEGER :: dest, tag, ierror
                   ...
                   ! Assign values to x, y, z and initialize MPI variables.
                   ...
                   ! Set the name of the communicator.
                   CALL mpi_comm_set_name(comm, "Communicator Name", ierror)
                   ! Send values in x, y, and z.
                   CALL mpi_send(x, 100, MPI_REAL, dest, tag, comm, ierror)
                   IF (ierror/=0) PRINT *, ’WARNING: X send error’, ierror
                   CALL mpi_send(y(3,:), 10, MPI_INTEGER, dest, tag, comm)
                   CALL mpi_send(z, 1, MPI_DOUBLE_PRECISION, dest, tag, comm)
         7 The ﬁrst example sends the entire array X and includes the optional error argument return value. The second
            example sends a noncontiguous subarray (the third row of Y) and the third example sends a scalar Z. Note the
            diﬀerences between the calls in this example and those in C.12.6.2.
            C.13    Clause 19 notes : Examples of host association (19.5.1.4)
         1 The ﬁrst two examples are examples of valid host association. The third example is an example of invalid host
            association.
            Example 1:
                   PROGRAM A
                      INTEGER I, J
                      ...
                   CONTAINS
                      SUBROUTINE B
                         INTEGER I  ! Declaration of I hides
                                    ! program A’s declaration of I
                            ...
                         I = J      ! Use of variable J from program A
                                    ! through host association
                      END SUBROUTINE B
                   END PROGRAM A
            c
            ISO/IEC 2017 – All rights reserved                                                      613
            ISO/IEC DIS 1539-1:2017 (E)
            Example 2:
                   PROGRAM A
                      TYPE T
                         ...
                      END TYPE T
                      ...
                   CONTAINS
                      SUBROUTINE B
                         IMPLICIT TYPE (T) (C)  ! Refers to type T declared below
                                                ! in subroutine B, not type T
                                                ! declared above in program A
                            ...
                         TYPE T
                            ...
                         END TYPE T
                            ...
                      END SUBROUTINE B
                   END PROGRAM A
            Example 3:
                   PROGRAM Q
                      REAL (KIND = 1) :: C
                         ...
                   CONTAINS
                      SUBROUTINE R
                         REAL (KIND = KIND (C)) :: D  ! Invalid declaration
                                                      ! See below
                         REAL (KIND = 2) :: C
                            ...
                      END SUBROUTINE R
                   END PROGRAM Q
         2 In the declaration of D in subroutine R, the use of C would refer to the declaration of C in subroutine R, not
            program Q. However, it is invalid because the declaration of C is required to occur before it is used in the
            declaration of D (10.1.12).
                                                                  c
            614                                                  ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
                                                                    Index
               In the index, entries in italics denote BNF terms, and page numbers in bold face denote primary text or
               deﬁnitions.
               Symbols                                                     A
               −, 155                                                      Aedit descriptor, 278
               <, 159, 446                                                 ABS, 350, 449
               <=, 159                                                     ABSTRACT, 69, 70, 85, 302, 303
               >, 159                                                      ABSTRACTattribute, 23, 69, 85
               >=, 159                                                     abstract interface, 15, 15, 294, 301, 303, 309, 328, 510,
               *, 55, 58, 60, 65, 100, 104, 114, 138, 155, 240, 241, 271,            514
                        283, 288, 311, 330                                 abstract interface block, 15, 15, 303
               **, 155                                                     abstract type, 23, 59, 82, 85, 85, 88, 131, 139
               +, 155                                                      ac-do-variable (R776), 93, 93, 164, 166, 512
               -stmt, 20                                                   ac-implied-do (R774), 93, 93, 153, 512
               .AND., 150, 151, 154, 158, 158, 352                         ac-implied-do-control (R775), 93, 93, 153, 164–166, 512
               .EQ., 149, 151, 154, 158, 159, 159, 161, 302, 446           ac-spec (R770), 92, 93
               .EQV., 150, 151, 154, 158, 158                              ac-value (R773), 93, 93
               .FALSE., 68, 479                                            access-id (R828), 111, 111
               .GE., 149, 151, 154, 158, 159, 161, 302, 446                access-name, 111
               .GT., 149, 151, 154, 158, 159, 161, 302, 446                access-spec (R807), 69, 74, 75, 80–83, 95, 98, 98, 111,
               .LE., 149, 151, 154, 158, 159, 161, 302, 446                          112, 304, 308
               .LT., 149, 151, 154, 158, 159, 161, 302, 446                access-stmt (R827), 36, 98, 111, 111, 112
               .NE., 149, 151, 154, 158, 159, 159, 161, 302, 446           ACCESS=speciﬁer, 226, 227, 254, 255
               .NEQV., 150, 151, 154, 158, 158, 413                        accessibility attribute, 98, 111, 294
               .NOT., 150, 151, 154, 158, 158                              accessibility statement, 111
               .OR., 150, 151, 154, 158, 158, 353                          ACHAR, 68, 169, 350
               .TRUE., 68, 479                                             ACOS, 350
               /, 155                                                      ACOSH, 350
               / edit descriptor, 281                                      ACQUIRED_LOCK=speciﬁer, 213, 525, 528
               //, 157                                                     action, 218
               /=, 159, 446                                                action-stmt (R515), 7, 37, 37, 153, 196, 204
               : edit descriptor, 281                                      ACTION=speciﬁer, 226, 228, 254, 255, 565
               ;, 54                                                       active image, 14, 41, 140, 144, 145, 186, 213, 216, 341,
               <=, 446                                                               407
               ==, 159, 446                                                actual argument, 5, 16, 30, 31, 41, 45–47, 60, 63, 72,
               >, 446                                                                84, 85, 103–108, 131, 133, 141, 143, 153, 162,
               >=, 446                                                               163, 193, 246, 305–307, 310–324, 332–338, 342,
               &, 54, 288                                                            348, 349, 370, 394, 395, 411, 420, 433–435, 438,
               c
               ISO/IEC 2017 – All rights reserved                                                                               615
               ISO/IEC DIS 1539-1:2017 (E)
                        450, 483, 484, 486, 489–491, 513, 517–519, 522,    ancestor-module-name, 297
                        527–529, 541, 543, 584, 585, 587, 590              and-op (R1019), 51, 150, 150
               actual-arg (R1524), 311, 311                                and-operand (R1014), 150, 150
               actual-arg-spec (R1523), 88, 311, 311                       ANINT, 352
               add-op (R1009), 51, 148, 148                                ANY, 353
               add-operand (R1005), 148, 148, 151, 152                     arg-name, 75, 77, 82
               ADJUSTL, 351                                                argument
               ADJUSTR, 351                                                     dummy, 316
               ADVANCE=speciﬁer, 232, 233, 234, 245, 563                   argument association, 6, 6, 23, 58, 66, 76, 77, 100, 103,
               advancing input/output statement, 221                                 110, 111, 143, 144, 299, 313, 314, 323, 330,
               AIMAG, 351                                                            513, 519, 521, 522, 540, 586
               AINT, 351                                                   argument keyword, 12, 16, 47, 301, 304, 313, 337, 342,
               ALL, 120, 352                                                         450, 510, 511, 512, 573
               alloc-opt (R928), 138, 138, 139, 144                        arithmetic IF statement, 540
               allocatable, 5, 5, 20, 31, 45, 46, 58, 60, 61, 71, 76, 77,  array, 5, 7, 13, 20, 46, 102–104, 133–136
                        79, 84, 87, 89, 90, 96, 100, 103–106, 110, 113,         assumed-shape, 5, 60, 101, 103, 122, 123, 136, 137,
                        124, 125, 131, 132, 138, 139, 141–144, 163, 165,             301, 315–319, 321, 322, 328, 479, 489, 491, 503,
                        167–170, 172, 173, 193, 207, 237, 238, 243, 285,             584, 601, 607, 609
                        300, 301, 311, 315, 317, 321, 329, 335, 337, 352,       assumed-size, 5, 104, 105, 110, 123, 133, 134, 147,
                        369, 379, 394–396, 407, 408, 410, 411, 421, 424,             164, 167, 189, 200, 237, 315, 316, 320, 395,
                        426, 428, 431, 434, 435, 444, 450, 479, 484,                 424, 426, 427, 434, 484, 488, 493, 496, 500,
                        486–488, 493, 500, 502–504, 516, 517, 526                    502, 503, 596, 598, 601
               ALLOCATABLEattribute,5,58–60, 68, 69, 74, 75, 98,                deferred-shape, 5, 103
                        98–100, 103, 108, 110, 112, 131, 134, 183, 189,         explicit-shape, 5, 60, 76, 100, 103, 166, 315, 320,
                        199, 200, 298, 301, 306, 307, 317, 320, 328,                 488
                        336, 488, 516, 522, 523, 587, 591                  array bound, 7, 76, 78, 97, 165
               ALLOCATABLEstatement, 112                                   array constructor, 92, 92
               allocatable-decl (R830), 112, 112                           array element, 5, 45, 134
               allocatable-stmt (R829), 36, 112, 514                       array element order, 134–135
               ALLOCATEstatement, 58, 59, 66, 101, 103, 138, 141,          array pointer, 5, 101, 103, 104, 163, 354, 488
                        144, 145, 172, 206, 438, 497, 498, 517, 518,       array section, 5, 101, 113, 114, 132, 134–137, 183, 223,
                        525–527, 532, 543                                            315, 316, 321, 322, 516, 519
               allocate-coarray-spec (R936), 138, 138, 139                 array-constructor (R769), 92, 93, 147
               allocate-coshape-spec (R937), 138, 138, 139                 array-element (R917), 113, 114, 124, 129, 130, 133
               allocate-object (R932), 66, 138, 138–145, 206, 438, 440,    array-name, 115, 514
                        528, 529, 532                                      array-section (R918), 5, 129, 133, 134, 135
               allocate-shape-spec (R933), 138, 138–141                    array-spec (R815), 28, 95–97, 102, 102–105, 112, 115,
               allocate-stmt (R927), 37, 138, 529                                    117, 125
               ALLOCATED, 75, 141, 145, 352                                ASCII character, 5, 65, 68, 167, 223, 238, 270, 284,
               allocation (R931), 138, 138–141                                       350, 365, 386, 389, 396–398, 409, 422
               allocation status, 46, 87, 89, 90, 106, 109, 110, 141,      ASCII collating sequence, 68, 350, 365, 386, 389, 397,
                        141–145, 193, 207, 210, 317, 321, 352, 407, 411,             398, 409
                        504, 522, 526                                      ASIN, 353
               alphanumeric-character (R601), 49, 49, 50                   ASINH, 354
               alt-return-spec (R1525), 7, 204, 311, 311                   ASSIGN statement, 539
               ancestor component, 86                                      assigned format, 539
                                                                                    c
               616                                                                 ISO/IEC 2017 – All rights reserved
                                                                                                  ISO/IEC DIS 1539-1:2017 (E)
               assigned GO TO statement, 539                                             123–125, 164, 165, 172, 294, 293–297, 303,
               ASSIGNMENT, 82, 170, 171, 302, 306, 307                                   331, 334, 511–514, 517
               assignment, 167–179                                             association (R1104), 182, 182
                    deﬁned, 81, 170, 306                                       association status, see pointer association status
                    elemental, 12, 171                                         assumed type parameter, 24, 24, 58, 315, 317
                    elemental array (FORALL), 177                              assumed-implied-spec (R821), 104, 104, 105
                    masked array (WHERE), 175                                  assumed-rankdummydataobject,6,45,60,83,84,101,
                    pointer, 171                                                         102, 136, 199, 200, 300, 301, 307, 315–317, 321,
               assignment statement, 17, 31, 44, 58, 84, 167, 179, 475,                  322, 328, 393–395, 418, 424, 426, 427, 434, 479,
                         524                                                             484, 489, 491, 601, 602, 604
               assignment-stmt (R1032), 37, 167, 167, 175, 177, 178,           assumed-rank-spec (R825), 102, 105
                         528                                                   assumed-shapearray, 5, 60, 101, 103, 122, 123, 136, 137,
               ASSOCIATE construct, 46, 182, 185, 321, 512, 513,                         301, 315–319, 321, 322, 328, 479, 489, 491, 503,
                         516, 528                                                        584, 601, 607, 609
               associate name, 6, 6, 24, 58, 61, 88, 99, 143, 182, 183,        assumed-shape-spec (R819), 102, 103, 103
                         185, 202, 513, 516, 517, 522, 528                     assumed-size array, 5, 104, 105, 110, 123, 133, 134, 147,
               ASSOCIATE statement, 46, 182, 516                                         164, 167, 189, 200, 237, 315, 316, 320, 395,
               associate-construct (R1102), 37, 182, 182                                 424, 426, 427, 434, 484, 488, 493, 496, 500,
               associate-construct-name, 182                                             502, 503, 596, 598, 601
               associate-name, 182, 199–203, 512                               assumed-size-spec (R822), 102, 104, 104
               associate-stmt (R1103), 7, 182, 182, 204                        assumed-type, 7, 59, 60, 315, 328, 489, 603
               ASSOCIATED, 75, 142, 145, 338, 354                              ASYNCHRONOUSattribute,98,98,99,112,183,192,
               associating entity, 6, 46, 66, 137, 182, 183, 185, 187,                   235, 294, 296, 300, 301, 316, 317, 367, 418, 504,
                         203, 330, 522, 522                                              505, 507, 514
               association, 6                                                  asynchronous communication, 98, 507
                    argument, 6, 6, 23, 58, 66, 76, 77, 100, 103, 110,         asynchronous input/output, 98, 226, 228, 230, 234–236,
                         111, 143, 144, 299, 313, 314, 323, 330, 513,                    239, 240, 247, 250, 251, 253, 255, 257, 258
                         519, 521, 522, 540, 586                               ASYNCHRONOUSstatement, 112, 184, 298, 512, 514
                    common, 126                                                asynchronous-stmt (R831), 36, 112
                    construct, 6, 6, 143, 144, 513, 516, 519, 522              ASYNCHRONOUS=speciﬁer,227,228,232,233,234,
                    equivalence, 124                                                     254, 255
                    host, 6, 6, 39, 59, 60, 66, 98, 111, 113, 118, 126, 164,   ATAN, 355
                         165, 172, 297, 299, 320, 333–335, 511, 513–516,       ATAN2, 32, 355
                         519, 522, 613                                         ATANH, 356
                    inheritance, 6, 6, 9, 47, 86, 88, 519, 522                 atomic subroutine, 22, 41, 207, 208, 337, 340, 342, 356–
                    linkage, 6, 6, 506, 513, 516, 516                                    360, 377, 437, 441, 528
                    name, 6, 6, 47, 513, 519                                   ATOMIC_ADD,356, 438
                    pointer, 6, 6, 12, 22, 23, 44, 47, 85, 87, 89, 101,        ATOMIC_AND,356
                         106, 108, 110, 111, 131, 143, 145, 171, 173,          ATOMIC_CAS, 357
                         174, 193, 207, 210, 240, 300, 314, 316, 318,          ATOMIC_DEFINE, 357, 592, 593
                         320, 321, 329, 330, 343, 354, 407, 411, 482,          ATOMIC_FETCH_ADD,357
                         483, 517–520, 522, 528                                ATOMIC_FETCH_AND,358
                    sequence, 320                                              ATOMIC_FETCH_OR,358
                    storage, 6, 6, 46, 47, 123–125, 331, 334, 429, 519–        ATOMIC_FETCH_XOR,359
                         522                                                   ATOMIC_INT_KIND, 356–360, 437
                    use, 6, 6, 31, 39, 47, 60, 66, 86, 98, 109, 111, 118,      ATOMIC_LOGICAL_KIND, 357, 360, 437
                c
               ISO/IEC 2017 – All rights reserved                                                                                     617
              ISO/IEC DIS 1539-1:2017 (E)
              ATOMIC_OR,359                                                   PASS, 75, 77, 82, 311
              ATOMIC_REF, 359, 592, 593                                       POINTER, 5, 17, 58–60, 68, 69, 74, 75, 96, 103,
              ATOMIC_XOR,360                                                       105, 108, 108, 110, 115, 117, 131, 134, 142,
              attr-spec (R802), 95, 95–97, 117                                     172, 183, 192, 199, 200, 299–301, 303, 306, 307,
              attribute, 7, 59, 68, 72, 95–111, 296                                309, 317, 320–323, 328, 334, 336, 484, 488, 503,
                   ABSTRACT, 23, 69, 85                                            516, 519, 522, 523, 543, 587, 591
                   accessibility, 98, 111, 294                                PRIVATE, 71, 86, 98, 98, 111, 123, 335, 571
                   ALLOCATABLE,5, 58–60, 68, 69, 74, 75, 98, 98–              PROTECTED, 31, 109, 109, 117, 124, 192, 295,
                        100, 103, 108, 110, 112, 131, 134, 183, 189,               543
                        199, 200, 298, 301, 306, 307, 317, 320, 328,          PUBLIC, 86, 98, 98, 111, 123, 571
                        336, 488, 516, 522, 523, 587, 591                     SAVE, 19, 24, 33, 46, 78, 85, 97, 99, 100, 109, 109,
                   ASYNCHRONOUS,98,98,99,112,183,192, 235,                         110, 113, 117, 124, 126, 144, 192, 309, 334, 518
                        294, 296, 300, 301, 316, 317, 367, 418, 504,          SEQUENCE, 19, 69, 71, 71, 72, 85, 125, 172, 173,
                        505, 507, 514                                              202, 486
                   BIND, 6, 7, 44, 69–71, 85, 90, 99, 99, 110, 112,           TARGET, 6, 22, 31, 78, 108, 110, 110, 117, 124,
                        124, 125, 172, 173, 192, 202, 298, 300, 301,               126, 142, 143, 172, 183, 192, 193, 200, 301, 307,
                        327, 329, 486, 487, 489, 504–506, 516, 523, 596            315, 316, 318, 321–323, 367, 407, 418, 481, 484,
                   CODIMENSION, 60, 75, 96, 99, 99, 105, 113                       504, 505, 517–519, 527, 543, 584, 585
                   CONTIGUOUS, 75, 77, 101, 101, 102, 113, 136,               VALUE, 60, 77, 83, 105, 110, 110, 118, 192, 240,
                        137, 173, 192, 300, 315, 317–319, 321, 322, 489,           300, 301, 303, 305, 306, 314–318, 328, 334, 336,
                        491, 520                                                   367, 418, 489, 490, 507, 519, 543, 596, 598
                   DEFERRED, 81, 82, 85                                       VOLATILE, 31, 110, 110, 111, 118, 172, 173, 183,
                   DIMENSION, 75, 96, 102, 102, 115, 125                           192, 294, 296, 300, 301, 316–318, 334, 514, 519,
                   EXTENDS, 23, 85, 85, 487                                        525, 528, 550
                   EXTERNAL, 17, 29, 30, 105, 105, 108, 117, 118,        attribute speciﬁcation statements, 111–127
                        120, 172, 294, 298, 300, 303, 308, 320, 324,     automatic data object, 7, 32, 96, 97, 100, 110, 113, 124,
                        326, 514, 515, 582                                         125, 525, 541
                   INTENT, 105, 105–107, 116, 192, 543                   B
                   INTENT (IN), 105, 106, 107, 111, 189, 305–307,        Bedit descriptor, 277
                        315, 318, 320–322, 334, 335, 338, 356–360,       BACKSPACEstatement, 218, 221, 247, 250, 251, 252,
                        365–368, 377, 378, 383, 384, 408, 416, 451,                564, 565
                        481–483, 503, 504, 543, 584, 598                 backspace-stmt (R1224), 37, 251, 335
                   INTENT (INOUT), 30, 105, 106, 107, 110, 193, base object, 7, 98, 101, 124, 131, 137, 164, 235, 321,
                        306, 316, 318, 324, 335, 336, 356–360, 365–368,            334, 336
                        378, 382–384, 407, 408, 438, 440, 528, 529, 598  BESSEL_J0, 360
                   INTENT (OUT), 31, 60, 83–85, 104, 105, 105– BESSEL_J1, 360
                        107, 110, 143, 164, 306, 316, 318, 324, 334–336, BESSEL_JN, 361
                        356–360, 365–368, 370, 372, 377, 378, 382–384,   BESSEL_Y0, 361
                        407, 408, 416, 430, 453–455, 481, 483, 503, 504, BESSEL_Y1, 361
                        517–519, 524, 525, 527–529, 598                  BESSEL_YN, 362
                   INTRINSIC,105,107,107,108,294,310,324,325, BGE, 362
                        515                                              BGT, 362
                   NON_OVERRIDABLE,81, 82                                binary-constant (R765), 92, 92
                   NON_RECURSIVE, 301, 327, 327, 331, 332                BIND (C), see BIND attribute
                   OPTIONAL,108,108,110,116,164,183,189,301 BINDattribute,6,7,44,69–71,85,90,99,99,110,112,
                   PARAMETER,9, 44, 91, 97, 108, 108, 116, 130                     124, 125, 172, 173, 192, 202, 298, 300, 301, 327,
                                                                                 c
              618                                                                ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
                       329, 486, 487, 489, 504–506, 516, 523, 596                362–365, 373–375, 387, 389, 391, 392, 403, 404,
              BIND statement, 112, 298, 505, 511                                 418
              bind-entity (R833), 112, 112                              branch, 204, 332, 539
              bind-stmt (R832), 37, 112                                 branch target statement, 7, 40, 52, 175, 192, 204, 204,
              binding, 7, 81, 82, 82, 86, 87, 160, 171, 243, 249, 307,           205, 227, 231, 232, 250, 251, 253, 255, 312, 332
                       326, 510, 511                                    BTEST, 364
              binding label, 7, 99, 301, 309, 327, 329, 505–507, 509,   BZ edit descriptor, 282
                       510, 543                                         C
              binding name, 7, 81, 82, 86, 311, 511                     Caddress, 7, 481–484, 486, 487, 492, 497, 499, 526, 527,
              binding-attr (R752), 81, 82, 82                                    598
              binding-name, 81, 82, 311, 326, 511                       Cdescriptor, 8, 143, 490–505
              binding-private-stmt (R747), 81, 81, 83                   C_ALERT, 480
              bit model, 338                                            C_ASSOCIATED, 480
              BIT_SIZE, 339, 363, 408                                   C_BACKSPACE, 480
              blank common, 8, 96, 113, 125, 126, 519, 521              C_BOOL, 479, 480
              blank interpretation mode, 228                            C_CARRIAGE_RETURN,480
              blank-interp-edit-desc (R1318), 267, 268                  C_CHAR,480, 543
              BLANK=speciﬁer, 227, 228, 232, 233, 235, 247, 254,        C_DOUBLE,479
                       255, 282                                         C_DOUBLE_COMPLEX,480
              BLE, 363                                                  C_F_POINTER, 480, 481
              block, 7                                                  C_F_PROCPOINTER,483
                   interface, 295                                       C_FLOAT, 479
              block (R1101), 7, 181, 182, 184–188, 190, 191, 194–196,   C_FLOAT_COMPLEX,480
                       199, 201                                         C_FORM_FEED,480
              BLOCKconstruct, 19, 31, 41, 43, 84, 97, 99, 101, 103,     C_FUNLOC,483, 483, 506
                       109, 111, 118, 120–122, 143, 164, 183, 334,      C_FUNPTR, 74, 85, 99, 131, 139, 140, 170, 479, 480,
                       512, 518, 519, 525, 527, 532                              483, 486, 487, 527
              block data program unit, 297                              C_HORIZONTAL_TAB,480
              BLOCKDATAstatement, 53, 293, 297                          C_INT, 479
              block scoping unit, 14, 19                                C_INT16_T, 479
              BLOCKstatement, 97, 101, 103, 184, 525                    C_INT32_T, 479
              block-construct (R1107), 37, 184, 184                     C_INT64_T, 479
              block-construct-name, 184                                 C_INT8_T, 479
              block-data (R1420), 35, 120, 297, 298                     C_INT_FAST16_T, 479
              block-data-name, 297                                      C_INT_FAST32_T, 479
              block-data-stmt (R1421), 35, 297, 297                     C_INT_FAST64_T, 479
              block-speciﬁcation-part (R1109), 20, 184, 184             C_INT_FAST8_T, 479
              block-stmt (R1108), 7, 184, 184, 204                      C_INT_LEAST16_T, 479
              BLT, 363                                                  C_INT_LEAST32_T, 479
              BNedit descriptor, 282                                    C_INT_LEAST64_T, 479
              bound, 5, 7, 7, 45, 46, 75, 87, 90, 103, 138, 140, 144,   C_INT_LEAST8_T, 479
                       145, 173, 207, 407, 513                          C_INTMAX_T,479
              bounds, 102–105, 133–136                                  C_INTPTR_T, 479
              bounds-remapping (R1036), 171, 172, 172, 173              C_LOC, 60, 105, 335, 484, 543
              bounds-spec (R1035), 171, 172, 172, 173                   C_LONG,479
              boz-literal-constant (R764), 51, 92, 92, 115, 277, 339,   C_LONG_DOUBLE,479
               c
              ISO/IEC 2017 – All rights reserved                                                                          619
             ISO/IEC DIS 1539-1:2017 (E)
             C_LONG_DOUBLE_COMPLEX,480                              char-variable (R905), 129, 129, 223
             C_LONG_LONG,479                                        character context, 8, 49, 53–55, 67
             C_NEW_LINE,480                                         character literal constant, 66
             C_NULL_CHAR,480                                        character sequence type, 20, 71, 124–126, 521, 525
             C_NULL_FUNPTR,479, 480                                 character set, 49
             C_NULL_PTR,479, 480                                    character storage unit, 21, 21, 104, 124, 126, 437, 520,
             C_PTR, 74, 85, 99, 131, 139, 140, 170, 479–481, 484,           524, 526
                      486, 487, 490, 526, 527, 596                  character string edit descriptor, 266, 283
             C_SHORT, 479                                           character type, 65–68
             C_SIGNED_CHAR,479                                      CHARACTER_KINDS,437
             C_SIZE_T, 479                                          CHARACTER_STORAGE_SIZE,437
             C_SIZEOF, 105, 164, 484                                characteristics, 8, 86, 174, 243, 244, 300, 301, 303, 309,
             C_VERTICAL_TAB, 480                                            310, 319, 324, 327, 329, 331, 349, 411
             CALLstatement, 22, 204, 207, 299, 311, 324, 332, 407       dummy argument, 300
             call-stmt (R1521), 37, 311, 312, 313                       procedure, 300
             CASEstatement, 197                                     child data transfer statement, 222, 223, 234–236, 239,
             case-construct (R1140), 37, 196, 197                           245, 243–247, 262, 286
             case-construct-name, 197                               CLASS, 59, 59, 60, 243
             case-expr (R1144), 197, 197                            CLASS DEFAULT statement, 202
             case-selector (R1145), 197, 197                        CLASS IS statement, 202, 379
             case-stmt (R1142), 196, 197, 197                       CLOSE statement, 218, 219, 223, 225, 226, 230, 230,
             case-value (R1147), 197, 197                                   247, 250, 564
             case-value-range (R1146), 197, 197                     close-spec (R1209), 231, 231
             CEILING, 364                                           close-stmt (R1208), 37, 231, 335
             CFI_address, 496                                       CMPLX, 169, 339, 365, 445
             CFI_allocate, 497, 504                                 CO_BROADCAST,365
             CFI_cdesc_t, 8, 489–491, 492, 492–494, 496–502, 504    CO_MAX,366
             CFI_deallocate, 494, 498, 504                          CO_MIN, 366
             CFI_establish, 498                                     CO_REDUCE,367, 535
             CFI_is_contiguous, 500                                 CO_SUM,368, 535
             CFI_section, 500                                       coarray, 8, 8, 10, 31, 41, 45, 46, 70, 75, 76, 84, 99–101,
             CFI_select_part, 501                                           106, 108, 110, 111, 124, 125, 132, 138–141, 144,
             CFI_setpointer, 502                                            145, 167, 168, 170, 172, 173, 183, 185–187, 189,
             CHANGETEAMconstruct,22,46,137,183, 185, 191,                   206–208, 294, 301, 311, 316, 318, 319, 321, 322,
                      204, 512, 513, 528                                    324, 328, 341, 342, 345, 347, 356–360, 369, 390,
             CHANGETEAMstatement, 22, 40, 46, 185, 206, 215,                395, 407, 431, 432, 434, 435, 440, 488
                      341, 516                                          established, 8, 46, 186
             change-team-construct (R1111), 37, 185, 185            coarray-association (R1113), 46, 185, 185
             change-team-stmt (R1112), 185, 185                     coarray-name, 113, 185, 512, 514
             changeable mode, 224                                   coarray-spec (R809), 74–76, 95, 96, 99, 99, 100, 112,
             CHAR, 67, 364                                                  113, 117
             char-length (R723), 65, 65, 66, 74, 75, 95–97, 542     cobound, 8, 45, 46, 99–101, 137, 140, 165, 183, 187, 319,
             char-literal-constant (R724), 51, 55, 56, 66, 246, 267,        345, 347, 395, 407, 434, 435, 513
                      268, 531                                      codimension, 8, 8, 10, 45, 101, 137, 183, 300, 369, 395,
             char-selector (R721), 61, 65, 66                               435
             char-string-edit-desc (R1321), 266, 268                CODIMENSIONattribute, 60, 75, 96, 99, 99, 105, 113
                                                                           c
             620                                                          ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
               codimension-decl (R835), 113, 113, 183, 185, 186, 512        component deﬁnition statement, 74
               codimension-stmt (R834), 37, 113, 514                        component keyword, 16, 47, 80, 89, 511
               coindexed object, 8, 31, 41, 45, 46, 78, 113, 131, 137,      component order, 9, 80, 89, 238
                         139, 167, 168, 170, 172, 173, 182, 208, 212, 311,  component-array-spec (R740), 74, 74–76
                         312, 315–318, 321, 322, 334, 356–360, 365–368,     component-attr-spec (R738), 74, 74, 75, 77, 78
                         377, 407, 441, 481, 483, 484                       component-data-source (R758), 88, 88, 89
               coindexed-named-object (R914), 129, 130, 132, 132            component-decl (R739), 66, 74, 74–76, 78
               collating sequence, 8, 67, 68, 159, 270, 350, 364, 365,      component-def-stmt (R736), 9, 74, 74, 75
                         386, 389, 397, 398, 401–406, 409                   component-initialization (R743), 74, 77, 78
               collective subroutine, 22, 337, 341, 342, 365–368, 380,      component-name, 74, 78
                         428, 441                                           component-part (R735), 69, 74, 80, 83
               COMMAND_ARGUMENT_COUNT,166,368,383                           component-spec (R757), 88, 88, 165
               comment, 54, 55, 290                                         computed GO TO statement, 7, 204, 205, 540, 541
               common association, 126                                      computed-goto-stmt (R1158), 38, 205, 205
               common block, 8, 33, 38, 44, 96, 97, 99, 109, 110, 112,      concat-op (R1011), 51, 149, 149
                         113, 124–127, 164, 297, 298, 505, 506, 509–512,    CONCURRENT,188
                         516, 519–521, 526, 542                             concurrent-control (R1126), 177, 178, 189, 189, 190
               common block storage sequence, 126                           concurrent-header (R1125), 177–179, 188, 189, 189, 512
               COMMONstatement, 8, 125, 125–127, 184, 296, 298, concurrent-limit (R1127), 153, 178, 189, 189–191
                         511, 521, 540                                      concurrent-locality (R1129), 188, 189, 189
               common-block-name, 112, 117, 125, 184, 296                   concurrent-step (R1128), 153, 178, 189, 189–191
               common-block-object (R874), 125, 125, 296, 514               conformable, 9, 45, 141, 153, 161, 167, 171, 324, 336,
               common-stmt (R873), 37, 125, 514                                       380, 387, 388, 392, 401, 402, 404, 405, 413,
               companion processor, 7, 9, 15, 42, 47, 48, 69, 91, 99,                 415, 429, 435, 465
                         479, 484, 506, 507                                 CONJG, 368
               compatibility                                                connect-spec (R1205), 226, 226, 227
                    Fortran 77, 32                                          connected, 9, 13, 16, 18, 218–222, 225, 226, 228–231,
                    Fortran 2003, 31                                                  236, 240, 242, 243
                    Fortran 2008, 30                                        connection mode, 224
                    Fortran 90, 32                                          constant, 9, 44, 51, 57
                    Fortran 95, 31                                               integer, 62
               COMPILER_OPTIONS, 164, 437                                        named, 116
               COMPILER_VERSION, 164, 437                                   constant (R604), 51, 51, 114, 130, 147
               completion step, 42, 231                                     constant expression, 7, 10, 24, 32, 57, 58, 66, 73, 75, 76,
               complex part designator, 11, 43, 132                                   78, 93, 97, 101, 103, 104, 113, 114, 116, 124,
               complex type, 64–65                                                    164, 165, 166, 166, 234, 300, 301, 321, 338,
               complex-literal-constant (R718), 51, 64                                350, 351, 353, 364, 365, 369, 370, 380, 381, 386,
               complex-part-designator (R915), 129, 132, 132, 133, 137                389, 391, 394–396, 399–401, 405, 409, 418, 420,
               component, 9, 10, 15, 16, 20, 21, 69–71, 74, 89, 118,                  422, 424, 426, 428, 434–436, 488, 543
                         511                                                constant-expr (R1029), 24, 58, 77, 78, 96, 97, 104, 105,
                    direct, 9, 9, 69, 78, 316, 444, 486                               108, 116, 166, 166, 197
                    parent, 6, 9, 80, 84, 86, 89, 522, 552                  constant-subobject (R847), 114, 114
                    potential subobject, 9, 69, 70, 335                     construct
                    ultimate, 9, 31, 68–70, 75, 99, 101, 104, 105, 110,          ASSOCIATE,46,181,182,185,199,321,512,513,
                         124, 125, 139, 142, 166, 167, 243, 315, 316,                 516, 528
                         334, 520                                                BLOCK, xix, 14, 19, 20, 31, 41, 43, 84, 97, 99,
                c
               ISO/IEC 2017 – All rights reserved                                                                                 621
              ISO/IEC DIS 1539-1:2017 (E)
                        101, 103, 109, 111, 118, 120–122, 143, 164, 181,             435, 513
                        183, 334, 512, 518, 519, 525, 527, 532             COS, 369
                   CHANGE TEAM, xx, 22, 46, 137, 181, 183, 185, COSH, 369
                        191, 204, 512, 513, 528                            COSHAPE, 369
                   CRITICAL, 181, 187, 187, 191, 204, 341                  cosubscript, 10, 45, 46, 101, 137, 345, 347, 390, 431,
                   DO, 41, 52, 93, 181, 188, 204, 238, 539, 554, 555                 432, 435
                   DOCONCURRENT,xviii, 30, 31, 188, 191, 195, cosubscript (R925), 131, 137, 137
                        204, 335, 512, 519, 525, 527, 532, 542             COUNT,338, 370
                   FORALL, 177, 335, 512, 525, 540, 542                    CPU_TIME, 370
                   IF, 41, 181, 195, 452, 539                              CRITICAL construct, 187, 191, 204
                   nonblock DO, xviii, 540                                 CRITICAL statement, 161, 187, 206, 207, 216
                   SELECT CASE, 41, 181, 196, 540, 541, 553                critical-construct (R1116), 37, 187, 187
                   SELECT RANK, xviii, 41, 46, 104, 105, 181, 183,         critical-construct-name, 187
                        199, 321, 528                                      critical-stmt (R1117), 7, 187, 187, 204
                   SELECTTYPE,41,46,58,59,181,183,201,321, CSHIFT, 371
                        512, 513, 516, 528                                 current record, 221
                   WHERE,17, 175                                           current team, 22, 84, 137, 140, 141, 144, 145, 185, 186,
              construct association, 6, 6, 143, 144, 513, 516, 519, 522              208, 209, 211–213, 215, 341, 365, 380, 385, 390,
              construct entity, 6, 10, 111, 121, 182, 184, 185, 189,                 407, 412, 428, 431, 432, 435, 438, 441
                        192, 201, 509, 510, 512, 519                       CURRENT_TEAM,385, 438
              construct-name, 204                                          CYCLEstatement, 182, 188, 191, 192, 542
              constructor                                                  cycle-stmt (R1133), 37, 191, 191
                   array, 92                                               D
                   derived-type, 88                                        d (R1310), 267, 267, 272–276, 279, 280, 286
                   structure, 88                                           Dedit descriptor, 273
              CONTAINS statement, 39, 40, 81, 332                          data edit descriptor, 266, 270–280
              contains-stmt (R1543), 36, 81, 294, 332                      data entity, 8, 9, 10, 17–19, 25, 43–45
              contiguous, 10, 20, 30, 71, 77, 101, 130, 137, 173, 174,     data object, 7–9, 10, 10, 11, 19, 21, 24, 38–40, 43–46
                        183, 193, 235, 242, 393, 484, 520, 543             data object designator, 11, 19, 45, 129
              CONTIGUOUS attribute, 75, 77, 101, 101, 102, 113,            data object reference, 19, 44, 46
                        136, 137, 173, 192, 300, 315, 317–319, 321, 322,   data pointer, 17, 17, 46, 481, 493, 503, 520
                        489, 491, 520                                      DATAstatement, 32, 33, 40, 92, 97, 113, 126, 298, 411,
              CONTIGUOUSstatement, 113                                               512, 515, 523, 540, 541
              contiguous-stmt (R836), 37, 113                              data transfer, 241
              continuation, 54, 55                                         data transfer input statement, 231
              CONTINUEstatement, 205, 539                                  data transfer output statement, 231
              continue-stmt (R1159), 37, 189, 205                          data transfer statement, 33, 52, 217–223, 225, 231, 236,
              control character, 49, 67, 217, 220                                    239–241, 246, 250, 252, 260–263, 265, 266, 277,
              control edit descriptor, 266, 280–283                                  282, 284–286, 288, 290, 439, 524, 526, 534, 563,
              control information list, 232                                          564, 567, 568
              control mask, 176                                            data type, 23, see type
              control-edit-desc (R1313), 266, 267                          data-component-def-stmt (R737), 74, 74–76
              conversion                                                   data-edit-desc (R1307), 266, 267
                   numeric, 169                                            data-i-do-object (R841), 113, 113, 114
              corank, 10, 45, 46, 76, 99, 100, 102, 131, 137, 139, 147,    data-i-do-variable (R842), 113, 113, 114, 166, 512
                        183, 187, 300, 318, 369, 390, 395, 407, 431,       data-implied-do (R840), 113, 113, 114, 166, 512
                                                                                   c
              622                                                                 ISO/IEC 2017 – All rights reserved
                                                                                                ISO/IEC DIS 1539-1:2017 (E)
               data-pointer-component-name, 171, 172                                    260
               data-pointer-initialization compatible, 77                     default-initialized, 10, 78, 106, 328, 517–519, 523, 525,
               data-pointer-object (R1034), 171, 171–173, 178, 354,                     527
                         529                                                  DEFERREDattribute, 81, 82, 85
               data-ref (R911), 7, 130, 131–133, 172, 235, 311, 313,          deferred type parameter, 24, 24, 31, 58, 66, 90, 108,
                         321, 326                                                       126, 132, 139–141, 144, 145, 167, 168, 173,
               data-stmt (R837), 36, 113, 303, 334, 514                                 193, 207, 285, 300, 317, 396, 411, 428, 481,
               data-stmt-constant (R845), 92, 114, 114, 115                             483, 489, 517, 522
               data-stmt-object (R839), 113, 113–115                          deferred-coshape-spec (R810), 74, 99, 100, 100
               data-stmt-repeat (R844), 114, 114                              deferred-shape array, 5, 103
               data-stmt-set (R838), 113, 113                                 deferred-shape-spec (R820), 5, 74, 102, 103, 103, 116
               data-stmt-value (R843), 113, 114, 114                          deﬁnable, 10, 106–109, 136, 168, 183, 237, 314, 316,
               data-target (R1037), 88, 89, 109, 171, 172, 172, 173,                    318, 323, 519, 528
                         178, 321, 334, 354, 520                              deﬁned, 10, 11, 25, 44, 46
               DATE_AND_TIME,372                                              deﬁned assignment, 11, 22, 167, 170, 171, 175, 178, 299,
               DBLE, 339, 373                                                           306, 311, 316, 335
               DCedit descriptor, 283                                         deﬁned assignment statement, 31, 171, 324, 528
               dealloc-opt (R941), 142, 142, 144                              deﬁned input/output, 11, 224, 229, 237–239, 243, 245,
               DEALLOCATE statement, 142, 144, 145, 206, 438,                           246, 246, 247, 243–249, 260, 280, 286, 287,
                         498, 532                                                       291, 299, 305, 307, 311, 324, 335, 439, 588
               deallocate-stmt (R940), 37, 142, 529                           deﬁned operation, 11, 19, 151, 160, 161–163, 189, 299,
               decimal edit descriptor, 283                                             305, 311, 324, 335
               decimal edit mode, 228                                         deﬁned-binary-op (R1023), 17, 52, 150, 150, 151, 160,
               decimal symbol, 10, 228, 235, 255, 270–276, 283, 284                     295
               decimal-edit-desc (R1320), 267, 268                            deﬁned-io-generic-spec (R1509), 11, 82, 243, 244, 249,
               DECIMAL= speciﬁer, 227, 228, 232, 233, 235, 247,                         302, 302, 305, 307
                         254, 255, 283                                        deﬁned-operator (R609), 52, 82, 296, 302, 543
               declaration, 10, 39, 95–127                                    deﬁned-unary-op (R1003), 17, 52, 148, 148, 151, 160,
               declaration-construct (R507), 36, 36, 184                                295
               declaration-type-spec (R703), 59, 59, 66, 74, 75, 95, 97,      deﬁnition, 10, 11
                         118, 164, 308, 309, 327, 330                         deﬁnition of variables, 523
               declared type, 23, 60, 61, 77, 89, 90, 93, 95, 130, 132,       deleted features, 29, 30, 32, 33, 539, 540
                         139, 140, 142, 160, 162, 167, 170–173, 182, 202,     DELIM= speciﬁer, 227, 228, 232, 233, 235, 247, 254,
                         203, 249, 306, 311, 314, 317, 326, 333, 379, 403,              256, 289, 291, 565
                         407, 421, 438, 440, 513                              delimiter mode, 228
               DEFAULT, 189, 197, 202                                         derived type, 11, 21, 23, 42, 43, 46, 57, 68–90, 93, 486,
               default character, 65                                                    487
               default complex, 64                                            derived type deﬁnition statement, see TYPE statement
               default initialization, 10, 10, 76–79, 88, 89, 97, 104, 105,   derived type determination, 71
                         113, 124, 125, 127, 316, 411, 517, 522, 526          derived-type type speciﬁer, 59
               default real, 63                                               derived-type-def (R726), 36, 59, 60, 69, 70, 73, 487
               default-char-constant-expr (R1030), 99, 166, 166, 232,         derived-type-spec (R754), 24, 59, 60, 66, 87, 88, 202,
                         233                                                            243, 511
               default-char-expr (R1025), 162, 162, 166, 205, 226–232,        derived-type-stmt (R727), 69, 69, 70, 73, 98, 514
                         234–236                                              descendant, 11, 39, 70, 80, 81, 83, 109, 297, 510
               default-char-variable (R906), 129, 129, 138, 227, 254–         designator, 8, 11, 11, 47, 104, 105, 110, 113, 124, 125,
                c
               ISO/IEC 2017 – All rights reserved                                                                                   623
              ISO/IEC DIS 1539-1:2017 (E)
                       133, 133, 162, 164, 165, 288, 320, 321, 334,             88, 96, 98–100, 103–108, 110, 111, 113, 116,
                       336                                                      118, 122, 124, 125, 139–141, 143, 144, 160, 163,
                  data object, 129                                              164, 170, 189, 193, 207, 240, 245, 246, 299–308,
              designator (R901), 78, 113, 114, 129, 129, 131, 132,              310, 311, 313–321, 328, 331, 332, 334–336, 438,
                       147, 172, 182, 287, 334, 369, 390, 395, 431,             489–491, 511–513, 519, 528, 529, 543, 573, 584
                       435                                                  characteristics of, 300
              designator, 147                                               restrictions, 321
              digit, 27, 28, 49, 49, 52, 62, 92, 285                   dummy data object, 6, 8, 12, 60, 77, 97, 104–106, 110,
              digit-string (R711), 62, 62, 63, 271, 272, 278                    300, 305–307
              digit-string, 62                                              assumed-rank, 6, 45, 60, 83, 84, 101, 102, 136, 199,
              DIGITS, 373                                                       200, 300, 301, 307, 315–317, 321, 322, 328,
              DIM, 373                                                          393–395, 418, 424, 426, 427, 434, 479, 484, 489,
              DIMENSION attribute, 75, 96, 102, 102, 115, 125                   491, 601, 602, 604
              DIMENSION statement, 115, 298                            dummy function, 12, 66, 96
              dimension-spec (R814), 102                               dummyprocedure,8,12,14,18,105,118,121,123,165,
              dimension-stmt (R848), 37, 115, 514                               172, 299, 300, 302–304, 308, 309, 312, 319, 320,
              direct access, 219                                                326, 328, 330, 334, 507, 510, 515
              direct access data transfer statement, 236               dummy-arg (R1536), 330, 330–332
              direct component, 9, 9, 69, 78, 316, 444, 486            dummy-arg-name(R1531),116,117,299,328,328,330,
              DIRECT=speciﬁer, 254, 256                                         333, 514
              disassociated, 11, 12, 24, 46, 61, 77–79, 97, 103, 115,  dynamic type, 17, 23, 24, 60, 61, 84, 85, 87, 90, 93,
                       142, 144, 145, 163, 171, 173, 309, 321, 337,             110, 140, 142, 144, 160, 162, 168, 170, 171,
                       346, 379, 410, 411, 421, 428, 450, 517, 518,             173, 183, 201, 202, 207, 210, 249, 311, 317,
                       520, 527                                                 326, 347, 379, 403, 407, 421, 429, 490, 513,
              distinguishable, 307                                              517, 522, 552, 601
              DOCONCURRENTconstruct, 30, 31, 188, 191, 195, E
                       204, 335, 512, 519, 525, 527, 532, 542          e (R1311), 267, 267, 273–276, 279, 280, 286
              DOCONCURRENTstatement, 59, 178, 188                      Eedit descriptor, 273
              DOconstruct, 41, 52, 93, 188, 204, 238, 539, 554, 555    edit descriptor, 266
              DOstatement, 188, 524, 540, 542                               /, 281
              DOWHILEstatement, 188                                         :, 281
              do-construct (R1119), 37, 188, 190, 191, 204                  A, 278
              do-construct-name, 188–191                                    B, 277
              do-stmt (R1120), 7, 188, 188, 190, 204, 528                   BN, 282
              do-variable (R1124), 93, 113, 188, 188–190, 237, 260,         BZ, 282
                       261, 263, 285, 524, 526, 528, 564                    character string, 266, 283
              DOT_PRODUCT,373                                               control, 266, 280–283
              DOUBLEPRECISION, 53, 61, 63, 69                               D, 273
              DPedit descriptor, 283                                        data, 266, 270–280
              DPROD, 374                                                    DC, 283
              DSHIFTL, 374                                                  decimal, 283
              DSHIFTR, 375                                                  DP, 283
              DTedit descriptor, 280                                        DT, 280
              dtv-type-spec (R1221), 243                                    E, 273
              dummy argument, 5, 6, 8, 12, 12, 16–18, 24, 25, 30,           EN, 274
                       41, 46, 47, 50, 58–61, 66, 72, 75, 77, 82–84, 86,    ES, 275
                                                                               c
              624                                                             ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
                    EX, 276                                                 else-stmt (R1137), 195, 195
                    F, 272                                                  ELSEWHEREstatement, 53, 175
                    G, 278, 279                                             elsewhere-stmt (R1048), 175, 175
                    H, 539                                                  ENedit descriptor, 274
                    I, 271                                                  ENCODING=speciﬁer, 227, 228, 254, 256, 533
                    L, 278                                                  ENDASSOCIATEstatement, 53, 182
                    O, 277                                                  ENDBLOCKDATAstatement, 53, 297
                    P, 282                                                  ENDBLOCKstatement, 53, 144, 184
                    position, 280                                           ENDCRITICALstatement, 53, 161, 187, 206, 207
                    RC, 282                                                 ENDDOstatement, 53, 189
                    RD, 282                                                 ENDENUMstatement, 53, 90
                    RN, 282                                                 ENDFORALLstatement, 53, 177
                    round, 282                                              ENDFUNCTIONstatement, 53, 328
                    RP, 282                                                 ENDIFstatement, 53, 195, 539
                    RU, 282                                                 ENDINTERFACEstatement, 53, 302
                    RZ, 282                                                 ENDMODULEstatement, 53, 294
                    S, 282                                                  ENDPROCEDUREstatement, 53, 331
                    SP, 282                                                 ENDPROGRAMstatement, 53, 293
                    SS, 282                                                 ENDSELECTstatement, 53, 197, 202
                    T, 281                                                  ENDstatement, 13, 40, 40, 41, 53, 55, 84, 85, 109, 126,
                    TL, 281                                                           143, 144, 207, 482, 527
                    TR, 281                                                 ENDSUBMODULEstatement, 53, 297
                    X, 281                                                  ENDSUBROUTINEstatement, 53, 330
                    Z, 277                                                  ENDTEAMstatement, 40, 53, 185, 206, 215, 341
               eﬀective argument, 5, 6, 12, 24, 58, 60, 61, 66, 101–106,    ENDTYPEstatement, 53, 70
                         207, 314–317, 319, 320, 323, 326, 418, 482, 490,   ENDWHEREstatement, 53, 175
                         513, 519, 522, 524, 527                            end-associate-stmt (R1106), 7, 182, 182, 204
               eﬀective item, 12, 238, 241, 242, 246, 247, 249, 261, 268,   end-block-data-stmt (R1422), 13, 35, 40, 297, 297
                         269, 281, 284, 285, 289                            end-block-stmt (R1110), 7, 184, 184, 204
               eﬀective position, 308                                       end-change-team-stmt (R1114), 185, 185, 186
               element sequence, 320                                        end-critical-stmt (R1118), 7, 187, 187, 204
               ELEMENTAL, 13, 327, 327, 328, 332, 334, 336                  end-do (R1131), 188, 189, 190, 192
               elemental, 12, 22, 45, 66, 84, 86, 160, 161, 166, 171, 174,  end-do-stmt (R1132), 7, 189, 189, 190, 204
                         175, 177, 299–301, 309, 316, 319, 324, 325, 332,   end-enum-stmt (R763), 90, 90
                         336, 337, 342, 361, 362, 408, 450–452              end-forall-stmt (R1054), 177, 177, 178
               elemental array assignment (FORALL), 177                     end-function-stmt (R1533), 7, 13, 20, 35, 40, 204, 302,
               elemental assignment, 12, 171                                          328, 328, 329, 332
               elemental operation, 12, 153, 163, 177                       end-if-stmt (R1138), 7, 195, 195, 204
               elemental operator, 12, 153, 444                             end-interface-stmt (R1504), 302, 302
               elemental procedure, 12, 45, 163, 173, 309, 312, 321,        end-module-stmt (R1406), 13, 35, 40, 294, 294
                         325, 327, 335, 335–338                             end-mp-subprogram-stmt (R1540), 7, 13, 20, 36, 40, 204,
               elemental reference, 13, 177, 316, 324–326, 336                        330, 331, 331, 332
               elemental subprogram, 13, 327, 328, 335, 336                 end-program-stmt (R1403), 7, 13, 20, 35, 40, 42, 85, 204,
               ELSE IF statement, 53, 195                                             205, 293, 293
               ELSE statement, 195                                          end-select-rank-stmt (R1151), 7, 199, 199, 200, 204
               else-if-stmt (R1136), 195, 195                               end-select-stmt (R1143), 7, 196, 197, 197, 204
                c
               ISO/IEC 2017 – All rights reserved                                                                                 625
              ISO/IEC DIS 1539-1:2017 (E)
              end-select-type-stmt (R1155), 7, 201, 202, 202–204          error indicator, 496
              end-submodule-stmt (R1419), 13, 35, 40, 297, 297            ERRORSTOPstatement, 41, 42, 205, 532
              end-subroutine-stmt (R1537), 7, 13, 20, 35, 40, 204, 302,   error termination, 42, 85, 141, 143, 205, 246, 260, 261,
                        330, 330, 332                                              341, 356–360, 377, 378, 407, 419, 531, 534
              end-type-stmt (R730), 69, 70                                error-stop-stmt (R1161), 37, 85, 205
              end-where-stmt (R1049), 175, 175                            ERROR_UNIT, 224, 225, 229, 438
              END=speciﬁer, 7, 232, 233, 250, 251, 261                    ES edit descriptor, 275
              endﬁle record, 218                                          established coarray, 8, 46, 137, 186
              ENDFILE statement, 53, 218, 219, 221, 228, 247, 250,        evaluation
                        252, 564                                               operations, 153
              endﬁle-stmt (R1225), 37, 251, 335                                optional, 161
              entity-decl (R803), 66, 75, 95, 96, 96, 97, 165, 166, 514        parentheses, 162
              entity-name, 112, 117                                       EVENTPOSTstatement,206,207,211,212,215, 377,
              ENTRYstatement, 12, 40, 160, 170, 294, 299, 303, 327,                438, 525, 528, 533
                        328, 331, 511, 521, 540, 542                      event variable, 25, 41, 207, 212, 215, 377, 438, 525
              entry-name, 328, 331, 511                                   EVENTWAITstatement,206,207,212,212,215, 438,
              entry-stmt (R1541), 36, 294, 297, 303, 331, 331, 511,                525, 528, 533
                        514                                               event-post-stmt (R1170), 37, 211
              ENUMstatement, 90                                           event-variable (R1171), 211, 211, 212, 215, 438, 528
              enum-def (R759), 36, 90, 90, 91                             event-wait-spec (R1173), 212, 212
              enum-def-stmt (R760), 90, 90                                event-wait-stmt (R1172), 37, 212, 212
              enumeration, 90                                             EVENT_QUERY,xx, 377, 560, 594
              enumerator, 90                                              EVENT_TYPE,25, 70, 106, 139, 140, 211, 438
              enumerator (R762), 90, 90                                   EXedit descriptor, 276
              ENUMERATORstatement, 90                                     executable construct, 181
              enumerator-def-stmt (R761), 90, 90                          executable statement, 20, 20, 39
              EOR=speciﬁer, 7, 232, 233, 250, 251, 261, 261, 564          executable-construct (R514), 20, 36, 37, 331
              EOSHIFT, 375                                                EXECUTE_COMMAND_LINE,347,378
              EPSILON, 376                                                execution control, 181
              equiv-op (R1021), 51, 150, 150                              execution-part (R509), 35, 36, 36, 293, 328–330
              equiv-operand (R1016), 150, 150                             execution-part-construct (R510), 36, 36, 181
              equivalence association, 124                                exist, 218, 225
              EQUIVALENCE statement, 123, 123–126, 184, 296, EXIST= speciﬁer, 254, 256
                        298, 521, 540, 542                                EXIT statement, 182, 192, 204
              equivalence-object (R872), 124, 124, 125, 296               exit-stmt (R1156), 37, 204, 204
              equivalence-set (R871), 124, 124                            EXP, 378
              equivalence-stmt (R870), 37, 124, 514                       explicit formatting, 265–283
              ERF, 376                                                    explicit initialization, 13, 78, 79, 96, 97, 113, 517, 522,
              ERFC, 376                                                            523
              ERFC_SCALED, 377                                            explicit interface, 15, 31, 77, 81, 118, 123, 174, 300–304,
              ERR= speciﬁer, 7, 227, 231, 232, 250, 251, 253–255,                  309–311, 313, 319, 320, 333, 334, 510, 511, 528,
                        260                                                        543, 573
              errmsg-variable (R929), 138, 138, 140, 142, 143, 145,       explicit-coshape-spec (R811), 99, 100, 100
                        208, 209, 212, 214–216, 528, 532                  explicit-shape array, 5, 60, 76, 100, 103, 166, 315, 320,
              ERRMSG=speciﬁer, xix, 138, 141–143, 145, 187, 208,                   488
                        215, 525, 532                                     explicit-shape-spec (R816), 5, 74, 75, 97, 102, 102–104,
                                                                                  c
              626                                                                ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
                        125                                                FAIL IMAGE statement, 206
               EXPONENT,378, 457                                           fail-image-stmt (R1163), 37, 206
               exponent (R717), 63, 63                                     failed image, 14, 41, 138, 140, 144, 145, 186, 214, 341,
               exponent-letter (R716), 63, 63                                        407
               expr (R1022), 28, 84, 88, 89, 93, 138, 147, 150, 150, 162,  FAILED_IMAGES, 380
                        163, 166–173, 177, 178, 182, 185, 197, 237, 311,   ﬁeld, 268
                        312, 333, 334, 475, 527                            ﬁle
               expression, 147, 147–166                                         connected, 225
                   constant, 7, 10, 24, 32, 57, 58, 66, 73, 75, 76, 78,         external, 13, 13, 32, 217–222, 224–226, 230, 234,
                        93, 97, 101, 103, 104, 113, 114, 116, 124, 164,              253, 270, 280, 289, 335, 506, 563, 596
                        165, 166, 166, 234, 300, 301, 321, 338, 350,            internal, 16, 16, 217, 223, 224, 226, 234, 238, 241,
                        351, 353, 364, 365, 369, 370, 380, 381, 386, 389,            243, 245, 247, 260, 262, 280, 281, 524, 526
                        391, 394–396, 399–401, 405, 409, 418, 420, 422,    ﬁle access method, 218–220
                        424, 426, 428, 434–436, 488                        ﬁle connection, 223–231
                   speciﬁcation, 20, 24, 41, 73, 75, 84, 98, 133, 164,     ﬁle inquiry statement, 253
                        165, 165, 184, 332, 445, 541                       ﬁle position, 218, 221
               extended real model, 340                                    ﬁle positioning statement, 218, 251
               extended type, 6, 9, 15, 23, 23, 73, 80, 84–86, 522, 544,   ﬁle storage unit, 13, 21, 217, 220–223, 229, 234, 236,
                        549                                                          242, 252, 258–260, 439, 520
               extended-intrinsic-op (R610), 52, 52                        ﬁle-name-expr (R1206), 227, 227, 228, 254–256
               EXTENDSattribute, 23, 85, 85, 487                           ﬁle-unit-number (R1202), 223, 223, 224, 226, 227, 231,
               EXTENDS_TYPE_OF,75, 379                                               233, 245, 250, 251, 253–260, 335, 439
               extensible type, 23, 59, 70, 77, 85, 243, 379, 421, 552,    FILE=speciﬁer, 226, 227, 228, 229, 230, 254, 255, 255,
                        590                                                          528, 565
               extension operation, 151                                    FILE_STORAGE_SIZE, 439
               extension type, 23, 60, 85, 87, 202, 317, 379, 590          FINAL statement, 13, 83
               extent, 13, 45, 316                                         ﬁnal subroutine, 7, 13, 13, 31, 82–85, 136, 164, 315,
               EXTERNAL attribute, 17, 29, 30, 105, 105, 108, 117,                   548, 549
                        118, 120, 172, 294, 298, 300, 303, 308, 320,       ﬁnal-procedure-stmt (R753), 81, 83
                        324, 326, 514, 515, 582                            ﬁnal-subroutine-name, 83
               external ﬁle, 13, 13, 32, 217–222, 224–226, 230, 234,       ﬁnalizable, 13, 31, 83, 84, 104, 105, 143, 189
                        253, 270, 280, 289, 335, 506, 563, 596             ﬁnalization, 13, 19, 84, 85, 136, 178, 299, 311, 324, 334,
               external input/output unit, 13, 509                                   335
               external linkage, 99, 479, 505–507                          FINDLOC, 380
               external procedure, 18, 29, 38, 81, 105, 118, 121, 172,     ﬁxed source form, 54, 54
                        211, 299, 300, 302–304, 308, 309, 312, 320, 326,   FLOOR, 381
                        509, 510, 514, 515, 543, 573, 578, 582             FLUSHstatement, 219, 250, 253, 262
               EXTERNALstatement, 105, 308                                 ﬂush-spec (R1229), 253, 253
               external subprogram, 18, 22, 38, 299                        ﬂush-stmt (R1228), 37, 253, 335
               external unit, 13, 224–226, 240, 245–247, 257, 262, 438–    FMT=speciﬁer, 232, 233
                        440                                                FORALLconstruct, 177, 335, 512, 525, 540, 542
               external-name, 308                                          FORALLstatement, 59, 153, 179, 512, 524
               external-stmt (R1511), 37, 308                              forall-assignment-stmt (R1053), 153, 177, 177–179, 335
               external-subprogram (R503), 35, 35, 120, 331                forall-body-construct (R1052), 177, 177–179
               F                                                           forall-construct (R1050), 37, 177, 177, 178
               F edit descriptor, 272                                      forall-construct-name, 177, 178
               c
               ISO/IEC 2017 – All rights reserved                                                                               627
              ISO/IEC DIS 1539-1:2017 (E)
              forall-construct-stmt (R1051), 7, 177, 177, 178, 204                 511, 514
              forall-stmt (R1055), 38, 177, 178, 179, 179, 204            function-subprogram (R1529), 21, 35, 36, 294, 328, 330
              FORM TEAM statement, 22, 40, 137, 186, 206, 207, G
                        212, 215, 525, 528, 533
              form-team-spec (R1178), 212, 212                            Gedit descriptor, 278, 279
              form-team-stmt (R1175), 37, 212                             GAMMA,382
              FORM=speciﬁer, 227, 229, 254, 256                           generic identiﬁer, 14, 15, 294, 303–305, 307, 325, 337,
              format (R1215), 231–233, 234, 234, 241, 265, 266                     509, 514
              format control, 268                                         generic interface, 15, 82, 86, 90, 107, 160, 170, 171, 249,
              format descriptor, see edit descriptor                               295, 296, 304, 304–306, 325, 510, 591
              FORMATstatement, 29, 40, 52, 234, 265, 265, 294             generic interface block, 15, 15, 303, 304, 307
              format-item (R1304), 266, 266                               generic procedure reference, 307
              format-items (R1303), 265, 266, 266                         GENERICstatement, 81, 82, 304, 304, 307, 324
              format-speciﬁcation (R1302), 265, 265                       generic-name, 81, 82, 302, 511, 514
              format-stmt (R1301), 36, 265, 265, 294, 297, 303            generic-spec (R1508), 15, 81, 82, 86, 111, 160, 171, 295,
              FORMATTED,243, 244, 302                                              296, 302, 302–304, 324, 511, 514
              formatted data transfer, 242                                generic-stmt (R1510), 36, 304
              formatted input/output statement, 217, 233                  GET_COMMAND,382
              formatted record, 217                                       GET_COMMAND_ARGUMENT,383
              FORMATTED=speciﬁer, 254, 256                                GET_ENVIRONMENT_VARIABLE,384,535
              formatting                                                  GET_TEAM,385, 438–440
                   explicit, 265–283                                      global entity, 509
                   list-directed, 243, 283–287                            global identiﬁer, 509
                   namelist, 243, 287–291                                 GOTOstatement, 7, 53, 204, 204
              forms, 218                                                  goto-stmt (R1157), 37, 204, 204
              Fortran 2003 compatibility, 31                              graphic character, 49, 67, 290
              Fortran 2008 compatibility, 30                              H
              Fortran 77 compatibility, 32                                halting mode, 443, 448, 448, 451, 453, 454, 465, 471,
              Fortran 90 compatibility, 32                                         472, 507, 536
              Fortran 95 compatibility, 31                                hex-constant (R767), 92, 92
              Fortran character set, 49, 65                               hex-digit (R768), 92, 92, 278
              FRACTION, 381                                               hex-digit-string (R1322), 278, 278
              free source form, 53, 53                                    host, 14, 14, 38, 297, 333, 511, 514, 515
              function, 13                                                host association, 6, 6, 17, 39, 59, 60, 66, 98, 111, 113,
                   intrinsic, 337                                                  118, 126, 164, 165, 172, 297, 299, 320, 333–335,
                   intrinsic elemental, 337                                        511, 513–516, 519, 522, 613
                   intrinsic inquiry, 337                                 host instance, 14, 174, 312, 313, 320, 330, 354, 514, 518,
              function reference, 19, 43, 44, 324                                  522, 527
              function result, 13, 31, 66, 95, 118, 124, 125, 143, 300,   host scoping unit, 14, 38, 118, 121, 324, 325, 515, 522
                        329, 331, 336, 489, 511, 521, 527                 HUGE, 386
              FUNCTION statement, 12, 59, 60, 118, 160, 164, 293,         HYPOT, 386
                        327, 328, 331, 332, 511
              function-name, 96, 303, 328, 329, 331, 333, 511, 514        I
              function-reference (R1520), 88, 96, 129, 147, 311, 313,     I edit descriptor, 271
                        324                                               IACHAR, 68, 169, 386
              function-stmt (R1530), 35, 302, 303, 327, 328, 328, 329,    IALL, 386
                                                                                  c
              628                                                                ISO/IEC 2017 – All rights reserved
                                                                                       ISO/IEC DIS 1539-1:2017 (E)
              IAND, 356, 387                                          IEEE_MAX_NUM,457,458
              IANY, 387                                               IEEE_MAX_NUM_MAG,458
              IBCLR, 388                                              IEEE_MIN_NUM, 458, 459
              IBITS, 388                                              IEEE_MIN_NUM_MAG,459
              IBSET, 389                                              IEEE_MODES_TYPE,444, 448, 454, 465, 466
              ICHAR, 67, 68, 389                                      IEEE_NAN, 444
              id-variable (R1214), 232, 232                           IEEE_NEAREST, 444, 447
              ID= speciﬁer, 232, 233, 235, 250, 254, 255, 256, 528,   IEEE_NEGATIVE_DENORMAL,444
                       567, 568                                       IEEE_NEGATIVE_INF, 444
              IEEE inﬁnity, 14                                        IEEE_NEGATIVE_NORMAL,444
              IEEE NaN, 14, 160, 445, 446, 467                        IEEE_NEGATIVE_SUBNORMAL, 444, 444, 452,
              IEEE_ALL, 444                                                    456, 457
              IEEE_ARITHMETIC, 164, 166, 349, 443–475, 543            IEEE_NEGATIVE_ZERO, 444
              IEEE_AWAY, 447, 454                                     IEEE_NEXT_AFTER, 459
              IEEE_CLASS, 452, 452                                    IEEE_NEXT_DOWN,460,460
              IEEE_CLASS_TYPE, 444, 452, 475                          IEEE_NEXT_UP, 460
              IEEE_COPY_SIGN, 449, 452                                IEEE_OTHER, 444, 447
              IEEE_DATATYPE, 444                                      IEEE_OTHER_VALUE, 444
              IEEE_DENORMAL,444                                       IEEE_OVERFLOW,444
              IEEE_DIVIDE, 444                                        IEEE_POSITIVE_DENORMAL, 444
              IEEE_DIVIDE_BY_ZERO, 444                                IEEE_POSITIVE_INF, 444
              IEEE_DOWN,444, 447                                      IEEE_POSITIVE_NORMAL, 444
              IEEE_EXCEPTIONS, 164, 166, 192, 443–475, 543            IEEE_POSITIVE_SUBNORMAL, 444, 444, 452, 456
              IEEE_FEATURES, 443–444                                  IEEE_POSITIVE_ZERO, 444
              IEEE_FEATURES_TYPE, 444                                 IEEE_QUIET_EQ, 460
              IEEE_FLAG_TYPE, 444, 453, 454, 465, 471                 IEEE_QUIET_GE, 461
              IEEE_FMA, 453                                           IEEE_QUIET_GT, 461
              IEEE_GET_FLAG, 192, 446, 453, 476, 477, 536             IEEE_QUIET_LE, 461
              IEEE_GET_HALTING_MODE,192, 453, 454                     IEEE_QUIET_LT, 462
              IEEE_GET_MODES,448, 454, 454, 466                       IEEE_QUIET_NAN, 444
              IEEE_GET_ROUNDING_MODE,447,454,455,466 IEEE_QUIET_NE, 462
              IEEE_GET_STATUS, 446, 455, 455, 466, 467, 476, IEEE_REAL, 463
                       536                                            IEEE_REM, 449, 463
              IEEE_GET_UNDERFLOW_MODE,455,467                         IEEE_RINT, 449, 463
              IEEE_HALTING, 444                                       IEEE_ROUND_TYPE,444, 454, 455, 463, 466, 473
              IEEE_INEXACT, 444                                       IEEE_ROUNDING, 444
              IEEE_INEXACT_FLAG, 444                                  IEEE_SCALB, 464
              IEEE_INF, 444                                           IEEE_SELECTED_REAL_KIND, 464
              IEEE_INT, 455                                           IEEE_SET_FLAG, 446, 455, 465, 467, 476, 477, 536
              IEEE_INVALID, 444                                       IEEE_SET_HALTING_MODE, 192, 446, 454, 465,
              IEEE_INVALID_FLAG, 444                                           471, 476, 477, 536
              IEEE_IS_FINITE, 456                                     IEEE_SET_MODES, 448, 454, 465, 466
              IEEE_IS_NAN, 456                                        IEEE_SET_ROUNDING_MODE,447,454,455,466,
              IEEE_IS_NEGATIVE, 456                                            466
              IEEE_IS_NORMAL, 457                                     IEEE_SET_STATUS, 446, 447, 455, 466, 467, 477,
              IEEE_LOGB, 449, 457                                              536
              c
              ISO/IEC 2017 – All rights reserved                                                                       629
               ISO/IEC DIS 1539-1:2017 (E)
               IEEE_SET_UNDERFLOW_MODE, 454, 455, 466,                                322, 324, 337, 341, 346–348, 356–360, 370, 372,
                         467                                                          384, 390, 407, 411, 412, 416, 430–432, 435, 441,
               IEEE_SIGNALING_EQ, 467                                                 448, 509, 517, 518, 525, 527
               IEEE_SIGNALING_GE, 468                                            active, 14, 145
               IEEE_SIGNALING_GT, 468                                            failed, 14, 140, 144, 145, 214, 407
               IEEE_SIGNALING_LE, 468                                            stopped, 14, 140, 144, 145, 407
               IEEE_SIGNALING_LT, 469                                       image control statement, 14, 41, 161, 187, 192, 206,
               IEEE_SIGNALING_NAN, 444                                                206–208, 210, 215, 216, 324, 335, 341, 342, 380,
               IEEE_SIGNALING_NE, 469                                                 428, 441
               IEEE_SIGNBIT, 469                                            image index, 14, 40, 45, 137, 138, 209, 213, 218, 319,
               IEEE_SQRT, 444                                                         345, 347, 390, 431, 435, 509
               IEEE_STATUS_TYPE, 444, 448, 455, 466, 467, 476               image-selector (R924), 8, 10, 40, 130–132, 137, 137,
               IEEE_SUBNORMAL,444                                                     138, 287
               IEEE_SUPPORT_DATATYPE, 444, 445, 452, 453, image-selector-spec (R926), 137, 137
                         455, 458–464, 466–469, 470, 470, 474, 475          image-set (R1167), 209, 209
               IEEE_SUPPORT_DENORMAL,470                                    IMAGE_INDEX, 390
               IEEE_SUPPORT_DIVIDE, 471, 474                                IMAGE_STATUS, 390
               IEEE_SUPPORT_FLAG, 471, 474                                  imaginary part, 64
               IEEE_SUPPORT_HALTING, 471, 474                               implicit interface, 15, 75, 174, 294, 309–311, 319, 483,
               IEEE_SUPPORT_INF, 448, 449, 460, 472, 474, 475                         515
               IEEE_SUPPORT_IO, 472                                         IMPLICIT NONE statement, 118
               IEEE_SUPPORT_NAN, 445, 446, 448, 472, 474, 475               IMPLICIT statement, 40, 118, 123, 298
               IEEE_SUPPORT_ROUNDING,466, 473, 474                          implicit-none-spec (R866), 118, 118
               IEEE_SUPPORT_SQRT, 473, 474                                  implicit-part (R505), 36, 36
               IEEE_SUPPORT_STANDARD, 473                                   implicit-part-stmt (R506), 36, 36
               IEEE_SUPPORT_SUBNORMAL, 448, 449, 452, 460, implicit-spec (R864), 118, 118
                         470, 474, 474, 475                                 implicit-stmt (R863), 36, 118, 118
               IEEE_SUPPORT_UNDERFLOW_CONTROL,474                           implied-shape array, 104
               IEEE_TO_ZERO, 444, 447                                       implied-shape-or-assumed-size-spec (R823), 102, 104,
               IEEE_UNDERFLOW,444                                                     104
               IEEE_UNDERFLOW_FLAG,444                                      implied-shape-spec (R824), 102, 104, 105
               IEEE_UNORDERED,449, 475                                      IMPORTstatement, 40, 120, 509, 515
               IEEE_UP, 444, 447                                            import-name, 120, 121
               IEEE_USUAL, 444                                              import-stmt (R867), 36, 120, 184
               IEEE_VALUE, 458, 459, 475                                    IMPURE, 327, 327, 332, 334, 336
               IEOR, 360, 389                                               IN, 106
               IF construct, 41, 195, 539                                   INCLUDE line, 53, 55
               IF statement, 153, 196                                       inclusive scope, 14, 184, 204, 205, 227, 231, 232, 234,
               if-construct (R1134), 37, 195, 195                                     250, 251, 253, 255, 312, 332, 509, 510
               if-construct-name, 195                                       INDEX, 391
               if-stmt (R1139), 37, 196, 196                                index-name, 178, 179, 188–191, 512, 525
               if-then-stmt (R1135), 7, 195, 195, 204                       inherit, 6, 9, 15, 70, 81, 82, 84–87, 522, 552
               imag-part (R720), 64, 64                                     inheritance association, 6, 6, 9, 47, 86, 88, 519, 522
               image, 1, 14, 14, 22, 40–42, 45, 46, 84, 100, 138–141,       initial team, 22, 46, 137, 224, 347, 385, 390, 412, 431,
                         144, 170, 172, 173, 186–188, 205–211, 213–216,               439
                         218, 219, 224, 225, 257, 311, 315, 318, 319, 321,  initial-data-target (R744), 31, 77, 78, 78, 96, 97, 109,
                                                                                     c
               630                                                                  ISO/IEC 2017 – All rights reserved
                                                                                              ISO/IEC DIS 1539-1:2017 (E)
                         114, 115                                           INT8, 439
               initial-proc-target (R1518), 78, 309, 309, 310               integer constant, 62
               INITIAL_TEAM, 385, 439                                       integer editing, 271
               initialization, 97                                           integer model, 340
                    default, 10, 10, 76–79, 88, 89, 97, 104, 105, 113,      integer type, 61–62
                         124, 125, 127, 316, 517, 522, 526                  integer-type-spec (R705), 59, 61, 61, 73, 93, 113, 189,
                    explicit, 13, 78, 79, 96, 97, 113, 517, 522, 523                  512
               initialization (R805), 96, 96, 97, 166                       INTEGER_KINDS, 439
               INOUT, 53, 106                                               INTENT (IN) attribute, 105, 106, 107, 111, 189, 305–
               input statement, 231                                                   307, 315, 318, 320–322, 334, 335, 338, 356–
               input-item (R1216), 231, 232, 237, 237, 249, 263, 528                  360, 365–368, 377, 378, 383, 384, 408, 416, 451,
               input/output editing, 265–291                                          481–483, 503, 504, 543, 584, 598
               input/output list, 236                                       INTENT (INOUT) attribute, 30, 105, 106, 107, 110,
               input/output statement, 524                                            193, 306, 316, 318, 324, 335, 336, 356–360,
               input/output statements, 217–262                                       365–368, 378, 382–384, 407, 408, 438, 440, 528,
               input/output unit, 16, 24, 40                                          529, 598
               INPUT_UNIT, 224, 225, 229, 245, 439                          INTENT (OUT) attribute, 31, 60, 83–85, 104, 105,
               INQUIRE statement, 32, 219, 220, 222, 223, 225, 226,                   105–107, 110, 143, 164, 306, 316, 318, 324,
                         235, 236, 246, 247, 250, 253, 262, 263, 439,                 334–336, 356–360, 365–368, 370, 372, 377, 378,
                         524, 526–528, 534, 563                                       382–384, 407, 408, 416, 430, 453–455, 481, 483,
               inquire-spec (R1231), 254, 254, 255, 263                               503, 504, 517–519, 524, 525, 527–529, 598
               inquire-stmt (R1230), 37, 254, 335                           INTENT attribute, 105, 105–107, 116, 192, 543
               inquiry function, 15, 22, 100, 103, 105, 131, 141, 164,      INTENT statement, 116, 184
                         314, 315, 337–339, 342, 352, 354, 363, 369, 373,   intent-spec (R826), 95, 106, 116, 309
                         376, 379, 386, 390, 393–396, 401, 404, 409, 414,   intent-stmt (R849), 37, 116
                         415, 417, 421, 424, 426, 428, 432, 434, 443, 444,  interface, 15, 15, 39, 44, 47, 75, 82, 107, 243–245, 280,
                         446–450, 470–474, 484                                        300, 301, 311, 319, 320, 324, 325, 331–334,
               inquiry, type parameter, 132                                           489–491, 506, 507, 573
               instance, 330                                                     abstract, 15, 15, 294, 301, 303, 309, 328, 510, 514
               INT, 115, 169, 339, 374, 375, 387, 389, 391, 392, 404             explicit, 15, 31, 77, 81, 118, 123, 174, 300–304,
               int-constant (R607), 51, 51, 114                                       309–311, 313, 319, 320, 333, 334, 510, 511, 528,
               int-constant-expr (R1031), 61, 65, 73, 90, 91, 113, 166,               543, 573
                         166, 199, 200                                           generic, 15, 82, 86, 90, 107, 160, 170, 171, 249, 295,
               int-constant-name, 62                                                  296, 304, 304–306, 325, 510
               int-constant-subobject (R846), 114, 114                           implicit, 15, 75, 174, 294, 309–311, 319, 483, 515
               int-expr (R1026), 40, 58, 93, 130, 133, 137, 138, 153,            procedure, 301
                         162, 162, 164–166, 188–190, 205, 209, 212,              speciﬁc, 15, 249, 303, 303, 304, 309, 325, 543
                         213, 223, 224, 227, 232, 237, 239, 250, 254,       interface block, 15, 39, 243, 249, 295, 302–304, 324, 325,
                         332                                                          573
               int-literal-constant (R708), 51, 62, 62, 65, 266, 267        interface body, 15, 19, 40, 101, 103, 105, 118, 164, 302,
               int-variable (R907), 129, 129, 144, 227, 232, 233, 254,                302, 327, 328, 331, 332, 491, 511, 514, 573
                         257–261, 534                                       INTERFACE statement, 302, 573
               int-variable-name, 188                                       interface-block (R1501), 36, 302, 302
               INT16, 439                                                   interface-body (R1505), 302, 302, 303
               INT32, 439                                                   interface-name (R1516), 81, 82, 308, 309, 309
               INT64, 439                                                   interface-speciﬁcation (R1502), 302, 302, 303
                c
               ISO/IEC 2017 – All rights reserved                                                                                 631
              ISO/IEC DIS 1539-1:2017 (E)
              interface-stmt (R1503), 302, 302–305, 514                           261, 262, 524
              internal ﬁle, 16, 16, 217, 223, 224, 226, 234, 238, 241,   IOR, 359, 392
                       243, 245, 247, 260, 262, 280, 281, 524, 526       IOSTAT= speciﬁer, 227, 231, 232, 246, 250, 251, 253,
              internal procedure, 14, 18, 38, 172, 299–302, 312, 320,             254, 260, 261, 262, 394, 439, 524, 534, 564
                       326, 328, 330, 354, 507, 510, 511, 514            IOSTAT_END, 246, 262, 439
              internal subprogram, 22, 38, 40, 118, 299, 324, 514        IOSTAT_EOR, 246, 262, 439
              internal unit, 16, 16, 224, 226, 240, 245, 246, 255, 262,  IOSTAT_INQUIRE_INTERNAL_UNIT, 246, 262,
                       439                                                        439, 442
              internal-ﬁle-variable (R1203), 223, 223, 224, 233, 263,    IPARITY, 392
                       528                                               IS_CONTIGUOUS, 60, 393
              internal-subprogram (R512), 36, 36                         IS_IOSTAT_END, 394
              internal-subprogram-part (R511), 35, 36, 36, 293, 328–     IS_IOSTAT_EOR, 394
                       330                                               ISHFT, 393
              interoperable, 15, 90, 91, 99, 328, 333, 481, 483–491,     ISHFTC, 393
                       505, 506                                          ISO 10646 character, 16, 65, 68, 167, 223, 228, 238,
              interoperate, 485                                                   270, 284, 409, 422
              intrinsic, 9, 12, 14, 15, 16, 17, 18, 22, 23, 42, 43, 45,  ISO_C_BINDING, 60, 74, 85, 99, 105, 131, 139, 140,
                       47, 58, 60, 84, 92, 105, 301, 318, 325, 326, 436,          164, 170, 335, 436, 479–486, 526, 527, 543
                       510, 512                                          ISO_Fortran_binding.h, 491
              intrinsic assignment statement, 31, 89, 143, 145, 163,     ISO_FORTRAN_ENV, 25, 30, 70, 74, 99, 106, 131,
                       167, 171, 173, 216, 253, 262, 289, 334, 335,               138–140, 145, 164, 170, 185, 205, 211, 212,
                       524, 532                                                   214–216, 222, 224, 229, 240, 245, 246, 262, 341,
              INTRINSIC attribute, 105, 107, 107, 108, 294, 310,                  356–360, 380, 385, 390, 391, 407, 412, 428, 429,
                       324, 325, 515                                              431, 436–441, 527, 536, 564
              intrinsic function, 337                                    K
              intrinsic operation, 153–160                               k (R1314), 267, 267, 274, 279, 282
              intrinsic procedure, 337–436                               keyword, 16
              INTRINSIC statement, 298, 310                                  argument, 12, 16, 47, 301, 304, 313, 337, 342, 450,
              intrinsic subroutines, 337                                          510, 511, 512, 573
              intrinsic type, 9, 23, 42, 43, 57, 61–68, 490, 494             component, 16, 47, 80, 89, 511
              intrinsic-operator (R608), 17, 51, 52, 148, 150, 153, 154,     statement, 16, 47
                       160, 305                                              type parameter, 16, 47, 88
              intrinsic-procedure-name, 310, 514                         keyword (R516), 47, 47, 87, 88, 311
              intrinsic-stmt (R1519), 37, 310, 514                       KIND, 61–65, 68, 73, 91, 132, 169, 394
              intrinsic-type-spec (R704), 59, 61, 66                     kind type parameter, 24, 29, 42, 58, 61–66, 68, 73, 83,
              io-control-spec (R1213), 231, 232, 232, 233, 236, 245,              84, 91, 93, 165–169, 287, 306, 315, 328, 374,
                       263                                                        379, 421, 439, 479, 480, 485, 543
              io-implied-do (R1218), 237, 237, 238, 241, 263, 524,       kind-param (R709), 62, 62, 63, 65–68
                       526, 528, 564                                     kind-selector (R706), 28, 61, 61, 62, 68
              io-implied-do-control (R1220), 237, 237, 239
              io-implied-do-object (R1219), 237, 237, 241                L
              io-unit (R1201), 24, 223, 223, 224, 232, 233, 335          L edit descriptor, 278
              IOLENGTH=speciﬁer, 222, 253, 260                           label, see statement label
              iomsg-variable (R1207), 227, 227, 231, 232, 250, 251,      label (R611), 7, 52, 52, 188, 190, 204, 205, 227, 231,
                       253, 254, 261, 262, 524                                    232, 234, 250, 251, 253–255, 261, 311, 312
              IOMSG= speciﬁer, 227, 231, 232, 250, 251, 253, 254,        label-do-stmt (R1121), 188, 188, 190
                                                                                 c
              632                                                               ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
               language-binding-spec (R808), 95, 99, 112, 328              LOCK_TYPE,25, 31, 70, 106, 139, 140, 214, 440
               LBOUND, 60, 168, 173, 183, 200, 394                         LOG, 32, 398
               lbracket (R771), 74, 92, 93, 95, 96, 112, 113, 117, 137,    LOG10, 399
                        138                                                LOG_GAMMA,398
               LCOBOUND,395                                                LOGICAL, 399
               LEADZ, 395                                                  logical intrinsic operation, 157
               left tab limit, 281                                         logical type, 68
               LEN, 132, 396                                               logical-expr (R1024), 162, 162, 175, 188, 190–192, 195,
               LEN_TRIM, 396                                                         196, 205
               length type parameter, 24, 24, 42, 58, 68, 77, 93, 108,     logical-literal-constant (R725), 51, 68, 148, 150
                        141, 167, 168, 315, 396, 484, 485, 543             logical-variable (R904), 129, 129, 213–215, 254, 256,
               length-selector (R722), 28, 65, 65, 66                                257, 528
               letter, 49, 49, 50, 52, 118, 148, 150                       LOGICAL_KINDS, 440
               letter-spec (R865), 118, 118                                loop-control (R1123), 188, 188, 190, 191, 194
               level-1-expr (R1002), 148, 148, 151                         lower-bound (R817), 102, 102–105
               level-2-expr (R1006), 148, 148, 149, 151, 152               lower-bound-expr (R934), 138, 138, 172
               level-3-expr (R1010), 149, 149                              lower-cobound (R812), 100, 101, 101
               level-4-expr (R1012), 149, 149, 150                         M
               level-5-expr (R1017), 150, 150
               lexical token, 14, 16, 27, 50, 52                           m(R1309), 267, 267, 271, 272, 277, 278
               LGE, 68, 396                                                main program, 16, 18, 22, 38, 41, 43
               LGT, 68, 397                                                main-program (R1401), 35, 38, 120, 293, 293
               line, 16, 53–56                                             mask-expr (R1046), 175, 175–179, 189, 191
               linkage association, 6, 6, 506, 513, 516, 516               masked array assignment, 17, 175, 524
               list-directed formatting, 243, 283–287                      masked array assignment (WHERE), 175
               list-directed input/output statement, 234                   masked-elsewhere-stmt (R1047), 175, 175, 176, 178
               literal constant, 9, 44, 130, 162                           MASKL, 399
               literal-constant (R605), 51, 51, 147                        MASKR,399
               LLE, 68, 397                                                MATMUL,400
               LLT, 68, 398                                                MAX,336, 338, 401
               LOCAL, 189, 192, 193, 195, 512, 519, 527                    MAXEXPONENT,401
               local identiﬁer, 509, 510                                   MAXLOC,338, 401
               local procedure pointer, 17, 330                            MAXVAL,402
               local variable, 17, 25, 31, 43, 44, 97, 99, 101, 103, 109,  MERGE,403
                        111, 141, 143, 312, 330, 334                       MERGE_BITS, 403
               local-deﬁned-operator (R1414), 295, 295, 296                MIN, 404
               local-name, 295, 296                                        MINEXPONENT,404
               LOCAL_INIT, 189, 192, 193, 512, 519, 525, 527               MINLOC, 404
               locality, 192, 193, 512, 519, 525, 527                      MINVAL, 405
               locality-spec (R1130), 189, 189                             MOD,32, 406
               LOCK statement, 206, 207, 213, 216, 440, 441, 525,          mode
                        528                                                     blank interpretation, 228
               lock variable, 25, 41, 216, 440, 441, 525, 528                   changeable, 224
               lock-stat (R1180), 213, 213                                      connection, 224
               lock-stmt (R1179), 37, 213                                       decimal edit, 228
               lock-variable (R1182), 213, 213–215, 440, 528                    delimiter, 228
               c
               ISO/IEC 2017 – All rights reserved                                                                               633
              ISO/IEC DIS 1539-1:2017 (E)
                   halting, 443, 448, 448, 451, 453, 454, 465, 471, 472,   named-constant (R606), 51, 51, 55, 64, 90, 116, 514
                        507, 536                                           named-constant-def (R852), 116, 116, 514
                   IEEE rounding, 443, 444, 447, 448, 449                  NAMED=speciﬁer, 254, 257
                   input/output rounding, 224, 230, 236, 259, 277,         namelist formatting, 243, 287–291
                        282, 472                                           namelist input/output statement, 234
                   pad, 229                                                NAMELISTstatement, 123, 184, 288, 296
                   sign, 230, 282                                          namelist-group-name, 123, 232–234, 240–242, 265, 288,
                   underﬂow, 447, 448, 451, 455, 467, 474, 475, 536                  291, 296, 514, 528
              model                                                        namelist-group-object (R869), 123, 123, 241, 243, 249,
                   bit, 338                                                          263, 287, 288, 296
                   extended real, 340                                      namelist-stmt (R868), 37, 123, 514, 528
                   integer, 340                                            NaN, 17, 272–276, 279, 349, 379, 382, 420, 424, 427,
                   real, 340                                                         445, 448, 449, 452, 453, 456, 472, 473
              MODULE,302, 303, 327, 327, 330                               NEAREST, 408
              module, 16, 17, 18, 19, 21, 22, 38, 39, 43, 293              NEW_INDEX=speciﬁer, 212, 533
              module (R1404), 35, 120, 294                                 NEW_LINE, 278, 279, 409
              module procedure, 18, 81, 122, 172, 299–304, 309, 312,       NEWUNIT=speciﬁer, 224, 227, 229, 245, 525, 528
                        320, 326, 327, 330, 331, 333, 436, 510, 511        NEXTREC=speciﬁer, 254, 257
              module procedure interface body, 121, 303                    NINT, 409
              module reference, 19, 294                                    NML=speciﬁer, 232, 234, 528
              MODULEstatement, 293, 294                                    NON_INTRINSIC, 295
              module subprogram, 22, 38, 40, 118, 324                      NON_OVERRIDABLEattribute, 81, 82
              module-name, 294, 295, 514                                   NON_RECURSIVE, 327, 327
              module-nature (R1410), 295, 295                              NON_RECURSIVEattribute, 301, 327, 327, 331, 332
              module-stmt (R1405), 35, 294, 294                            nonadvancing input/output statement, 221
              module-subprogram (R1408), 36, 294, 294, 331                 nonblock DO construct, 540
              module-subprogram-part (R1407), 35, 83, 87, 294, 294,        NONE, 118, 120, 189
                        297, 578                                           nonexecutable statement, 20, 39
              MODULO,32, 406                                               nonlabel-do-stmt (R1122), 188, 188, 190
              MOLD=speciﬁer, 138                                           nonstandard intrinsic, xviii, 16, 29, 582
              MOVE_ALLOC,141, 207, 337, 407                                NOPASS, 75, 77, 82
              mp-subprogram-stmt (R1539), 36, 330, 330, 331                NOPASS attribute, see PASS attribute
              mult-op (R1008), 51, 148, 148                                NORM2, 410
              mult-operand (R1004), 148, 148, 151                          normal number, 448
              MVBITS, 337, 338, 408                                        normal termination, 14, 40, 41, 42, 85, 205, 218, 230,
              N                                                                      231, 391, 428, 441
              n (R1316), 267, 267, 268, 281                                NOT, 410
              name, 17, 46, 50, 509                                        not-op (R1018), 51, 150, 150
              name (R603), 28, 47, 50, 50, 51, 96, 117, 129, 202, 241,     NULL, 89, 96, 163, 165, 166, 320, 338, 410, 517, 518
                        309, 328                                           null-init (R806), 77, 78, 96, 96, 97, 114, 115, 309
              name association, 6, 6, 47, 513, 519                         NULLIFY statement, 142
              name-value subsequence, 287, 288                             nullify-stmt (R938), 37, 142, 529
              NAME=speciﬁer,95, 99, 112, 254, 255, 256, 309, 309,          NUM_IMAGES,166, 411, 435
                        328, 506                                           NUMBER=speciﬁer, 254, 257
              named constant, 9, 24, 44, 46, 50, 58, 62, 64, 66, 104,      numeric conversion, 169
                        105, 108, 111, 114, 116, 124, 130, 333             numeric editing, 271
                                                                                   c
              634                                                                 ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
              numeric intrinsic operation, 154                          optional-stmt (R850), 37, 116
              numeric sequence type, 20, 71, 124–126, 521, 525          or-op (R1020), 51, 150, 150
              numeric storage unit, 21, 21, 126, 440, 520, 524, 526     or-operand (R1015), 150, 150
              numeric type, 23, 61–65, 154–156, 158, 162, 169, 373,     other-speciﬁcation-stmt (R513), 36, 36
                       374, 400, 415, 429                               OUT, 106
              numeric-expr (R1027), 162, 162                            OUT_OF_RANGE,412
              NUMERIC_STORAGE_SIZE, 440                                 output statement, 231
              O                                                         output-item (R1217), 231, 232, 237, 237, 249, 254
              Oedit descriptor, 277                                     OUTPUT_UNIT,224, 225, 229, 245, 440
              object, 10, 10, 42–45                                     override, 78, 86, 95, 96, 118, 243, 271, 522
              object designator, 11, 43, 44, 110, 114, 130, 164, 287    P
              object-name (R804), 96, 96, 112, 113, 116–118, 129,       Pedit descriptor, 282
                       136, 514                                         PACK, 413
              obsolescent feature, 29, 30, 33, 540–542                  pad mode, 229
              octal-constant (R766), 92, 92                             PAD= speciﬁer, 32, 33, 227, 229, 232, 233, 236, 247,
              ONLY, 120, 121, 122, 295, 295, 296, 516, 570, 572                  254, 257
              only (R1412), 295, 295, 296                               padding, 339, 339, 391, 418
              only-use-name (R1413), 295, 295, 296                      PARAMETER attribute, 9, 44, 91, 97, 108, 108, 116,
              OPENstatement, 33, 218, 219, 223–225, 226, 226, 230,               130
                       234, 242, 243, 247, 256, 260, 277, 289, 525,     PARAMETERstatement, 40, 116, 118, 298
                       528, 533, 534, 563, 565–567                      parameter-stmt (R851), 36, 116, 514
              open-stmt (R1204), 37, 226, 335                           parent component, 6, 9, 80, 84, 86, 89, 522, 552
              OPENED=speciﬁer, 254, 257                                 parent data transfer statement, 236, 245, 243–247, 262,
              operand, 17                                                        286
              operation, 57                                             parent team, 22, 22, 46, 137, 186, 211, 212, 380, 385,
                   deﬁned, 11, 19, 81, 151, 160, 161–163, 189, 299,              390, 412, 428, 431, 440
                       305, 311, 324, 335                               parent type, 9, 23, 70, 73, 80, 84–86, 307, 552
                   elemental, 12, 153, 163, 177                         parent-identiﬁer (R1418), 297, 297
                   intrinsic, 153–160
                     logical, 157                                       parent-string (R909), 101, 130, 130
                     numeric , 154                                      parent-submodule-name, 297
                     relational, 158                                    parent-type-name, 69, 70
              OPERATOR,57, 82, 160, 295, 302, 305, 573                  PARENT_TEAM,385, 440
              operator, 17, 51                                          parentheses, 162
                   character, 149                                       PARITY, 413
                   deﬁned binary, 150                                   part-name, 7, 130–133, 136, 137
                   deﬁned unary, 148                                    part-ref (R912), 101, 114, 124, 130, 130–133, 135, 137,
                   elemental, 12, 153, 444                                       369, 390, 395, 431, 435
                   logical, 150                                         partially associated, 521
                   numeric, 148                                         PASS attribute, 75, 77, 82, 311
                   relational, 149                                      passed-object dummy argument, 17, 77, 81, 82, 86, 308,
              operator precedence, 151                                           313, 588
              OPTIONAL attribute, 108, 108, 110, 116, 164, 183,         PAUSE statement, 539
                       189, 301                                         pending aﬀector, 98, 235, 240, 507, 508
              optional dummy argument, 321                              PENDING=speciﬁer, 254, 255, 257
              OPTIONALstatement, 116, 184                               POINTER, 74, 75, 77
               c
              ISO/IEC 2017 – All rights reserved                                                                          635
              ISO/IEC DIS 1539-1:2017 (E)
              pointer, 6, 11, 12, 17, 20, 22, 24, 46, 71, 76, 136, 142–   preconnection, 226
                        144, 166, 300, 301, 316, 334, 428, 479, 491,      preﬁx (R1526), 327, 327, 328, 330
                        502, 517, 584                                     preﬁx-spec (R1527), 327, 327, 328, 334, 336
                   procedure, 483                                         PRESENT, 60, 75, 108, 164, 321, 338, 414, 585
              pointer assignment, 17, 103, 105, 142, 170, 171, 172,       present, 320
                        321, 518                                          primary, 147
              pointer assignment statement, 17, 22, 58, 77, 89, 163,      primary (R1001), 147, 147, 148, 333
                        171, 173, 179, 348, 354                           PRINT statement, 219, 228, 231, 240, 245, 246, 250
              pointer association, 6, 6, 12, 22, 23, 44, 47, 85, 87, 89,  print-stmt (R1212), 37, 232, 335
                        101, 106, 108, 110, 111, 131, 143, 145, 171,      PRIVATE attribute, 71, 86, 98, 98, 111, 123, 335, 571
                        173, 174, 193, 207, 210, 240, 300, 314, 316,      PRIVATE statement, 80, 81, 83, 111, 296
                        318, 320, 321, 329, 330, 343, 354, 407, 411,      private-components-stmt (R745), 70, 80, 80
                        482, 483, 517–520, 522, 528, 584                  private-or-sequence (R729), 69, 70, 70
              pointer association context, 106, 109, 334, 528             proc-attr-spec (R1514), 308, 308, 309
              pointer association status, 517                             proc-component-attr-spec (R742), 75, 75, 77
              POINTER attribute, 5, 17, 58–60, 68, 69, 74, 75, 96,        proc-component-def-stmt (R741), 74, 75, 75
                        103, 105, 108, 108, 110, 115, 117, 131, 134,      proc-component-ref (R1039), 172, 172, 311, 321
                        142, 172, 183, 192, 199, 200, 299–301, 303, 306,  proc-decl (R1515), 75, 78, 308, 309, 309
                        307, 309, 317, 320–323, 328, 334, 336, 484, 488,  proc-entity-name, 116, 117
                        503, 516, 519, 522, 523, 543, 587, 591            proc-interface (R1513), 75, 308, 308, 309
              POINTERstatement, 116, 298                                  proc-language-binding-spec (R1528), 308, 309, 328, 328,
              pointer-assignment-stmt (R1033), 37, 171, 177, 178,                  330, 333, 489
                        334, 529                                          proc-pointer-init (R1517), 309, 309
              pointer-decl (R854), 116, 116                               proc-pointer-name (R858), 117, 117, 142, 172
              pointer-object (R939), 142, 142, 529                        proc-pointer-object (R1038), 171, 172, 173, 178, 354,
              pointer-stmt (R853), 37, 116, 514                                    529
              polymorphic, 17, 31, 60, 61, 77, 90, 104, 105, 131, 142,    proc-target (R1040), 88, 89, 171, 172, 173, 178, 321,
                        162, 167, 168, 173, 182, 183, 189, 192, 201, 203,          354, 520
                        237, 243, 300, 301, 311, 314–317, 334, 335, 379,  PROCEDURE,75, 81, 308, 330
                        403, 407, 421, 428, 517, 522                      procedure, 11, 18, 19, 47, 48, 108, 302
              POPCNT, 414                                                      characteristics of, 300
              POPPAR, 414                                                      dummy, 8, 12, 14, 18, 105, 118, 121, 123, 165, 172,
              POS=speciﬁer, 220–222, 232, 233, 236, 236, 254, 258,                 299, 300, 302–304, 308, 309, 312, 319, 320, 326,
                        534                                                        328, 334, 507, 510, 515
              position edit descriptor, 280                                    elemental, 12, 45, 163, 173, 309, 312, 321, 325, 327,
              position-edit-desc (R1315), 267, 267                                 335, 335–338
              position-spec (R1227), 251, 251                                  external, 18, 29, 38, 81, 105, 118, 121, 172, 211,
              POSITION= speciﬁer, 226, 227, 229, 254, 258, 565                     299, 300, 302–304, 308, 309, 312, 320, 326, 509,
              positional arguments, 337                                            510, 514, 515, 543, 573, 578, 582
              potential subobject component, 9, 31, 69, 70, 139, 335,          internal, 14, 18, 38, 172, 299–302, 312, 320, 326,
                        438, 440                                                   328, 330, 354, 507, 510, 511, 514
              power-op (R1007), 51, 148, 148                                   intrinsic, 337–436
              pre-existing, 522                                                module, 18, 81, 122, 172, 299–304, 309, 312, 320,
              precedence of operators, 151                                         326, 327, 330, 331, 333, 436, 510, 511
              PRECISION, 62, 414, 464                                          non-Fortran, 332
              preconnected, 18, 219, 224–226, 229, 234, 240, 438–440           pure, 18, 31, 178, 189, 333, 335, 337, 342, 407,
                                                                                  c
              636                                                                ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
                        418, 436, 444, 450, 483                            Q
                   type-bound, 7, 15, 17, 18, 68, 70, 77, 82, 82–86,       QUIET=speciﬁer, 205
                        170, 249, 295, 305, 311, 313, 315, 326, 510,       R
                        511                                                r (R1306), 266, 266–268
              proceduredeclarationstatement, 40, 105, 301, 303, 308,       RADIX, 62, 415, 444, 464
                        332, 348, 511, 543                                 RANDOM_INIT, 348, 416, 535
              procedure designator, 11, 19, 45                             RANDOM_NUMBER,348,416,417
              procedure interface, 301                                     RANDOM_SEED,338, 348, 416
              procedure pointer, 8, 14, 17, 17, 38, 96, 105, 106, 108,     RANGE, 61, 62, 417, 464
                        125, 172, 174, 299, 300, 303, 304, 308, 312,       RANK, 60, 417
                        313, 319–321, 326, 330, 483, 511, 514, 543, 584    rank, 18, 20, 43–46, 76, 77, 83, 84, 88, 89, 95, 99, 101–
              procedure reference, 5, 19, 31, 44, 108, 133, 246, 299,                105, 116, 126, 131–135, 137, 139, 141, 160, 162,
                        305, 311, 313                                                163, 167–169, 171–175, 183, 209, 300, 305–307,
                   generic, 307                                                      316, 317, 320, 321, 325, 336, 347, 352, 353,
                   resolving, 324                                                    369–371, 375, 376, 380, 381, 387, 388, 392, 394,
                   type-bound, 326                                                   395, 400–407, 410, 411, 413, 415, 416, 419, 424,
              PROCEDUREstatement, 302, 304, 543                                      426, 427, 429, 431, 433–435, 476, 482, 488, 513,
              procedure-component-name, 172                                          520, 587, 588
              procedure-declaration-stmt (R1512), 36, 308, 309             RANK(*),104, 199
              procedure-designator (R1522), 311, 311, 321, 326             RANKDEFAULT,105, 199
              procedure-entity-name, 309, 310                              rbracket (R772), 74, 92, 93, 95, 96, 112, 113, 117, 137,
              procedure-name, 81, 82, 172, 174, 302, 303, 309, 311,                  138
                        312, 330, 331                                      RCedit descriptor, 282
              procedure-stmt (R1506), 302, 302, 303                        RDedit descriptor, 282
              processor, 18, 29, 30, 47, 48                                READ(FORMATTED),243, 302
              processor dependent, 18, 30, 47, 531–537                     READ(UNFORMATTED),243, 244, 302
              PRODUCT,415                                                  READstatement, 33, 44, 220, 224, 228, 231, 240, 245,
              program, 18, 29, 30, 38                                                246, 250, 253, 261, 527, 563–565, 567, 569
              program (R501), 35                                           read-stmt (R1210), 37, 231, 232, 335, 528
              PROGRAMstatement, 293                                        READ=speciﬁer, 254, 258
              program unit, 16, 17, 18, 18, 19, 21, 29, 35, 38–40, 42,     READWRITE=speciﬁer, 254, 258
                        46, 49, 50, 52–55, 72, 109, 118, 224, 230, 293,    REAL, 169, 339, 418, 445
                        297, 385, 505, 509, 517, 541, 544, 570–572, 574,   real and complex editing, 272
                        577–581, 597                                       real model, 340
              program-name, 293                                            real part, 64
              program-stmt (R1402), 35, 293, 293                           real type, 62–64, 64
              program-unit (R502), 28, 35, 35, 38                          real-literal-constant (R714), 51, 63, 63
              PROTECTED attribute, 31, 109, 109, 117, 124, 192,            real-part (R719), 64, 64
                        295, 543                                           REAL128, 441
              PROTECTEDstatement, 117                                      REAL32, 441
              protected-stmt (R855), 37, 117                               REAL64, 441
              PUBLIC attribute, 86, 98, 98, 111, 123, 571                  REAL_KINDS, 440
              PUBLIC statement, 111, 296                                   REC=speciﬁer, 221, 232, 233, 236
              PURE, 327, 327, 332, 334                                     RECL= speciﬁer, 227, 229, 242, 243, 254, 258, 260,
              pure procedure, 18, 31, 178, 189, 333, 335, 337, 342,                  526, 533
                        407, 418, 436, 444, 450, 483, 543                  record, 18, 217
               c
              ISO/IEC 2017 – All rights reserved                                                                               637
              ISO/IEC DIS 1539-1:2017 (E)
              record ﬁle, 13, 19, 217, 219, 221–223                    save-stmt (R856), 37, 117, 514
              record number, 219                                       saved, 19, 517, 523
              RECURSIVE, 66, 327, 332                                  saved-entity (R857), 117, 117, 184
              recursive input/output statement, 262                    scalar, 19, 19, 21, 335
              REDUCE, 418                                              scalar-xyz (R403), 28, 28
              reference, 19, 45                                        SCALE, 421
                  procedure, 31                                        scale factor, 267, 282
              rel-op (R1013), 51, 149, 149, 159, 445                   SCAN, 422
              relational intrinsic operation, 158                      scoping unit, 6, 14, 19, 25, 38, 40, 41, 43, 47, 66, 71,
              rename (R1411), 295, 295, 296, 510                                72, 81, 84, 88, 97–99, 105, 107, 110, 111, 117,
              rep-char, 66, 67, 268, 284, 289                                   118, 120–123, 125, 126, 143, 165, 172, 184, 185,
              REPEAT, 419                                                       189, 192, 193, 235, 238, 294–296, 301, 303, 307,
              repeat speciﬁcation, 266                                          324–328, 331, 333, 443, 445, 505, 510–516, 519,
              representation method, 61, 62, 65, 68                             521, 522, 526, 571, 582, 588
              RESHAPE, 94, 420                                         section subscript, 135
              resolving procedure reference, 324                       section-subscript (R920), 25, 130, 131, 133, 133, 135–
              resolving procedure references                                    137
                  deﬁned input/output, 249                             segment, 207
              restricted expression, 164                               SELECT CASE construct, 41, 196, 541, 553
              RESULT, 328, 328, 329, 331, 332                          SELECT CASE statement, 53, 196
              result-name, 328, 329, 331, 332, 514                     SELECT RANK construct, 41, 46, 104, 105, 183, 199,
              RETURN statement, 41, 85, 109, 126, 143, 144, 185,                321, 528
                       187, 192, 332, 482, 527                         SELECT RANK statement, 46, 105, 199, 516
              return-stmt (R1542), 38, 40, 332, 332                    SELECT TYPE construct, 41, 46, 58, 59, 183, 201,
              REWINDstatement, 218, 219, 221, 247, 250, 252, 252,               321, 512, 513, 516, 528
                       564                                             SELECT TYPE statement, 46, 53, 201, 516
              rewind-stmt (R1226), 38, 251, 335                        select-case-stmt (R1141), 7, 196, 197, 197, 204
              RNedit descriptor, 282                                   select-construct-name, 199–202
              round edit descriptor, 282                               select-rank-case-stmt (R1150), 199, 199, 200
              round-edit-desc (R1319), 267, 268                        select-rank-construct (R1148), 37, 199, 199, 200
              ROUND=speciﬁer, 227, 230, 232, 233, 236, 247, 254,       select-rank-stmt (R1149), 7, 199, 199, 200, 204
                       259, 283                                        select-type-construct (R1152), 37, 201, 202
              rounding mode                                            select-type-stmt (R1153), 7, 201, 201, 202, 204
                  IEEE, 443, 444, 447, 448, 449, 454, 463, 466, 473    SELECTED_CHAR_KIND,65, 422
                  input/output, 224, 230, 236, 259, 277, 282, 472      SELECTED_INT_KIND, 61, 73, 423
              RPedit descriptor, 282                                   SELECTED_REAL_KIND,62, 338, 423, 544
              RRSPACING, 420                                           selector, 182
              RUedit descriptor, 282                                   selector (R1105), 182, 182, 183, 185, 186, 199, 201–203,
              RZedit descriptor, 282                                            321, 517, 528
              S                                                        separate module procedure, 330
              S edit descriptor, 282                                   separate module subprogram statement, 330
              SAME_TYPE_AS,75, 421                                     separate-module-subprogram (R1538), 36, 294, 330,
              SAVEattribute, 19, 24, 33, 46, 78, 85, 97, 99, 100, 109,          330, 331
                       109, 110, 113, 117, 124, 126, 144, 192, 309,    sequence, 19
                       334, 518                                        sequence association, 320
              SAVE statement, 117, 184, 298, 511                       SEQUENCEattribute, 19, 69, 71, 71, 72, 85, 125, 172,
                                                                              c
              638                                                             ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
                       173, 202, 486                                    speciﬁcation expression, 20, 24, 41, 73, 75, 84, 98, 133,
              SEQUENCEstatement, 71                                               164, 165, 165, 184, 332, 445, 541, 543
              sequence structure, 19                                    speciﬁcation function, 165
              sequence type, 19, 19, 31, 69, 71, 71, 124, 487, 520      speciﬁcation inquiry, 164
                   character, 20, 71, 124–126, 521, 525                 speciﬁcation-construct (R508), 36, 36, 184
                   numeric, 20, 71, 124–126, 521, 525                   speciﬁcation-expr (R1028), 7, 59, 66, 97, 101, 102, 164,
              sequence-stmt (R731), 70, 71                                        164, 336
              sequential access, 219                                    speciﬁcation-part (R504), 35, 36, 36, 41, 81, 98, 99, 111,
              sequential access data transfer statement, 236                      165, 166, 293, 294, 297, 298, 302, 328, 330, 334,
              SEQUENTIAL=speciﬁer, 254, 259                                       336
              SET_EXPONENT,424                                          SPREAD, 427
              SHAPE, 60, 424                                            SQRT, 32, 428, 449, 473
              shape, 20, 45, 207                                        SS edit descriptor, 282
              SHARED, 189, 192, 193                                     standard intrinsic, xviii, 16, 29, 436
              SHIFTA, 424                                               standard-conforming program, 20, 29
              SHIFTL, 425                                               stat-variable (R942), 41, 137, 138, 140, 142, 143, 144,
              SHIFTR, 425                                                         144, 145, 208, 209, 212–216, 227, 231, 232, 250,
              SIGN, 32, 33, 63, 425                                               251, 253, 254, 260–262, 394, 528, 532
              sign (R712), 62, 62, 63, 272                              STAT=speciﬁer, xix, 137, 138, 141–143, 144, 187, 208,
              sign mode, 230, 271, 282                                            215, 441, 525, 532
              sign-edit-desc (R1317), 267, 268                          STAT_FAILED_IMAGE, 41, 138, 145, 215, 216, 341,
              SIGN= speciﬁer, 227, 230, 232, 233, 236, 254, 259,                  380, 407, 408, 441, 442
                       282                                              STAT_LOCKED, 216, 441, 442
              signed-digit-string (R710), 62, 63, 271–273               STAT_LOCKED_OTHER_IMAGE,216,441, 442
              signed-int-literal-constant (R707), 62, 62, 64, 114, 267  STAT_STOPPED_IMAGE, 145, 215, 216, 341, 407,
              signed-real-literal-constant (R713), 63, 64, 114                    408, 428, 441, 442
              signiﬁcand (R715), 63, 63                                 STAT_UNLOCKED,216, 441, 442
              simply contiguous, 20, 136, 137, 137, 173, 315, 317,      STAT_UNLOCKED_FAILED_IMAGE, 216, 441,
                       318, 490, 491                                              442
              SIN, 426                                                  statement, 20, 53
              SINH, 426                                                      accessibility, 111
              SIZE, 60, 426                                                  ALLOCATABLE, 112
              size, 20, 45                                                   ALLOCATE, 58, 59, 66, 101, 103, 138, 141, 144,
              size of a common block, 126                                         145, 172, 206, 438, 497, 498, 517, 518, 525–527,
              SIZE= speciﬁer, 232, 236, 254, 259, 261, 524, 527, 564              532, 543
              source-expr (R930), 138, 138–142, 334, 517–519                 arithmetic IF, 540
              SOURCE=speciﬁer, 138, 140, 142, 334, 438, 525–527,             ASSIGN, 539
                       543                                                   assigned GO TO, 539
              SP edit descriptor, 282                                        assignment, 17, 31, 44, 58, 84, 167, 179, 475, 524
              SPACING, 427                                                   ASSOCIATE, 46, 182, 516
              special character, 49                                          ASYNCHRONOUS,112, 184, 298, 512, 514
              speciﬁc interface, 15, 249, 303, 303, 304, 309, 325, 543       attribute speciﬁcation, 111–127
              speciﬁc interface block, 15, 15, 303                           BACKSPACE, 218, 221, 247, 250, 251, 252, 564,
              speciﬁc name, 20                                                    565
              speciﬁc-procedure (R1507), 302, 302, 304                       BIND, 112, 298, 505, 511
              speciﬁcation, 95–127                                           BLOCK, 97, 101, 103, 184, 525
               c
              ISO/IEC 2017 – All rights reserved                                                                           639
             ISO/IEC DIS 1539-1:2017 (E)
                  BLOCKDATA,53, 293, 297                                  ENDPROCEDURE,53,331
                  CALL, 22, 204, 207, 299, 311, 324, 332, 407             ENDPROGRAM,53,293
                  CASE, 197                                               ENDSELECT,53, 197, 202
                  CHANGE TEAM, 22, 40, 46, 185, 206, 215, 341,            ENDSUBMODULE,53,297
                      516                                                 ENDSUBROUTINE,53, 330
                  CLASS DEFAULT, 202                                      ENDTEAM,40,53, 185, 206, 215, 341
                  CLASS IS, 202, 379                                      ENDTYPE,53, 70
                  CLOSE, 218, 219, 223, 225, 226, 230, 230, 247,          ENDWHERE,53,175
                      250, 564                                            ENDFILE, 53, 218, 219, 221, 228, 247, 250, 252,
                  COMMON, 8, 125, 125–127, 184, 296, 298, 511,                564
                      521, 540                                            ENTRY, 12, 40, 160, 170, 294, 299, 303, 327, 328,
                  component deﬁnition, 74                                     331, 511, 521, 540, 542
                  computed GO TO, 7, 204, 205, 540, 541                   ENUM,90
                  CONTAINS, 39, 40, 81, 332                               ENUMERATOR,90
                  CONTIGUOUS, 113                                         EQUIVALENCE,123,123–126,184,296,298,521,
                  CONTINUE, 205, 539                                          540, 542
                  CRITICAL, 161, 187, 206, 207, 216                       ERRORSTOP,41, 42, 205, 532
                  CYCLE, 182, 188, 191, 192, 542                          EVENTPOST,206, 207, 211, 212, 215, 377, 438,
                  DATA, 32, 33, 40, 92, 97, 113, 126, 298, 411, 512,          525, 528, 533
                      515, 523, 540, 541                                  EVENTWAIT,206, 207, 212, 212, 215, 438, 525,
                  data transfer, 33, 52, 217–223, 225, 231, 236, 239–         528, 533
                      241, 246, 250, 252, 260–263, 265, 266, 277, 282,    executable, 20, 20, 39
                      284–286, 288, 290, 439, 524, 526, 534, 563, 564,    EXIT, 182, 192, 204
                      567, 568                                            EXTERNAL, 105, 308
                  DEALLOCATE, 142, 144, 145, 206, 438, 498, 532           FAIL IMAGE, 206
                  deﬁned assignment, 31, 170, 171, 324, 528               ﬁle inquiry, 253
                  derived type deﬁnition, see statement, TYPE             ﬁle positioning, 218, 251
                  DIMENSION, 115, 298                                     FINAL, 13, 83
                  DO, 188, 524, 540, 542                                  FLUSH, 219, 250, 253, 262
                  DOCONCURRENT,59,178, 188                                FORALL, 59, 153, 179, 512, 524
                  DOWHILE,188                                             FORM TEAM, 22, 40, 137, 186, 206, 207, 212,
                  ELSE, 195                                                   215, 525, 528, 533
                  ELSE IF, 53, 195                                        FORMAT,29, 40, 52, 234, 265, 265, 294
                  ELSEWHERE,53, 175                                       formatted input/output, 217, 233
                  END, 13, 40, 109, 126, 143, 144, 207, 482, 527          FUNCTION, 12, 59, 60, 118, 160, 164, 293, 327,
                  ENDASSOCIATE, 53, 182                                       328, 331, 332, 511
                  ENDBLOCK,53,144, 184                                    GENERIC, 81, 82, 304, 304, 307, 324
                  ENDBLOCKDATA,53,297                                     GOTO,7,53, 204, 204
                  ENDCRITICAL, 53, 161, 187, 206, 207                     IF, 153, 196
                  ENDDO,53, 189                                           IMPLICIT, 40, 118, 123, 298
                  ENDENUM,53,90                                           IMPLICIT NONE, 118
                  ENDFORALL,53, 177                                       IMPORT, 40, 120, 509, 515
                  ENDFUNCTION,53, 328                                     input/output, 217–262, 524
                  ENDIF, 53, 195, 539                                     INQUIRE, 32, 219, 220, 222, 223, 225, 226, 235,
                  ENDINTERFACE,53, 302                                        236, 246, 247, 250, 253, 262, 263, 439, 524,
                  ENDMODULE,53,294                                            526–528, 534, 563
                                                                             c
             640                                                            ISO/IEC 2017 – All rights reserved
                                                                                         ISO/IEC DIS 1539-1:2017 (E)
                   INTENT, 116, 184                                          SYNCALL,186, 206, 208, 209, 210, 215, 216
                   INTERFACE, 302, 573                                       SYNCIMAGES,206, 209, 215, 216
                   INTRINSIC, 298, 310                                       SYNCMEMORY,206,207, 210, 215, 216, 593
                   intrinsic assignment, 31, 89, 143, 145, 163, 167,         SYNCTEAM,186, 206, 211, 215, 216
                       171, 173, 216, 253, 262, 289, 334, 335, 524,          TARGET, 117, 298
                       532                                                   TYPE, 69, 73, 98, 514
                   list-directed input/output, 234                           type declaration, 40, 59, 60, 78, 95, 95–97, 105,
                   LOCK, 206, 207, 213, 216, 440, 441, 525, 528                   118, 123, 126, 165, 294, 298, 329, 331, 333,
                   MODULE,293, 294                                                523
                   NAMELIST, 123, 184, 288, 296                              type guard, 66, 202
                   namelist input/output, 234                                TYPEIS, 202, 421
                   nonexecutable, 20, 39                                     type parameter deﬁnition, 73
                   NULLIFY, 142                                              type-bound procedure, 81, 82
                   OPEN, 33, 218, 219, 223–225, 226, 226, 230, 234,          unformatted input/output, 218, 233
                       242, 243, 247, 256, 260, 277, 289, 525, 528,          UNLOCK,206, 207, 213, 216, 440, 441, 525, 528
                       533, 534, 563, 565–567                                USE, 6, 19, 40, 72, 111, 294, 298, 324–326, 510,
                   OPTIONAL, 116, 184                                             512, 513, 516, 570–572, 577
                   PARAMETER,40, 116, 118, 298                               VALUE, 117, 184
                   PAUSE, 539                                                VOLATILE, 118, 184, 298, 512, 514
                   POINTER, 116, 298                                         WAIT, 225, 235, 250, 250, 567, 568
                   pointer assignment, 17, 22, 58, 77, 89, 163, 171,         WHERE,17, 153, 175
                       173, 179, 348, 354                                    WRITE, 219, 224, 228, 231, 240, 245, 246, 250,
                   PRINT, 219, 228, 231, 240, 245, 246, 250                       262, 524, 563, 564, 566, 567
                   PRIVATE, 80, 81, 83, 111, 296                        statement entity, 21, 192, 509, 510, 512
                   PROCEDURE,302, 304, 543                              statement function, 333, 541
                   procedure declaration, 40, 105, 301, 303, 308, 332,  statement function statement, 12, 40, 66, 184, 294, 324,
                       348, 511, 543                                              332, 333, 512, 513, 541
                   PROGRAM,293                                          statement keyword, 16, 47
                   PROTECTED,117                                        statement label, 7, 21, 52, 52–55, 312, 509
                   PUBLIC, 111, 296                                     statement order, 39
                   READ, 33, 44, 220, 224, 228, 231, 240, 245, 246,     STATUS= speciﬁer, 226–229, 230, 231, 231, 533, 534,
                       250, 253, 261, 527, 563–565, 567, 569                      566
                   RETURN,41,85,109,126,143,144,185,187,192, stmt-function-stmt (R1544), 36, 294, 297, 303, 333, 514
                       332, 482, 527                                    STOPstatement, 41, 42, 205, 207, 335, 532
                   REWIND, 218, 219, 221, 247, 250, 252, 252, 564       stop-code (R1162), 205, 205, 206
                   SAVE, 117, 184, 298, 511                             stop-stmt (R1160), 38, 85, 205
                   SELECT CASE, 53, 196                                 stopped image, 14, 41, 140, 144, 145, 341, 407
                   SELECT RANK, 46, 105, 199, 516                       STOPPED_IMAGES, 428
                   SELECT TYPE, 46, 53, 201, 516                        storage association, 6, 6, 46, 47, 123–127, 331, 334, 429,
                   separate module subprogram, 330                                519–522
                   SEQUENCE, 71                                         storage sequence, 21, 69, 71, 124–127, 298, 354, 520,
                   statement function, 12, 40, 66, 184, 294, 324, 332,            520, 521
                       333, 512, 513, 541                               storage unit, 21, 21, 123–127, 235, 239, 247, 250, 298,
                   STOP, 41, 42, 205, 207, 335, 532                               320, 354, 520–522
                   SUBMODULE,293, 297                                        character, 21, 21, 104, 124, 126, 437, 520, 524, 526
                   SUBROUTINE, 12, 170, 293, 327, 330, 331, 332              ﬁle, 13, 21, 217, 220–223, 229, 234, 236, 242, 252,
               c
              ISO/IEC 2017 – All rights reserved                                                                           641
              ISO/IEC DIS 1539-1:2017 (E)
                        258–260, 439, 520                                 subscript (R919), 114, 133, 133, 136, 239
                   numeric, 21, 21, 126, 440, 520, 524, 526               subscript triplet, 135
                   unspeciﬁed, 21, 21, 520, 524, 526                      subscript-triplet (R921), 133, 133–136
              STORAGE_SIZE, 92, 428                                       substring, 130
              stream access, 220                                          substring (R908), 124, 129, 130
              stream access data transfer statement, 236                  substring ending point., 130
              stream ﬁle, 13, 21, 217, 220, 222, 260                      substring starting point, 130
              STREAM=speciﬁer, 254, 259                                   substring-range (R910), 101, 130, 130, 132–134, 137,
              stride (R922), 133, 133, 135, 136, 239                               239
              structure, 9, 21, 42, 43, 69                                suﬃx (R1532), 328, 328, 331
              structure component, 21, 114, 130–132, 486, 551             SUM, 429
              structure constructor, 9, 16, 21, 43, 47, 57, 80, 88, 89,   SYNC ALL statement, 186, 206, 208, 209, 210, 215,
                        114, 115, 162, 164, 165, 411, 440, 511, 547                216
              structure-component (R913), 113, 114, 129, 130, 131,        SYNCIMAGESstatement, 206, 209, 215, 216
                        136, 138, 142                                     SYNC MEMORY statement, 206, 207, 210, 215, 216,
              structure-constructor (R756), 21, 88, 88, 114, 147, 334              593
              subcomponent, 9, 10, 78, 88, 172, 517–519, 523, 525–        SYNCTEAMstatement, 186, 206, 211, 215, 216
                        527                                               sync-all-stmt (R1164), 38, 208
              submodule, 16, 18, 21, 21, 22, 38, 39, 43, 297              sync-images-stmt (R1166), 38, 209
              submodule (R1416), 35, 297                                  sync-memory-stmt (R1168), 38, 210
              submodule identiﬁer, 297                                    sync-stat (R1165), 185, 187, 208, 208–213, 215, 216
              SUBMODULEstatement, 293, 297                                sync-team-stmt (R1169), 38, 211
              submodule-name, 297                                         synchronous input/output, 228, 234, 236, 239
              submodule-stmt (R1417), 35, 297, 297                        SYSTEM_CLOCK,430
              subobject, 5, 9, 10, 21, 43–45, 106, 131, 315, 517, 518     T
              subprogram, 16, 21, 38, 40, 41, 43, 118                     Tedit descriptor, 281
                   elemental, 13, 327, 328, 335, 336                      TAN, 430
                   external, 18, 22, 38, 299                              TANH, 430
                   internal, 22, 38, 40, 299, 514                         target, 12, 22, 44, 46, 61, 77–79, 84, 89, 97, 100, 101,
                   module, 22, 38, 40                                              103, 105–109, 115, 129, 131, 138, 141, 142, 144,
              subroutine, 22                                                       162, 163, 168, 171–173, 178, 179, 237, 241, 243,
                   atomic, 22, 41, 207, 208, 337, 340, 342, 356–360,               309, 312, 314, 316, 318, 320, 481, 483, 484,
                        377, 437, 441, 528                                         516–519, 522, 525, 527, 528
                   collective, 22, 337, 341, 342, 365–368, 380, 428, 441  TARGET attribute, 6, 22, 31, 78, 108, 110, 110, 117,
              subroutine reference, 324                                            124, 126, 142, 143, 172, 183, 192, 193, 200, 301,
              SUBROUTINEstatement, 12, 170, 293, 327, 330, 331,                    307, 315, 316, 318, 321–323, 367, 407, 418, 481,
                        332                                                        484, 504, 505, 517–519, 527, 543, 584, 585
              subroutine-name, 303, 330, 511                              TARGETstatement, 117, 298
              subroutine-stmt (R1535), 35, 302, 303, 327, 328, 330,       target-decl (R860), 117, 117
                        330, 511, 514                                     target-stmt (R859), 37, 117, 514
              subroutine-subprogram (R1534), 21, 35, 36, 294, 330,        team, 14, 22, 22, 40, 45, 46, 137, 138, 144, 186, 208,
                        330                                                        209, 211, 213, 215, 337, 341, 390, 412, 428,
              subroutines                                                          431, 432
                   intrinsic, 337                                              current, 341
              subscript, 133                                              team number, 22, 137, 213
                   section, 135                                           team variable, 25, 186, 441, 525
                                                                                  c
              642                                                                ISO/IEC 2017 – All rights reserved
                                                                                             ISO/IEC DIS 1539-1:2017 (E)
              team-construct-name, 185                                          integer, 61–62
              team-number (R1176), 212, 212, 213                                intrinsic, 9, 23, 42, 43, 57, 61–68
              team-value (R1115), 137, 185, 185, 186, 211                       logical, 68
              team-variable (R1177), 212, 212, 213, 215, 528                    numeric, 23, 61–65, 154–156, 158, 162, 169, 373,
              TEAM=speciﬁer, 137, 137                                                374, 400, 415, 429
              TEAM_NUMBER,431                                                   operation, 163
              TEAM_NUMBER=speciﬁer, 137, 137                                    parent, 9, 23, 70, 73, 80, 84–86, 307, 552
              TEAM_TYPE,25,74,99,131,139,140, 170, 185, 212,                    primary, 162
                        380, 385, 390, 412, 428, 431, 441, 527                  real, 62–64, 64
              THEN, 195                                                    type compatible, 23, 60, 77, 139, 167, 171, 307, 315,
              THIS_IMAGE, 166, 431                                                   407
              TINY, 427, 432                                               type conformance, 167
              TKRcompatible, 307                                           type declaration statement, 40, 59, 60, 78, 95, 95–97,
              TLedit descriptor, 281                                                 105, 118, 123, 126, 165, 294, 298, 329, 331,
              totally associated, 521                                                333, 523
              TRedit descriptor, 281                                       type equality, 71
              TRAILZ, 432                                                  type guard statement, 66, 202
              TRANSFER, 166, 432                                           TYPEISstatement, 202, 421
              transfer of control, 181, 204, 261                           type parameter, 5, 7, 15, 16, 23, 31, 42, 58, 60, 61, 68,
              transformational function, 22, 166, 333, 337, 337, 338,                71, 73, 77, 89, 93, 95–97, 116, 126, 162, 165,
                        342, 361, 362, 437, 450                                      167, 183, 185, 300, 315, 336, 403, 407, 433,
              TRANSPOSE, 433                                                         481, 487, 511, 513
              TRIM, 433                                                    type parameter deﬁnition statement, 73
              truncation, 339, 391, 418                                    type parameter inquiry, 24, 132, 162, 164
              TYPE, 59                                                     type parameter keyword, 16, 47, 88
              type, 23, 42, 57–93                                          type parameter order, 24, 73
                   abstract, 23, 59, 82, 85, 85, 88, 131, 139              type speciﬁer, 59
                   character, 65–68                                             CHARACTER,65
                   complex, 64–65                                               CLASS, 60
                   declared, 23, 60, 61, 77, 89, 90, 93, 95, 130, 132,          COMPLEX,64
                        139, 140, 142, 160, 162, 167, 170–173, 182, 202,        derived type, 59
                        203, 249, 306, 311, 314, 317, 326, 333, 379, 403,       DOUBLEPRECISION, 63
                        407, 421, 438, 440, 513                                 INTEGER, 61
                   derived, 11, 21, 23, 42, 43, 46, 57, 68–90, 93, 486,         LOGICAL, 68
                        487                                                     REAL, 63
                   dynamic, 17, 23, 24, 60, 61, 84, 85, 87, 90, 93, 110,        TYPE, 59
                        140, 142, 144, 160, 162, 168, 170, 171, 173,       TYPEstatement, 69, 73, 98, 514
                        183, 201, 202, 207, 210, 249, 311, 317, 326,       type-attr-spec (R728), 69, 69, 85
                        347, 379, 403, 407, 421, 429, 513, 517, 522,       type-bound procedure, 7, 15, 17, 18, 68, 70, 77, 82, 82–
                        552, 601                                                     86, 170, 249, 295, 305, 311, 313, 315, 326, 510,
                   expression, 162                                                   511
                   extended, 6, 9, 15, 23, 23, 73, 80, 84–86, 522, 544,    type-bound procedure statement, 81, 82
                        549                                                type-bound-generic-stmt (R751), 81, 81, 305
                   extensible, 23, 59, 70, 77, 85, 243, 379, 421, 552,     type-bound-proc-binding (R748), 81, 81
                        590                                                type-bound-proc-decl (R750), 81, 81
                   extension, 23, 60, 85, 87, 202, 317, 379, 590           type-bound-procedure-part (R746), 69, 71, 81, 83, 487
               c
              ISO/IEC 2017 – All rights reserved                                                                               643
               ISO/IEC DIS 1539-1:2017 (E)
               type-bound-procedure-stmt (R749), 81, 81                     until-spec (R1174), 212, 212
               type-declaration-stmt (R801), 36, 66, 95, 95, 334, 514       UNTIL_COUNT=speciﬁer, 212, 377
               type-guard-stmt (R1154), 201, 202, 202                       upper-bound (R818), 102, 102, 103
               type-name, 69, 70, 72, 82, 87                                upper-bound-expr (R935), 138, 138, 172
               type-param-attr-spec (R734), 73, 73                          upper-cobound (R813), 100, 101, 101
               type-param-decl (R733), 73, 73                               use association, 6, 6, 17, 31, 39, 47, 60, 66, 86, 98, 109,
               type-param-def-stmt (R732), 69, 73, 73                                 111, 112, 118, 123–125, 164, 165, 172, 294,
               type-param-inquiry (R916), 24, 132, 132, 147, 511                      293–297, 303, 331, 334, 511–514, 517
               type-param-name, 69, 73, 75, 132, 147, 511, 514              use path, 296
               type-param-spec (R755), 87, 87, 88                           USE statement, 6, 19, 40, 72, 111, 294, 298, 324–326,
               type-param-value (R701), xix, 24, 58, 58, 59, 65, 66, 75,              510, 512, 513, 516, 570–572, 577
                         87, 88, 139, 140, 327, 542                         use-deﬁned-operator (R1415), 295, 295, 296
               type-spec (R702), 59, 59, 66, 93, 138–141, 202               use-name, 295, 296, 510
               U                                                            use-stmt (R1409), 36, 184, 295, 295, 514
               UBOUND,60, 200, 434                                          V
               UCOBOUND,434                                                 v (R1312), 246, 267, 267, 280
               ultimate argument, 24, 140, 144, 314, 318, 319, 321,         VALUE attribute, 60, 77, 83, 105, 110, 110, 118, 192,
                         322, 341                                                     240, 300, 301, 303, 305, 306, 314–318, 328, 334,
               ultimate component, 9, 31, 68–70, 75, 99, 101, 104, 105,               336, 367, 418, 489, 490, 507, 519, 543, 596, 598
                         110, 111, 124, 125, 139, 142, 166, 167, 243, 315,  value separator, 283
                         316, 334, 520                                      VALUEstatement, 117, 184
               ultimate entity, 296                                         value-stmt (R861), 37, 117
               undeﬁned, 12, 24, 44, 143, 517, 518, 523, 524                variable, 10, 21, 25, 43, 44, 46, 50, 108
               undeﬁnition of variables, 523                                     deﬁnition & undeﬁnition, 523
               underﬂow mode, 447, 448, 451, 455, 467, 474, 475, 536        variable (R902), 89, 113, 114, 129, 129, 137, 167–169,
               underscore (R602), 49, 49                                              171, 172, 177, 178, 182, 201, 211–213, 237, 311,
               UNFORMATTED,243, 244, 302                                              321, 475, 528
               unformatted data transfer, 242                               variable-name (R903), 123–125, 129, 129, 130, 138, 142,
               unformatted input/output statement, 218, 233                           171, 172, 189, 514, 528
               unformatted record, 217                                      vector subscript, 25, 45, 78, 101, 131, 135, 136, 182,
               UNFORMATTED=speciﬁer, 254, 259                                         201, 223, 287, 315, 316, 321, 322, 516, 519,
               Unicode ﬁle, 228                                                       584
               unit, 9, 18, 24, 218–220, 223, 223–226, 228–231, 235,        vector-subscript (R923), 133, 133–135
                         236, 239–241, 245, 250, 251, 253–260, 262, 280,    VERIFY, 436
                         286, 438, 439, 524, 526, 563, 565–568              VOLATILEattribute, 31, 110, 110, 111, 118, 172, 173,
               UNIT=speciﬁer, 226, 231, 232, 250, 251, 253, 254                       183, 192, 294, 296, 300, 301, 316–318, 334, 514,
               unlimited polymorphic, 24, 60, 60, 93, 125, 139, 171,                  519, 525, 528, 550
                         172, 202, 317, 379, 421, 428, 601                  VOLATILE statement, 118, 184, 298, 512, 514
               unlimited-format-item (R1305), 265, 266, 266, 269            volatile-stmt (R862), 37, 118
               UNLOCKstatement, 206, 207, 213, 216, 440, 441, 525,          W
                         528
               unlock-stmt (R1181), 38, 213                                 w (R1308), 267, 267, 271–280, 284, 286, 289
               unordered segments, 207, 207, 340, 348, 377, 416             wait operation, 226, 230, 236, 239, 240, 250, 250–251,
               UNPACK, 435                                                            253, 257, 258, 260, 261
               unsaved, 24, 141, 143, 330, 518, 519, 525–527                WAITstatement, 225, 235, 250, 250, 567, 568
               unspeciﬁed storage unit, 21, 21, 520, 524, 526               wait-spec (R1223), 250, 250
                                                                                     c
               644                                                                  ISO/IEC 2017 – All rights reserved
                                                                                     ISO/IEC DIS 1539-1:2017 (E)
             wait-stmt (R1222), 38, 250, 335                         WRITE(UNFORMATTED),243, 244, 302
             WHEREconstruct, 17, 175                                 WRITE statement, 219, 224, 228, 231, 240, 245, 246,
             WHEREstatement, 17, 153, 175                                     250, 262, 524, 563, 564, 566, 567
             where-assignment-stmt (R1045), 153, 175, 175, 177,      write-stmt (R1211), 38, 231, 232, 335, 528
                      178                                            WRITE=speciﬁer, 254, 260
             where-body-construct (R1044), 175, 175–177              X
             where-construct (R1042), 37, 175, 175, 177, 178
             where-construct-name, 175                               Xedit descriptor, 281
             where-construct-stmt (R1043), 7, 175, 175, 176, 178,    xyz-list (R401), 28
                      204                                            xyz-name (R402), 28
             where-stmt (R1041), 38, 175, 175, 177, 178              Z
             WHILE, 188, 190, 191
             whole array, 25, 133, 133, 134, 395, 434                Z edit descriptor, 277
             WRITE(FORMATTED),243, 244, 302                          zero-size array, 45, 103, 114
              c
             ISO/IEC 2017 – All rights reserved                                                                     645
